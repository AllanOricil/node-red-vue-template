<script type="text/html" data-template-name="remote-server">
  <div id="app"></div>
</script>

<script type="text/html" data-template-name="your-node">
  <div id="app"></div>
</script>

<style>
  /* TODO: add this as a global vue app style instead */
  .node-red-vue-input-error-message {
    color: var(--red-ui-form-input-border-error-color);
  }
</style>

<!-- TODO: create a /core/client lib and change to ts -->
<script type="text/javascript">var __defProp = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  (function($$1) {
    "use strict";
    /**
    * @vue/shared v3.5.13
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function makeMap(str) {
      const map2 = /* @__PURE__ */ Object.create(null);
      for (const key of str.split(",")) map2[key] = 1;
      return (val) => val in map2;
    }
    const EMPTY_OBJ = true ? Object.freeze({}) : {};
    const EMPTY_ARR = true ? Object.freeze([]) : [];
    const NOOP = () => {
    };
    const NO = () => false;
    const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
    (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
    const isModelListener = (key) => key.startsWith("onUpdate:");
    const extend = Object.assign;
    const remove$1 = (arr, el) => {
      const i = arr.indexOf(el);
      if (i > -1) {
        arr.splice(i, 1);
      }
    };
    const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
    const isArray$1 = Array.isArray;
    const isMap$1 = (val) => toTypeString(val) === "[object Map]";
    const isSet$1 = (val) => toTypeString(val) === "[object Set]";
    const isDate$1 = (val) => toTypeString(val) === "[object Date]";
    const isRegExp$1 = (val) => toTypeString(val) === "[object RegExp]";
    const isFunction$1 = (val) => typeof val === "function";
    const isString$1 = (val) => typeof val === "string";
    const isSymbol$2 = (val) => typeof val === "symbol";
    const isObject = (val) => val !== null && typeof val === "object";
    const isPromise$1 = (val) => {
      return (isObject(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
    };
    const objectToString = Object.prototype.toString;
    const toTypeString = (value) => objectToString.call(value);
    const toRawType = (value) => {
      return toTypeString(value).slice(8, -1);
    };
    const isPlainObject$2 = (val) => toTypeString(val) === "[object Object]";
    const isIntegerKey = (key) => isString$1(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
    const isReservedProp = /* @__PURE__ */ makeMap(
      // the leading comma is intentional so empty string "" is also included
      ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
    );
    const isBuiltInDirective = /* @__PURE__ */ makeMap(
      "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
    );
    const cacheStringFunction = (fn) => {
      const cache = /* @__PURE__ */ Object.create(null);
      return (str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
      };
    };
    const camelizeRE = /-(\w)/g;
    const camelize = cacheStringFunction(
      (str) => {
        return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
      }
    );
    const hyphenateRE = /\B([A-Z])/g;
    const hyphenate = cacheStringFunction(
      (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
    );
    const capitalize$1 = cacheStringFunction((str) => {
      return str.charAt(0).toUpperCase() + str.slice(1);
    });
    const toHandlerKey = cacheStringFunction(
      (str) => {
        const s = str ? `on${capitalize$1(str)}` : ``;
        return s;
      }
    );
    const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
    const invokeArrayFns = (fns, ...arg) => {
      for (let i = 0; i < fns.length; i++) {
        fns[i](...arg);
      }
    };
    const def = (obj, key, value, writable = false) => {
      Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        writable,
        value
      });
    };
    const looseToNumber = (val) => {
      const n = parseFloat(val);
      return isNaN(n) ? val : n;
    };
    const toNumber$1 = (val) => {
      const n = isString$1(val) ? Number(val) : NaN;
      return isNaN(n) ? val : n;
    };
    let _globalThis;
    const getGlobalThis = () => {
      return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    };
    const identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
    function genPropsAccessExp(name) {
      return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;
    }
    function genCacheKey(source, options) {
      return source + JSON.stringify(
        options,
        (_, val) => typeof val === "function" ? val.toString() : val
      );
    }
    const PatchFlags = {
      "TEXT": 1,
      "1": "TEXT",
      "CLASS": 2,
      "2": "CLASS",
      "STYLE": 4,
      "4": "STYLE",
      "PROPS": 8,
      "8": "PROPS",
      "FULL_PROPS": 16,
      "16": "FULL_PROPS",
      "NEED_HYDRATION": 32,
      "32": "NEED_HYDRATION",
      "STABLE_FRAGMENT": 64,
      "64": "STABLE_FRAGMENT",
      "KEYED_FRAGMENT": 128,
      "128": "KEYED_FRAGMENT",
      "UNKEYED_FRAGMENT": 256,
      "256": "UNKEYED_FRAGMENT",
      "NEED_PATCH": 512,
      "512": "NEED_PATCH",
      "DYNAMIC_SLOTS": 1024,
      "1024": "DYNAMIC_SLOTS",
      "DEV_ROOT_FRAGMENT": 2048,
      "2048": "DEV_ROOT_FRAGMENT",
      "CACHED": -1,
      "-1": "CACHED",
      "BAIL": -2,
      "-2": "BAIL"
    };
    const PatchFlagNames = {
      [1]: `TEXT`,
      [2]: `CLASS`,
      [4]: `STYLE`,
      [8]: `PROPS`,
      [16]: `FULL_PROPS`,
      [32]: `NEED_HYDRATION`,
      [64]: `STABLE_FRAGMENT`,
      [128]: `KEYED_FRAGMENT`,
      [256]: `UNKEYED_FRAGMENT`,
      [512]: `NEED_PATCH`,
      [1024]: `DYNAMIC_SLOTS`,
      [2048]: `DEV_ROOT_FRAGMENT`,
      [-1]: `HOISTED`,
      [-2]: `BAIL`
    };
    const ShapeFlags = {
      "ELEMENT": 1,
      "1": "ELEMENT",
      "FUNCTIONAL_COMPONENT": 2,
      "2": "FUNCTIONAL_COMPONENT",
      "STATEFUL_COMPONENT": 4,
      "4": "STATEFUL_COMPONENT",
      "TEXT_CHILDREN": 8,
      "8": "TEXT_CHILDREN",
      "ARRAY_CHILDREN": 16,
      "16": "ARRAY_CHILDREN",
      "SLOTS_CHILDREN": 32,
      "32": "SLOTS_CHILDREN",
      "TELEPORT": 64,
      "64": "TELEPORT",
      "SUSPENSE": 128,
      "128": "SUSPENSE",
      "COMPONENT_SHOULD_KEEP_ALIVE": 256,
      "256": "COMPONENT_SHOULD_KEEP_ALIVE",
      "COMPONENT_KEPT_ALIVE": 512,
      "512": "COMPONENT_KEPT_ALIVE",
      "COMPONENT": 6,
      "6": "COMPONENT"
    };
    const SlotFlags = {
      "STABLE": 1,
      "1": "STABLE",
      "DYNAMIC": 2,
      "2": "DYNAMIC",
      "FORWARDED": 3,
      "3": "FORWARDED"
    };
    const slotFlagsText = {
      [1]: "STABLE",
      [2]: "DYNAMIC",
      [3]: "FORWARDED"
    };
    const GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol";
    const isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);
    const isGloballyWhitelisted = isGloballyAllowed;
    const range$1 = 2;
    function generateCodeFrame(source, start = 0, end = source.length) {
      start = Math.max(0, Math.min(start, source.length));
      end = Math.max(0, Math.min(end, source.length));
      if (start > end) return "";
      let lines = source.split(/(\r?\n)/);
      const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
      lines = lines.filter((_, idx) => idx % 2 === 0);
      let count = 0;
      const res = [];
      for (let i = 0; i < lines.length; i++) {
        count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
        if (count >= start) {
          for (let j = i - range$1; j <= i + range$1 || end > count; j++) {
            if (j < 0 || j >= lines.length) continue;
            const line = j + 1;
            res.push(
              `${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`
            );
            const lineLength = lines[j].length;
            const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
            if (j === i) {
              const pad2 = start - (count - (lineLength + newLineSeqLength));
              const length = Math.max(
                1,
                end > count ? lineLength - pad2 : end - start
              );
              res.push(`   |  ` + " ".repeat(pad2) + "^".repeat(length));
            } else if (j > i) {
              if (end > count) {
                const length = Math.max(Math.min(end - count, lineLength), 1);
                res.push(`   |  ` + "^".repeat(length));
              }
              count += lineLength + newLineSeqLength;
            }
          }
          break;
        }
      }
      return res.join("\n");
    }
    function normalizeStyle(value) {
      if (isArray$1(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
          const item = value[i];
          const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
          if (normalized) {
            for (const key in normalized) {
              res[key] = normalized[key];
            }
          }
        }
        return res;
      } else if (isString$1(value) || isObject(value)) {
        return value;
      }
    }
    const listDelimiterRE = /;(?![^(]*\))/g;
    const propertyDelimiterRE = /:([^]+)/;
    const styleCommentRE = /\/\*[^]*?\*\//g;
    function parseStringStyle(cssText) {
      const ret = {};
      cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
        if (item) {
          const tmp = item.split(propertyDelimiterRE);
          tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
      });
      return ret;
    }
    function stringifyStyle(styles) {
      if (!styles) return "";
      if (isString$1(styles)) return styles;
      let ret = "";
      for (const key in styles) {
        const value = styles[key];
        if (isString$1(value) || typeof value === "number") {
          const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
          ret += `${normalizedKey}:${value};`;
        }
      }
      return ret;
    }
    function normalizeClass(value) {
      let res = "";
      if (isString$1(value)) {
        res = value;
      } else if (isArray$1(value)) {
        for (let i = 0; i < value.length; i++) {
          const normalized = normalizeClass(value[i]);
          if (normalized) {
            res += normalized + " ";
          }
        }
      } else if (isObject(value)) {
        for (const name in value) {
          if (value[name]) {
            res += name + " ";
          }
        }
      }
      return res.trim();
    }
    function normalizeProps(props) {
      if (!props) return null;
      let { class: klass, style } = props;
      if (klass && !isString$1(klass)) {
        props.class = normalizeClass(klass);
      }
      if (style) {
        props.style = normalizeStyle(style);
      }
      return props;
    }
    const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
    const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
    const MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
    const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
    const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
    const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
    const isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
    const isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
    const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
    const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
    const isBooleanAttr = /* @__PURE__ */ makeMap(
      specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`
    );
    function includeBooleanAttr(value) {
      return !!value || value === "";
    }
    const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
    const attrValidationCache = {};
    function isSSRSafeAttrName(name) {
      if (attrValidationCache.hasOwnProperty(name)) {
        return attrValidationCache[name];
      }
      const isUnsafe = unsafeAttrCharRE.test(name);
      if (isUnsafe) {
        console.error(`unsafe attribute name: ${name}`);
      }
      return attrValidationCache[name] = !isUnsafe;
    }
    const propsToAttrMap = {
      acceptCharset: "accept-charset",
      className: "class",
      htmlFor: "for",
      httpEquiv: "http-equiv"
    };
    const isKnownHtmlAttr = /* @__PURE__ */ makeMap(
      `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`
    );
    const isKnownSvgAttr = /* @__PURE__ */ makeMap(
      `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`
    );
    const isKnownMathMLAttr = /* @__PURE__ */ makeMap(
      `accent,accentunder,actiontype,align,alignmentscope,altimg,altimg-height,altimg-valign,altimg-width,alttext,bevelled,close,columnsalign,columnlines,columnspan,denomalign,depth,dir,display,displaystyle,encoding,equalcolumns,equalrows,fence,fontstyle,fontweight,form,frame,framespacing,groupalign,height,href,id,indentalign,indentalignfirst,indentalignlast,indentshift,indentshiftfirst,indentshiftlast,indextype,justify,largetop,largeop,lquote,lspace,mathbackground,mathcolor,mathsize,mathvariant,maxsize,minlabelspacing,mode,other,overflow,position,rowalign,rowlines,rowspan,rquote,rspace,scriptlevel,scriptminsize,scriptsizemultiplier,selection,separator,separators,shift,side,src,stackalign,stretchy,subscriptshift,superscriptshift,symmetric,voffset,width,widths,xlink:href,xlink:show,xlink:type,xmlns`
    );
    function isRenderableAttrValue(value) {
      if (value == null) {
        return false;
      }
      const type2 = typeof value;
      return type2 === "string" || type2 === "number" || type2 === "boolean";
    }
    const escapeRE = /["'&<>]/;
    function escapeHtml(string) {
      const str = "" + string;
      const match = escapeRE.exec(str);
      if (!match) {
        return str;
      }
      let html = "";
      let escaped;
      let index;
      let lastIndex = 0;
      for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
          case 34:
            escaped = "&quot;";
            break;
          case 38:
            escaped = "&amp;";
            break;
          case 39:
            escaped = "&#39;";
            break;
          case 60:
            escaped = "&lt;";
            break;
          case 62:
            escaped = "&gt;";
            break;
          default:
            continue;
        }
        if (lastIndex !== index) {
          html += str.slice(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escaped;
      }
      return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
    }
    const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
    function escapeHtmlComment(src) {
      return src.replace(commentStripRE, "");
    }
    const cssVarNameEscapeSymbolsRE = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g;
    function getEscapedCssVarName(key, doubleEscape) {
      return key.replace(
        cssVarNameEscapeSymbolsRE,
        (s) => doubleEscape ? s === '"' ? '\\\\\\"' : `\\\\${s}` : `\\${s}`
      );
    }
    function looseCompareArrays(a, b) {
      if (a.length !== b.length) return false;
      let equal2 = true;
      for (let i = 0; equal2 && i < a.length; i++) {
        equal2 = looseEqual(a[i], b[i]);
      }
      return equal2;
    }
    function looseEqual(a, b) {
      if (a === b) return true;
      let aValidType = isDate$1(a);
      let bValidType = isDate$1(b);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? a.getTime() === b.getTime() : false;
      }
      aValidType = isSymbol$2(a);
      bValidType = isSymbol$2(b);
      if (aValidType || bValidType) {
        return a === b;
      }
      aValidType = isArray$1(a);
      bValidType = isArray$1(b);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a, b) : false;
      }
      aValidType = isObject(a);
      bValidType = isObject(b);
      if (aValidType || bValidType) {
        if (!aValidType || !bValidType) {
          return false;
        }
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) {
          return false;
        }
        for (const key in a) {
          const aHasKey = a.hasOwnProperty(key);
          const bHasKey = b.hasOwnProperty(key);
          if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
            return false;
          }
        }
      }
      return String(a) === String(b);
    }
    function looseIndexOf(arr, val) {
      return arr.findIndex((item) => looseEqual(item, val));
    }
    const isRef$1 = (val) => {
      return !!(val && val["__v_isRef"] === true);
    };
    const toDisplayString = (val) => {
      return isString$1(val) ? val : val == null ? "" : isArray$1(val) || isObject(val) && (val.toString === objectToString || !isFunction$1(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
    };
    const replacer = (_key, val) => {
      if (isRef$1(val)) {
        return replacer(_key, val.value);
      } else if (isMap$1(val)) {
        return {
          [`Map(${val.size})`]: [...val.entries()].reduce(
            (entries, [key, val2], i) => {
              entries[stringifySymbol(key, i) + " =>"] = val2;
              return entries;
            },
            {}
          )
        };
      } else if (isSet$1(val)) {
        return {
          [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
        };
      } else if (isSymbol$2(val)) {
        return stringifySymbol(val);
      } else if (isObject(val) && !isArray$1(val) && !isPlainObject$2(val)) {
        return String(val);
      }
      return val;
    };
    const stringifySymbol = (v, i = "") => {
      var _a;
      return (
        // Symbol.description in es2019+ so we need to cast here to pass
        // the lib: es2016 check
        isSymbol$2(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v
      );
    };
    /**
    * @vue/reactivity v3.5.13
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    function warn$2(msg, ...args) {
      console.warn(`[Vue warn] ${msg}`, ...args);
    }
    let activeEffectScope;
    class EffectScope {
      constructor(detached = false) {
        this.detached = detached;
        this._active = true;
        this.effects = [];
        this.cleanups = [];
        this._isPaused = false;
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) {
          this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
            this
          ) - 1;
        }
      }
      get active() {
        return this._active;
      }
      pause() {
        if (this._active) {
          this._isPaused = true;
          let i, l;
          if (this.scopes) {
            for (i = 0, l = this.scopes.length; i < l; i++) {
              this.scopes[i].pause();
            }
          }
          for (i = 0, l = this.effects.length; i < l; i++) {
            this.effects[i].pause();
          }
        }
      }
      /**
       * Resumes the effect scope, including all child scopes and effects.
       */
      resume() {
        if (this._active) {
          if (this._isPaused) {
            this._isPaused = false;
            let i, l;
            if (this.scopes) {
              for (i = 0, l = this.scopes.length; i < l; i++) {
                this.scopes[i].resume();
              }
            }
            for (i = 0, l = this.effects.length; i < l; i++) {
              this.effects[i].resume();
            }
          }
        }
      }
      run(fn) {
        if (this._active) {
          const currentEffectScope = activeEffectScope;
          try {
            activeEffectScope = this;
            return fn();
          } finally {
            activeEffectScope = currentEffectScope;
          }
        } else if (true) {
          warn$2(`cannot run an inactive effect scope.`);
        }
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      on() {
        activeEffectScope = this;
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      off() {
        activeEffectScope = this.parent;
      }
      stop(fromParent) {
        if (this._active) {
          this._active = false;
          let i, l;
          for (i = 0, l = this.effects.length; i < l; i++) {
            this.effects[i].stop();
          }
          this.effects.length = 0;
          for (i = 0, l = this.cleanups.length; i < l; i++) {
            this.cleanups[i]();
          }
          this.cleanups.length = 0;
          if (this.scopes) {
            for (i = 0, l = this.scopes.length; i < l; i++) {
              this.scopes[i].stop(true);
            }
            this.scopes.length = 0;
          }
          if (!this.detached && this.parent && !fromParent) {
            const last2 = this.parent.scopes.pop();
            if (last2 && last2 !== this) {
              this.parent.scopes[this.index] = last2;
              last2.index = this.index;
            }
          }
          this.parent = void 0;
        }
      }
    }
    function effectScope(detached) {
      return new EffectScope(detached);
    }
    function getCurrentScope() {
      return activeEffectScope;
    }
    function onScopeDispose(fn, failSilently = false) {
      if (activeEffectScope) {
        activeEffectScope.cleanups.push(fn);
      } else if (!failSilently) {
        warn$2(
          `onScopeDispose() is called when there is no active effect scope to be associated with.`
        );
      }
    }
    let activeSub;
    const EffectFlags = {
      "ACTIVE": 1,
      "1": "ACTIVE",
      "RUNNING": 2,
      "2": "RUNNING",
      "TRACKING": 4,
      "4": "TRACKING",
      "NOTIFIED": 8,
      "8": "NOTIFIED",
      "DIRTY": 16,
      "16": "DIRTY",
      "ALLOW_RECURSE": 32,
      "32": "ALLOW_RECURSE",
      "PAUSED": 64,
      "64": "PAUSED"
    };
    const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
    class ReactiveEffect {
      constructor(fn) {
        this.fn = fn;
        this.deps = void 0;
        this.depsTail = void 0;
        this.flags = 1 | 4;
        this.next = void 0;
        this.cleanup = void 0;
        this.scheduler = void 0;
        if (activeEffectScope && activeEffectScope.active) {
          activeEffectScope.effects.push(this);
        }
      }
      pause() {
        this.flags |= 64;
      }
      resume() {
        if (this.flags & 64) {
          this.flags &= ~64;
          if (pausedQueueEffects.has(this)) {
            pausedQueueEffects.delete(this);
            this.trigger();
          }
        }
      }
      /**
       * @internal
       */
      notify() {
        if (this.flags & 2 && !(this.flags & 32)) {
          return;
        }
        if (!(this.flags & 8)) {
          batch(this);
        }
      }
      run() {
        if (!(this.flags & 1)) {
          return this.fn();
        }
        this.flags |= 2;
        cleanupEffect(this);
        prepareDeps(this);
        const prevEffect = activeSub;
        const prevShouldTrack = shouldTrack;
        activeSub = this;
        shouldTrack = true;
        try {
          return this.fn();
        } finally {
          if (activeSub !== this) {
            warn$2(
              "Active effect was not restored correctly - this is likely a Vue internal bug."
            );
          }
          cleanupDeps(this);
          activeSub = prevEffect;
          shouldTrack = prevShouldTrack;
          this.flags &= ~2;
        }
      }
      stop() {
        if (this.flags & 1) {
          for (let link = this.deps; link; link = link.nextDep) {
            removeSub(link);
          }
          this.deps = this.depsTail = void 0;
          cleanupEffect(this);
          this.onStop && this.onStop();
          this.flags &= ~1;
        }
      }
      trigger() {
        if (this.flags & 64) {
          pausedQueueEffects.add(this);
        } else if (this.scheduler) {
          this.scheduler();
        } else {
          this.runIfDirty();
        }
      }
      /**
       * @internal
       */
      runIfDirty() {
        if (isDirty(this)) {
          this.run();
        }
      }
      get dirty() {
        return isDirty(this);
      }
    }
    let batchDepth = 0;
    let batchedSub;
    let batchedComputed;
    function batch(sub, isComputed = false) {
      sub.flags |= 8;
      if (isComputed) {
        sub.next = batchedComputed;
        batchedComputed = sub;
        return;
      }
      sub.next = batchedSub;
      batchedSub = sub;
    }
    function startBatch() {
      batchDepth++;
    }
    function endBatch() {
      if (--batchDepth > 0) {
        return;
      }
      if (batchedComputed) {
        let e = batchedComputed;
        batchedComputed = void 0;
        while (e) {
          const next = e.next;
          e.next = void 0;
          e.flags &= ~8;
          e = next;
        }
      }
      let error;
      while (batchedSub) {
        let e = batchedSub;
        batchedSub = void 0;
        while (e) {
          const next = e.next;
          e.next = void 0;
          e.flags &= ~8;
          if (e.flags & 1) {
            try {
              ;
              e.trigger();
            } catch (err) {
              if (!error) error = err;
            }
          }
          e = next;
        }
      }
      if (error) throw error;
    }
    function prepareDeps(sub) {
      for (let link = sub.deps; link; link = link.nextDep) {
        link.version = -1;
        link.prevActiveLink = link.dep.activeLink;
        link.dep.activeLink = link;
      }
    }
    function cleanupDeps(sub) {
      let head2;
      let tail2 = sub.depsTail;
      let link = tail2;
      while (link) {
        const prev = link.prevDep;
        if (link.version === -1) {
          if (link === tail2) tail2 = prev;
          removeSub(link);
          removeDep(link);
        } else {
          head2 = link;
        }
        link.dep.activeLink = link.prevActiveLink;
        link.prevActiveLink = void 0;
        link = prev;
      }
      sub.deps = head2;
      sub.depsTail = tail2;
    }
    function isDirty(sub) {
      for (let link = sub.deps; link; link = link.nextDep) {
        if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
          return true;
        }
      }
      if (sub._dirty) {
        return true;
      }
      return false;
    }
    function refreshComputed(computed2) {
      if (computed2.flags & 4 && !(computed2.flags & 16)) {
        return;
      }
      computed2.flags &= ~16;
      if (computed2.globalVersion === globalVersion) {
        return;
      }
      computed2.globalVersion = globalVersion;
      const dep = computed2.dep;
      computed2.flags |= 2;
      if (dep.version > 0 && !computed2.isSSR && computed2.deps && !isDirty(computed2)) {
        computed2.flags &= ~2;
        return;
      }
      const prevSub = activeSub;
      const prevShouldTrack = shouldTrack;
      activeSub = computed2;
      shouldTrack = true;
      try {
        prepareDeps(computed2);
        const value = computed2.fn(computed2._value);
        if (dep.version === 0 || hasChanged(value, computed2._value)) {
          computed2._value = value;
          dep.version++;
        }
      } catch (err) {
        dep.version++;
        throw err;
      } finally {
        activeSub = prevSub;
        shouldTrack = prevShouldTrack;
        cleanupDeps(computed2);
        computed2.flags &= ~2;
      }
    }
    function removeSub(link, soft = false) {
      const { dep, prevSub, nextSub } = link;
      if (prevSub) {
        prevSub.nextSub = nextSub;
        link.prevSub = void 0;
      }
      if (nextSub) {
        nextSub.prevSub = prevSub;
        link.nextSub = void 0;
      }
      if (dep.subsHead === link) {
        dep.subsHead = nextSub;
      }
      if (dep.subs === link) {
        dep.subs = prevSub;
        if (!prevSub && dep.computed) {
          dep.computed.flags &= ~4;
          for (let l = dep.computed.deps; l; l = l.nextDep) {
            removeSub(l, true);
          }
        }
      }
      if (!soft && !--dep.sc && dep.map) {
        dep.map.delete(dep.key);
      }
    }
    function removeDep(link) {
      const { prevDep, nextDep } = link;
      if (prevDep) {
        prevDep.nextDep = nextDep;
        link.prevDep = void 0;
      }
      if (nextDep) {
        nextDep.prevDep = prevDep;
        link.nextDep = void 0;
      }
    }
    function effect(fn, options) {
      if (fn.effect instanceof ReactiveEffect) {
        fn = fn.effect.fn;
      }
      const e = new ReactiveEffect(fn);
      if (options) {
        extend(e, options);
      }
      try {
        e.run();
      } catch (err) {
        e.stop();
        throw err;
      }
      const runner = e.run.bind(e);
      runner.effect = e;
      return runner;
    }
    function stop(runner) {
      runner.effect.stop();
    }
    let shouldTrack = true;
    const trackStack = [];
    function pauseTracking() {
      trackStack.push(shouldTrack);
      shouldTrack = false;
    }
    function enableTracking() {
      trackStack.push(shouldTrack);
      shouldTrack = true;
    }
    function resetTracking() {
      const last2 = trackStack.pop();
      shouldTrack = last2 === void 0 ? true : last2;
    }
    function onEffectCleanup(fn, failSilently = false) {
      if (activeSub instanceof ReactiveEffect) {
        activeSub.cleanup = fn;
      } else if (!failSilently) {
        warn$2(
          `onEffectCleanup() was called when there was no active effect to associate with.`
        );
      }
    }
    function cleanupEffect(e) {
      const { cleanup } = e;
      e.cleanup = void 0;
      if (cleanup) {
        const prevSub = activeSub;
        activeSub = void 0;
        try {
          cleanup();
        } finally {
          activeSub = prevSub;
        }
      }
    }
    let globalVersion = 0;
    class Link {
      constructor(sub, dep) {
        this.sub = sub;
        this.dep = dep;
        this.version = dep.version;
        this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
      }
    }
    class Dep {
      constructor(computed2) {
        this.computed = computed2;
        this.version = 0;
        this.activeLink = void 0;
        this.subs = void 0;
        this.map = void 0;
        this.key = void 0;
        this.sc = 0;
        if (true) {
          this.subsHead = void 0;
        }
      }
      track(debugInfo) {
        if (!activeSub || !shouldTrack || activeSub === this.computed) {
          return;
        }
        let link = this.activeLink;
        if (link === void 0 || link.sub !== activeSub) {
          link = this.activeLink = new Link(activeSub, this);
          if (!activeSub.deps) {
            activeSub.deps = activeSub.depsTail = link;
          } else {
            link.prevDep = activeSub.depsTail;
            activeSub.depsTail.nextDep = link;
            activeSub.depsTail = link;
          }
          addSub(link);
        } else if (link.version === -1) {
          link.version = this.version;
          if (link.nextDep) {
            const next = link.nextDep;
            next.prevDep = link.prevDep;
            if (link.prevDep) {
              link.prevDep.nextDep = next;
            }
            link.prevDep = activeSub.depsTail;
            link.nextDep = void 0;
            activeSub.depsTail.nextDep = link;
            activeSub.depsTail = link;
            if (activeSub.deps === link) {
              activeSub.deps = next;
            }
          }
        }
        if (activeSub.onTrack) {
          activeSub.onTrack(
            extend(
              {
                effect: activeSub
              },
              debugInfo
            )
          );
        }
        return link;
      }
      trigger(debugInfo) {
        this.version++;
        globalVersion++;
        this.notify(debugInfo);
      }
      notify(debugInfo) {
        startBatch();
        try {
          if (true) {
            for (let head2 = this.subsHead; head2; head2 = head2.nextSub) {
              if (head2.sub.onTrigger && !(head2.sub.flags & 8)) {
                head2.sub.onTrigger(
                  extend(
                    {
                      effect: head2.sub
                    },
                    debugInfo
                  )
                );
              }
            }
          }
          for (let link = this.subs; link; link = link.prevSub) {
            if (link.sub.notify()) {
              ;
              link.sub.dep.notify();
            }
          }
        } finally {
          endBatch();
        }
      }
    }
    function addSub(link) {
      link.dep.sc++;
      if (link.sub.flags & 4) {
        const computed2 = link.dep.computed;
        if (computed2 && !link.dep.subs) {
          computed2.flags |= 4 | 16;
          for (let l = computed2.deps; l; l = l.nextDep) {
            addSub(l);
          }
        }
        const currentTail = link.dep.subs;
        if (currentTail !== link) {
          link.prevSub = currentTail;
          if (currentTail) currentTail.nextSub = link;
        }
        if (link.dep.subsHead === void 0) {
          link.dep.subsHead = link;
        }
        link.dep.subs = link;
      }
    }
    const targetMap = /* @__PURE__ */ new WeakMap();
    const ITERATE_KEY = Symbol(
      true ? "Object iterate" : ""
    );
    const MAP_KEY_ITERATE_KEY = Symbol(
      true ? "Map keys iterate" : ""
    );
    const ARRAY_ITERATE_KEY = Symbol(
      true ? "Array iterate" : ""
    );
    function track(target, type2, key) {
      if (shouldTrack && activeSub) {
        let depsMap = targetMap.get(target);
        if (!depsMap) {
          targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
        }
        let dep = depsMap.get(key);
        if (!dep) {
          depsMap.set(key, dep = new Dep());
          dep.map = depsMap;
          dep.key = key;
        }
        if (true) {
          dep.track({
            target,
            type: type2,
            key
          });
        } else {
          dep.track();
        }
      }
    }
    function trigger(target, type2, key, newValue, oldValue, oldTarget) {
      const depsMap = targetMap.get(target);
      if (!depsMap) {
        globalVersion++;
        return;
      }
      const run = (dep) => {
        if (dep) {
          if (true) {
            dep.trigger({
              target,
              type: type2,
              key,
              newValue,
              oldValue,
              oldTarget
            });
          } else {
            dep.trigger();
          }
        }
      };
      startBatch();
      if (type2 === "clear") {
        depsMap.forEach(run);
      } else {
        const targetIsArray = isArray$1(target);
        const isArrayIndex = targetIsArray && isIntegerKey(key);
        if (targetIsArray && key === "length") {
          const newLength = Number(newValue);
          depsMap.forEach((dep, key2) => {
            if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol$2(key2) && key2 >= newLength) {
              run(dep);
            }
          });
        } else {
          if (key !== void 0 || depsMap.has(void 0)) {
            run(depsMap.get(key));
          }
          if (isArrayIndex) {
            run(depsMap.get(ARRAY_ITERATE_KEY));
          }
          switch (type2) {
            case "add":
              if (!targetIsArray) {
                run(depsMap.get(ITERATE_KEY));
                if (isMap$1(target)) {
                  run(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
              } else if (isArrayIndex) {
                run(depsMap.get("length"));
              }
              break;
            case "delete":
              if (!targetIsArray) {
                run(depsMap.get(ITERATE_KEY));
                if (isMap$1(target)) {
                  run(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
              }
              break;
            case "set":
              if (isMap$1(target)) {
                run(depsMap.get(ITERATE_KEY));
              }
              break;
          }
        }
      }
      endBatch();
    }
    function getDepFromReactive(object, key) {
      const depMap = targetMap.get(object);
      return depMap && depMap.get(key);
    }
    function reactiveReadArray(array) {
      const raw = toRaw(array);
      if (raw === array) return raw;
      track(raw, "iterate", ARRAY_ITERATE_KEY);
      return isShallow(array) ? raw : raw.map(toReactive);
    }
    function shallowReadArray(arr) {
      track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
      return arr;
    }
    const arrayInstrumentations = {
      __proto__: null,
      [Symbol.iterator]() {
        return iterator(this, Symbol.iterator, toReactive);
      },
      concat(...args) {
        return reactiveReadArray(this).concat(
          ...args.map((x) => isArray$1(x) ? reactiveReadArray(x) : x)
        );
      },
      entries() {
        return iterator(this, "entries", (value) => {
          value[1] = toReactive(value[1]);
          return value;
        });
      },
      every(fn, thisArg) {
        return apply(this, "every", fn, thisArg, void 0, arguments);
      },
      filter(fn, thisArg) {
        return apply(this, "filter", fn, thisArg, (v) => v.map(toReactive), arguments);
      },
      find(fn, thisArg) {
        return apply(this, "find", fn, thisArg, toReactive, arguments);
      },
      findIndex(fn, thisArg) {
        return apply(this, "findIndex", fn, thisArg, void 0, arguments);
      },
      findLast(fn, thisArg) {
        return apply(this, "findLast", fn, thisArg, toReactive, arguments);
      },
      findLastIndex(fn, thisArg) {
        return apply(this, "findLastIndex", fn, thisArg, void 0, arguments);
      },
      // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
      forEach(fn, thisArg) {
        return apply(this, "forEach", fn, thisArg, void 0, arguments);
      },
      includes(...args) {
        return searchProxy(this, "includes", args);
      },
      indexOf(...args) {
        return searchProxy(this, "indexOf", args);
      },
      join(separator) {
        return reactiveReadArray(this).join(separator);
      },
      // keys() iterator only reads `length`, no optimisation required
      lastIndexOf(...args) {
        return searchProxy(this, "lastIndexOf", args);
      },
      map(fn, thisArg) {
        return apply(this, "map", fn, thisArg, void 0, arguments);
      },
      pop() {
        return noTracking(this, "pop");
      },
      push(...args) {
        return noTracking(this, "push", args);
      },
      reduce(fn, ...args) {
        return reduce(this, "reduce", fn, args);
      },
      reduceRight(fn, ...args) {
        return reduce(this, "reduceRight", fn, args);
      },
      shift() {
        return noTracking(this, "shift");
      },
      // slice could use ARRAY_ITERATE but also seems to beg for range tracking
      some(fn, thisArg) {
        return apply(this, "some", fn, thisArg, void 0, arguments);
      },
      splice(...args) {
        return noTracking(this, "splice", args);
      },
      toReversed() {
        return reactiveReadArray(this).toReversed();
      },
      toSorted(comparer) {
        return reactiveReadArray(this).toSorted(comparer);
      },
      toSpliced(...args) {
        return reactiveReadArray(this).toSpliced(...args);
      },
      unshift(...args) {
        return noTracking(this, "unshift", args);
      },
      values() {
        return iterator(this, "values", toReactive);
      }
    };
    function iterator(self2, method, wrapValue) {
      const arr = shallowReadArray(self2);
      const iter = arr[method]();
      if (arr !== self2 && !isShallow(self2)) {
        iter._next = iter.next;
        iter.next = () => {
          const result = iter._next();
          if (result.value) {
            result.value = wrapValue(result.value);
          }
          return result;
        };
      }
      return iter;
    }
    const arrayProto = Array.prototype;
    function apply(self2, method, fn, thisArg, wrappedRetFn, args) {
      const arr = shallowReadArray(self2);
      const needsWrap = arr !== self2 && !isShallow(self2);
      const methodFn = arr[method];
      if (methodFn !== arrayProto[method]) {
        const result2 = methodFn.apply(self2, args);
        return needsWrap ? toReactive(result2) : result2;
      }
      let wrappedFn = fn;
      if (arr !== self2) {
        if (needsWrap) {
          wrappedFn = function(item, index) {
            return fn.call(this, toReactive(item), index, self2);
          };
        } else if (fn.length > 2) {
          wrappedFn = function(item, index) {
            return fn.call(this, item, index, self2);
          };
        }
      }
      const result = methodFn.call(arr, wrappedFn, thisArg);
      return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
    }
    function reduce(self2, method, fn, args) {
      const arr = shallowReadArray(self2);
      let wrappedFn = fn;
      if (arr !== self2) {
        if (!isShallow(self2)) {
          wrappedFn = function(acc, item, index) {
            return fn.call(this, acc, toReactive(item), index, self2);
          };
        } else if (fn.length > 3) {
          wrappedFn = function(acc, item, index) {
            return fn.call(this, acc, item, index, self2);
          };
        }
      }
      return arr[method](wrappedFn, ...args);
    }
    function searchProxy(self2, method, args) {
      const arr = toRaw(self2);
      track(arr, "iterate", ARRAY_ITERATE_KEY);
      const res = arr[method](...args);
      if ((res === -1 || res === false) && isProxy(args[0])) {
        args[0] = toRaw(args[0]);
        return arr[method](...args);
      }
      return res;
    }
    function noTracking(self2, method, args = []) {
      pauseTracking();
      startBatch();
      const res = toRaw(self2)[method].apply(self2, args);
      endBatch();
      resetTracking();
      return res;
    }
    const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
    const builtInSymbols = new Set(
      /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$2)
    );
    function hasOwnProperty(key) {
      if (!isSymbol$2(key)) key = String(key);
      const obj = toRaw(this);
      track(obj, "has", key);
      return obj.hasOwnProperty(key);
    }
    class BaseReactiveHandler {
      constructor(_isReadonly = false, _isShallow = false) {
        this._isReadonly = _isReadonly;
        this._isShallow = _isShallow;
      }
      get(target, key, receiver) {
        if (key === "__v_skip") return target["__v_skip"];
        const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_isShallow") {
          return isShallow2;
        } else if (key === "__v_raw") {
          if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
          // this means the receiver is a user proxy of the reactive proxy
          Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
            return target;
          }
          return;
        }
        const targetIsArray = isArray$1(target);
        if (!isReadonly2) {
          let fn;
          if (targetIsArray && (fn = arrayInstrumentations[key])) {
            return fn;
          }
          if (key === "hasOwnProperty") {
            return hasOwnProperty;
          }
        }
        const res = Reflect.get(
          target,
          key,
          // if this is a proxy wrapping a ref, return methods using the raw ref
          // as receiver so that we don't have to call `toRaw` on the ref in all
          // its class methods
          isRef(target) ? target : receiver
        );
        if (isSymbol$2(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
          return res;
        }
        if (!isReadonly2) {
          track(target, "get", key);
        }
        if (isShallow2) {
          return res;
        }
        if (isRef(res)) {
          return targetIsArray && isIntegerKey(key) ? res : res.value;
        }
        if (isObject(res)) {
          return isReadonly2 ? readonly(res) : reactive(res);
        }
        return res;
      }
    }
    class MutableReactiveHandler extends BaseReactiveHandler {
      constructor(isShallow2 = false) {
        super(false, isShallow2);
      }
      set(target, key, value, receiver) {
        let oldValue = target[key];
        if (!this._isShallow) {
          const isOldValueReadonly = isReadonly(oldValue);
          if (!isShallow(value) && !isReadonly(value)) {
            oldValue = toRaw(oldValue);
            value = toRaw(value);
          }
          if (!isArray$1(target) && isRef(oldValue) && !isRef(value)) {
            if (isOldValueReadonly) {
              return false;
            } else {
              oldValue.value = value;
              return true;
            }
          }
        }
        const hadKey = isArray$1(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
        const result = Reflect.set(
          target,
          key,
          value,
          isRef(target) ? target : receiver
        );
        if (target === toRaw(receiver)) {
          if (!hadKey) {
            trigger(target, "add", key, value);
          } else if (hasChanged(value, oldValue)) {
            trigger(target, "set", key, value, oldValue);
          }
        }
        return result;
      }
      deleteProperty(target, key) {
        const hadKey = hasOwn(target, key);
        const oldValue = target[key];
        const result = Reflect.deleteProperty(target, key);
        if (result && hadKey) {
          trigger(target, "delete", key, void 0, oldValue);
        }
        return result;
      }
      has(target, key) {
        const result = Reflect.has(target, key);
        if (!isSymbol$2(key) || !builtInSymbols.has(key)) {
          track(target, "has", key);
        }
        return result;
      }
      ownKeys(target) {
        track(
          target,
          "iterate",
          isArray$1(target) ? "length" : ITERATE_KEY
        );
        return Reflect.ownKeys(target);
      }
    }
    class ReadonlyReactiveHandler extends BaseReactiveHandler {
      constructor(isShallow2 = false) {
        super(true, isShallow2);
      }
      set(target, key) {
        if (true) {
          warn$2(
            `Set operation on key "${String(key)}" failed: target is readonly.`,
            target
          );
        }
        return true;
      }
      deleteProperty(target, key) {
        if (true) {
          warn$2(
            `Delete operation on key "${String(key)}" failed: target is readonly.`,
            target
          );
        }
        return true;
      }
    }
    const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
    const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
    const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
    const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
    const toShallow = (value) => value;
    const getProto = (v) => Reflect.getPrototypeOf(v);
    function createIterableMethod(method, isReadonly2, isShallow2) {
      return function(...args) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const targetIsMap = isMap$1(rawTarget);
        const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
        const isKeyOnly = method === "keys" && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(
          rawTarget,
          "iterate",
          isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
        );
        return {
          // iterator protocol
          next() {
            const { value, done } = innerIterator.next();
            return done ? { value, done } : {
              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
              done
            };
          },
          // iterable protocol
          [Symbol.iterator]() {
            return this;
          }
        };
      };
    }
    function createReadonlyMethod(type2) {
      return function(...args) {
        if (true) {
          const key = args[0] ? `on key "${args[0]}" ` : ``;
          warn$2(
            `${capitalize$1(type2)} operation ${key}failed: target is readonly.`,
            toRaw(this)
          );
        }
        return type2 === "delete" ? false : type2 === "clear" ? void 0 : this;
      };
    }
    function createInstrumentations(readonly2, shallow) {
      const instrumentations = {
        get(key) {
          const target = this["__v_raw"];
          const rawTarget = toRaw(target);
          const rawKey = toRaw(key);
          if (!readonly2) {
            if (hasChanged(key, rawKey)) {
              track(rawTarget, "get", key);
            }
            track(rawTarget, "get", rawKey);
          }
          const { has } = getProto(rawTarget);
          const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
          if (has.call(rawTarget, key)) {
            return wrap(target.get(key));
          } else if (has.call(rawTarget, rawKey)) {
            return wrap(target.get(rawKey));
          } else if (target !== rawTarget) {
            target.get(key);
          }
        },
        get size() {
          const target = this["__v_raw"];
          !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
          return Reflect.get(target, "size", target);
        },
        has(key) {
          const target = this["__v_raw"];
          const rawTarget = toRaw(target);
          const rawKey = toRaw(key);
          if (!readonly2) {
            if (hasChanged(key, rawKey)) {
              track(rawTarget, "has", key);
            }
            track(rawTarget, "has", rawKey);
          }
          return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
        },
        forEach(callback, thisArg) {
          const observed = this;
          const target = observed["__v_raw"];
          const rawTarget = toRaw(target);
          const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
          !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
          return target.forEach((value, key) => {
            return callback.call(thisArg, wrap(value), wrap(key), observed);
          });
        }
      };
      extend(
        instrumentations,
        readonly2 ? {
          add: createReadonlyMethod("add"),
          set: createReadonlyMethod("set"),
          delete: createReadonlyMethod("delete"),
          clear: createReadonlyMethod("clear")
        } : {
          add(value) {
            if (!shallow && !isShallow(value) && !isReadonly(value)) {
              value = toRaw(value);
            }
            const target = toRaw(this);
            const proto = getProto(target);
            const hadKey = proto.has.call(target, value);
            if (!hadKey) {
              target.add(value);
              trigger(target, "add", value, value);
            }
            return this;
          },
          set(key, value) {
            if (!shallow && !isShallow(value) && !isReadonly(value)) {
              value = toRaw(value);
            }
            const target = toRaw(this);
            const { has, get } = getProto(target);
            let hadKey = has.call(target, key);
            if (!hadKey) {
              key = toRaw(key);
              hadKey = has.call(target, key);
            } else if (true) {
              checkIdentityKeys(target, has, key);
            }
            const oldValue = get.call(target, key);
            target.set(key, value);
            if (!hadKey) {
              trigger(target, "add", key, value);
            } else if (hasChanged(value, oldValue)) {
              trigger(target, "set", key, value, oldValue);
            }
            return this;
          },
          delete(key) {
            const target = toRaw(this);
            const { has, get } = getProto(target);
            let hadKey = has.call(target, key);
            if (!hadKey) {
              key = toRaw(key);
              hadKey = has.call(target, key);
            } else if (true) {
              checkIdentityKeys(target, has, key);
            }
            const oldValue = get ? get.call(target, key) : void 0;
            const result = target.delete(key);
            if (hadKey) {
              trigger(target, "delete", key, void 0, oldValue);
            }
            return result;
          },
          clear() {
            const target = toRaw(this);
            const hadItems = target.size !== 0;
            const oldTarget = true ? isMap$1(target) ? new Map(target) : new Set(target) : void 0;
            const result = target.clear();
            if (hadItems) {
              trigger(
                target,
                "clear",
                void 0,
                void 0,
                oldTarget
              );
            }
            return result;
          }
        }
      );
      const iteratorMethods = [
        "keys",
        "values",
        "entries",
        Symbol.iterator
      ];
      iteratorMethods.forEach((method) => {
        instrumentations[method] = createIterableMethod(method, readonly2, shallow);
      });
      return instrumentations;
    }
    function createInstrumentationGetter(isReadonly2, shallow) {
      const instrumentations = createInstrumentations(isReadonly2, shallow);
      return (target, key, receiver) => {
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_raw") {
          return target;
        }
        return Reflect.get(
          hasOwn(instrumentations, key) && key in target ? instrumentations : target,
          key,
          receiver
        );
      };
    }
    const mutableCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, false)
    };
    const shallowCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, true)
    };
    const readonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, false)
    };
    const shallowReadonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, true)
    };
    function checkIdentityKeys(target, has, key) {
      const rawKey = toRaw(key);
      if (rawKey !== key && has.call(target, rawKey)) {
        const type2 = toRawType(target);
        warn$2(
          `Reactive ${type2} contains both the raw and reactive versions of the same object${type2 === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
        );
      }
    }
    const reactiveMap = /* @__PURE__ */ new WeakMap();
    const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
    const readonlyMap = /* @__PURE__ */ new WeakMap();
    const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
    function targetTypeMap(rawType) {
      switch (rawType) {
        case "Object":
        case "Array":
          return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
          return 2;
        default:
          return 0;
      }
    }
    function getTargetType(value) {
      return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
    }
    function reactive(target) {
      if (isReadonly(target)) {
        return target;
      }
      return createReactiveObject(
        target,
        false,
        mutableHandlers,
        mutableCollectionHandlers,
        reactiveMap
      );
    }
    function shallowReactive(target) {
      return createReactiveObject(
        target,
        false,
        shallowReactiveHandlers,
        shallowCollectionHandlers,
        shallowReactiveMap
      );
    }
    function readonly(target) {
      return createReactiveObject(
        target,
        true,
        readonlyHandlers,
        readonlyCollectionHandlers,
        readonlyMap
      );
    }
    function shallowReadonly(target) {
      return createReactiveObject(
        target,
        true,
        shallowReadonlyHandlers,
        shallowReadonlyCollectionHandlers,
        shallowReadonlyMap
      );
    }
    function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
      if (!isObject(target)) {
        if (true) {
          warn$2(
            `value cannot be made ${isReadonly2 ? "readonly" : "reactive"}: ${String(
              target
            )}`
          );
        }
        return target;
      }
      if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
        return target;
      }
      const existingProxy = proxyMap.get(target);
      if (existingProxy) {
        return existingProxy;
      }
      const targetType = getTargetType(target);
      if (targetType === 0) {
        return target;
      }
      const proxy = new Proxy(
        target,
        targetType === 2 ? collectionHandlers : baseHandlers
      );
      proxyMap.set(target, proxy);
      return proxy;
    }
    function isReactive(value) {
      if (isReadonly(value)) {
        return isReactive(value["__v_raw"]);
      }
      return !!(value && value["__v_isReactive"]);
    }
    function isReadonly(value) {
      return !!(value && value["__v_isReadonly"]);
    }
    function isShallow(value) {
      return !!(value && value["__v_isShallow"]);
    }
    function isProxy(value) {
      return value ? !!value["__v_raw"] : false;
    }
    function toRaw(observed) {
      const raw = observed && observed["__v_raw"];
      return raw ? toRaw(raw) : observed;
    }
    function markRaw(value) {
      if (!hasOwn(value, "__v_skip") && Object.isExtensible(value)) {
        def(value, "__v_skip", true);
      }
      return value;
    }
    const toReactive = (value) => isObject(value) ? reactive(value) : value;
    const toReadonly = (value) => isObject(value) ? readonly(value) : value;
    function isRef(r) {
      return r ? r["__v_isRef"] === true : false;
    }
    function ref$1(value) {
      return createRef(value, false);
    }
    function shallowRef(value) {
      return createRef(value, true);
    }
    function createRef(rawValue, shallow) {
      if (isRef(rawValue)) {
        return rawValue;
      }
      return new RefImpl(rawValue, shallow);
    }
    class RefImpl {
      constructor(value, isShallow2) {
        this.dep = new Dep();
        this["__v_isRef"] = true;
        this["__v_isShallow"] = false;
        this._rawValue = isShallow2 ? value : toRaw(value);
        this._value = isShallow2 ? value : toReactive(value);
        this["__v_isShallow"] = isShallow2;
      }
      get value() {
        if (true) {
          this.dep.track({
            target: this,
            type: "get",
            key: "value"
          });
        } else {
          this.dep.track();
        }
        return this._value;
      }
      set value(newValue) {
        const oldValue = this._rawValue;
        const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
        newValue = useDirectValue ? newValue : toRaw(newValue);
        if (hasChanged(newValue, oldValue)) {
          this._rawValue = newValue;
          this._value = useDirectValue ? newValue : toReactive(newValue);
          if (true) {
            this.dep.trigger({
              target: this,
              type: "set",
              key: "value",
              newValue,
              oldValue
            });
          } else {
            this.dep.trigger();
          }
        }
      }
    }
    function triggerRef(ref2) {
      if (ref2.dep) {
        if (true) {
          ref2.dep.trigger({
            target: ref2,
            type: "set",
            key: "value",
            newValue: ref2._value
          });
        } else {
          ref2.dep.trigger();
        }
      }
    }
    function unref(ref2) {
      return isRef(ref2) ? ref2.value : ref2;
    }
    function toValue(source) {
      return isFunction$1(source) ? source() : unref(source);
    }
    const shallowUnwrapHandlers = {
      get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
      set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        } else {
          return Reflect.set(target, key, value, receiver);
        }
      }
    };
    function proxyRefs(objectWithRefs) {
      return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
    }
    class CustomRefImpl {
      constructor(factory) {
        this["__v_isRef"] = true;
        this._value = void 0;
        const dep = this.dep = new Dep();
        const { get, set } = factory(dep.track.bind(dep), dep.trigger.bind(dep));
        this._get = get;
        this._set = set;
      }
      get value() {
        return this._value = this._get();
      }
      set value(newVal) {
        this._set(newVal);
      }
    }
    function customRef(factory) {
      return new CustomRefImpl(factory);
    }
    function toRefs(object) {
      if (!isProxy(object)) {
        warn$2(`toRefs() expects a reactive object but received a plain one.`);
      }
      const ret = isArray$1(object) ? new Array(object.length) : {};
      for (const key in object) {
        ret[key] = propertyToRef(object, key);
      }
      return ret;
    }
    class ObjectRefImpl {
      constructor(_object, _key, _defaultValue) {
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this["__v_isRef"] = true;
        this._value = void 0;
      }
      get value() {
        const val = this._object[this._key];
        return this._value = val === void 0 ? this._defaultValue : val;
      }
      set value(newVal) {
        this._object[this._key] = newVal;
      }
      get dep() {
        return getDepFromReactive(toRaw(this._object), this._key);
      }
    }
    class GetterRefImpl {
      constructor(_getter) {
        this._getter = _getter;
        this["__v_isRef"] = true;
        this["__v_isReadonly"] = true;
        this._value = void 0;
      }
      get value() {
        return this._value = this._getter();
      }
    }
    function toRef(source, key, defaultValue) {
      if (isRef(source)) {
        return source;
      } else if (isFunction$1(source)) {
        return new GetterRefImpl(source);
      } else if (isObject(source) && arguments.length > 1) {
        return propertyToRef(source, key, defaultValue);
      } else {
        return ref$1(source);
      }
    }
    function propertyToRef(source, key, defaultValue) {
      const val = source[key];
      return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
    }
    class ComputedRefImpl {
      constructor(fn, setter, isSSR) {
        this.fn = fn;
        this.setter = setter;
        this._value = void 0;
        this.dep = new Dep(this);
        this.__v_isRef = true;
        this.deps = void 0;
        this.depsTail = void 0;
        this.flags = 16;
        this.globalVersion = globalVersion - 1;
        this.next = void 0;
        this.effect = this;
        this["__v_isReadonly"] = !setter;
        this.isSSR = isSSR;
      }
      /**
       * @internal
       */
      notify() {
        this.flags |= 16;
        if (!(this.flags & 8) && // avoid infinite self recursion
        activeSub !== this) {
          batch(this, true);
          return true;
        } else if (true) ;
      }
      get value() {
        const link = true ? this.dep.track({
          target: this,
          type: "get",
          key: "value"
        }) : this.dep.track();
        refreshComputed(this);
        if (link) {
          link.version = this.dep.version;
        }
        return this._value;
      }
      set value(newValue) {
        if (this.setter) {
          this.setter(newValue);
        } else if (true) {
          warn$2("Write operation failed: computed value is readonly");
        }
      }
    }
    function computed$1(getterOrOptions, debugOptions, isSSR = false) {
      let getter;
      let setter;
      if (isFunction$1(getterOrOptions)) {
        getter = getterOrOptions;
      } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
      }
      const cRef = new ComputedRefImpl(getter, setter, isSSR);
      if (debugOptions && !isSSR) {
        cRef.onTrack = debugOptions.onTrack;
        cRef.onTrigger = debugOptions.onTrigger;
      }
      return cRef;
    }
    const TrackOpTypes = {
      "GET": "get",
      "HAS": "has",
      "ITERATE": "iterate"
    };
    const TriggerOpTypes = {
      "SET": "set",
      "ADD": "add",
      "DELETE": "delete",
      "CLEAR": "clear"
    };
    const ReactiveFlags = {
      "SKIP": "__v_skip",
      "IS_REACTIVE": "__v_isReactive",
      "IS_READONLY": "__v_isReadonly",
      "IS_SHALLOW": "__v_isShallow",
      "RAW": "__v_raw",
      "IS_REF": "__v_isRef"
    };
    const WatchErrorCodes = {
      "WATCH_GETTER": 2,
      "2": "WATCH_GETTER",
      "WATCH_CALLBACK": 3,
      "3": "WATCH_CALLBACK",
      "WATCH_CLEANUP": 4,
      "4": "WATCH_CLEANUP"
    };
    const INITIAL_WATCHER_VALUE = {};
    const cleanupMap = /* @__PURE__ */ new WeakMap();
    let activeWatcher = void 0;
    function getCurrentWatcher() {
      return activeWatcher;
    }
    function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
      if (owner) {
        let cleanups = cleanupMap.get(owner);
        if (!cleanups) cleanupMap.set(owner, cleanups = []);
        cleanups.push(cleanupFn);
      } else if (!failSilently) {
        warn$2(
          `onWatcherCleanup() was called when there was no active watcher to associate with.`
        );
      }
    }
    function watch$1(source, cb, options = EMPTY_OBJ) {
      const { immediate, deep, once: once2, scheduler, augmentJob, call } = options;
      const warnInvalidSource = (s) => {
        (options.onWarn || warn$2)(
          `Invalid watch source: `,
          s,
          `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`
        );
      };
      const reactiveGetter = (source2) => {
        if (deep) return source2;
        if (isShallow(source2) || deep === false || deep === 0)
          return traverse(source2, 1);
        return traverse(source2);
      };
      let effect2;
      let getter;
      let cleanup;
      let boundCleanup;
      let forceTrigger = false;
      let isMultiSource = false;
      if (isRef(source)) {
        getter = () => source.value;
        forceTrigger = isShallow(source);
      } else if (isReactive(source)) {
        getter = () => reactiveGetter(source);
        forceTrigger = true;
      } else if (isArray$1(source)) {
        isMultiSource = true;
        forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
        getter = () => source.map((s) => {
          if (isRef(s)) {
            return s.value;
          } else if (isReactive(s)) {
            return reactiveGetter(s);
          } else if (isFunction$1(s)) {
            return call ? call(s, 2) : s();
          } else {
            warnInvalidSource(s);
          }
        });
      } else if (isFunction$1(source)) {
        if (cb) {
          getter = call ? () => call(source, 2) : source;
        } else {
          getter = () => {
            if (cleanup) {
              pauseTracking();
              try {
                cleanup();
              } finally {
                resetTracking();
              }
            }
            const currentEffect = activeWatcher;
            activeWatcher = effect2;
            try {
              return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
            } finally {
              activeWatcher = currentEffect;
            }
          };
        }
      } else {
        getter = NOOP;
        warnInvalidSource(source);
      }
      if (cb && deep) {
        const baseGetter = getter;
        const depth = deep === true ? Infinity : deep;
        getter = () => traverse(baseGetter(), depth);
      }
      const scope2 = getCurrentScope();
      const watchHandle = () => {
        effect2.stop();
        if (scope2 && scope2.active) {
          remove$1(scope2.effects, effect2);
        }
      };
      if (once2 && cb) {
        const _cb = cb;
        cb = (...args) => {
          _cb(...args);
          watchHandle();
        };
      }
      let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
      const job = (immediateFirstRun) => {
        if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
          return;
        }
        if (cb) {
          const newValue = effect2.run();
          if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
            if (cleanup) {
              cleanup();
            }
            const currentWatcher = activeWatcher;
            activeWatcher = effect2;
            try {
              const args = [
                newValue,
                // pass undefined as the old value when it's changed for the first time
                oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
                boundCleanup
              ];
              call ? call(cb, 3, args) : (
                // @ts-expect-error
                cb(...args)
              );
              oldValue = newValue;
            } finally {
              activeWatcher = currentWatcher;
            }
          }
        } else {
          effect2.run();
        }
      };
      if (augmentJob) {
        augmentJob(job);
      }
      effect2 = new ReactiveEffect(getter);
      effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
      boundCleanup = (fn) => onWatcherCleanup(fn, false, effect2);
      cleanup = effect2.onStop = () => {
        const cleanups = cleanupMap.get(effect2);
        if (cleanups) {
          if (call) {
            call(cleanups, 4);
          } else {
            for (const cleanup2 of cleanups) cleanup2();
          }
          cleanupMap.delete(effect2);
        }
      };
      if (true) {
        effect2.onTrack = options.onTrack;
        effect2.onTrigger = options.onTrigger;
      }
      if (cb) {
        if (immediate) {
          job(true);
        } else {
          oldValue = effect2.run();
        }
      } else if (scheduler) {
        scheduler(job.bind(null, true), true);
      } else {
        effect2.run();
      }
      watchHandle.pause = effect2.pause.bind(effect2);
      watchHandle.resume = effect2.resume.bind(effect2);
      watchHandle.stop = watchHandle;
      return watchHandle;
    }
    function traverse(value, depth = Infinity, seen) {
      if (depth <= 0 || !isObject(value) || value["__v_skip"]) {
        return value;
      }
      seen = seen || /* @__PURE__ */ new Set();
      if (seen.has(value)) {
        return value;
      }
      seen.add(value);
      depth--;
      if (isRef(value)) {
        traverse(value.value, depth, seen);
      } else if (isArray$1(value)) {
        for (let i = 0; i < value.length; i++) {
          traverse(value[i], depth, seen);
        }
      } else if (isSet$1(value) || isMap$1(value)) {
        value.forEach((v) => {
          traverse(v, depth, seen);
        });
      } else if (isPlainObject$2(value)) {
        for (const key in value) {
          traverse(value[key], depth, seen);
        }
        for (const key of Object.getOwnPropertySymbols(value)) {
          if (Object.prototype.propertyIsEnumerable.call(value, key)) {
            traverse(value[key], depth, seen);
          }
        }
      }
      return value;
    }
    /**
    * @vue/runtime-core v3.5.13
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    const stack = [];
    function pushWarningContext(vnode) {
      stack.push(vnode);
    }
    function popWarningContext() {
      stack.pop();
    }
    let isWarning = false;
    function warn$1(msg, ...args) {
      if (isWarning) return;
      isWarning = true;
      pauseTracking();
      const instance = stack.length ? stack[stack.length - 1].component : null;
      const appWarnHandler = instance && instance.appContext.config.warnHandler;
      const trace = getComponentTrace();
      if (appWarnHandler) {
        callWithErrorHandling(
          appWarnHandler,
          instance,
          11,
          [
            // eslint-disable-next-line no-restricted-syntax
            msg + args.map((a) => {
              var _a, _b;
              return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
            }).join(""),
            instance && instance.proxy,
            trace.map(
              ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
            ).join("\n"),
            trace
          ]
        );
      } else {
        const warnArgs = [`[Vue warn]: ${msg}`, ...args];
        if (trace.length && // avoid spamming console during tests
        true) {
          warnArgs.push(`
  `, ...formatTrace(trace));
        }
        console.warn(...warnArgs);
      }
      resetTracking();
      isWarning = false;
    }
    function getComponentTrace() {
      let currentVNode = stack[stack.length - 1];
      if (!currentVNode) {
        return [];
      }
      const normalizedStack = [];
      while (currentVNode) {
        const last2 = normalizedStack[0];
        if (last2 && last2.vnode === currentVNode) {
          last2.recurseCount++;
        } else {
          normalizedStack.push({
            vnode: currentVNode,
            recurseCount: 0
          });
        }
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
      }
      return normalizedStack;
    }
    function formatTrace(trace) {
      const logs = [];
      trace.forEach((entry, i) => {
        logs.push(...i === 0 ? [] : [`
  `], ...formatTraceEntry(entry));
      });
      return logs;
    }
    function formatTraceEntry({ vnode, recurseCount }) {
      const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
      const isRoot = vnode.component ? vnode.component.parent == null : false;
      const open = ` at <${formatComponentName(
        vnode.component,
        vnode.type,
        isRoot
      )}`;
      const close = `>` + postfix;
      return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
    }
    function formatProps(props) {
      const res = [];
      const keys = Object.keys(props);
      keys.slice(0, 3).forEach((key) => {
        res.push(...formatProp(key, props[key]));
      });
      if (keys.length > 3) {
        res.push(` ...`);
      }
      return res;
    }
    function formatProp(key, value, raw) {
      if (isString$1(value)) {
        value = JSON.stringify(value);
        return raw ? value : [`${key}=${value}`];
      } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
        return raw ? value : [`${key}=${value}`];
      } else if (isRef(value)) {
        value = formatProp(key, toRaw(value.value), true);
        return raw ? value : [`${key}=Ref<`, value, `>`];
      } else if (isFunction$1(value)) {
        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
      } else {
        value = toRaw(value);
        return raw ? value : [`${key}=`, value];
      }
    }
    function assertNumber(val, type2) {
      if (false) return;
      if (val === void 0) {
        return;
      } else if (typeof val !== "number") {
        warn$1(`${type2} is not a valid number - got ${JSON.stringify(val)}.`);
      } else if (isNaN(val)) {
        warn$1(`${type2} is NaN - the duration expression might be incorrect.`);
      }
    }
    const ErrorCodes = {
      "SETUP_FUNCTION": 0,
      "0": "SETUP_FUNCTION",
      "RENDER_FUNCTION": 1,
      "1": "RENDER_FUNCTION",
      "NATIVE_EVENT_HANDLER": 5,
      "5": "NATIVE_EVENT_HANDLER",
      "COMPONENT_EVENT_HANDLER": 6,
      "6": "COMPONENT_EVENT_HANDLER",
      "VNODE_HOOK": 7,
      "7": "VNODE_HOOK",
      "DIRECTIVE_HOOK": 8,
      "8": "DIRECTIVE_HOOK",
      "TRANSITION_HOOK": 9,
      "9": "TRANSITION_HOOK",
      "APP_ERROR_HANDLER": 10,
      "10": "APP_ERROR_HANDLER",
      "APP_WARN_HANDLER": 11,
      "11": "APP_WARN_HANDLER",
      "FUNCTION_REF": 12,
      "12": "FUNCTION_REF",
      "ASYNC_COMPONENT_LOADER": 13,
      "13": "ASYNC_COMPONENT_LOADER",
      "SCHEDULER": 14,
      "14": "SCHEDULER",
      "COMPONENT_UPDATE": 15,
      "15": "COMPONENT_UPDATE",
      "APP_UNMOUNT_CLEANUP": 16,
      "16": "APP_UNMOUNT_CLEANUP"
    };
    const ErrorTypeStrings$1 = {
      ["sp"]: "serverPrefetch hook",
      ["bc"]: "beforeCreate hook",
      ["c"]: "created hook",
      ["bm"]: "beforeMount hook",
      ["m"]: "mounted hook",
      ["bu"]: "beforeUpdate hook",
      ["u"]: "updated",
      ["bum"]: "beforeUnmount hook",
      ["um"]: "unmounted hook",
      ["a"]: "activated hook",
      ["da"]: "deactivated hook",
      ["ec"]: "errorCaptured hook",
      ["rtc"]: "renderTracked hook",
      ["rtg"]: "renderTriggered hook",
      [0]: "setup function",
      [1]: "render function",
      [2]: "watcher getter",
      [3]: "watcher callback",
      [4]: "watcher cleanup function",
      [5]: "native event handler",
      [6]: "component event handler",
      [7]: "vnode hook",
      [8]: "directive hook",
      [9]: "transition hook",
      [10]: "app errorHandler",
      [11]: "app warnHandler",
      [12]: "ref function",
      [13]: "async component loader",
      [14]: "scheduler flush",
      [15]: "component update",
      [16]: "app unmount cleanup function"
    };
    function callWithErrorHandling(fn, instance, type2, args) {
      try {
        return args ? fn(...args) : fn();
      } catch (err) {
        handleError(err, instance, type2);
      }
    }
    function callWithAsyncErrorHandling(fn, instance, type2, args) {
      if (isFunction$1(fn)) {
        const res = callWithErrorHandling(fn, instance, type2, args);
        if (res && isPromise$1(res)) {
          res.catch((err) => {
            handleError(err, instance, type2);
          });
        }
        return res;
      }
      if (isArray$1(fn)) {
        const values = [];
        for (let i = 0; i < fn.length; i++) {
          values.push(callWithAsyncErrorHandling(fn[i], instance, type2, args));
        }
        return values;
      } else if (true) {
        warn$1(
          `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof fn}`
        );
      }
    }
    function handleError(err, instance, type2, throwInDev = true) {
      const contextVNode = instance ? instance.vnode : null;
      const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
      if (instance) {
        let cur = instance.parent;
        const exposedInstance = instance.proxy;
        const errorInfo = true ? ErrorTypeStrings$1[type2] : `https://vuejs.org/error-reference/#runtime-${type2}`;
        while (cur) {
          const errorCapturedHooks = cur.ec;
          if (errorCapturedHooks) {
            for (let i = 0; i < errorCapturedHooks.length; i++) {
              if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                return;
              }
            }
          }
          cur = cur.parent;
        }
        if (errorHandler) {
          pauseTracking();
          callWithErrorHandling(errorHandler, null, 10, [
            err,
            exposedInstance,
            errorInfo
          ]);
          resetTracking();
          return;
        }
      }
      logError(err, type2, contextVNode, throwInDev, throwUnhandledErrorInProduction);
    }
    function logError(err, type2, contextVNode, throwInDev = true, throwInProd = false) {
      if (true) {
        const info = ErrorTypeStrings$1[type2];
        if (contextVNode) {
          pushWarningContext(contextVNode);
        }
        warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
        if (contextVNode) {
          popWarningContext();
        }
        if (throwInDev) {
          throw err;
        } else {
          console.error(err);
        }
      } else if (throwInProd) {
        throw err;
      } else {
        console.error(err);
      }
    }
    const queue = [];
    let flushIndex = -1;
    const pendingPostFlushCbs = [];
    let activePostFlushCbs = null;
    let postFlushIndex = 0;
    const resolvedPromise = /* @__PURE__ */ Promise.resolve();
    let currentFlushPromise = null;
    const RECURSION_LIMIT = 100;
    function nextTick(fn) {
      const p2 = currentFlushPromise || resolvedPromise;
      return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
    }
    function findInsertionIndex(id2) {
      let start = flushIndex + 1;
      let end = queue.length;
      while (start < end) {
        const middle = start + end >>> 1;
        const middleJob = queue[middle];
        const middleJobId = getId(middleJob);
        if (middleJobId < id2 || middleJobId === id2 && middleJob.flags & 2) {
          start = middle + 1;
        } else {
          end = middle;
        }
      }
      return start;
    }
    function queueJob(job) {
      if (!(job.flags & 1)) {
        const jobId = getId(job);
        const lastJob = queue[queue.length - 1];
        if (!lastJob || // fast path when the job id is larger than the tail
        !(job.flags & 2) && jobId >= getId(lastJob)) {
          queue.push(job);
        } else {
          queue.splice(findInsertionIndex(jobId), 0, job);
        }
        job.flags |= 1;
        queueFlush();
      }
    }
    function queueFlush() {
      if (!currentFlushPromise) {
        currentFlushPromise = resolvedPromise.then(flushJobs);
      }
    }
    function queuePostFlushCb(cb) {
      if (!isArray$1(cb)) {
        if (activePostFlushCbs && cb.id === -1) {
          activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
        } else if (!(cb.flags & 1)) {
          pendingPostFlushCbs.push(cb);
          cb.flags |= 1;
        }
      } else {
        pendingPostFlushCbs.push(...cb);
      }
      queueFlush();
    }
    function flushPreFlushCbs(instance, seen, i = flushIndex + 1) {
      if (true) {
        seen = seen || /* @__PURE__ */ new Map();
      }
      for (; i < queue.length; i++) {
        const cb = queue[i];
        if (cb && cb.flags & 2) {
          if (instance && cb.id !== instance.uid) {
            continue;
          }
          if (checkRecursiveUpdates(seen, cb)) {
            continue;
          }
          queue.splice(i, 1);
          i--;
          if (cb.flags & 4) {
            cb.flags &= ~1;
          }
          cb();
          if (!(cb.flags & 4)) {
            cb.flags &= ~1;
          }
        }
      }
    }
    function flushPostFlushCbs(seen) {
      if (pendingPostFlushCbs.length) {
        const deduped = [...new Set(pendingPostFlushCbs)].sort(
          (a, b) => getId(a) - getId(b)
        );
        pendingPostFlushCbs.length = 0;
        if (activePostFlushCbs) {
          activePostFlushCbs.push(...deduped);
          return;
        }
        activePostFlushCbs = deduped;
        if (true) {
          seen = seen || /* @__PURE__ */ new Map();
        }
        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
          const cb = activePostFlushCbs[postFlushIndex];
          if (checkRecursiveUpdates(seen, cb)) {
            continue;
          }
          if (cb.flags & 4) {
            cb.flags &= ~1;
          }
          if (!(cb.flags & 8)) cb();
          cb.flags &= ~1;
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
      }
    }
    const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
    function flushJobs(seen) {
      if (true) {
        seen = seen || /* @__PURE__ */ new Map();
      }
      const check = true ? (job) => checkRecursiveUpdates(seen, job) : NOOP;
      try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
          const job = queue[flushIndex];
          if (job && !(job.flags & 8)) {
            if (check(job)) {
              continue;
            }
            if (job.flags & 4) {
              job.flags &= ~1;
            }
            callWithErrorHandling(
              job,
              job.i,
              job.i ? 15 : 14
            );
            if (!(job.flags & 4)) {
              job.flags &= ~1;
            }
          }
        }
      } finally {
        for (; flushIndex < queue.length; flushIndex++) {
          const job = queue[flushIndex];
          if (job) {
            job.flags &= ~1;
          }
        }
        flushIndex = -1;
        queue.length = 0;
        flushPostFlushCbs(seen);
        currentFlushPromise = null;
        if (queue.length || pendingPostFlushCbs.length) {
          flushJobs(seen);
        }
      }
    }
    function checkRecursiveUpdates(seen, fn) {
      const count = seen.get(fn) || 0;
      if (count > RECURSION_LIMIT) {
        const instance = fn.i;
        const componentName = instance && getComponentName(instance.type);
        handleError(
          `Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
          null,
          10
        );
        return true;
      }
      seen.set(fn, count + 1);
      return false;
    }
    let isHmrUpdating = false;
    const hmrDirtyComponents = /* @__PURE__ */ new Map();
    if (true) {
      getGlobalThis().__VUE_HMR_RUNTIME__ = {
        createRecord: tryWrap(createRecord),
        rerender: tryWrap(rerender),
        reload: tryWrap(reload)
      };
    }
    const map = /* @__PURE__ */ new Map();
    function registerHMR(instance) {
      const id2 = instance.type.__hmrId;
      let record = map.get(id2);
      if (!record) {
        createRecord(id2, instance.type);
        record = map.get(id2);
      }
      record.instances.add(instance);
    }
    function unregisterHMR(instance) {
      map.get(instance.type.__hmrId).instances.delete(instance);
    }
    function createRecord(id2, initialDef) {
      if (map.has(id2)) {
        return false;
      }
      map.set(id2, {
        initialDef: normalizeClassComponent(initialDef),
        instances: /* @__PURE__ */ new Set()
      });
      return true;
    }
    function normalizeClassComponent(component) {
      return isClassComponent(component) ? component.__vccOpts : component;
    }
    function rerender(id2, newRender) {
      const record = map.get(id2);
      if (!record) {
        return;
      }
      record.initialDef.render = newRender;
      [...record.instances].forEach((instance) => {
        if (newRender) {
          instance.render = newRender;
          normalizeClassComponent(instance.type).render = newRender;
        }
        instance.renderCache = [];
        isHmrUpdating = true;
        instance.update();
        isHmrUpdating = false;
      });
    }
    function reload(id2, newComp) {
      const record = map.get(id2);
      if (!record) return;
      newComp = normalizeClassComponent(newComp);
      updateComponentDef(record.initialDef, newComp);
      const instances = [...record.instances];
      for (let i = 0; i < instances.length; i++) {
        const instance = instances[i];
        const oldComp = normalizeClassComponent(instance.type);
        let dirtyInstances = hmrDirtyComponents.get(oldComp);
        if (!dirtyInstances) {
          if (oldComp !== record.initialDef) {
            updateComponentDef(oldComp, newComp);
          }
          hmrDirtyComponents.set(oldComp, dirtyInstances = /* @__PURE__ */ new Set());
        }
        dirtyInstances.add(instance);
        instance.appContext.propsCache.delete(instance.type);
        instance.appContext.emitsCache.delete(instance.type);
        instance.appContext.optionsCache.delete(instance.type);
        if (instance.ceReload) {
          dirtyInstances.add(instance);
          instance.ceReload(newComp.styles);
          dirtyInstances.delete(instance);
        } else if (instance.parent) {
          queueJob(() => {
            isHmrUpdating = true;
            instance.parent.update();
            isHmrUpdating = false;
            dirtyInstances.delete(instance);
          });
        } else if (instance.appContext.reload) {
          instance.appContext.reload();
        } else if (typeof window !== "undefined") {
          window.location.reload();
        } else {
          console.warn(
            "[HMR] Root or manually mounted instance modified. Full reload required."
          );
        }
        if (instance.root.ce && instance !== instance.root) {
          instance.root.ce._removeChildStyle(oldComp);
        }
      }
      queuePostFlushCb(() => {
        hmrDirtyComponents.clear();
      });
    }
    function updateComponentDef(oldComp, newComp) {
      extend(oldComp, newComp);
      for (const key in oldComp) {
        if (key !== "__file" && !(key in newComp)) {
          delete oldComp[key];
        }
      }
    }
    function tryWrap(fn) {
      return (id2, arg) => {
        try {
          return fn(id2, arg);
        } catch (e) {
          console.error(e);
          console.warn(
            `[HMR] Something went wrong during Vue component hot-reload. Full reload required.`
          );
        }
      };
    }
    let devtools$1;
    let buffer = [];
    let devtoolsNotInstalled = false;
    function emit$1(event, ...args) {
      if (devtools$1) {
        devtools$1.emit(event, ...args);
      } else if (!devtoolsNotInstalled) {
        buffer.push({ event, args });
      }
    }
    function setDevtoolsHook$1(hook, target) {
      var _a, _b;
      devtools$1 = hook;
      if (devtools$1) {
        devtools$1.enabled = true;
        buffer.forEach(({ event, args }) => devtools$1.emit(event, ...args));
        buffer = [];
      } else if (
        // handle late devtools injection - only do this if we are in an actual
        // browser environment to avoid the timer handle stalling test runner exit
        // (#4815)
        typeof window !== "undefined" && // some envs mock window but not fully
        window.HTMLElement && // also exclude jsdom
        // eslint-disable-next-line no-restricted-syntax
        !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))
      ) {
        const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
        replay.push((newHook) => {
          setDevtoolsHook$1(newHook, target);
        });
        setTimeout(() => {
          if (!devtools$1) {
            target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
            devtoolsNotInstalled = true;
            buffer = [];
          }
        }, 3e3);
      } else {
        devtoolsNotInstalled = true;
        buffer = [];
      }
    }
    function devtoolsInitApp(app, version2) {
      emit$1("app:init", app, version2, {
        Fragment,
        Text,
        Comment,
        Static
      });
    }
    function devtoolsUnmountApp(app) {
      emit$1("app:unmount", app);
    }
    const devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook(
      "component:added"
      /* COMPONENT_ADDED */
    );
    const devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook(
      "component:updated"
      /* COMPONENT_UPDATED */
    );
    const _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook(
      "component:removed"
      /* COMPONENT_REMOVED */
    );
    const devtoolsComponentRemoved = (component) => {
      if (devtools$1 && typeof devtools$1.cleanupBuffer === "function" && // remove the component if it wasn't buffered
      !devtools$1.cleanupBuffer(component)) {
        _devtoolsComponentRemoved(component);
      }
    };
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function createDevtoolsComponentHook(hook) {
      return (component) => {
        emit$1(
          hook,
          component.appContext.app,
          component.uid,
          component.parent ? component.parent.uid : void 0,
          component
        );
      };
    }
    const devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook(
      "perf:start"
      /* PERFORMANCE_START */
    );
    const devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook(
      "perf:end"
      /* PERFORMANCE_END */
    );
    function createDevtoolsPerformanceHook(hook) {
      return (component, type2, time) => {
        emit$1(hook, component.appContext.app, component.uid, component, type2, time);
      };
    }
    function devtoolsComponentEmit(component, event, params) {
      emit$1(
        "component:emit",
        component.appContext.app,
        component,
        event,
        params
      );
    }
    let currentRenderingInstance = null;
    let currentScopeId = null;
    function setCurrentRenderingInstance(instance) {
      const prev = currentRenderingInstance;
      currentRenderingInstance = instance;
      currentScopeId = instance && instance.type.__scopeId || null;
      return prev;
    }
    function pushScopeId(id2) {
      currentScopeId = id2;
    }
    function popScopeId() {
      currentScopeId = null;
    }
    const withScopeId = (_id) => withCtx;
    function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
      if (!ctx) return fn;
      if (fn._n) {
        return fn;
      }
      const renderFnWithContext = (...args) => {
        if (renderFnWithContext._d) {
          setBlockTracking(-1);
        }
        const prevInstance = setCurrentRenderingInstance(ctx);
        let res;
        try {
          res = fn(...args);
        } finally {
          setCurrentRenderingInstance(prevInstance);
          if (renderFnWithContext._d) {
            setBlockTracking(1);
          }
        }
        if (true) {
          devtoolsComponentUpdated(ctx);
        }
        return res;
      };
      renderFnWithContext._n = true;
      renderFnWithContext._c = true;
      renderFnWithContext._d = true;
      return renderFnWithContext;
    }
    function validateDirectiveName(name) {
      if (isBuiltInDirective(name)) {
        warn$1("Do not use built-in directive ids as custom directive id: " + name);
      }
    }
    function withDirectives(vnode, directives) {
      if (currentRenderingInstance === null) {
        warn$1(`withDirectives can only be used inside render functions.`);
        return vnode;
      }
      const instance = getComponentPublicInstance(currentRenderingInstance);
      const bindings = vnode.dirs || (vnode.dirs = []);
      for (let i = 0; i < directives.length; i++) {
        let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
        if (dir) {
          if (isFunction$1(dir)) {
            dir = {
              mounted: dir,
              updated: dir
            };
          }
          if (dir.deep) {
            traverse(value);
          }
          bindings.push({
            dir,
            instance,
            value,
            oldValue: void 0,
            arg,
            modifiers
          });
        }
      }
      return vnode;
    }
    function invokeDirectiveHook(vnode, prevVNode, instance, name) {
      const bindings = vnode.dirs;
      const oldBindings = prevVNode && prevVNode.dirs;
      for (let i = 0; i < bindings.length; i++) {
        const binding = bindings[i];
        if (oldBindings) {
          binding.oldValue = oldBindings[i].value;
        }
        let hook = binding.dir[name];
        if (hook) {
          pauseTracking();
          callWithAsyncErrorHandling(hook, instance, 8, [
            vnode.el,
            binding,
            vnode,
            prevVNode
          ]);
          resetTracking();
        }
      }
    }
    const TeleportEndKey = Symbol("_vte");
    const isTeleport = (type2) => type2.__isTeleport;
    const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
    const isTeleportDeferred = (props) => props && (props.defer || props.defer === "");
    const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
    const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
    const resolveTarget = (props, select) => {
      const targetSelector = props && props.to;
      if (isString$1(targetSelector)) {
        if (!select) {
          warn$1(
            `Current renderer does not support string target for Teleports. (missing querySelector renderer option)`
          );
          return null;
        } else {
          const target = select(targetSelector);
          if (!target && !isTeleportDisabled(props)) {
            warn$1(
              `Failed to locate Teleport target with selector "${targetSelector}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
            );
          }
          return target;
        }
      } else {
        if (!targetSelector && !isTeleportDisabled(props)) {
          warn$1(`Invalid Teleport target: ${targetSelector}`);
        }
        return targetSelector;
      }
    };
    const TeleportImpl = {
      name: "Teleport",
      __isTeleport: true,
      process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
        const {
          mc: mountChildren,
          pc: patchChildren,
          pbc: patchBlockChildren,
          o: { insert, querySelector, createText, createComment }
        } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag, children, dynamicChildren } = n2;
        if (isHmrUpdating) {
          optimized = false;
          dynamicChildren = null;
        }
        if (n1 == null) {
          const placeholder = n2.el = true ? createComment("teleport start") : createText("");
          const mainAnchor = n2.anchor = true ? createComment("teleport end") : createText("");
          insert(placeholder, container, anchor);
          insert(mainAnchor, container, anchor);
          const mount = (container2, anchor2) => {
            if (shapeFlag & 16) {
              if (parentComponent && parentComponent.isCE) {
                parentComponent.ce._teleportTarget = container2;
              }
              mountChildren(
                children,
                container2,
                anchor2,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            }
          };
          const mountToTarget = () => {
            const target = n2.target = resolveTarget(n2.props, querySelector);
            const targetAnchor = prepareAnchor(target, n2, createText, insert);
            if (target) {
              if (namespace !== "svg" && isTargetSVG(target)) {
                namespace = "svg";
              } else if (namespace !== "mathml" && isTargetMathML(target)) {
                namespace = "mathml";
              }
              if (!disabled) {
                mount(target, targetAnchor);
                updateCssVars(n2, false);
              }
            } else if (!disabled) {
              warn$1(
                "Invalid Teleport target on mount:",
                target,
                `(${typeof target})`
              );
            }
          };
          if (disabled) {
            mount(container, mainAnchor);
            updateCssVars(n2, true);
          }
          if (isTeleportDeferred(n2.props)) {
            queuePostRenderEffect(() => {
              mountToTarget();
              n2.el.__isMounted = true;
            }, parentSuspense);
          } else {
            mountToTarget();
          }
        } else {
          if (isTeleportDeferred(n2.props) && !n1.el.__isMounted) {
            queuePostRenderEffect(() => {
              TeleportImpl.process(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized,
                internals
              );
              delete n1.el.__isMounted;
            }, parentSuspense);
            return;
          }
          n2.el = n1.el;
          n2.targetStart = n1.targetStart;
          const mainAnchor = n2.anchor = n1.anchor;
          const target = n2.target = n1.target;
          const targetAnchor = n2.targetAnchor = n1.targetAnchor;
          const wasDisabled = isTeleportDisabled(n1.props);
          const currentContainer = wasDisabled ? container : target;
          const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
          if (namespace === "svg" || isTargetSVG(target)) {
            namespace = "svg";
          } else if (namespace === "mathml" || isTargetMathML(target)) {
            namespace = "mathml";
          }
          if (dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              currentContainer,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds
            );
            traverseStaticChildren(n1, n2, true);
          } else if (!optimized) {
            patchChildren(
              n1,
              n2,
              currentContainer,
              currentAnchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              false
            );
          }
          if (disabled) {
            if (!wasDisabled) {
              moveTeleport(
                n2,
                container,
                mainAnchor,
                internals,
                1
              );
            } else {
              if (n2.props && n1.props && n2.props.to !== n1.props.to) {
                n2.props.to = n1.props.to;
              }
            }
          } else {
            if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
              const nextTarget = n2.target = resolveTarget(
                n2.props,
                querySelector
              );
              if (nextTarget) {
                moveTeleport(
                  n2,
                  nextTarget,
                  null,
                  internals,
                  0
                );
              } else if (true) {
                warn$1(
                  "Invalid Teleport target on update:",
                  target,
                  `(${typeof target})`
                );
              }
            } else if (wasDisabled) {
              moveTeleport(
                n2,
                target,
                targetAnchor,
                internals,
                1
              );
            }
          }
          updateCssVars(n2, disabled);
        }
      },
      remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
        const {
          shapeFlag,
          children,
          anchor,
          targetStart,
          targetAnchor,
          target,
          props
        } = vnode;
        if (target) {
          hostRemove(targetStart);
          hostRemove(targetAnchor);
        }
        doRemove && hostRemove(anchor);
        if (shapeFlag & 16) {
          const shouldRemove = doRemove || !isTeleportDisabled(props);
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            unmount(
              child,
              parentComponent,
              parentSuspense,
              shouldRemove,
              !!child.dynamicChildren
            );
          }
        }
      },
      move: moveTeleport,
      hydrate: hydrateTeleport
    };
    function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
      if (moveType === 0) {
        insert(vnode.targetAnchor, container, parentAnchor);
      }
      const { el, anchor, shapeFlag, children, props } = vnode;
      const isReorder = moveType === 2;
      if (isReorder) {
        insert(el, container, parentAnchor);
      }
      if (!isReorder || isTeleportDisabled(props)) {
        if (shapeFlag & 16) {
          for (let i = 0; i < children.length; i++) {
            move(
              children[i],
              container,
              parentAnchor,
              2
            );
          }
        }
      }
      if (isReorder) {
        insert(anchor, container, parentAnchor);
      }
    }
    function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
      o: { nextSibling, parentNode, querySelector, insert, createText }
    }, hydrateChildren) {
      const target = vnode.target = resolveTarget(
        vnode.props,
        querySelector
      );
      if (target) {
        const disabled = isTeleportDisabled(vnode.props);
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16) {
          if (disabled) {
            vnode.anchor = hydrateChildren(
              nextSibling(node),
              vnode,
              parentNode(node),
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
            vnode.targetStart = targetNode;
            vnode.targetAnchor = targetNode && nextSibling(targetNode);
          } else {
            vnode.anchor = nextSibling(node);
            let targetAnchor = targetNode;
            while (targetAnchor) {
              if (targetAnchor && targetAnchor.nodeType === 8) {
                if (targetAnchor.data === "teleport start anchor") {
                  vnode.targetStart = targetAnchor;
                } else if (targetAnchor.data === "teleport anchor") {
                  vnode.targetAnchor = targetAnchor;
                  target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                  break;
                }
              }
              targetAnchor = nextSibling(targetAnchor);
            }
            if (!vnode.targetAnchor) {
              prepareAnchor(target, vnode, createText, insert);
            }
            hydrateChildren(
              targetNode && nextSibling(targetNode),
              vnode,
              target,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        }
        updateCssVars(vnode, disabled);
      }
      return vnode.anchor && nextSibling(vnode.anchor);
    }
    const Teleport = TeleportImpl;
    function updateCssVars(vnode, isDisabled) {
      const ctx = vnode.ctx;
      if (ctx && ctx.ut) {
        let node, anchor;
        if (isDisabled) {
          node = vnode.el;
          anchor = vnode.anchor;
        } else {
          node = vnode.targetStart;
          anchor = vnode.targetAnchor;
        }
        while (node && node !== anchor) {
          if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
          node = node.nextSibling;
        }
        ctx.ut();
      }
    }
    function prepareAnchor(target, vnode, createText, insert) {
      const targetStart = vnode.targetStart = createText("");
      const targetAnchor = vnode.targetAnchor = createText("");
      targetStart[TeleportEndKey] = targetAnchor;
      if (target) {
        insert(targetStart, target);
        insert(targetAnchor, target);
      }
      return targetAnchor;
    }
    const leaveCbKey = Symbol("_leaveCb");
    const enterCbKey$1 = Symbol("_enterCb");
    function useTransitionState() {
      const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: /* @__PURE__ */ new Map()
      };
      onMounted(() => {
        state.isMounted = true;
      });
      onBeforeUnmount(() => {
        state.isUnmounting = true;
      });
      return state;
    }
    const TransitionHookValidator = [Function, Array];
    const BaseTransitionPropsValidators = {
      mode: String,
      appear: Boolean,
      persisted: Boolean,
      // enter
      onBeforeEnter: TransitionHookValidator,
      onEnter: TransitionHookValidator,
      onAfterEnter: TransitionHookValidator,
      onEnterCancelled: TransitionHookValidator,
      // leave
      onBeforeLeave: TransitionHookValidator,
      onLeave: TransitionHookValidator,
      onAfterLeave: TransitionHookValidator,
      onLeaveCancelled: TransitionHookValidator,
      // appear
      onBeforeAppear: TransitionHookValidator,
      onAppear: TransitionHookValidator,
      onAfterAppear: TransitionHookValidator,
      onAppearCancelled: TransitionHookValidator
    };
    const recursiveGetSubtree = (instance) => {
      const subTree = instance.subTree;
      return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
    };
    const BaseTransitionImpl = {
      name: `BaseTransition`,
      props: BaseTransitionPropsValidators,
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        return () => {
          const children = slots.default && getTransitionRawChildren(slots.default(), true);
          if (!children || !children.length) {
            return;
          }
          const child = findNonCommentChild(children);
          const rawProps = toRaw(props);
          const { mode } = rawProps;
          if (mode && mode !== "in-out" && mode !== "out-in" && mode !== "default") {
            warn$1(`invalid <transition> mode: ${mode}`);
          }
          if (state.isLeaving) {
            return emptyPlaceholder(child);
          }
          const innerChild = getInnerChild$1(child);
          if (!innerChild) {
            return emptyPlaceholder(child);
          }
          let enterHooks = resolveTransitionHooks(
            innerChild,
            rawProps,
            state,
            instance,
            // #11061, ensure enterHooks is fresh after clone
            (hooks) => enterHooks = hooks
          );
          if (innerChild.type !== Comment) {
            setTransitionHooks(innerChild, enterHooks);
          }
          let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
          if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
            let leavingHooks = resolveTransitionHooks(
              oldInnerChild,
              rawProps,
              state,
              instance
            );
            setTransitionHooks(oldInnerChild, leavingHooks);
            if (mode === "out-in" && innerChild.type !== Comment) {
              state.isLeaving = true;
              leavingHooks.afterLeave = () => {
                state.isLeaving = false;
                if (!(instance.job.flags & 8)) {
                  instance.update();
                }
                delete leavingHooks.afterLeave;
                oldInnerChild = void 0;
              };
              return emptyPlaceholder(child);
            } else if (mode === "in-out" && innerChild.type !== Comment) {
              leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                const leavingVNodesCache = getLeavingNodesForType(
                  state,
                  oldInnerChild
                );
                leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                el[leaveCbKey] = () => {
                  earlyRemove();
                  el[leaveCbKey] = void 0;
                  delete enterHooks.delayedLeave;
                  oldInnerChild = void 0;
                };
                enterHooks.delayedLeave = () => {
                  delayedLeave();
                  delete enterHooks.delayedLeave;
                  oldInnerChild = void 0;
                };
              };
            } else {
              oldInnerChild = void 0;
            }
          } else if (oldInnerChild) {
            oldInnerChild = void 0;
          }
          return child;
        };
      }
    };
    function findNonCommentChild(children) {
      let child = children[0];
      if (children.length > 1) {
        let hasFound = false;
        for (const c of children) {
          if (c.type !== Comment) {
            if (hasFound) {
              warn$1(
                "<transition> can only be used on a single element or component. Use <transition-group> for lists."
              );
              break;
            }
            child = c;
            hasFound = true;
            if (false) break;
          }
        }
      }
      return child;
    }
    const BaseTransition = BaseTransitionImpl;
    function getLeavingNodesForType(state, vnode) {
      const { leavingVNodes } = state;
      let leavingVNodesCache = leavingVNodes.get(vnode.type);
      if (!leavingVNodesCache) {
        leavingVNodesCache = /* @__PURE__ */ Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
      }
      return leavingVNodesCache;
    }
    function resolveTransitionHooks(vnode, props, state, instance, postClone) {
      const {
        appear,
        mode,
        persisted = false,
        onBeforeEnter,
        onEnter,
        onAfterEnter,
        onEnterCancelled,
        onBeforeLeave,
        onLeave,
        onAfterLeave,
        onLeaveCancelled,
        onBeforeAppear,
        onAppear,
        onAfterAppear,
        onAppearCancelled
      } = props;
      const key = String(vnode.key);
      const leavingVNodesCache = getLeavingNodesForType(state, vnode);
      const callHook2 = (hook, args) => {
        hook && callWithAsyncErrorHandling(
          hook,
          instance,
          9,
          args
        );
      };
      const callAsyncHook = (hook, args) => {
        const done = args[1];
        callHook2(hook, args);
        if (isArray$1(hook)) {
          if (hook.every((hook2) => hook2.length <= 1)) done();
        } else if (hook.length <= 1) {
          done();
        }
      };
      const hooks = {
        mode,
        persisted,
        beforeEnter(el) {
          let hook = onBeforeEnter;
          if (!state.isMounted) {
            if (appear) {
              hook = onBeforeAppear || onBeforeEnter;
            } else {
              return;
            }
          }
          if (el[leaveCbKey]) {
            el[leaveCbKey](
              true
              /* cancelled */
            );
          }
          const leavingVNode = leavingVNodesCache[key];
          if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
            leavingVNode.el[leaveCbKey]();
          }
          callHook2(hook, [el]);
        },
        enter(el) {
          let hook = onEnter;
          let afterHook = onAfterEnter;
          let cancelHook = onEnterCancelled;
          if (!state.isMounted) {
            if (appear) {
              hook = onAppear || onEnter;
              afterHook = onAfterAppear || onAfterEnter;
              cancelHook = onAppearCancelled || onEnterCancelled;
            } else {
              return;
            }
          }
          let called = false;
          const done = el[enterCbKey$1] = (cancelled) => {
            if (called) return;
            called = true;
            if (cancelled) {
              callHook2(cancelHook, [el]);
            } else {
              callHook2(afterHook, [el]);
            }
            if (hooks.delayedLeave) {
              hooks.delayedLeave();
            }
            el[enterCbKey$1] = void 0;
          };
          if (hook) {
            callAsyncHook(hook, [el, done]);
          } else {
            done();
          }
        },
        leave(el, remove2) {
          const key2 = String(vnode.key);
          if (el[enterCbKey$1]) {
            el[enterCbKey$1](
              true
              /* cancelled */
            );
          }
          if (state.isUnmounting) {
            return remove2();
          }
          callHook2(onBeforeLeave, [el]);
          let called = false;
          const done = el[leaveCbKey] = (cancelled) => {
            if (called) return;
            called = true;
            remove2();
            if (cancelled) {
              callHook2(onLeaveCancelled, [el]);
            } else {
              callHook2(onAfterLeave, [el]);
            }
            el[leaveCbKey] = void 0;
            if (leavingVNodesCache[key2] === vnode) {
              delete leavingVNodesCache[key2];
            }
          };
          leavingVNodesCache[key2] = vnode;
          if (onLeave) {
            callAsyncHook(onLeave, [el, done]);
          } else {
            done();
          }
        },
        clone(vnode2) {
          const hooks2 = resolveTransitionHooks(
            vnode2,
            props,
            state,
            instance,
            postClone
          );
          if (postClone) postClone(hooks2);
          return hooks2;
        }
      };
      return hooks;
    }
    function emptyPlaceholder(vnode) {
      if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
      }
    }
    function getInnerChild$1(vnode) {
      if (!isKeepAlive(vnode)) {
        if (isTeleport(vnode.type) && vnode.children) {
          return findNonCommentChild(vnode.children);
        }
        return vnode;
      }
      if (vnode.component) {
        return vnode.component.subTree;
      }
      const { shapeFlag, children } = vnode;
      if (children) {
        if (shapeFlag & 16) {
          return children[0];
        }
        if (shapeFlag & 32 && isFunction$1(children.default)) {
          return children.default();
        }
      }
    }
    function setTransitionHooks(vnode, hooks) {
      if (vnode.shapeFlag & 6 && vnode.component) {
        vnode.transition = hooks;
        setTransitionHooks(vnode.component.subTree, hooks);
      } else if (vnode.shapeFlag & 128) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
      } else {
        vnode.transition = hooks;
      }
    }
    function getTransitionRawChildren(children, keepComment = false, parentKey) {
      let ret = [];
      let keyedFragmentCount = 0;
      for (let i = 0; i < children.length; i++) {
        let child = children[i];
        const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
        if (child.type === Fragment) {
          if (child.patchFlag & 128) keyedFragmentCount++;
          ret = ret.concat(
            getTransitionRawChildren(child.children, keepComment, key)
          );
        } else if (keepComment || child.type !== Comment) {
          ret.push(key != null ? cloneVNode(child, { key }) : child);
        }
      }
      if (keyedFragmentCount > 1) {
        for (let i = 0; i < ret.length; i++) {
          ret[i].patchFlag = -2;
        }
      }
      return ret;
    }
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function defineComponent(options, extraOptions) {
      return isFunction$1(options) ? (
        // #8236: extend call and options.name access are considered side-effects
        // by Rollup, so we have to wrap it in a pure-annotated IIFE.
        /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
      ) : options;
    }
    function useId() {
      const i = getCurrentInstance();
      if (i) {
        return (i.appContext.config.idPrefix || "v") + "-" + i.ids[0] + i.ids[1]++;
      } else if (true) {
        warn$1(
          `useId() is called when there is no active component instance to be associated with.`
        );
      }
      return "";
    }
    function markAsyncBoundary(instance) {
      instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
    }
    const knownTemplateRefs = /* @__PURE__ */ new WeakSet();
    function useTemplateRef(key) {
      const i = getCurrentInstance();
      const r = shallowRef(null);
      if (i) {
        const refs = i.refs === EMPTY_OBJ ? i.refs = {} : i.refs;
        let desc;
        if ((desc = Object.getOwnPropertyDescriptor(refs, key)) && !desc.configurable) {
          warn$1(`useTemplateRef('${key}') already exists.`);
        } else {
          Object.defineProperty(refs, key, {
            enumerable: true,
            get: () => r.value,
            set: (val) => r.value = val
          });
        }
      } else if (true) {
        warn$1(
          `useTemplateRef() is called when there is no active component instance to be associated with.`
        );
      }
      const ret = true ? readonly(r) : r;
      if (true) {
        knownTemplateRefs.add(ret);
      }
      return ret;
    }
    function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
      if (isArray$1(rawRef)) {
        rawRef.forEach(
          (r, i) => setRef(
            r,
            oldRawRef && (isArray$1(oldRawRef) ? oldRawRef[i] : oldRawRef),
            parentSuspense,
            vnode,
            isUnmount
          )
        );
        return;
      }
      if (isAsyncWrapper(vnode) && !isUnmount) {
        if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
          setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
        }
        return;
      }
      const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
      const value = isUnmount ? null : refValue;
      const { i: owner, r: ref3 } = rawRef;
      if (!owner) {
        warn$1(
          `Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`
        );
        return;
      }
      const oldRef = oldRawRef && oldRawRef.r;
      const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
      const setupState = owner.setupState;
      const rawSetupState = toRaw(setupState);
      const canSetSetupRef = setupState === EMPTY_OBJ ? () => false : (key) => {
        if (true) {
          if (hasOwn(rawSetupState, key) && !isRef(rawSetupState[key])) {
            warn$1(
              `Template ref "${key}" used on a non-ref value. It will not work in the production build.`
            );
          }
          if (knownTemplateRefs.has(rawSetupState[key])) {
            return false;
          }
        }
        return hasOwn(rawSetupState, key);
      };
      if (oldRef != null && oldRef !== ref3) {
        if (isString$1(oldRef)) {
          refs[oldRef] = null;
          if (canSetSetupRef(oldRef)) {
            setupState[oldRef] = null;
          }
        } else if (isRef(oldRef)) {
          oldRef.value = null;
        }
      }
      if (isFunction$1(ref3)) {
        callWithErrorHandling(ref3, owner, 12, [value, refs]);
      } else {
        const _isString = isString$1(ref3);
        const _isRef = isRef(ref3);
        if (_isString || _isRef) {
          const doSet = () => {
            if (rawRef.f) {
              const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
              if (isUnmount) {
                isArray$1(existing) && remove$1(existing, refValue);
              } else {
                if (!isArray$1(existing)) {
                  if (_isString) {
                    refs[ref3] = [refValue];
                    if (canSetSetupRef(ref3)) {
                      setupState[ref3] = refs[ref3];
                    }
                  } else {
                    ref3.value = [refValue];
                    if (rawRef.k) refs[rawRef.k] = ref3.value;
                  }
                } else if (!existing.includes(refValue)) {
                  existing.push(refValue);
                }
              }
            } else if (_isString) {
              refs[ref3] = value;
              if (canSetSetupRef(ref3)) {
                setupState[ref3] = value;
              }
            } else if (_isRef) {
              ref3.value = value;
              if (rawRef.k) refs[rawRef.k] = value;
            } else if (true) {
              warn$1("Invalid template ref type:", ref3, `(${typeof ref3})`);
            }
          };
          if (value) {
            doSet.id = -1;
            queuePostRenderEffect(doSet, parentSuspense);
          } else {
            doSet();
          }
        } else if (true) {
          warn$1("Invalid template ref type:", ref3, `(${typeof ref3})`);
        }
      }
    }
    let hasLoggedMismatchError = false;
    const logMismatchError = () => {
      if (hasLoggedMismatchError) {
        return;
      }
      console.error("Hydration completed but contains mismatches.");
      hasLoggedMismatchError = true;
    };
    const isSVGContainer = (container) => container.namespaceURI.includes("svg") && container.tagName !== "foreignObject";
    const isMathMLContainer = (container) => container.namespaceURI.includes("MathML");
    const getContainerType = (container) => {
      if (container.nodeType !== 1) return void 0;
      if (isSVGContainer(container)) return "svg";
      if (isMathMLContainer(container)) return "mathml";
      return void 0;
    };
    const isComment = (node) => node.nodeType === 8;
    function createHydrationFunctions(rendererInternals) {
      const {
        mt: mountComponent,
        p: patch,
        o: {
          patchProp: patchProp2,
          createText,
          nextSibling,
          parentNode,
          remove: remove2,
          insert,
          createComment
        }
      } = rendererInternals;
      const hydrate2 = (vnode, container) => {
        if (!container.hasChildNodes()) {
          warn$1(
            `Attempting to hydrate existing markup but container is empty. Performing full mount instead.`
          );
          patch(null, vnode, container);
          flushPostFlushCbs();
          container._vnode = vnode;
          return;
        }
        hydrateNode(container.firstChild, vnode, null, null, null);
        flushPostFlushCbs();
        container._vnode = vnode;
      };
      const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
        optimized = optimized || !!vnode.dynamicChildren;
        const isFragmentStart = isComment(node) && node.data === "[";
        const onMismatch = () => handleMismatch(
          node,
          vnode,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          isFragmentStart
        );
        const { type: type2, ref: ref3, shapeFlag, patchFlag } = vnode;
        let domType = node.nodeType;
        vnode.el = node;
        if (true) {
          def(node, "__vnode", vnode, true);
          def(node, "__vueParentComponent", parentComponent, true);
        }
        if (patchFlag === -2) {
          optimized = false;
          vnode.dynamicChildren = null;
        }
        let nextNode = null;
        switch (type2) {
          case Text:
            if (domType !== 3) {
              if (vnode.children === "") {
                insert(vnode.el = createText(""), parentNode(node), node);
                nextNode = node;
              } else {
                nextNode = onMismatch();
              }
            } else {
              if (node.data !== vnode.children) {
                warn$1(
                  `Hydration text mismatch in`,
                  node.parentNode,
                  `
    - rendered on server: ${JSON.stringify(
                    node.data
                  )}
    - expected on client: ${JSON.stringify(vnode.children)}`
                );
                logMismatchError();
                node.data = vnode.children;
              }
              nextNode = nextSibling(node);
            }
            break;
          case Comment:
            if (isTemplateNode(node)) {
              nextNode = nextSibling(node);
              replaceNode(
                vnode.el = node.content.firstChild,
                node,
                parentComponent
              );
            } else if (domType !== 8 || isFragmentStart) {
              nextNode = onMismatch();
            } else {
              nextNode = nextSibling(node);
            }
            break;
          case Static:
            if (isFragmentStart) {
              node = nextSibling(node);
              domType = node.nodeType;
            }
            if (domType === 1 || domType === 3) {
              nextNode = node;
              const needToAdoptContent = !vnode.children.length;
              for (let i = 0; i < vnode.staticCount; i++) {
                if (needToAdoptContent)
                  vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
                if (i === vnode.staticCount - 1) {
                  vnode.anchor = nextNode;
                }
                nextNode = nextSibling(nextNode);
              }
              return isFragmentStart ? nextSibling(nextNode) : nextNode;
            } else {
              onMismatch();
            }
            break;
          case Fragment:
            if (!isFragmentStart) {
              nextNode = onMismatch();
            } else {
              nextNode = hydrateFragment(
                node,
                vnode,
                parentComponent,
                parentSuspense,
                slotScopeIds,
                optimized
              );
            }
            break;
          default:
            if (shapeFlag & 1) {
              if ((domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) && !isTemplateNode(node)) {
                nextNode = onMismatch();
              } else {
                nextNode = hydrateElement(
                  node,
                  vnode,
                  parentComponent,
                  parentSuspense,
                  slotScopeIds,
                  optimized
                );
              }
            } else if (shapeFlag & 6) {
              vnode.slotScopeIds = slotScopeIds;
              const container = parentNode(node);
              if (isFragmentStart) {
                nextNode = locateClosingAnchor(node);
              } else if (isComment(node) && node.data === "teleport start") {
                nextNode = locateClosingAnchor(node, node.data, "teleport end");
              } else {
                nextNode = nextSibling(node);
              }
              mountComponent(
                vnode,
                container,
                null,
                parentComponent,
                parentSuspense,
                getContainerType(container),
                optimized
              );
              if (isAsyncWrapper(vnode) && !vnode.type.__asyncResolved) {
                let subTree;
                if (isFragmentStart) {
                  subTree = createVNode(Fragment);
                  subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
                } else {
                  subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
                }
                subTree.el = node;
                vnode.component.subTree = subTree;
              }
            } else if (shapeFlag & 64) {
              if (domType !== 8) {
                nextNode = onMismatch();
              } else {
                nextNode = vnode.type.hydrate(
                  node,
                  vnode,
                  parentComponent,
                  parentSuspense,
                  slotScopeIds,
                  optimized,
                  rendererInternals,
                  hydrateChildren
                );
              }
            } else if (shapeFlag & 128) {
              nextNode = vnode.type.hydrate(
                node,
                vnode,
                parentComponent,
                parentSuspense,
                getContainerType(parentNode(node)),
                slotScopeIds,
                optimized,
                rendererInternals,
                hydrateNode
              );
            } else if (true) {
              warn$1("Invalid HostVNode type:", type2, `(${typeof type2})`);
            }
        }
        if (ref3 != null) {
          setRef(ref3, null, parentSuspense, vnode);
        }
        return nextNode;
      };
      const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        optimized = optimized || !!vnode.dynamicChildren;
        const { type: type2, props, patchFlag, shapeFlag, dirs, transition } = vnode;
        const forcePatch = type2 === "input" || type2 === "option";
        if (true) {
          if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "created");
          }
          let needCallTransitionHooks = false;
          if (isTemplateNode(el)) {
            needCallTransitionHooks = needTransition(
              null,
              // no need check parentSuspense in hydration
              transition
            ) && parentComponent && parentComponent.vnode.props && parentComponent.vnode.props.appear;
            const content = el.content.firstChild;
            if (needCallTransitionHooks) {
              transition.beforeEnter(content);
            }
            replaceNode(content, el, parentComponent);
            vnode.el = el = content;
          }
          if (shapeFlag & 16 && // skip if element has innerHTML / textContent
          !(props && (props.innerHTML || props.textContent))) {
            let next = hydrateChildren(
              el.firstChild,
              vnode,
              el,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
            let hasWarned2 = false;
            while (next) {
              if (!isMismatchAllowed(
                el,
                1
                /* CHILDREN */
              )) {
                if (!hasWarned2) {
                  warn$1(
                    `Hydration children mismatch on`,
                    el,
                    `
  Server rendered element contains more child nodes than client vdom.`
                  );
                  hasWarned2 = true;
                }
                logMismatchError();
              }
              const cur = next;
              next = next.nextSibling;
              remove2(cur);
            }
          } else if (shapeFlag & 8) {
            let clientText = vnode.children;
            if (clientText[0] === "\n" && (el.tagName === "PRE" || el.tagName === "TEXTAREA")) {
              clientText = clientText.slice(1);
            }
            if (el.textContent !== clientText) {
              if (!isMismatchAllowed(
                el,
                0
                /* TEXT */
              )) {
                warn$1(
                  `Hydration text content mismatch on`,
                  el,
                  `
    - rendered on server: ${el.textContent}
    - expected on client: ${vnode.children}`
                );
                logMismatchError();
              }
              el.textContent = vnode.children;
            }
          }
          if (props) {
            if (true) {
              const isCustomElement = el.tagName.includes("-");
              for (const key in props) {
                if (
                  // #11189 skip if this node has directives that have created hooks
                  // as it could have mutated the DOM in any possible way
                  !(dirs && dirs.some((d) => d.dir.created)) && propHasMismatch(el, key, props[key], vnode, parentComponent)
                ) {
                  logMismatchError();
                }
                if (forcePatch && (key.endsWith("value") || key === "indeterminate") || isOn(key) && !isReservedProp(key) || // force hydrate v-bind with .prop modifiers
                key[0] === "." || isCustomElement) {
                  patchProp2(el, key, null, props[key], void 0, parentComponent);
                }
              }
            } else if (props.onClick) {
              patchProp2(
                el,
                "onClick",
                null,
                props.onClick,
                void 0,
                parentComponent
              );
            } else if (patchFlag & 4 && isReactive(props.style)) {
              for (const key in props.style) props.style[key];
            }
          }
          let vnodeHooks;
          if (vnodeHooks = props && props.onVnodeBeforeMount) {
            invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          }
          if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
          }
          if ((vnodeHooks = props && props.onVnodeMounted) || dirs || needCallTransitionHooks) {
            queueEffectWithSuspense(() => {
              vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
              needCallTransitionHooks && transition.enter(el);
              dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
            }, parentSuspense);
          }
        }
        return el.nextSibling;
      };
      const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        optimized = optimized || !!parentVNode.dynamicChildren;
        const children = parentVNode.children;
        const l = children.length;
        let hasWarned2 = false;
        for (let i = 0; i < l; i++) {
          const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);
          const isText = vnode.type === Text;
          if (node) {
            if (isText && !optimized) {
              if (i + 1 < l && normalizeVNode(children[i + 1]).type === Text) {
                insert(
                  createText(
                    node.data.slice(vnode.children.length)
                  ),
                  container,
                  nextSibling(node)
                );
                node.data = vnode.children;
              }
            }
            node = hydrateNode(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          } else if (isText && !vnode.children) {
            insert(vnode.el = createText(""), container);
          } else {
            if (!isMismatchAllowed(
              container,
              1
              /* CHILDREN */
            )) {
              if (!hasWarned2) {
                warn$1(
                  `Hydration children mismatch on`,
                  container,
                  `
  Server rendered element contains fewer child nodes than client vdom.`
                );
                hasWarned2 = true;
              }
              logMismatchError();
            }
            patch(
              null,
              vnode,
              container,
              null,
              parentComponent,
              parentSuspense,
              getContainerType(container),
              slotScopeIds
            );
          }
        }
        return node;
      };
      const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        const { slotScopeIds: fragmentSlotScopeIds } = vnode;
        if (fragmentSlotScopeIds) {
          slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        }
        const container = parentNode(node);
        const next = hydrateChildren(
          nextSibling(node),
          vnode,
          container,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        if (next && isComment(next) && next.data === "]") {
          return nextSibling(vnode.anchor = next);
        } else {
          logMismatchError();
          insert(vnode.anchor = createComment(`]`), container, next);
          return next;
        }
      };
      const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
        if (!isMismatchAllowed(
          node.parentElement,
          1
          /* CHILDREN */
        )) {
          warn$1(
            `Hydration node mismatch:
  - rendered on server:`,
            node,
            node.nodeType === 3 ? `(text)` : isComment(node) && node.data === "[" ? `(start of fragment)` : ``,
            `
  - expected on client:`,
            vnode.type
          );
          logMismatchError();
        }
        vnode.el = null;
        if (isFragment) {
          const end = locateClosingAnchor(node);
          while (true) {
            const next2 = nextSibling(node);
            if (next2 && next2 !== end) {
              remove2(next2);
            } else {
              break;
            }
          }
        }
        const next = nextSibling(node);
        const container = parentNode(node);
        remove2(node);
        patch(
          null,
          vnode,
          container,
          next,
          parentComponent,
          parentSuspense,
          getContainerType(container),
          slotScopeIds
        );
        if (parentComponent) {
          parentComponent.vnode.el = vnode.el;
          updateHOCHostEl(parentComponent, vnode.el);
        }
        return next;
      };
      const locateClosingAnchor = (node, open = "[", close = "]") => {
        let match = 0;
        while (node) {
          node = nextSibling(node);
          if (node && isComment(node)) {
            if (node.data === open) match++;
            if (node.data === close) {
              if (match === 0) {
                return nextSibling(node);
              } else {
                match--;
              }
            }
          }
        }
        return node;
      };
      const replaceNode = (newNode, oldNode, parentComponent) => {
        const parentNode2 = oldNode.parentNode;
        if (parentNode2) {
          parentNode2.replaceChild(newNode, oldNode);
        }
        let parent = parentComponent;
        while (parent) {
          if (parent.vnode.el === oldNode) {
            parent.vnode.el = parent.subTree.el = newNode;
          }
          parent = parent.parent;
        }
      };
      const isTemplateNode = (node) => {
        return node.nodeType === 1 && node.tagName === "TEMPLATE";
      };
      return [hydrate2, hydrateNode];
    }
    function propHasMismatch(el, key, clientValue, vnode, instance) {
      let mismatchType;
      let mismatchKey;
      let actual;
      let expected;
      if (key === "class") {
        actual = el.getAttribute("class");
        expected = normalizeClass(clientValue);
        if (!isSetEqual(toClassSet(actual || ""), toClassSet(expected))) {
          mismatchType = 2;
          mismatchKey = `class`;
        }
      } else if (key === "style") {
        actual = el.getAttribute("style") || "";
        expected = isString$1(clientValue) ? clientValue : stringifyStyle(normalizeStyle(clientValue));
        const actualMap = toStyleMap(actual);
        const expectedMap = toStyleMap(expected);
        if (vnode.dirs) {
          for (const { dir, value } of vnode.dirs) {
            if (dir.name === "show" && !value) {
              expectedMap.set("display", "none");
            }
          }
        }
        if (instance) {
          resolveCssVars(instance, vnode, expectedMap);
        }
        if (!isMapEqual(actualMap, expectedMap)) {
          mismatchType = 3;
          mismatchKey = "style";
        }
      } else if (el instanceof SVGElement && isKnownSvgAttr(key) || el instanceof HTMLElement && (isBooleanAttr(key) || isKnownHtmlAttr(key))) {
        if (isBooleanAttr(key)) {
          actual = el.hasAttribute(key);
          expected = includeBooleanAttr(clientValue);
        } else if (clientValue == null) {
          actual = el.hasAttribute(key);
          expected = false;
        } else {
          if (el.hasAttribute(key)) {
            actual = el.getAttribute(key);
          } else if (key === "value" && el.tagName === "TEXTAREA") {
            actual = el.value;
          } else {
            actual = false;
          }
          expected = isRenderableAttrValue(clientValue) ? String(clientValue) : false;
        }
        if (actual !== expected) {
          mismatchType = 4;
          mismatchKey = key;
        }
      }
      if (mismatchType != null && !isMismatchAllowed(el, mismatchType)) {
        const format2 = (v) => v === false ? `(not rendered)` : `${mismatchKey}="${v}"`;
        const preSegment = `Hydration ${MismatchTypeString[mismatchType]} mismatch on`;
        const postSegment = `
    - rendered on server: ${format2(actual)}
    - expected on client: ${format2(expected)}
    Note: this mismatch is check-only. The DOM will not be rectified in production due to performance overhead.
    You should fix the source of the mismatch.`;
        {
          warn$1(preSegment, el, postSegment);
        }
        return true;
      }
      return false;
    }
    function toClassSet(str) {
      return new Set(str.trim().split(/\s+/));
    }
    function isSetEqual(a, b) {
      if (a.size !== b.size) {
        return false;
      }
      for (const s of a) {
        if (!b.has(s)) {
          return false;
        }
      }
      return true;
    }
    function toStyleMap(str) {
      const styleMap = /* @__PURE__ */ new Map();
      for (const item of str.split(";")) {
        let [key, value] = item.split(":");
        key = key.trim();
        value = value && value.trim();
        if (key && value) {
          styleMap.set(key, value);
        }
      }
      return styleMap;
    }
    function isMapEqual(a, b) {
      if (a.size !== b.size) {
        return false;
      }
      for (const [key, value] of a) {
        if (value !== b.get(key)) {
          return false;
        }
      }
      return true;
    }
    function resolveCssVars(instance, vnode, expectedMap) {
      const root = instance.subTree;
      if (instance.getCssVars && (vnode === root || root && root.type === Fragment && root.children.includes(vnode))) {
        const cssVars = instance.getCssVars();
        for (const key in cssVars) {
          expectedMap.set(
            `--${getEscapedCssVarName(key, false)}`,
            String(cssVars[key])
          );
        }
      }
      if (vnode === root && instance.parent) {
        resolveCssVars(instance.parent, instance.vnode, expectedMap);
      }
    }
    const allowMismatchAttr = "data-allow-mismatch";
    const MismatchTypeString = {
      [
        0
        /* TEXT */
      ]: "text",
      [
        1
        /* CHILDREN */
      ]: "children",
      [
        2
        /* CLASS */
      ]: "class",
      [
        3
        /* STYLE */
      ]: "style",
      [
        4
        /* ATTRIBUTE */
      ]: "attribute"
    };
    function isMismatchAllowed(el, allowedType) {
      if (allowedType === 0 || allowedType === 1) {
        while (el && !el.hasAttribute(allowMismatchAttr)) {
          el = el.parentElement;
        }
      }
      const allowedAttr = el && el.getAttribute(allowMismatchAttr);
      if (allowedAttr == null) {
        return false;
      } else if (allowedAttr === "") {
        return true;
      } else {
        const list = allowedAttr.split(",");
        if (allowedType === 0 && list.includes("children")) {
          return true;
        }
        return allowedAttr.split(",").includes(MismatchTypeString[allowedType]);
      }
    }
    const requestIdleCallback = getGlobalThis().requestIdleCallback || ((cb) => setTimeout(cb, 1));
    const cancelIdleCallback = getGlobalThis().cancelIdleCallback || ((id2) => clearTimeout(id2));
    const hydrateOnIdle = (timeout2 = 1e4) => (hydrate2) => {
      const id2 = requestIdleCallback(hydrate2, { timeout: timeout2 });
      return () => cancelIdleCallback(id2);
    };
    function elementIsVisibleInViewport(el) {
      const { top, left, bottom, right } = el.getBoundingClientRect();
      const { innerHeight, innerWidth } = window;
      return (top > 0 && top < innerHeight || bottom > 0 && bottom < innerHeight) && (left > 0 && left < innerWidth || right > 0 && right < innerWidth);
    }
    const hydrateOnVisible = (opts) => (hydrate2, forEach) => {
      const ob = new IntersectionObserver((entries) => {
        for (const e of entries) {
          if (!e.isIntersecting) continue;
          ob.disconnect();
          hydrate2();
          break;
        }
      }, opts);
      forEach((el) => {
        if (!(el instanceof Element)) return;
        if (elementIsVisibleInViewport(el)) {
          hydrate2();
          ob.disconnect();
          return false;
        }
        ob.observe(el);
      });
      return () => ob.disconnect();
    };
    const hydrateOnMediaQuery = (query) => (hydrate2) => {
      if (query) {
        const mql = matchMedia(query);
        if (mql.matches) {
          hydrate2();
        } else {
          mql.addEventListener("change", hydrate2, { once: true });
          return () => mql.removeEventListener("change", hydrate2);
        }
      }
    };
    const hydrateOnInteraction = (interactions = []) => (hydrate2, forEach) => {
      if (isString$1(interactions)) interactions = [interactions];
      let hasHydrated = false;
      const doHydrate = (e) => {
        if (!hasHydrated) {
          hasHydrated = true;
          teardown();
          hydrate2();
          e.target.dispatchEvent(new e.constructor(e.type, e));
        }
      };
      const teardown = () => {
        forEach((el) => {
          for (const i of interactions) {
            el.removeEventListener(i, doHydrate);
          }
        });
      };
      forEach((el) => {
        for (const i of interactions) {
          el.addEventListener(i, doHydrate, { once: true });
        }
      });
      return teardown;
    };
    function forEachElement(node, cb) {
      if (isComment(node) && node.data === "[") {
        let depth = 1;
        let next = node.nextSibling;
        while (next) {
          if (next.nodeType === 1) {
            const result = cb(next);
            if (result === false) {
              break;
            }
          } else if (isComment(next)) {
            if (next.data === "]") {
              if (--depth === 0) break;
            } else if (next.data === "[") {
              depth++;
            }
          }
          next = next.nextSibling;
        }
      } else {
        cb(node);
      }
    }
    const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function defineAsyncComponent(source) {
      if (isFunction$1(source)) {
        source = { loader: source };
      }
      const {
        loader,
        loadingComponent,
        errorComponent,
        delay: delay2 = 200,
        hydrate: hydrateStrategy,
        timeout: timeout2,
        // undefined = never times out
        suspensible = true,
        onError: userOnError
      } = source;
      let pendingRequest = null;
      let resolvedComp;
      let retries = 0;
      const retry2 = () => {
        retries++;
        pendingRequest = null;
        return load();
      };
      const load = () => {
        let thisRequest;
        return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
          err = err instanceof Error ? err : new Error(String(err));
          if (userOnError) {
            return new Promise((resolve2, reject) => {
              const userRetry = () => resolve2(retry2());
              const userFail = () => reject(err);
              userOnError(err, userRetry, userFail, retries + 1);
            });
          } else {
            throw err;
          }
        }).then((comp) => {
          if (thisRequest !== pendingRequest && pendingRequest) {
            return pendingRequest;
          }
          if (!comp) {
            warn$1(
              `Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.`
            );
          }
          if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
            comp = comp.default;
          }
          if (comp && !isObject(comp) && !isFunction$1(comp)) {
            throw new Error(`Invalid async component load result: ${comp}`);
          }
          resolvedComp = comp;
          return comp;
        }));
      };
      return /* @__PURE__ */ defineComponent({
        name: "AsyncComponentWrapper",
        __asyncLoader: load,
        __asyncHydrate(el, instance, hydrate2) {
          const doHydrate = hydrateStrategy ? () => {
            const teardown = hydrateStrategy(
              hydrate2,
              (cb) => forEachElement(el, cb)
            );
            if (teardown) {
              (instance.bum || (instance.bum = [])).push(teardown);
            }
          } : hydrate2;
          if (resolvedComp) {
            doHydrate();
          } else {
            load().then(() => !instance.isUnmounted && doHydrate());
          }
        },
        get __asyncResolved() {
          return resolvedComp;
        },
        setup() {
          const instance = currentInstance;
          markAsyncBoundary(instance);
          if (resolvedComp) {
            return () => createInnerComp(resolvedComp, instance);
          }
          const onError = (err) => {
            pendingRequest = null;
            handleError(
              err,
              instance,
              13,
              !errorComponent
            );
          };
          if (suspensible && instance.suspense || isInSSRComponentSetup) {
            return load().then((comp) => {
              return () => createInnerComp(comp, instance);
            }).catch((err) => {
              onError(err);
              return () => errorComponent ? createVNode(errorComponent, {
                error: err
              }) : null;
            });
          }
          const loaded = ref$1(false);
          const error = ref$1();
          const delayed = ref$1(!!delay2);
          if (delay2) {
            setTimeout(() => {
              delayed.value = false;
            }, delay2);
          }
          if (timeout2 != null) {
            setTimeout(() => {
              if (!loaded.value && !error.value) {
                const err = new Error(
                  `Async component timed out after ${timeout2}ms.`
                );
                onError(err);
                error.value = err;
              }
            }, timeout2);
          }
          load().then(() => {
            loaded.value = true;
            if (instance.parent && isKeepAlive(instance.parent.vnode)) {
              instance.parent.update();
            }
          }).catch((err) => {
            onError(err);
            error.value = err;
          });
          return () => {
            if (loaded.value && resolvedComp) {
              return createInnerComp(resolvedComp, instance);
            } else if (error.value && errorComponent) {
              return createVNode(errorComponent, {
                error: error.value
              });
            } else if (loadingComponent && !delayed.value) {
              return createVNode(loadingComponent);
            }
          };
        }
      });
    }
    function createInnerComp(comp, parent) {
      const { ref: ref22, props, children, ce } = parent.vnode;
      const vnode = createVNode(comp, props, children);
      vnode.ref = ref22;
      vnode.ce = ce;
      delete parent.vnode.ce;
      return vnode;
    }
    const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
    const KeepAliveImpl = {
      name: `KeepAlive`,
      // Marker for special handling inside the renderer. We are not using a ===
      // check directly on KeepAlive in the renderer, because importing it directly
      // would prevent it from being tree-shaken.
      __isKeepAlive: true,
      props: {
        include: [String, RegExp, Array],
        exclude: [String, RegExp, Array],
        max: [String, Number]
      },
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const sharedContext = instance.ctx;
        if (!sharedContext.renderer) {
          return () => {
            const children = slots.default && slots.default();
            return children && children.length === 1 ? children[0] : children;
          };
        }
        const cache = /* @__PURE__ */ new Map();
        const keys = /* @__PURE__ */ new Set();
        let current = null;
        if (true) {
          instance.__v_cache = cache;
        }
        const parentSuspense = instance.suspense;
        const {
          renderer: {
            p: patch,
            m: move,
            um: _unmount,
            o: { createElement }
          }
        } = sharedContext;
        const storageContainer = createElement("div");
        sharedContext.activate = (vnode, container, anchor, namespace, optimized) => {
          const instance2 = vnode.component;
          move(vnode, container, anchor, 0, parentSuspense);
          patch(
            instance2.vnode,
            vnode,
            container,
            anchor,
            instance2,
            parentSuspense,
            namespace,
            vnode.slotScopeIds,
            optimized
          );
          queuePostRenderEffect(() => {
            instance2.isDeactivated = false;
            if (instance2.a) {
              invokeArrayFns(instance2.a);
            }
            const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
            if (vnodeHook) {
              invokeVNodeHook(vnodeHook, instance2.parent, vnode);
            }
          }, parentSuspense);
          if (true) {
            devtoolsComponentAdded(instance2);
          }
        };
        sharedContext.deactivate = (vnode) => {
          const instance2 = vnode.component;
          invalidateMount(instance2.m);
          invalidateMount(instance2.a);
          move(vnode, storageContainer, null, 1, parentSuspense);
          queuePostRenderEffect(() => {
            if (instance2.da) {
              invokeArrayFns(instance2.da);
            }
            const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
            if (vnodeHook) {
              invokeVNodeHook(vnodeHook, instance2.parent, vnode);
            }
            instance2.isDeactivated = true;
          }, parentSuspense);
          if (true) {
            devtoolsComponentAdded(instance2);
          }
        };
        function unmount(vnode) {
          resetShapeFlag(vnode);
          _unmount(vnode, instance, parentSuspense, true);
        }
        function pruneCache(filter) {
          cache.forEach((vnode, key) => {
            const name = getComponentName(vnode.type);
            if (name && !filter(name)) {
              pruneCacheEntry(key);
            }
          });
        }
        function pruneCacheEntry(key) {
          const cached = cache.get(key);
          if (cached && (!current || !isSameVNodeType(cached, current))) {
            unmount(cached);
          } else if (current) {
            resetShapeFlag(current);
          }
          cache.delete(key);
          keys.delete(key);
        }
        watch(
          () => [props.include, props.exclude],
          ([include, exclude]) => {
            include && pruneCache((name) => matches(include, name));
            exclude && pruneCache((name) => !matches(exclude, name));
          },
          // prune post-render after `current` has been updated
          { flush: "post", deep: true }
        );
        let pendingCacheKey = null;
        const cacheSubtree = () => {
          if (pendingCacheKey != null) {
            if (isSuspense(instance.subTree.type)) {
              queuePostRenderEffect(() => {
                cache.set(pendingCacheKey, getInnerChild(instance.subTree));
              }, instance.subTree.suspense);
            } else {
              cache.set(pendingCacheKey, getInnerChild(instance.subTree));
            }
          }
        };
        onMounted(cacheSubtree);
        onUpdated(cacheSubtree);
        onBeforeUnmount(() => {
          cache.forEach((cached) => {
            const { subTree, suspense } = instance;
            const vnode = getInnerChild(subTree);
            if (cached.type === vnode.type && cached.key === vnode.key) {
              resetShapeFlag(vnode);
              const da = vnode.component.da;
              da && queuePostRenderEffect(da, suspense);
              return;
            }
            unmount(cached);
          });
        });
        return () => {
          pendingCacheKey = null;
          if (!slots.default) {
            return current = null;
          }
          const children = slots.default();
          const rawVNode = children[0];
          if (children.length > 1) {
            if (true) {
              warn$1(`KeepAlive should contain exactly one component child.`);
            }
            current = null;
            return children;
          } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
            current = null;
            return rawVNode;
          }
          let vnode = getInnerChild(rawVNode);
          if (vnode.type === Comment) {
            current = null;
            return vnode;
          }
          const comp = vnode.type;
          const name = getComponentName(
            isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp
          );
          const { include, exclude, max } = props;
          if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
            vnode.shapeFlag &= ~256;
            current = vnode;
            return rawVNode;
          }
          const key = vnode.key == null ? comp : vnode.key;
          const cachedVNode = cache.get(key);
          if (vnode.el) {
            vnode = cloneVNode(vnode);
            if (rawVNode.shapeFlag & 128) {
              rawVNode.ssContent = vnode;
            }
          }
          pendingCacheKey = key;
          if (cachedVNode) {
            vnode.el = cachedVNode.el;
            vnode.component = cachedVNode.component;
            if (vnode.transition) {
              setTransitionHooks(vnode, vnode.transition);
            }
            vnode.shapeFlag |= 512;
            keys.delete(key);
            keys.add(key);
          } else {
            keys.add(key);
            if (max && keys.size > parseInt(max, 10)) {
              pruneCacheEntry(keys.values().next().value);
            }
          }
          vnode.shapeFlag |= 256;
          current = vnode;
          return isSuspense(rawVNode.type) ? rawVNode : vnode;
        };
      }
    };
    const KeepAlive = KeepAliveImpl;
    function matches(pattern2, name) {
      if (isArray$1(pattern2)) {
        return pattern2.some((p2) => matches(p2, name));
      } else if (isString$1(pattern2)) {
        return pattern2.split(",").includes(name);
      } else if (isRegExp$1(pattern2)) {
        pattern2.lastIndex = 0;
        return pattern2.test(name);
      }
      return false;
    }
    function onActivated(hook, target) {
      registerKeepAliveHook(hook, "a", target);
    }
    function onDeactivated(hook, target) {
      registerKeepAliveHook(hook, "da", target);
    }
    function registerKeepAliveHook(hook, type2, target = currentInstance) {
      const wrappedHook = hook.__wdc || (hook.__wdc = () => {
        let current = target;
        while (current) {
          if (current.isDeactivated) {
            return;
          }
          current = current.parent;
        }
        return hook();
      });
      injectHook(type2, wrappedHook, target);
      if (target) {
        let current = target.parent;
        while (current && current.parent) {
          if (isKeepAlive(current.parent.vnode)) {
            injectToKeepAliveRoot(wrappedHook, type2, target, current);
          }
          current = current.parent;
        }
      }
    }
    function injectToKeepAliveRoot(hook, type2, target, keepAliveRoot) {
      const injected = injectHook(
        type2,
        hook,
        keepAliveRoot,
        true
        /* prepend */
      );
      onUnmounted(() => {
        remove$1(keepAliveRoot[type2], injected);
      }, target);
    }
    function resetShapeFlag(vnode) {
      vnode.shapeFlag &= ~256;
      vnode.shapeFlag &= ~512;
    }
    function getInnerChild(vnode) {
      return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
    }
    function injectHook(type2, hook, target = currentInstance, prepend = false) {
      if (target) {
        const hooks = target[type2] || (target[type2] = []);
        const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
          pauseTracking();
          const reset = setCurrentInstance(target);
          const res = callWithAsyncErrorHandling(hook, target, type2, args);
          reset();
          resetTracking();
          return res;
        });
        if (prepend) {
          hooks.unshift(wrappedHook);
        } else {
          hooks.push(wrappedHook);
        }
        return wrappedHook;
      } else if (true) {
        const apiName = toHandlerKey(ErrorTypeStrings$1[type2].replace(/ hook$/, ""));
        warn$1(
          `${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
        );
      }
    }
    const createHook = (lifecycle) => (hook, target = currentInstance) => {
      if (!isInSSRComponentSetup || lifecycle === "sp") {
        injectHook(lifecycle, (...args) => hook(...args), target);
      }
    };
    const onBeforeMount = createHook("bm");
    const onMounted = createHook("m");
    const onBeforeUpdate = createHook(
      "bu"
    );
    const onUpdated = createHook("u");
    const onBeforeUnmount = createHook(
      "bum"
    );
    const onUnmounted = createHook("um");
    const onServerPrefetch = createHook(
      "sp"
    );
    const onRenderTriggered = createHook("rtg");
    const onRenderTracked = createHook("rtc");
    function onErrorCaptured(hook, target = currentInstance) {
      injectHook("ec", hook, target);
    }
    const COMPONENTS = "components";
    const DIRECTIVES = "directives";
    function resolveComponent(name, maybeSelfReference) {
      return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
    }
    const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
    function resolveDynamicComponent(component) {
      if (isString$1(component)) {
        return resolveAsset(COMPONENTS, component, false) || component;
      } else {
        return component || NULL_DYNAMIC_COMPONENT;
      }
    }
    function resolveDirective(name) {
      return resolveAsset(DIRECTIVES, name);
    }
    function resolveAsset(type2, name, warnMissing = true, maybeSelfReference = false) {
      const instance = currentRenderingInstance || currentInstance;
      if (instance) {
        const Component = instance.type;
        if (type2 === COMPONENTS) {
          const selfName = getComponentName(
            Component,
            false
          );
          if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize$1(camelize(name)))) {
            return Component;
          }
        }
        const res = (
          // local registration
          // check instance[type] first which is resolved for options API
          resolve$1(instance[type2] || Component[type2], name) || // global registration
          resolve$1(instance.appContext[type2], name)
        );
        if (!res && maybeSelfReference) {
          return Component;
        }
        if (warnMissing && !res) {
          const extra = type2 === COMPONENTS ? `
  If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;
          warn$1(`Failed to resolve ${type2.slice(0, -1)}: ${name}${extra}`);
        }
        return res;
      } else if (true) {
        warn$1(
          `resolve${capitalize$1(type2.slice(0, -1))} can only be used in render() or setup().`
        );
      }
    }
    function resolve$1(registry, name) {
      return registry && (registry[name] || registry[camelize(name)] || registry[capitalize$1(camelize(name))]);
    }
    function renderList(source, renderItem, cache, index) {
      let ret;
      const cached = cache && cache[index];
      const sourceIsArray = isArray$1(source);
      if (sourceIsArray || isString$1(source)) {
        const sourceIsReactiveArray = sourceIsArray && isReactive(source);
        let needsWrap = false;
        if (sourceIsReactiveArray) {
          needsWrap = !isShallow(source);
          source = shallowReadArray(source);
        }
        ret = new Array(source.length);
        for (let i = 0, l = source.length; i < l; i++) {
          ret[i] = renderItem(
            needsWrap ? toReactive(source[i]) : source[i],
            i,
            void 0,
            cached && cached[i]
          );
        }
      } else if (typeof source === "number") {
        if (!Number.isInteger(source)) {
          warn$1(`The v-for range expect an integer value but got ${source}.`);
        }
        ret = new Array(source);
        for (let i = 0; i < source; i++) {
          ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
        }
      } else if (isObject(source)) {
        if (source[Symbol.iterator]) {
          ret = Array.from(
            source,
            (item, i) => renderItem(item, i, void 0, cached && cached[i])
          );
        } else {
          const keys = Object.keys(source);
          ret = new Array(keys.length);
          for (let i = 0, l = keys.length; i < l; i++) {
            const key = keys[i];
            ret[i] = renderItem(source[key], key, i, cached && cached[i]);
          }
        }
      } else {
        ret = [];
      }
      if (cache) {
        cache[index] = ret;
      }
      return ret;
    }
    function createSlots(slots, dynamicSlots) {
      for (let i = 0; i < dynamicSlots.length; i++) {
        const slot = dynamicSlots[i];
        if (isArray$1(slot)) {
          for (let j = 0; j < slot.length; j++) {
            slots[slot[j].name] = slot[j].fn;
          }
        } else if (slot) {
          slots[slot.name] = slot.key ? (...args) => {
            const res = slot.fn(...args);
            if (res) res.key = slot.key;
            return res;
          } : slot.fn;
        }
      }
      return slots;
    }
    function renderSlot(slots, name, props = {}, fallback, noSlotted) {
      if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
        if (name !== "default") props.name = name;
        return openBlock(), createBlock(
          Fragment,
          null,
          [createVNode("slot", props, fallback && fallback())],
          64
        );
      }
      let slot = slots[name];
      if (slot && slot.length > 1) {
        warn$1(
          `SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`
        );
        slot = () => [];
      }
      if (slot && slot._c) {
        slot._d = false;
      }
      openBlock();
      const validSlotContent = slot && ensureValidVNode(slot(props));
      const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      validSlotContent && validSlotContent.key;
      const rendered = createBlock(
        Fragment,
        {
          key: (slotKey && !isSymbol$2(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content
          (!validSlotContent && fallback ? "_fb" : "")
        },
        validSlotContent || (fallback ? fallback() : []),
        validSlotContent && slots._ === 1 ? 64 : -2
      );
      if (!noSlotted && rendered.scopeId) {
        rendered.slotScopeIds = [rendered.scopeId + "-s"];
      }
      if (slot && slot._c) {
        slot._d = true;
      }
      return rendered;
    }
    function ensureValidVNode(vnodes) {
      return vnodes.some((child) => {
        if (!isVNode(child)) return true;
        if (child.type === Comment) return false;
        if (child.type === Fragment && !ensureValidVNode(child.children))
          return false;
        return true;
      }) ? vnodes : null;
    }
    function toHandlers(obj, preserveCaseIfNecessary) {
      const ret = {};
      if (!isObject(obj)) {
        warn$1(`v-on with no argument expects an object value.`);
        return ret;
      }
      for (const key in obj) {
        ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : toHandlerKey(key)] = obj[key];
      }
      return ret;
    }
    const getPublicInstance = (i) => {
      if (!i) return null;
      if (isStatefulComponent(i)) return getComponentPublicInstance(i);
      return getPublicInstance(i.parent);
    };
    const publicPropertiesMap = (
      // Move PURE marker to new line to workaround compiler discarding it
      // due to type annotation
      /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
        $: (i) => i,
        $el: (i) => i.vnode.el,
        $data: (i) => i.data,
        $props: (i) => true ? shallowReadonly(i.props) : i.props,
        $attrs: (i) => true ? shallowReadonly(i.attrs) : i.attrs,
        $slots: (i) => true ? shallowReadonly(i.slots) : i.slots,
        $refs: (i) => true ? shallowReadonly(i.refs) : i.refs,
        $parent: (i) => getPublicInstance(i.parent),
        $root: (i) => getPublicInstance(i.root),
        $host: (i) => i.ce,
        $emit: (i) => i.emit,
        $options: (i) => true ? resolveMergedOptions(i) : i.type,
        $forceUpdate: (i) => i.f || (i.f = () => {
          queueJob(i.update);
        }),
        $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
        $watch: (i) => true ? instanceWatch.bind(i) : NOOP
      })
    );
    const isReservedPrefix = (key) => key === "_" || key === "$";
    const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
    const PublicInstanceProxyHandlers = {
      get({ _: instance }, key) {
        if (key === "__v_skip") {
          return true;
        }
        const { ctx, setupState, data, props, accessCache, type: type2, appContext } = instance;
        if (key === "__isVue") {
          return true;
        }
        let normalizedProps;
        if (key[0] !== "$") {
          const n = accessCache[key];
          if (n !== void 0) {
            switch (n) {
              case 1:
                return setupState[key];
              case 2:
                return data[key];
              case 4:
                return ctx[key];
              case 3:
                return props[key];
            }
          } else if (hasSetupBinding(setupState, key)) {
            accessCache[key] = 1;
            return setupState[key];
          } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
            accessCache[key] = 2;
            return data[key];
          } else if (
            // only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
          ) {
            accessCache[key] = 3;
            return props[key];
          } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
            accessCache[key] = 4;
            return ctx[key];
          } else if (shouldCacheAccess) {
            accessCache[key] = 0;
          }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        if (publicGetter) {
          if (key === "$attrs") {
            track(instance.attrs, "get", "");
            markAttrsAccessed();
          } else if (key === "$slots") {
            track(instance, "get", key);
          }
          return publicGetter(instance);
        } else if (
          // css module (injected by vue-loader)
          (cssModule = type2.__cssModules) && (cssModule = cssModule[key])
        ) {
          return cssModule;
        } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (
          // global properties
          globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
        ) {
          {
            return globalProperties[key];
          }
        } else if (currentRenderingInstance && (!isString$1(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
        // to infinite warning loop
        key.indexOf("__v") !== 0)) {
          if (data !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn(data, key)) {
            warn$1(
              `Property ${JSON.stringify(
                key
              )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
            );
          } else if (instance === currentRenderingInstance) {
            warn$1(
              `Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`
            );
          }
        }
      },
      set({ _: instance }, key, value) {
        const { data, setupState, ctx } = instance;
        if (hasSetupBinding(setupState, key)) {
          setupState[key] = value;
          return true;
        } else if (setupState.__isScriptSetup && hasOwn(setupState, key)) {
          warn$1(`Cannot mutate <script setup> binding "${key}" from Options API.`);
          return false;
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          data[key] = value;
          return true;
        } else if (hasOwn(instance.props, key)) {
          warn$1(`Attempting to mutate prop "${key}". Props are readonly.`);
          return false;
        }
        if (key[0] === "$" && key.slice(1) in instance) {
          warn$1(
            `Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`
          );
          return false;
        } else {
          if (key in instance.appContext.config.globalProperties) {
            Object.defineProperty(ctx, key, {
              enumerable: true,
              configurable: true,
              value
            });
          } else {
            ctx[key] = value;
          }
        }
        return true;
      },
      has({
        _: { data, setupState, accessCache, ctx, appContext, propsOptions }
      }, key) {
        let normalizedProps;
        return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
      },
      defineProperty(target, key, descriptor) {
        if (descriptor.get != null) {
          target._.accessCache[key] = 0;
        } else if (hasOwn(descriptor, "value")) {
          this.set(target, key, descriptor.value, null);
        }
        return Reflect.defineProperty(target, key, descriptor);
      }
    };
    if (true) {
      PublicInstanceProxyHandlers.ownKeys = (target) => {
        warn$1(
          `Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`
        );
        return Reflect.ownKeys(target);
      };
    }
    const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend({}, PublicInstanceProxyHandlers, {
      get(target, key) {
        if (key === Symbol.unscopables) {
          return;
        }
        return PublicInstanceProxyHandlers.get(target, key, target);
      },
      has(_, key) {
        const has = key[0] !== "_" && !isGloballyAllowed(key);
        if (!has && PublicInstanceProxyHandlers.has(_, key)) {
          warn$1(
            `Property ${JSON.stringify(
              key
            )} should not start with _ which is a reserved prefix for Vue internals.`
          );
        }
        return has;
      }
    });
    function createDevRenderContext(instance) {
      const target = {};
      Object.defineProperty(target, `_`, {
        configurable: true,
        enumerable: false,
        get: () => instance
      });
      Object.keys(publicPropertiesMap).forEach((key) => {
        Object.defineProperty(target, key, {
          configurable: true,
          enumerable: false,
          get: () => publicPropertiesMap[key](instance),
          // intercepted by the proxy so no need for implementation,
          // but needed to prevent set errors
          set: NOOP
        });
      });
      return target;
    }
    function exposePropsOnRenderContext(instance) {
      const {
        ctx,
        propsOptions: [propsOptions]
      } = instance;
      if (propsOptions) {
        Object.keys(propsOptions).forEach((key) => {
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => instance.props[key],
            set: NOOP
          });
        });
      }
    }
    function exposeSetupStateOnRenderContext(instance) {
      const { ctx, setupState } = instance;
      Object.keys(toRaw(setupState)).forEach((key) => {
        if (!setupState.__isScriptSetup) {
          if (isReservedPrefix(key[0])) {
            warn$1(
              `setup() return property ${JSON.stringify(
                key
              )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
            );
            return;
          }
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => setupState[key],
            set: NOOP
          });
        }
      });
    }
    const warnRuntimeUsage = (method) => warn$1(
      `${method}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`
    );
    function defineProps() {
      if (true) {
        warnRuntimeUsage(`defineProps`);
      }
      return null;
    }
    function defineEmits() {
      if (true) {
        warnRuntimeUsage(`defineEmits`);
      }
      return null;
    }
    function defineExpose(exposed) {
      if (true) {
        warnRuntimeUsage(`defineExpose`);
      }
    }
    function defineOptions(options) {
      if (true) {
        warnRuntimeUsage(`defineOptions`);
      }
    }
    function defineSlots() {
      if (true) {
        warnRuntimeUsage(`defineSlots`);
      }
      return null;
    }
    function defineModel() {
      if (true) {
        warnRuntimeUsage("defineModel");
      }
    }
    function withDefaults(props, defaults2) {
      if (true) {
        warnRuntimeUsage(`withDefaults`);
      }
      return null;
    }
    function useSlots() {
      return getContext().slots;
    }
    function useAttrs() {
      return getContext().attrs;
    }
    function getContext() {
      const i = getCurrentInstance();
      if (!i) {
        warn$1(`useContext() called without active instance.`);
      }
      return i.setupContext || (i.setupContext = createSetupContext(i));
    }
    function normalizePropsOrEmits(props) {
      return isArray$1(props) ? props.reduce(
        (normalized, p2) => (normalized[p2] = null, normalized),
        {}
      ) : props;
    }
    function mergeDefaults(raw, defaults2) {
      const props = normalizePropsOrEmits(raw);
      for (const key in defaults2) {
        if (key.startsWith("__skip")) continue;
        let opt = props[key];
        if (opt) {
          if (isArray$1(opt) || isFunction$1(opt)) {
            opt = props[key] = { type: opt, default: defaults2[key] };
          } else {
            opt.default = defaults2[key];
          }
        } else if (opt === null) {
          opt = props[key] = { default: defaults2[key] };
        } else if (true) {
          warn$1(`props default key "${key}" has no corresponding declaration.`);
        }
        if (opt && defaults2[`__skip_${key}`]) {
          opt.skipFactory = true;
        }
      }
      return props;
    }
    function mergeModels(a, b) {
      if (!a || !b) return a || b;
      if (isArray$1(a) && isArray$1(b)) return a.concat(b);
      return extend({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));
    }
    function createPropsRestProxy(props, excludedKeys) {
      const ret = {};
      for (const key in props) {
        if (!excludedKeys.includes(key)) {
          Object.defineProperty(ret, key, {
            enumerable: true,
            get: () => props[key]
          });
        }
      }
      return ret;
    }
    function withAsyncContext(getAwaitable) {
      const ctx = getCurrentInstance();
      if (!ctx) {
        warn$1(
          `withAsyncContext called without active current instance. This is likely a bug.`
        );
      }
      let awaitable = getAwaitable();
      unsetCurrentInstance();
      if (isPromise$1(awaitable)) {
        awaitable = awaitable.catch((e) => {
          setCurrentInstance(ctx);
          throw e;
        });
      }
      return [awaitable, () => setCurrentInstance(ctx)];
    }
    function createDuplicateChecker() {
      const cache = /* @__PURE__ */ Object.create(null);
      return (type2, key) => {
        if (cache[key]) {
          warn$1(`${type2} property "${key}" is already defined in ${cache[key]}.`);
        } else {
          cache[key] = type2;
        }
      };
    }
    let shouldCacheAccess = true;
    function applyOptions(instance) {
      const options = resolveMergedOptions(instance);
      const publicThis = instance.proxy;
      const ctx = instance.ctx;
      shouldCacheAccess = false;
      if (options.beforeCreate) {
        callHook$1(options.beforeCreate, instance, "bc");
      }
      const {
        // state
        data: dataOptions,
        computed: computedOptions,
        methods,
        watch: watchOptions,
        provide: provideOptions,
        inject: injectOptions,
        // lifecycle
        created,
        beforeMount,
        mounted,
        beforeUpdate,
        updated,
        activated,
        deactivated,
        beforeDestroy,
        beforeUnmount,
        destroyed,
        unmounted,
        render: render2,
        renderTracked,
        renderTriggered,
        errorCaptured,
        serverPrefetch,
        // public API
        expose,
        inheritAttrs,
        // assets
        components,
        directives,
        filters
      } = options;
      const checkDuplicateProperties = true ? createDuplicateChecker() : null;
      if (true) {
        const [propsOptions] = instance.propsOptions;
        if (propsOptions) {
          for (const key in propsOptions) {
            checkDuplicateProperties("Props", key);
          }
        }
      }
      if (injectOptions) {
        resolveInjections(injectOptions, ctx, checkDuplicateProperties);
      }
      if (methods) {
        for (const key in methods) {
          const methodHandler = methods[key];
          if (isFunction$1(methodHandler)) {
            if (true) {
              Object.defineProperty(ctx, key, {
                value: methodHandler.bind(publicThis),
                configurable: true,
                enumerable: true,
                writable: true
              });
            } else {
              ctx[key] = methodHandler.bind(publicThis);
            }
            if (true) {
              checkDuplicateProperties("Methods", key);
            }
          } else if (true) {
            warn$1(
              `Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`
            );
          }
        }
      }
      if (dataOptions) {
        if (!isFunction$1(dataOptions)) {
          warn$1(
            `The data option must be a function. Plain object usage is no longer supported.`
          );
        }
        const data = dataOptions.call(publicThis, publicThis);
        if (isPromise$1(data)) {
          warn$1(
            `data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`
          );
        }
        if (!isObject(data)) {
          warn$1(`data() should return an object.`);
        } else {
          instance.data = reactive(data);
          if (true) {
            for (const key in data) {
              checkDuplicateProperties("Data", key);
              if (!isReservedPrefix(key[0])) {
                Object.defineProperty(ctx, key, {
                  configurable: true,
                  enumerable: true,
                  get: () => data[key],
                  set: NOOP
                });
              }
            }
          }
        }
      }
      shouldCacheAccess = true;
      if (computedOptions) {
        for (const key in computedOptions) {
          const opt = computedOptions[key];
          const get = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
          if (get === NOOP) {
            warn$1(`Computed property "${key}" has no getter.`);
          }
          const set = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : true ? () => {
            warn$1(
              `Write operation failed: computed property "${key}" is readonly.`
            );
          } : NOOP;
          const c = computed({
            get,
            set
          });
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => c.value,
            set: (v) => c.value = v
          });
          if (true) {
            checkDuplicateProperties("Computed", key);
          }
        }
      }
      if (watchOptions) {
        for (const key in watchOptions) {
          createWatcher(watchOptions[key], ctx, publicThis, key);
        }
      }
      if (provideOptions) {
        const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
        Reflect.ownKeys(provides).forEach((key) => {
          provide(key, provides[key]);
        });
      }
      if (created) {
        callHook$1(created, instance, "c");
      }
      function registerLifecycleHook(register, hook) {
        if (isArray$1(hook)) {
          hook.forEach((_hook) => register(_hook.bind(publicThis)));
        } else if (hook) {
          register(hook.bind(publicThis));
        }
      }
      registerLifecycleHook(onBeforeMount, beforeMount);
      registerLifecycleHook(onMounted, mounted);
      registerLifecycleHook(onBeforeUpdate, beforeUpdate);
      registerLifecycleHook(onUpdated, updated);
      registerLifecycleHook(onActivated, activated);
      registerLifecycleHook(onDeactivated, deactivated);
      registerLifecycleHook(onErrorCaptured, errorCaptured);
      registerLifecycleHook(onRenderTracked, renderTracked);
      registerLifecycleHook(onRenderTriggered, renderTriggered);
      registerLifecycleHook(onBeforeUnmount, beforeUnmount);
      registerLifecycleHook(onUnmounted, unmounted);
      registerLifecycleHook(onServerPrefetch, serverPrefetch);
      if (isArray$1(expose)) {
        if (expose.length) {
          const exposed = instance.exposed || (instance.exposed = {});
          expose.forEach((key) => {
            Object.defineProperty(exposed, key, {
              get: () => publicThis[key],
              set: (val) => publicThis[key] = val
            });
          });
        } else if (!instance.exposed) {
          instance.exposed = {};
        }
      }
      if (render2 && instance.render === NOOP) {
        instance.render = render2;
      }
      if (inheritAttrs != null) {
        instance.inheritAttrs = inheritAttrs;
      }
      if (components) instance.components = components;
      if (directives) instance.directives = directives;
      if (serverPrefetch) {
        markAsyncBoundary(instance);
      }
    }
    function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
      if (isArray$1(injectOptions)) {
        injectOptions = normalizeInject(injectOptions);
      }
      for (const key in injectOptions) {
        const opt = injectOptions[key];
        let injected;
        if (isObject(opt)) {
          if ("default" in opt) {
            injected = inject(
              opt.from || key,
              opt.default,
              true
            );
          } else {
            injected = inject(opt.from || key);
          }
        } else {
          injected = inject(opt);
        }
        if (isRef(injected)) {
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => injected.value,
            set: (v) => injected.value = v
          });
        } else {
          ctx[key] = injected;
        }
        if (true) {
          checkDuplicateProperties("Inject", key);
        }
      }
    }
    function callHook$1(hook, instance, type2) {
      callWithAsyncErrorHandling(
        isArray$1(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
        instance,
        type2
      );
    }
    function createWatcher(raw, ctx, publicThis, key) {
      let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
      if (isString$1(raw)) {
        const handler = ctx[raw];
        if (isFunction$1(handler)) {
          {
            watch(getter, handler);
          }
        } else if (true) {
          warn$1(`Invalid watch handler specified by key "${raw}"`, handler);
        }
      } else if (isFunction$1(raw)) {
        {
          watch(getter, raw.bind(publicThis));
        }
      } else if (isObject(raw)) {
        if (isArray$1(raw)) {
          raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
        } else {
          const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
          if (isFunction$1(handler)) {
            watch(getter, handler, raw);
          } else if (true) {
            warn$1(`Invalid watch handler specified by key "${raw.handler}"`, handler);
          }
        }
      } else if (true) {
        warn$1(`Invalid watch option: "${key}"`, raw);
      }
    }
    function resolveMergedOptions(instance) {
      const base = instance.type;
      const { mixins, extends: extendsOptions } = base;
      const {
        mixins: globalMixins,
        optionsCache: cache,
        config: { optionMergeStrategies }
      } = instance.appContext;
      const cached = cache.get(base);
      let resolved;
      if (cached) {
        resolved = cached;
      } else if (!globalMixins.length && !mixins && !extendsOptions) {
        {
          resolved = base;
        }
      } else {
        resolved = {};
        if (globalMixins.length) {
          globalMixins.forEach(
            (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
          );
        }
        mergeOptions(resolved, base, optionMergeStrategies);
      }
      if (isObject(base)) {
        cache.set(base, resolved);
      }
      return resolved;
    }
    function mergeOptions(to, from, strats, asMixin = false) {
      const { mixins, extends: extendsOptions } = from;
      if (extendsOptions) {
        mergeOptions(to, extendsOptions, strats, true);
      }
      if (mixins) {
        mixins.forEach(
          (m) => mergeOptions(to, m, strats, true)
        );
      }
      for (const key in from) {
        if (asMixin && key === "expose") {
          warn$1(
            `"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`
          );
        } else {
          const strat = internalOptionMergeStrats[key] || strats && strats[key];
          to[key] = strat ? strat(to[key], from[key]) : from[key];
        }
      }
      return to;
    }
    const internalOptionMergeStrats = {
      data: mergeDataFn,
      props: mergeEmitsOrPropsOptions,
      emits: mergeEmitsOrPropsOptions,
      // objects
      methods: mergeObjectOptions,
      computed: mergeObjectOptions,
      // lifecycle
      beforeCreate: mergeAsArray,
      created: mergeAsArray,
      beforeMount: mergeAsArray,
      mounted: mergeAsArray,
      beforeUpdate: mergeAsArray,
      updated: mergeAsArray,
      beforeDestroy: mergeAsArray,
      beforeUnmount: mergeAsArray,
      destroyed: mergeAsArray,
      unmounted: mergeAsArray,
      activated: mergeAsArray,
      deactivated: mergeAsArray,
      errorCaptured: mergeAsArray,
      serverPrefetch: mergeAsArray,
      // assets
      components: mergeObjectOptions,
      directives: mergeObjectOptions,
      // watch
      watch: mergeWatchOptions,
      // provide / inject
      provide: mergeDataFn,
      inject: mergeInject
    };
    function mergeDataFn(to, from) {
      if (!from) {
        return to;
      }
      if (!to) {
        return from;
      }
      return function mergedDataFn() {
        return extend(
          isFunction$1(to) ? to.call(this, this) : to,
          isFunction$1(from) ? from.call(this, this) : from
        );
      };
    }
    function mergeInject(to, from) {
      return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
    }
    function normalizeInject(raw) {
      if (isArray$1(raw)) {
        const res = {};
        for (let i = 0; i < raw.length; i++) {
          res[raw[i]] = raw[i];
        }
        return res;
      }
      return raw;
    }
    function mergeAsArray(to, from) {
      return to ? [...new Set([].concat(to, from))] : from;
    }
    function mergeObjectOptions(to, from) {
      return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
    }
    function mergeEmitsOrPropsOptions(to, from) {
      if (to) {
        if (isArray$1(to) && isArray$1(from)) {
          return [.../* @__PURE__ */ new Set([...to, ...from])];
        }
        return extend(
          /* @__PURE__ */ Object.create(null),
          normalizePropsOrEmits(to),
          normalizePropsOrEmits(from != null ? from : {})
        );
      } else {
        return from;
      }
    }
    function mergeWatchOptions(to, from) {
      if (!to) return from;
      if (!from) return to;
      const merged = extend(/* @__PURE__ */ Object.create(null), to);
      for (const key in from) {
        merged[key] = mergeAsArray(to[key], from[key]);
      }
      return merged;
    }
    function createAppContext() {
      return {
        app: null,
        config: {
          isNativeTag: NO,
          performance: false,
          globalProperties: {},
          optionMergeStrategies: {},
          errorHandler: void 0,
          warnHandler: void 0,
          compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: /* @__PURE__ */ Object.create(null),
        optionsCache: /* @__PURE__ */ new WeakMap(),
        propsCache: /* @__PURE__ */ new WeakMap(),
        emitsCache: /* @__PURE__ */ new WeakMap()
      };
    }
    let uid$1 = 0;
    function createAppAPI(render2, hydrate2) {
      return function createApp2(rootComponent, rootProps = null) {
        if (!isFunction$1(rootComponent)) {
          rootComponent = extend({}, rootComponent);
        }
        if (rootProps != null && !isObject(rootProps)) {
          warn$1(`root props passed to app.mount() must be an object.`);
          rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = /* @__PURE__ */ new WeakSet();
        const pluginCleanupFns = [];
        let isMounted = false;
        const app = context.app = {
          _uid: uid$1++,
          _component: rootComponent,
          _props: rootProps,
          _container: null,
          _context: context,
          _instance: null,
          version,
          get config() {
            return context.config;
          },
          set config(v) {
            if (true) {
              warn$1(
                `app.config cannot be replaced. Modify individual options instead.`
              );
            }
          },
          use(plugin, ...options) {
            if (installedPlugins.has(plugin)) {
              warn$1(`Plugin has already been applied to target app.`);
            } else if (plugin && isFunction$1(plugin.install)) {
              installedPlugins.add(plugin);
              plugin.install(app, ...options);
            } else if (isFunction$1(plugin)) {
              installedPlugins.add(plugin);
              plugin(app, ...options);
            } else if (true) {
              warn$1(
                `A plugin must either be a function or an object with an "install" function.`
              );
            }
            return app;
          },
          mixin(mixin) {
            if (true) {
              if (!context.mixins.includes(mixin)) {
                context.mixins.push(mixin);
              } else if (true) {
                warn$1(
                  "Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : "")
                );
              }
            } else if (true) {
              warn$1("Mixins are only available in builds supporting Options API");
            }
            return app;
          },
          component(name, component) {
            if (true) {
              validateComponentName(name, context.config);
            }
            if (!component) {
              return context.components[name];
            }
            if (context.components[name]) {
              warn$1(`Component "${name}" has already been registered in target app.`);
            }
            context.components[name] = component;
            return app;
          },
          directive(name, directive) {
            if (true) {
              validateDirectiveName(name);
            }
            if (!directive) {
              return context.directives[name];
            }
            if (context.directives[name]) {
              warn$1(`Directive "${name}" has already been registered in target app.`);
            }
            context.directives[name] = directive;
            return app;
          },
          mount(rootContainer, isHydrate, namespace) {
            if (!isMounted) {
              if (rootContainer.__vue_app__) {
                warn$1(
                  `There is already an app instance mounted on the host container.
   If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`
                );
              }
              const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
              vnode.appContext = context;
              if (namespace === true) {
                namespace = "svg";
              } else if (namespace === false) {
                namespace = void 0;
              }
              if (true) {
                context.reload = () => {
                  render2(
                    cloneVNode(vnode),
                    rootContainer,
                    namespace
                  );
                };
              }
              if (isHydrate && hydrate2) {
                hydrate2(vnode, rootContainer);
              } else {
                render2(vnode, rootContainer, namespace);
              }
              isMounted = true;
              app._container = rootContainer;
              rootContainer.__vue_app__ = app;
              if (true) {
                app._instance = vnode.component;
                devtoolsInitApp(app, version);
              }
              return getComponentPublicInstance(vnode.component);
            } else if (true) {
              warn$1(
                `App has already been mounted.
  If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``
              );
            }
          },
          onUnmount(cleanupFn) {
            if (typeof cleanupFn !== "function") {
              warn$1(
                `Expected function as first argument to app.onUnmount(), but got ${typeof cleanupFn}`
              );
            }
            pluginCleanupFns.push(cleanupFn);
          },
          unmount() {
            if (isMounted) {
              callWithAsyncErrorHandling(
                pluginCleanupFns,
                app._instance,
                16
              );
              render2(null, app._container);
              if (true) {
                app._instance = null;
                devtoolsUnmountApp(app);
              }
              delete app._container.__vue_app__;
            } else if (true) {
              warn$1(`Cannot unmount an app that is not mounted.`);
            }
          },
          provide(key, value) {
            if (key in context.provides) {
              warn$1(
                `App already provides property with key "${String(key)}". It will be overwritten with the new value.`
              );
            }
            context.provides[key] = value;
            return app;
          },
          runWithContext(fn) {
            const lastApp = currentApp;
            currentApp = app;
            try {
              return fn();
            } finally {
              currentApp = lastApp;
            }
          }
        };
        return app;
      };
    }
    let currentApp = null;
    function provide(key, value) {
      if (!currentInstance) {
        if (true) {
          warn$1(`provide() can only be used inside setup().`);
        }
      } else {
        let provides = currentInstance.provides;
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) {
          provides = currentInstance.provides = Object.create(parentProvides);
        }
        provides[key] = value;
      }
    }
    function inject(key, defaultValue, treatDefaultAsFactory = false) {
      const instance = currentInstance || currentRenderingInstance;
      if (instance || currentApp) {
        const provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
        if (provides && key in provides) {
          return provides[key];
        } else if (arguments.length > 1) {
          return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
        } else if (true) {
          warn$1(`injection "${String(key)}" not found.`);
        }
      } else if (true) {
        warn$1(`inject() can only be used inside setup() or functional components.`);
      }
    }
    function hasInjectionContext() {
      return !!(currentInstance || currentRenderingInstance || currentApp);
    }
    const internalObjectProto = {};
    const createInternalObject = () => Object.create(internalObjectProto);
    const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
    function initProps(instance, rawProps, isStateful, isSSR = false) {
      const props = {};
      const attrs = createInternalObject();
      instance.propsDefaults = /* @__PURE__ */ Object.create(null);
      setFullProps(instance, rawProps, props, attrs);
      for (const key in instance.propsOptions[0]) {
        if (!(key in props)) {
          props[key] = void 0;
        }
      }
      if (true) {
        validateProps(rawProps || {}, props, instance);
      }
      if (isStateful) {
        instance.props = isSSR ? props : shallowReactive(props);
      } else {
        if (!instance.type.props) {
          instance.props = attrs;
        } else {
          instance.props = props;
        }
      }
      instance.attrs = attrs;
    }
    function isInHmrContext(instance) {
      while (instance) {
        if (instance.type.__hmrId) return true;
        instance = instance.parent;
      }
    }
    function updateProps(instance, rawProps, rawPrevProps, optimized) {
      const {
        props,
        attrs,
        vnode: { patchFlag }
      } = instance;
      const rawCurrentProps = toRaw(props);
      const [options] = instance.propsOptions;
      let hasAttrsChanged = false;
      if (
        // always force full diff in dev
        // - #1942 if hmr is enabled with sfc component
        // - vite#872 non-sfc component used by sfc component
        !isInHmrContext(instance) && (optimized || patchFlag > 0) && !(patchFlag & 16)
      ) {
        if (patchFlag & 8) {
          const propsToUpdate = instance.vnode.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            let key = propsToUpdate[i];
            if (isEmitListener(instance.emitsOptions, key)) {
              continue;
            }
            const value = rawProps[key];
            if (options) {
              if (hasOwn(attrs, key)) {
                if (value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              } else {
                const camelizedKey = camelize(key);
                props[camelizedKey] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  camelizedKey,
                  value,
                  instance,
                  false
                );
              }
            } else {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            }
          }
        }
      } else {
        if (setFullProps(instance, rawProps, props, attrs)) {
          hasAttrsChanged = true;
        }
        let kebabKey;
        for (const key in rawCurrentProps) {
          if (!rawProps || // for camelCase
          !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
          // and converted to camelCase (#955)
          ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
            if (options) {
              if (rawPrevProps && // for camelCase
              (rawPrevProps[key] !== void 0 || // for kebab-case
              rawPrevProps[kebabKey] !== void 0)) {
                props[key] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  key,
                  void 0,
                  instance,
                  true
                );
              }
            } else {
              delete props[key];
            }
          }
        }
        if (attrs !== rawCurrentProps) {
          for (const key in attrs) {
            if (!rawProps || !hasOwn(rawProps, key) && true) {
              delete attrs[key];
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (hasAttrsChanged) {
        trigger(instance.attrs, "set", "");
      }
      if (true) {
        validateProps(rawProps || {}, props, instance);
      }
    }
    function setFullProps(instance, rawProps, props, attrs) {
      const [options, needCastKeys] = instance.propsOptions;
      let hasAttrsChanged = false;
      let rawCastValues;
      if (rawProps) {
        for (let key in rawProps) {
          if (isReservedProp(key)) {
            continue;
          }
          const value = rawProps[key];
          let camelKey;
          if (options && hasOwn(options, camelKey = camelize(key))) {
            if (!needCastKeys || !needCastKeys.includes(camelKey)) {
              props[camelKey] = value;
            } else {
              (rawCastValues || (rawCastValues = {}))[camelKey] = value;
            }
          } else if (!isEmitListener(instance.emitsOptions, key)) {
            if (!(key in attrs) || value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (needCastKeys) {
        const rawCurrentProps = toRaw(props);
        const castValues = rawCastValues || EMPTY_OBJ;
        for (let i = 0; i < needCastKeys.length; i++) {
          const key = needCastKeys[i];
          props[key] = resolvePropValue(
            options,
            rawCurrentProps,
            key,
            castValues[key],
            instance,
            !hasOwn(castValues, key)
          );
        }
      }
      return hasAttrsChanged;
    }
    function resolvePropValue(options, props, key, value, instance, isAbsent) {
      const opt = options[key];
      if (opt != null) {
        const hasDefault = hasOwn(opt, "default");
        if (hasDefault && value === void 0) {
          const defaultValue = opt.default;
          if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
            const { propsDefaults } = instance;
            if (key in propsDefaults) {
              value = propsDefaults[key];
            } else {
              const reset = setCurrentInstance(instance);
              value = propsDefaults[key] = defaultValue.call(
                null,
                props
              );
              reset();
            }
          } else {
            value = defaultValue;
          }
          if (instance.ce) {
            instance.ce._setProp(key, value);
          }
        }
        if (opt[
          0
          /* shouldCast */
        ]) {
          if (isAbsent && !hasDefault) {
            value = false;
          } else if (opt[
            1
            /* shouldCastTrue */
          ] && (value === "" || value === hyphenate(key))) {
            value = true;
          }
        }
      }
      return value;
    }
    const mixinPropsCache = /* @__PURE__ */ new WeakMap();
    function normalizePropsOptions(comp, appContext, asMixin = false) {
      const cache = asMixin ? mixinPropsCache : appContext.propsCache;
      const cached = cache.get(comp);
      if (cached) {
        return cached;
      }
      const raw = comp.props;
      const normalized = {};
      const needCastKeys = [];
      let hasExtends = false;
      if (!isFunction$1(comp)) {
        const extendProps = (raw2) => {
          hasExtends = true;
          const [props, keys] = normalizePropsOptions(raw2, appContext, true);
          extend(normalized, props);
          if (keys) needCastKeys.push(...keys);
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendProps);
        }
        if (comp.extends) {
          extendProps(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendProps);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject(comp)) {
          cache.set(comp, EMPTY_ARR);
        }
        return EMPTY_ARR;
      }
      if (isArray$1(raw)) {
        for (let i = 0; i < raw.length; i++) {
          if (!isString$1(raw[i])) {
            warn$1(`props must be strings when using array syntax.`, raw[i]);
          }
          const normalizedKey = camelize(raw[i]);
          if (validatePropName(normalizedKey)) {
            normalized[normalizedKey] = EMPTY_OBJ;
          }
        }
      } else if (raw) {
        if (!isObject(raw)) {
          warn$1(`invalid props options`, raw);
        }
        for (const key in raw) {
          const normalizedKey = camelize(key);
          if (validatePropName(normalizedKey)) {
            const opt = raw[key];
            const prop = normalized[normalizedKey] = isArray$1(opt) || isFunction$1(opt) ? { type: opt } : extend({}, opt);
            const propType = prop.type;
            let shouldCast = false;
            let shouldCastTrue = true;
            if (isArray$1(propType)) {
              for (let index = 0; index < propType.length; ++index) {
                const type2 = propType[index];
                const typeName = isFunction$1(type2) && type2.name;
                if (typeName === "Boolean") {
                  shouldCast = true;
                  break;
                } else if (typeName === "String") {
                  shouldCastTrue = false;
                }
              }
            } else {
              shouldCast = isFunction$1(propType) && propType.name === "Boolean";
            }
            prop[
              0
              /* shouldCast */
            ] = shouldCast;
            prop[
              1
              /* shouldCastTrue */
            ] = shouldCastTrue;
            if (shouldCast || hasOwn(prop, "default")) {
              needCastKeys.push(normalizedKey);
            }
          }
        }
      }
      const res = [normalized, needCastKeys];
      if (isObject(comp)) {
        cache.set(comp, res);
      }
      return res;
    }
    function validatePropName(key) {
      if (key[0] !== "$" && !isReservedProp(key)) {
        return true;
      } else if (true) {
        warn$1(`Invalid prop name: "${key}" is a reserved property.`);
      }
      return false;
    }
    function getType(ctor) {
      if (ctor === null) {
        return "null";
      }
      if (typeof ctor === "function") {
        return ctor.name || "";
      } else if (typeof ctor === "object") {
        const name = ctor.constructor && ctor.constructor.name;
        return name || "";
      }
      return "";
    }
    function validateProps(rawProps, props, instance) {
      const resolvedValues = toRaw(props);
      const options = instance.propsOptions[0];
      const camelizePropsKey = Object.keys(rawProps).map((key) => camelize(key));
      for (const key in options) {
        let opt = options[key];
        if (opt == null) continue;
        validateProp(
          key,
          resolvedValues[key],
          opt,
          true ? shallowReadonly(resolvedValues) : resolvedValues,
          !camelizePropsKey.includes(key)
        );
      }
    }
    function validateProp(name, value, prop, props, isAbsent) {
      const { type: type2, required: required2, validator, skipCheck } = prop;
      if (required2 && isAbsent) {
        warn$1('Missing required prop: "' + name + '"');
        return;
      }
      if (value == null && !required2) {
        return;
      }
      if (type2 != null && type2 !== true && !skipCheck) {
        let isValid = false;
        const types2 = isArray$1(type2) ? type2 : [type2];
        const expectedTypes = [];
        for (let i = 0; i < types2.length && !isValid; i++) {
          const { valid, expectedType } = assertType(value, types2[i]);
          expectedTypes.push(expectedType || "");
          isValid = valid;
        }
        if (!isValid) {
          warn$1(getInvalidTypeMessage(name, value, expectedTypes));
          return;
        }
      }
      if (validator && !validator(value, props)) {
        warn$1('Invalid prop: custom validator check failed for prop "' + name + '".');
      }
    }
    const isSimpleType = /* @__PURE__ */ makeMap(
      "String,Number,Boolean,Function,Symbol,BigInt"
    );
    function assertType(value, type2) {
      let valid;
      const expectedType = getType(type2);
      if (expectedType === "null") {
        valid = value === null;
      } else if (isSimpleType(expectedType)) {
        const t = typeof value;
        valid = t === expectedType.toLowerCase();
        if (!valid && t === "object") {
          valid = value instanceof type2;
        }
      } else if (expectedType === "Object") {
        valid = isObject(value);
      } else if (expectedType === "Array") {
        valid = isArray$1(value);
      } else {
        valid = value instanceof type2;
      }
      return {
        valid,
        expectedType
      };
    }
    function getInvalidTypeMessage(name, value, expectedTypes) {
      if (expectedTypes.length === 0) {
        return `Prop type [] for prop "${name}" won't match anything. Did you mean to use type Array instead?`;
      }
      let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize$1).join(" | ")}`;
      const expectedType = expectedTypes[0];
      const receivedType = toRawType(value);
      const expectedValue = styleValue(value, expectedType);
      const receivedValue = styleValue(value, receivedType);
      if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean$1(expectedType, receivedType)) {
        message += ` with value ${expectedValue}`;
      }
      message += `, got ${receivedType} `;
      if (isExplicable(receivedType)) {
        message += `with value ${receivedValue}.`;
      }
      return message;
    }
    function styleValue(value, type2) {
      if (type2 === "String") {
        return `"${value}"`;
      } else if (type2 === "Number") {
        return `${Number(value)}`;
      } else {
        return `${value}`;
      }
    }
    function isExplicable(type2) {
      const explicitTypes = ["string", "number", "boolean"];
      return explicitTypes.some((elem) => type2.toLowerCase() === elem);
    }
    function isBoolean$1(...args) {
      return args.some((elem) => elem.toLowerCase() === "boolean");
    }
    const isInternalKey = (key) => key[0] === "_" || key === "$stable";
    const normalizeSlotValue = (value) => isArray$1(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
    const normalizeSlot = (key, rawSlot, ctx) => {
      if (rawSlot._n) {
        return rawSlot;
      }
      const normalized = withCtx((...args) => {
        if (currentInstance && (!ctx || ctx.root === currentInstance.root)) {
          warn$1(
            `Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
          );
        }
        return normalizeSlotValue(rawSlot(...args));
      }, ctx);
      normalized._c = false;
      return normalized;
    };
    const normalizeObjectSlots = (rawSlots, slots, instance) => {
      const ctx = rawSlots._ctx;
      for (const key in rawSlots) {
        if (isInternalKey(key)) continue;
        const value = rawSlots[key];
        if (isFunction$1(value)) {
          slots[key] = normalizeSlot(key, value, ctx);
        } else if (value != null) {
          if (true) {
            warn$1(
              `Non-function value encountered for slot "${key}". Prefer function slots for better performance.`
            );
          }
          const normalized = normalizeSlotValue(value);
          slots[key] = () => normalized;
        }
      }
    };
    const normalizeVNodeSlots = (instance, children) => {
      if (!isKeepAlive(instance.vnode) && true) {
        warn$1(
          `Non-function value encountered for default slot. Prefer function slots for better performance.`
        );
      }
      const normalized = normalizeSlotValue(children);
      instance.slots.default = () => normalized;
    };
    const assignSlots = (slots, children, optimized) => {
      for (const key in children) {
        if (optimized || key !== "_") {
          slots[key] = children[key];
        }
      }
    };
    const initSlots = (instance, children, optimized) => {
      const slots = instance.slots = createInternalObject();
      if (instance.vnode.shapeFlag & 32) {
        const type2 = children._;
        if (type2) {
          assignSlots(slots, children, optimized);
          if (optimized) {
            def(slots, "_", type2, true);
          }
        } else {
          normalizeObjectSlots(children, slots);
        }
      } else if (children) {
        normalizeVNodeSlots(instance, children);
      }
    };
    const updateSlots = (instance, children, optimized) => {
      const { vnode, slots } = instance;
      let needDeletionCheck = true;
      let deletionComparisonTarget = EMPTY_OBJ;
      if (vnode.shapeFlag & 32) {
        const type2 = children._;
        if (type2) {
          if (isHmrUpdating) {
            assignSlots(slots, children, optimized);
            trigger(instance, "set", "$slots");
          } else if (optimized && type2 === 1) {
            needDeletionCheck = false;
          } else {
            assignSlots(slots, children, optimized);
          }
        } else {
          needDeletionCheck = !children.$stable;
          normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
      } else if (children) {
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
      }
      if (needDeletionCheck) {
        for (const key in slots) {
          if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
            delete slots[key];
          }
        }
      }
    };
    let supported;
    let perf;
    function startMeasure(instance, type2) {
      if (instance.appContext.config.performance && isSupported()) {
        perf.mark(`vue-${type2}-${instance.uid}`);
      }
      if (true) {
        devtoolsPerfStart(instance, type2, isSupported() ? perf.now() : Date.now());
      }
    }
    function endMeasure(instance, type2) {
      if (instance.appContext.config.performance && isSupported()) {
        const startTag = `vue-${type2}-${instance.uid}`;
        const endTag = startTag + `:end`;
        perf.mark(endTag);
        perf.measure(
          `<${formatComponentName(instance, instance.type)}> ${type2}`,
          startTag,
          endTag
        );
        perf.clearMarks(startTag);
        perf.clearMarks(endTag);
      }
      if (true) {
        devtoolsPerfEnd(instance, type2, isSupported() ? perf.now() : Date.now());
      }
    }
    function isSupported() {
      if (supported !== void 0) {
        return supported;
      }
      if (typeof window !== "undefined" && window.performance) {
        supported = true;
        perf = window.performance;
      } else {
        supported = false;
      }
      return supported;
    }
    function initFeatureFlags() {
      const needWarn = [];
      if (false) {
        needWarn.push(`__VUE_OPTIONS_API__`);
        getGlobalThis().__VUE_OPTIONS_API__ = true;
      }
      if (false) {
        needWarn.push(`__VUE_PROD_DEVTOOLS__`);
        getGlobalThis().__VUE_PROD_DEVTOOLS__ = false;
      }
      if (false) {
        needWarn.push(`__VUE_PROD_HYDRATION_MISMATCH_DETAILS__`);
        getGlobalThis().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = false;
      }
      if (needWarn.length) {
        const multi = needWarn.length > 1;
        console.warn(
          `Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.
  
  For more details, see https://link.vuejs.org/feature-flags.`
        );
      }
    }
    const queuePostRenderEffect = queueEffectWithSuspense;
    function createRenderer(options) {
      return baseCreateRenderer(options);
    }
    function createHydrationRenderer(options) {
      return baseCreateRenderer(options, createHydrationFunctions);
    }
    function baseCreateRenderer(options, createHydrationFns) {
      {
        initFeatureFlags();
      }
      const target = getGlobalThis();
      target.__VUE__ = true;
      if (true) {
        setDevtoolsHook$1(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
      }
      const {
        insert: hostInsert,
        remove: hostRemove,
        patchProp: hostPatchProp,
        createElement: hostCreateElement,
        createText: hostCreateText,
        createComment: hostCreateComment,
        setText: hostSetText,
        setElementText: hostSetElementText,
        parentNode: hostParentNode,
        nextSibling: hostNextSibling,
        setScopeId: hostSetScopeId = NOOP,
        insertStaticContent: hostInsertStaticContent
      } = options;
      const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n2.dynamicChildren) => {
        if (n1 === n2) {
          return;
        }
        if (n1 && !isSameVNodeType(n1, n2)) {
          anchor = getNextHostNode(n1);
          unmount(n1, parentComponent, parentSuspense, true);
          n1 = null;
        }
        if (n2.patchFlag === -2) {
          optimized = false;
          n2.dynamicChildren = null;
        }
        const { type: type2, ref: ref3, shapeFlag } = n2;
        switch (type2) {
          case Text:
            processText(n1, n2, container, anchor);
            break;
          case Comment:
            processCommentNode(n1, n2, container, anchor);
            break;
          case Static:
            if (n1 == null) {
              mountStaticNode(n2, container, anchor, namespace);
            } else if (true) {
              patchStaticNode(n1, n2, container, namespace);
            }
            break;
          case Fragment:
            processFragment(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            break;
          default:
            if (shapeFlag & 1) {
              processElement(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 6) {
              processComponent(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 64) {
              type2.process(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized,
                internals
              );
            } else if (shapeFlag & 128) {
              type2.process(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized,
                internals
              );
            } else if (true) {
              warn$1("Invalid VNode type:", type2, `(${typeof type2})`);
            }
        }
        if (ref3 != null && parentComponent) {
          setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
        }
      };
      const processText = (n1, n2, container, anchor) => {
        if (n1 == null) {
          hostInsert(
            n2.el = hostCreateText(n2.children),
            container,
            anchor
          );
        } else {
          const el = n2.el = n1.el;
          if (n2.children !== n1.children) {
            hostSetText(el, n2.children);
          }
        }
      };
      const processCommentNode = (n1, n2, container, anchor) => {
        if (n1 == null) {
          hostInsert(
            n2.el = hostCreateComment(n2.children || ""),
            container,
            anchor
          );
        } else {
          n2.el = n1.el;
        }
      };
      const mountStaticNode = (n2, container, anchor, namespace) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(
          n2.children,
          container,
          anchor,
          namespace,
          n2.el,
          n2.anchor
        );
      };
      const patchStaticNode = (n1, n2, container, namespace) => {
        if (n2.children !== n1.children) {
          const anchor = hostNextSibling(n1.anchor);
          removeStaticNode(n1);
          [n2.el, n2.anchor] = hostInsertStaticContent(
            n2.children,
            container,
            anchor,
            namespace
          );
        } else {
          n2.el = n1.el;
          n2.anchor = n1.anchor;
        }
      };
      const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
        let next;
        while (el && el !== anchor) {
          next = hostNextSibling(el);
          hostInsert(el, container, nextSibling);
          el = next;
        }
        hostInsert(anchor, container, nextSibling);
      };
      const removeStaticNode = ({ el, anchor }) => {
        let next;
        while (el && el !== anchor) {
          next = hostNextSibling(el);
          hostRemove(el);
          el = next;
        }
        hostRemove(anchor);
      };
      const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        if (n2.type === "svg") {
          namespace = "svg";
        } else if (n2.type === "math") {
          namespace = "mathml";
        }
        if (n1 == null) {
          mountElement(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          patchElement(
            n1,
            n2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        let el;
        let vnodeHook;
        const { props, shapeFlag, transition, dirs } = vnode;
        el = vnode.el = hostCreateElement(
          vnode.type,
          namespace,
          props && props.is,
          props
        );
        if (shapeFlag & 8) {
          hostSetElementText(el, vnode.children);
        } else if (shapeFlag & 16) {
          mountChildren(
            vnode.children,
            el,
            null,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(vnode, namespace),
            slotScopeIds,
            optimized
          );
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "created");
        }
        setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        if (props) {
          for (const key in props) {
            if (key !== "value" && !isReservedProp(key)) {
              hostPatchProp(el, key, null, props[key], namespace, parentComponent);
            }
          }
          if ("value" in props) {
            hostPatchProp(el, "value", null, props.value, namespace);
          }
          if (vnodeHook = props.onVnodeBeforeMount) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
        }
        if (true) {
          def(el, "__vnode", vnode, true);
          def(el, "__vueParentComponent", parentComponent, true);
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        }
        const needCallTransitionHooks = needTransition(parentSuspense, transition);
        if (needCallTransitionHooks) {
          transition.beforeEnter(el);
        }
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
          }, parentSuspense);
        }
      };
      const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
        if (scopeId) {
          hostSetScopeId(el, scopeId);
        }
        if (slotScopeIds) {
          for (let i = 0; i < slotScopeIds.length; i++) {
            hostSetScopeId(el, slotScopeIds[i]);
          }
        }
        if (parentComponent) {
          let subTree = parentComponent.subTree;
          if (subTree.patchFlag > 0 && subTree.patchFlag & 2048) {
            subTree = filterSingleRoot(subTree.children) || subTree;
          }
          if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
            const parentVNode = parentComponent.vnode;
            setScopeId(
              el,
              parentVNode,
              parentVNode.scopeId,
              parentVNode.slotScopeIds,
              parentComponent.parent
            );
          }
        }
      };
      const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
        for (let i = start; i < children.length; i++) {
          const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
          patch(
            null,
            child,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        const el = n2.el = n1.el;
        if (true) {
          el.__vnode = n2;
        }
        let { patchFlag, dynamicChildren, dirs } = n2;
        patchFlag |= n1.patchFlag & 16;
        const oldProps = n1.props || EMPTY_OBJ;
        const newProps = n2.props || EMPTY_OBJ;
        let vnodeHook;
        parentComponent && toggleRecurse(parentComponent, false);
        if (vnodeHook = newProps.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        }
        if (dirs) {
          invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
        }
        parentComponent && toggleRecurse(parentComponent, true);
        if (isHmrUpdating) {
          patchFlag = 0;
          optimized = false;
          dynamicChildren = null;
        }
        if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
          hostSetElementText(el, "");
        }
        if (dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            el,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(n2, namespace),
            slotScopeIds
          );
          if (true) {
            traverseStaticChildren(n1, n2);
          }
        } else if (!optimized) {
          patchChildren(
            n1,
            n2,
            el,
            null,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(n2, namespace),
            slotScopeIds,
            false
          );
        }
        if (patchFlag > 0) {
          if (patchFlag & 16) {
            patchProps(el, oldProps, newProps, parentComponent, namespace);
          } else {
            if (patchFlag & 2) {
              if (oldProps.class !== newProps.class) {
                hostPatchProp(el, "class", null, newProps.class, namespace);
              }
            }
            if (patchFlag & 4) {
              hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
            }
            if (patchFlag & 8) {
              const propsToUpdate = n2.dynamicProps;
              for (let i = 0; i < propsToUpdate.length; i++) {
                const key = propsToUpdate[i];
                const prev = oldProps[key];
                const next = newProps[key];
                if (next !== prev || key === "value") {
                  hostPatchProp(el, key, prev, next, namespace, parentComponent);
                }
              }
            }
          }
          if (patchFlag & 1) {
            if (n1.children !== n2.children) {
              hostSetElementText(el, n2.children);
            }
          }
        } else if (!optimized && dynamicChildren == null) {
          patchProps(el, oldProps, newProps, parentComponent, namespace);
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
            dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
          }, parentSuspense);
        }
      };
      const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
        for (let i = 0; i < newChildren.length; i++) {
          const oldVNode = oldChildren[i];
          const newVNode = newChildren[i];
          const container = (
            // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
            // of the Fragment itself so it can move its children.
            (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
            // which also requires the correct parent container
            !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
            oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
              // In other cases, the parent container is not actually used so we
              // just pass the block element here to avoid a DOM parentNode call.
              fallbackContainer
            )
          );
          patch(
            oldVNode,
            newVNode,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            true
          );
        }
      };
      const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
        if (oldProps !== newProps) {
          if (oldProps !== EMPTY_OBJ) {
            for (const key in oldProps) {
              if (!isReservedProp(key) && !(key in newProps)) {
                hostPatchProp(
                  el,
                  key,
                  oldProps[key],
                  null,
                  namespace,
                  parentComponent
                );
              }
            }
          }
          for (const key in newProps) {
            if (isReservedProp(key)) continue;
            const next = newProps[key];
            const prev = oldProps[key];
            if (next !== prev && key !== "value") {
              hostPatchProp(el, key, prev, next, namespace, parentComponent);
            }
          }
          if ("value" in newProps) {
            hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
          }
        }
      };
      const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
        const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (
          // #5523 dev root fragment may inherit directives
          isHmrUpdating || patchFlag & 2048
        ) {
          patchFlag = 0;
          optimized = false;
          dynamicChildren = null;
        }
        if (fragmentSlotScopeIds) {
          slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        }
        if (n1 == null) {
          hostInsert(fragmentStartAnchor, container, anchor);
          hostInsert(fragmentEndAnchor, container, anchor);
          mountChildren(
            // #10007
            // such fragment like `<></>` will be compiled into
            // a fragment which doesn't have a children.
            // In this case fallback to an empty array
            n2.children || [],
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
          // of renderSlot() with no valid children
          n1.dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              container,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds
            );
            if (true) {
              traverseStaticChildren(n1, n2);
            } else if (
              // #2080 if the stable fragment has a key, it's a <template v-for> that may
              //  get moved around. Make sure all root level vnodes inherit el.
              // #2134 or if it's a component root, it may also get moved around
              // as the component is being moved.
              n2.key != null || parentComponent && n2 === parentComponent.subTree
            ) {
              traverseStaticChildren(
                n1,
                n2,
                true
                /* shallow */
              );
            }
          } else {
            patchChildren(
              n1,
              n2,
              container,
              fragmentEndAnchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        }
      };
      const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
          if (n2.shapeFlag & 512) {
            parentComponent.ctx.activate(
              n2,
              container,
              anchor,
              namespace,
              optimized
            );
          } else {
            mountComponent(
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              optimized
            );
          }
        } else {
          updateComponent(n1, n2, optimized);
        }
      };
      const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
        const instance = initialVNode.component = createComponentInstance(
          initialVNode,
          parentComponent,
          parentSuspense
        );
        if (instance.type.__hmrId) {
          registerHMR(instance);
        }
        if (true) {
          pushWarningContext(initialVNode);
          startMeasure(instance, `mount`);
        }
        if (isKeepAlive(initialVNode)) {
          instance.ctx.renderer = internals;
        }
        {
          if (true) {
            startMeasure(instance, `init`);
          }
          setupComponent(instance, false, optimized);
          if (true) {
            endMeasure(instance, `init`);
          }
        }
        if (instance.asyncDep) {
          if (isHmrUpdating) initialVNode.el = null;
          parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
          if (!initialVNode.el) {
            const placeholder = instance.subTree = createVNode(Comment);
            processCommentNode(null, placeholder, container, anchor);
          }
        } else {
          setupRenderEffect(
            instance,
            initialVNode,
            container,
            anchor,
            parentSuspense,
            namespace,
            optimized
          );
        }
        if (true) {
          popWarningContext();
          endMeasure(instance, `mount`);
        }
      };
      const updateComponent = (n1, n2, optimized) => {
        const instance = n2.component = n1.component;
        if (shouldUpdateComponent(n1, n2, optimized)) {
          if (instance.asyncDep && !instance.asyncResolved) {
            if (true) {
              pushWarningContext(n2);
            }
            updateComponentPreRender(instance, n2, optimized);
            if (true) {
              popWarningContext();
            }
            return;
          } else {
            instance.next = n2;
            instance.update();
          }
        } else {
          n2.el = n1.el;
          instance.vnode = n2;
        }
      };
      const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
        const componentUpdateFn = () => {
          if (!instance.isMounted) {
            let vnodeHook;
            const { el, props } = initialVNode;
            const { bm, m, parent, root, type: type2 } = instance;
            const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
            toggleRecurse(instance, false);
            if (bm) {
              invokeArrayFns(bm);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
              invokeVNodeHook(vnodeHook, parent, initialVNode);
            }
            toggleRecurse(instance, true);
            if (el && hydrateNode) {
              const hydrateSubTree = () => {
                if (true) {
                  startMeasure(instance, `render`);
                }
                instance.subTree = renderComponentRoot(instance);
                if (true) {
                  endMeasure(instance, `render`);
                }
                if (true) {
                  startMeasure(instance, `hydrate`);
                }
                hydrateNode(
                  el,
                  instance.subTree,
                  instance,
                  parentSuspense,
                  null
                );
                if (true) {
                  endMeasure(instance, `hydrate`);
                }
              };
              if (isAsyncWrapperVNode && type2.__asyncHydrate) {
                type2.__asyncHydrate(
                  el,
                  instance,
                  hydrateSubTree
                );
              } else {
                hydrateSubTree();
              }
            } else {
              if (root.ce) {
                root.ce._injectChildStyle(type2);
              }
              if (true) {
                startMeasure(instance, `render`);
              }
              const subTree = instance.subTree = renderComponentRoot(instance);
              if (true) {
                endMeasure(instance, `render`);
              }
              if (true) {
                startMeasure(instance, `patch`);
              }
              patch(
                null,
                subTree,
                container,
                anchor,
                instance,
                parentSuspense,
                namespace
              );
              if (true) {
                endMeasure(instance, `patch`);
              }
              initialVNode.el = subTree.el;
            }
            if (m) {
              queuePostRenderEffect(m, parentSuspense);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
              const scopedInitialVNode = initialVNode;
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
                parentSuspense
              );
            }
            if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
              instance.a && queuePostRenderEffect(instance.a, parentSuspense);
            }
            instance.isMounted = true;
            if (true) {
              devtoolsComponentAdded(instance);
            }
            initialVNode = container = anchor = null;
          } else {
            let { next, bu, u, parent, vnode } = instance;
            {
              const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
              if (nonHydratedAsyncRoot) {
                if (next) {
                  next.el = vnode.el;
                  updateComponentPreRender(instance, next, optimized);
                }
                nonHydratedAsyncRoot.asyncDep.then(() => {
                  if (!instance.isUnmounted) {
                    componentUpdateFn();
                  }
                });
                return;
              }
            }
            let originNext = next;
            let vnodeHook;
            if (true) {
              pushWarningContext(next || instance.vnode);
            }
            toggleRecurse(instance, false);
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            } else {
              next = vnode;
            }
            if (bu) {
              invokeArrayFns(bu);
            }
            if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
              invokeVNodeHook(vnodeHook, parent, next, vnode);
            }
            toggleRecurse(instance, true);
            if (true) {
              startMeasure(instance, `render`);
            }
            const nextTree = renderComponentRoot(instance);
            if (true) {
              endMeasure(instance, `render`);
            }
            const prevTree = instance.subTree;
            instance.subTree = nextTree;
            if (true) {
              startMeasure(instance, `patch`);
            }
            patch(
              prevTree,
              nextTree,
              // parent may have changed if it's in a teleport
              hostParentNode(prevTree.el),
              // anchor may have changed if it's in a fragment
              getNextHostNode(prevTree),
              instance,
              parentSuspense,
              namespace
            );
            if (true) {
              endMeasure(instance, `patch`);
            }
            next.el = nextTree.el;
            if (originNext === null) {
              updateHOCHostEl(instance, nextTree.el);
            }
            if (u) {
              queuePostRenderEffect(u, parentSuspense);
            }
            if (vnodeHook = next.props && next.props.onVnodeUpdated) {
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, next, vnode),
                parentSuspense
              );
            }
            if (true) {
              devtoolsComponentUpdated(instance);
            }
            if (true) {
              popWarningContext();
            }
          }
        };
        instance.scope.on();
        const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
        instance.scope.off();
        const update = instance.update = effect2.run.bind(effect2);
        const job = instance.job = effect2.runIfDirty.bind(effect2);
        job.i = instance;
        job.id = instance.uid;
        effect2.scheduler = () => queueJob(job);
        toggleRecurse(instance, true);
        if (true) {
          effect2.onTrack = instance.rtc ? (e) => invokeArrayFns(instance.rtc, e) : void 0;
          effect2.onTrigger = instance.rtg ? (e) => invokeArrayFns(instance.rtg, e) : void 0;
        }
        update();
      };
      const updateComponentPreRender = (instance, nextVNode, optimized) => {
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        pauseTracking();
        flushPreFlushCbs(instance);
        resetTracking();
      };
      const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        if (patchFlag > 0) {
          if (patchFlag & 128) {
            patchKeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            return;
          } else if (patchFlag & 256) {
            patchUnkeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            return;
          }
        }
        if (shapeFlag & 8) {
          if (prevShapeFlag & 16) {
            unmountChildren(c1, parentComponent, parentSuspense);
          }
          if (c2 !== c1) {
            hostSetElementText(container, c2);
          }
        } else {
          if (prevShapeFlag & 16) {
            if (shapeFlag & 16) {
              patchKeyedChildren(
                c1,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else {
              unmountChildren(c1, parentComponent, parentSuspense, true);
            }
          } else {
            if (prevShapeFlag & 8) {
              hostSetElementText(container, "");
            }
            if (shapeFlag & 16) {
              mountChildren(
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            }
          }
        }
      };
      const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        c1 = c1 || EMPTY_ARR;
        c2 = c2 || EMPTY_ARR;
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for (i = 0; i < commonLength; i++) {
          const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          patch(
            c1[i],
            nextChild,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
        if (oldLength > newLength) {
          unmountChildren(
            c1,
            parentComponent,
            parentSuspense,
            true,
            false,
            commonLength
          );
        } else {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            commonLength
          );
        }
      };
      const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        let i = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1;
        let e2 = l2 - 1;
        while (i <= e1 && i <= e2) {
          const n1 = c1[i];
          const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          if (isSameVNodeType(n1, n2)) {
            patch(
              n1,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          i++;
        }
        while (i <= e1 && i <= e2) {
          const n1 = c1[e1];
          const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
          if (isSameVNodeType(n1, n2)) {
            patch(
              n1,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          e1--;
          e2--;
        }
        if (i > e1) {
          if (i <= e2) {
            const nextPos = e2 + 1;
            const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
            while (i <= e2) {
              patch(
                null,
                c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              i++;
            }
          }
        } else if (i > e2) {
          while (i <= e1) {
            unmount(c1[i], parentComponent, parentSuspense, true);
            i++;
          }
        } else {
          const s1 = i;
          const s2 = i;
          const keyToNewIndexMap = /* @__PURE__ */ new Map();
          for (i = s2; i <= e2; i++) {
            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            if (nextChild.key != null) {
              if (keyToNewIndexMap.has(nextChild.key)) {
                warn$1(
                  `Duplicate keys found during update:`,
                  JSON.stringify(nextChild.key),
                  `Make sure keys are unique.`
                );
              }
              keyToNewIndexMap.set(nextChild.key, i);
            }
          }
          let j;
          let patched = 0;
          const toBePatched = e2 - s2 + 1;
          let moved = false;
          let maxNewIndexSoFar = 0;
          const newIndexToOldIndexMap = new Array(toBePatched);
          for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
          for (i = s1; i <= e1; i++) {
            const prevChild = c1[i];
            if (patched >= toBePatched) {
              unmount(prevChild, parentComponent, parentSuspense, true);
              continue;
            }
            let newIndex;
            if (prevChild.key != null) {
              newIndex = keyToNewIndexMap.get(prevChild.key);
            } else {
              for (j = s2; j <= e2; j++) {
                if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                  newIndex = j;
                  break;
                }
              }
            }
            if (newIndex === void 0) {
              unmount(prevChild, parentComponent, parentSuspense, true);
            } else {
              newIndexToOldIndexMap[newIndex - s2] = i + 1;
              if (newIndex >= maxNewIndexSoFar) {
                maxNewIndexSoFar = newIndex;
              } else {
                moved = true;
              }
              patch(
                prevChild,
                c2[newIndex],
                container,
                null,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              patched++;
            }
          }
          const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
          j = increasingNewIndexSequence.length - 1;
          for (i = toBePatched - 1; i >= 0; i--) {
            const nextIndex = s2 + i;
            const nextChild = c2[nextIndex];
            const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
            if (newIndexToOldIndexMap[i] === 0) {
              patch(
                null,
                nextChild,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (moved) {
              if (j < 0 || i !== increasingNewIndexSequence[j]) {
                move(nextChild, container, anchor, 2);
              } else {
                j--;
              }
            }
          }
        }
      };
      const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el, type: type2, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6) {
          move(vnode.component.subTree, container, anchor, moveType);
          return;
        }
        if (shapeFlag & 128) {
          vnode.suspense.move(container, anchor, moveType);
          return;
        }
        if (shapeFlag & 64) {
          type2.move(vnode, container, anchor, internals);
          return;
        }
        if (type2 === Fragment) {
          hostInsert(el, container, anchor);
          for (let i = 0; i < children.length; i++) {
            move(children[i], container, anchor, moveType);
          }
          hostInsert(vnode.anchor, container, anchor);
          return;
        }
        if (type2 === Static) {
          moveStaticNode(vnode, container, anchor);
          return;
        }
        const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
        if (needTransition2) {
          if (moveType === 0) {
            transition.beforeEnter(el);
            hostInsert(el, container, anchor);
            queuePostRenderEffect(() => transition.enter(el), parentSuspense);
          } else {
            const { leave, delayLeave, afterLeave } = transition;
            const remove22 = () => hostInsert(el, container, anchor);
            const performLeave = () => {
              leave(el, () => {
                remove22();
                afterLeave && afterLeave();
              });
            };
            if (delayLeave) {
              delayLeave(el, remove22, performLeave);
            } else {
              performLeave();
            }
          }
        } else {
          hostInsert(el, container, anchor);
        }
      };
      const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
        const {
          type: type2,
          props,
          ref: ref3,
          children,
          dynamicChildren,
          shapeFlag,
          patchFlag,
          dirs,
          cacheIndex
        } = vnode;
        if (patchFlag === -2) {
          optimized = false;
        }
        if (ref3 != null) {
          setRef(ref3, null, parentSuspense, vnode, true);
        }
        if (cacheIndex != null) {
          parentComponent.renderCache[cacheIndex] = void 0;
        }
        if (shapeFlag & 256) {
          parentComponent.ctx.deactivate(vnode);
          return;
        }
        const shouldInvokeDirs = shapeFlag & 1 && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6) {
          unmountComponent(vnode.component, parentSuspense, doRemove);
        } else {
          if (shapeFlag & 128) {
            vnode.suspense.unmount(parentSuspense, doRemove);
            return;
          }
          if (shouldInvokeDirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
          }
          if (shapeFlag & 64) {
            vnode.type.remove(
              vnode,
              parentComponent,
              parentSuspense,
              internals,
              doRemove
            );
          } else if (dynamicChildren && // #5154
          // when v-once is used inside a block, setBlockTracking(-1) marks the
          // parent block with hasOnce: true
          // so that it doesn't take the fast path during unmount - otherwise
          // components nested in v-once are never unmounted.
          !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
          (type2 !== Fragment || patchFlag > 0 && patchFlag & 64)) {
            unmountChildren(
              dynamicChildren,
              parentComponent,
              parentSuspense,
              false,
              true
            );
          } else if (type2 === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
            unmountChildren(children, parentComponent, parentSuspense);
          }
          if (doRemove) {
            remove2(vnode);
          }
        }
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
          }, parentSuspense);
        }
      };
      const remove2 = (vnode) => {
        const { type: type2, el, anchor, transition } = vnode;
        if (type2 === Fragment) {
          if (vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) {
            vnode.children.forEach((child) => {
              if (child.type === Comment) {
                hostRemove(child.el);
              } else {
                remove2(child);
              }
            });
          } else {
            removeFragment(el, anchor);
          }
          return;
        }
        if (type2 === Static) {
          removeStaticNode(vnode);
          return;
        }
        const performRemove = () => {
          hostRemove(el);
          if (transition && !transition.persisted && transition.afterLeave) {
            transition.afterLeave();
          }
        };
        if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
          const { leave, delayLeave } = transition;
          const performLeave = () => leave(el, performRemove);
          if (delayLeave) {
            delayLeave(vnode.el, performRemove, performLeave);
          } else {
            performLeave();
          }
        } else {
          performRemove();
        }
      };
      const removeFragment = (cur, end) => {
        let next;
        while (cur !== end) {
          next = hostNextSibling(cur);
          hostRemove(cur);
          cur = next;
        }
        hostRemove(end);
      };
      const unmountComponent = (instance, parentSuspense, doRemove) => {
        if (instance.type.__hmrId) {
          unregisterHMR(instance);
        }
        const { bum, scope: scope2, job, subTree, um, m, a } = instance;
        invalidateMount(m);
        invalidateMount(a);
        if (bum) {
          invokeArrayFns(bum);
        }
        scope2.stop();
        if (job) {
          job.flags |= 8;
          unmount(subTree, instance, parentSuspense, doRemove);
        }
        if (um) {
          queuePostRenderEffect(um, parentSuspense);
        }
        queuePostRenderEffect(() => {
          instance.isUnmounted = true;
        }, parentSuspense);
        if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0) {
            parentSuspense.resolve();
          }
        }
        if (true) {
          devtoolsComponentRemoved(instance);
        }
      };
      const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
        for (let i = start; i < children.length; i++) {
          unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
        }
      };
      const getNextHostNode = (vnode) => {
        if (vnode.shapeFlag & 6) {
          return getNextHostNode(vnode.component.subTree);
        }
        if (vnode.shapeFlag & 128) {
          return vnode.suspense.next();
        }
        const el = hostNextSibling(vnode.anchor || vnode.el);
        const teleportEnd = el && el[TeleportEndKey];
        return teleportEnd ? hostNextSibling(teleportEnd) : el;
      };
      let isFlushing = false;
      const render2 = (vnode, container, namespace) => {
        if (vnode == null) {
          if (container._vnode) {
            unmount(container._vnode, null, null, true);
          }
        } else {
          patch(
            container._vnode || null,
            vnode,
            container,
            null,
            null,
            null,
            namespace
          );
        }
        container._vnode = vnode;
        if (!isFlushing) {
          isFlushing = true;
          flushPreFlushCbs();
          flushPostFlushCbs();
          isFlushing = false;
        }
      };
      const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove2,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
      };
      let hydrate2;
      let hydrateNode;
      if (createHydrationFns) {
        [hydrate2, hydrateNode] = createHydrationFns(
          internals
        );
      }
      return {
        render: render2,
        hydrate: hydrate2,
        createApp: createAppAPI(render2, hydrate2)
      };
    }
    function resolveChildrenNamespace({ type: type2, props }, currentNamespace) {
      return currentNamespace === "svg" && type2 === "foreignObject" || currentNamespace === "mathml" && type2 === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
    }
    function toggleRecurse({ effect: effect2, job }, allowed) {
      if (allowed) {
        effect2.flags |= 32;
        job.flags |= 4;
      } else {
        effect2.flags &= ~32;
        job.flags &= ~4;
      }
    }
    function needTransition(parentSuspense, transition) {
      return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    }
    function traverseStaticChildren(n1, n2, shallow = false) {
      const ch1 = n1.children;
      const ch2 = n2.children;
      if (isArray$1(ch1) && isArray$1(ch2)) {
        for (let i = 0; i < ch1.length; i++) {
          const c1 = ch1[i];
          let c2 = ch2[i];
          if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
            if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
              c2 = ch2[i] = cloneIfMounted(ch2[i]);
              c2.el = c1.el;
            }
            if (!shallow && c2.patchFlag !== -2)
              traverseStaticChildren(c1, c2);
          }
          if (c2.type === Text) {
            c2.el = c1.el;
          }
          if (c2.type === Comment && !c2.el) {
            c2.el = c1.el;
          }
        }
      }
    }
    function getSequence(arr) {
      const p2 = arr.slice();
      const result = [0];
      let i, j, u, v, c;
      const len = arr.length;
      for (i = 0; i < len; i++) {
        const arrI = arr[i];
        if (arrI !== 0) {
          j = result[result.length - 1];
          if (arr[j] < arrI) {
            p2[i] = j;
            result.push(i);
            continue;
          }
          u = 0;
          v = result.length - 1;
          while (u < v) {
            c = u + v >> 1;
            if (arr[result[c]] < arrI) {
              u = c + 1;
            } else {
              v = c;
            }
          }
          if (arrI < arr[result[u]]) {
            if (u > 0) {
              p2[i] = result[u - 1];
            }
            result[u] = i;
          }
        }
      }
      u = result.length;
      v = result[u - 1];
      while (u-- > 0) {
        result[u] = v;
        v = p2[v];
      }
      return result;
    }
    function locateNonHydratedAsyncRoot(instance) {
      const subComponent = instance.subTree.component;
      if (subComponent) {
        if (subComponent.asyncDep && !subComponent.asyncResolved) {
          return subComponent;
        } else {
          return locateNonHydratedAsyncRoot(subComponent);
        }
      }
    }
    function invalidateMount(hooks) {
      if (hooks) {
        for (let i = 0; i < hooks.length; i++)
          hooks[i].flags |= 8;
      }
    }
    const ssrContextKey = Symbol.for("v-scx");
    const useSSRContext = () => {
      {
        const ctx = inject(ssrContextKey);
        if (!ctx) {
          warn$1(
            `Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`
          );
        }
        return ctx;
      }
    };
    function watchEffect(effect2, options) {
      return doWatch(effect2, null, options);
    }
    function watchPostEffect(effect2, options) {
      return doWatch(
        effect2,
        null,
        true ? extend({}, options, { flush: "post" }) : { flush: "post" }
      );
    }
    function watchSyncEffect(effect2, options) {
      return doWatch(
        effect2,
        null,
        true ? extend({}, options, { flush: "sync" }) : { flush: "sync" }
      );
    }
    function watch(source, cb, options) {
      if (!isFunction$1(cb)) {
        warn$1(
          `\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`
        );
      }
      return doWatch(source, cb, options);
    }
    function doWatch(source, cb, options = EMPTY_OBJ) {
      const { immediate, deep, flush, once: once2 } = options;
      if (!cb) {
        if (immediate !== void 0) {
          warn$1(
            `watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`
          );
        }
        if (deep !== void 0) {
          warn$1(
            `watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`
          );
        }
        if (once2 !== void 0) {
          warn$1(
            `watch() "once" option is only respected when using the watch(source, callback, options?) signature.`
          );
        }
      }
      const baseWatchOptions = extend({}, options);
      if (true) baseWatchOptions.onWarn = warn$1;
      const runsImmediately = cb && immediate || !cb && flush !== "post";
      let ssrCleanup;
      if (isInSSRComponentSetup) {
        if (flush === "sync") {
          const ctx = useSSRContext();
          ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
        } else if (!runsImmediately) {
          const watchStopHandle = () => {
          };
          watchStopHandle.stop = NOOP;
          watchStopHandle.resume = NOOP;
          watchStopHandle.pause = NOOP;
          return watchStopHandle;
        }
      }
      const instance = currentInstance;
      baseWatchOptions.call = (fn, type2, args) => callWithAsyncErrorHandling(fn, instance, type2, args);
      let isPre = false;
      if (flush === "post") {
        baseWatchOptions.scheduler = (job) => {
          queuePostRenderEffect(job, instance && instance.suspense);
        };
      } else if (flush !== "sync") {
        isPre = true;
        baseWatchOptions.scheduler = (job, isFirstRun) => {
          if (isFirstRun) {
            job();
          } else {
            queueJob(job);
          }
        };
      }
      baseWatchOptions.augmentJob = (job) => {
        if (cb) {
          job.flags |= 4;
        }
        if (isPre) {
          job.flags |= 2;
          if (instance) {
            job.id = instance.uid;
            job.i = instance;
          }
        }
      };
      const watchHandle = watch$1(source, cb, baseWatchOptions);
      if (isInSSRComponentSetup) {
        if (ssrCleanup) {
          ssrCleanup.push(watchHandle);
        } else if (runsImmediately) {
          watchHandle();
        }
      }
      return watchHandle;
    }
    function instanceWatch(source, value, options) {
      const publicThis = this.proxy;
      const getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
      let cb;
      if (isFunction$1(value)) {
        cb = value;
      } else {
        cb = value.handler;
        options = value;
      }
      const reset = setCurrentInstance(this);
      const res = doWatch(getter, cb.bind(publicThis), options);
      reset();
      return res;
    }
    function createPathGetter(ctx, path) {
      const segments = path.split(".");
      return () => {
        let cur = ctx;
        for (let i = 0; i < segments.length && cur; i++) {
          cur = cur[segments[i]];
        }
        return cur;
      };
    }
    function useModel(props, name, options = EMPTY_OBJ) {
      const i = getCurrentInstance();
      if (!i) {
        warn$1(`useModel() called without active instance.`);
        return ref$1();
      }
      const camelizedName = camelize(name);
      if (!i.propsOptions[0][camelizedName]) {
        warn$1(`useModel() called with prop "${name}" which is not declared.`);
        return ref$1();
      }
      const hyphenatedName = hyphenate(name);
      const modifiers = getModelModifiers(props, camelizedName);
      const res = customRef((track2, trigger2) => {
        let localValue;
        let prevSetValue = EMPTY_OBJ;
        let prevEmittedValue;
        watchSyncEffect(() => {
          const propValue = props[camelizedName];
          if (hasChanged(localValue, propValue)) {
            localValue = propValue;
            trigger2();
          }
        });
        return {
          get() {
            track2();
            return options.get ? options.get(localValue) : localValue;
          },
          set(value) {
            const emittedValue = options.set ? options.set(value) : value;
            if (!hasChanged(emittedValue, localValue) && !(prevSetValue !== EMPTY_OBJ && hasChanged(value, prevSetValue))) {
              return;
            }
            const rawProps = i.vnode.props;
            if (!(rawProps && // check if parent has passed v-model
            (name in rawProps || camelizedName in rawProps || hyphenatedName in rawProps) && (`onUpdate:${name}` in rawProps || `onUpdate:${camelizedName}` in rawProps || `onUpdate:${hyphenatedName}` in rawProps))) {
              localValue = value;
              trigger2();
            }
            i.emit(`update:${name}`, emittedValue);
            if (hasChanged(value, emittedValue) && hasChanged(value, prevSetValue) && !hasChanged(emittedValue, prevEmittedValue)) {
              trigger2();
            }
            prevSetValue = value;
            prevEmittedValue = emittedValue;
          }
        };
      });
      res[Symbol.iterator] = () => {
        let i2 = 0;
        return {
          next() {
            if (i2 < 2) {
              return { value: i2++ ? modifiers || EMPTY_OBJ : res, done: false };
            } else {
              return { done: true };
            }
          }
        };
      };
      return res;
    }
    const getModelModifiers = (props, modelName) => {
      return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
    };
    function emit(instance, event, ...rawArgs) {
      if (instance.isUnmounted) return;
      const props = instance.vnode.props || EMPTY_OBJ;
      if (true) {
        const {
          emitsOptions,
          propsOptions: [propsOptions]
        } = instance;
        if (emitsOptions) {
          if (!(event in emitsOptions) && true) {
            if (!propsOptions || !(toHandlerKey(camelize(event)) in propsOptions)) {
              warn$1(
                `Component emitted event "${event}" but it is neither declared in the emits option nor as an "${toHandlerKey(camelize(event))}" prop.`
              );
            }
          } else {
            const validator = emitsOptions[event];
            if (isFunction$1(validator)) {
              const isValid = validator(...rawArgs);
              if (!isValid) {
                warn$1(
                  `Invalid event arguments: event validation failed for event "${event}".`
                );
              }
            }
          }
        }
      }
      let args = rawArgs;
      const isModelListener2 = event.startsWith("update:");
      const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
      if (modifiers) {
        if (modifiers.trim) {
          args = rawArgs.map((a) => isString$1(a) ? a.trim() : a);
        }
        if (modifiers.number) {
          args = rawArgs.map(looseToNumber);
        }
      }
      if (true) {
        devtoolsComponentEmit(instance, event, args);
      }
      if (true) {
        const lowerCaseEvent = event.toLowerCase();
        if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {
          warn$1(
            `Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(
              instance,
              instance.type
            )} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate(
              event
            )}" instead of "${event}".`
          );
        }
      }
      let handlerName;
      let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
      props[handlerName = toHandlerKey(camelize(event))];
      if (!handler && isModelListener2) {
        handler = props[handlerName = toHandlerKey(hyphenate(event))];
      }
      if (handler) {
        callWithAsyncErrorHandling(
          handler,
          instance,
          6,
          args
        );
      }
      const onceHandler = props[handlerName + `Once`];
      if (onceHandler) {
        if (!instance.emitted) {
          instance.emitted = {};
        } else if (instance.emitted[handlerName]) {
          return;
        }
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(
          onceHandler,
          instance,
          6,
          args
        );
      }
    }
    function normalizeEmitsOptions(comp, appContext, asMixin = false) {
      const cache = appContext.emitsCache;
      const cached = cache.get(comp);
      if (cached !== void 0) {
        return cached;
      }
      const raw = comp.emits;
      let normalized = {};
      let hasExtends = false;
      if (!isFunction$1(comp)) {
        const extendEmits = (raw2) => {
          const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
          if (normalizedFromExtend) {
            hasExtends = true;
            extend(normalized, normalizedFromExtend);
          }
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendEmits);
        }
        if (comp.extends) {
          extendEmits(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendEmits);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject(comp)) {
          cache.set(comp, null);
        }
        return null;
      }
      if (isArray$1(raw)) {
        raw.forEach((key) => normalized[key] = null);
      } else {
        extend(normalized, raw);
      }
      if (isObject(comp)) {
        cache.set(comp, normalized);
      }
      return normalized;
    }
    function isEmitListener(options, key) {
      if (!options || !isOn(key)) {
        return false;
      }
      key = key.slice(2).replace(/Once$/, "");
      return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
    }
    let accessedAttrs = false;
    function markAttrsAccessed() {
      accessedAttrs = true;
    }
    function renderComponentRoot(instance) {
      const {
        type: Component,
        vnode,
        proxy,
        withProxy,
        propsOptions: [propsOptions],
        slots,
        attrs,
        emit: emit2,
        render: render2,
        renderCache,
        props,
        data,
        setupState,
        ctx,
        inheritAttrs
      } = instance;
      const prev = setCurrentRenderingInstance(instance);
      let result;
      let fallthroughAttrs;
      if (true) {
        accessedAttrs = false;
      }
      try {
        if (vnode.shapeFlag & 4) {
          const proxyToUse = withProxy || proxy;
          const thisProxy = setupState.__isScriptSetup ? new Proxy(proxyToUse, {
            get(target, key, receiver) {
              warn$1(
                `Property '${String(
                  key
                )}' was accessed via 'this'. Avoid using 'this' in templates.`
              );
              return Reflect.get(target, key, receiver);
            }
          }) : proxyToUse;
          result = normalizeVNode(
            render2.call(
              thisProxy,
              proxyToUse,
              renderCache,
              true ? shallowReadonly(props) : props,
              setupState,
              data,
              ctx
            )
          );
          fallthroughAttrs = attrs;
        } else {
          const render22 = Component;
          if (attrs === props) {
            markAttrsAccessed();
          }
          result = normalizeVNode(
            render22.length > 1 ? render22(
              true ? shallowReadonly(props) : props,
              true ? {
                get attrs() {
                  markAttrsAccessed();
                  return shallowReadonly(attrs);
                },
                slots,
                emit: emit2
              } : { attrs, slots, emit: emit2 }
            ) : render22(
              true ? shallowReadonly(props) : props,
              null
            )
          );
          fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
        }
      } catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1);
        result = createVNode(Comment);
      }
      let root = result;
      let setRoot = void 0;
      if (result.patchFlag > 0 && result.patchFlag & 2048) {
        [root, setRoot] = getChildRoot(result);
      }
      if (fallthroughAttrs && inheritAttrs !== false) {
        const keys = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root;
        if (keys.length) {
          if (shapeFlag & (1 | 6)) {
            if (propsOptions && keys.some(isModelListener)) {
              fallthroughAttrs = filterModelListeners(
                fallthroughAttrs,
                propsOptions
              );
            }
            root = cloneVNode(root, fallthroughAttrs, false, true);
          } else if (!accessedAttrs && root.type !== Comment) {
            const allAttrs = Object.keys(attrs);
            const eventAttrs = [];
            const extraAttrs = [];
            for (let i = 0, l = allAttrs.length; i < l; i++) {
              const key = allAttrs[i];
              if (isOn(key)) {
                if (!isModelListener(key)) {
                  eventAttrs.push(key[2].toLowerCase() + key.slice(3));
                }
              } else {
                extraAttrs.push(key);
              }
            }
            if (extraAttrs.length) {
              warn$1(
                `Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes.`
              );
            }
            if (eventAttrs.length) {
              warn$1(
                `Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
              );
            }
          }
        }
      }
      if (vnode.dirs) {
        if (!isElementRoot(root)) {
          warn$1(
            `Runtime directive used on component with non-element root node. The directives will not function as intended.`
          );
        }
        root = cloneVNode(root, null, false, true);
        root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
      }
      if (vnode.transition) {
        if (!isElementRoot(root)) {
          warn$1(
            `Component inside <Transition> renders non-element root node that cannot be animated.`
          );
        }
        setTransitionHooks(root, vnode.transition);
      }
      if (setRoot) {
        setRoot(root);
      } else {
        result = root;
      }
      setCurrentRenderingInstance(prev);
      return result;
    }
    const getChildRoot = (vnode) => {
      const rawChildren = vnode.children;
      const dynamicChildren = vnode.dynamicChildren;
      const childRoot = filterSingleRoot(rawChildren, false);
      if (!childRoot) {
        return [vnode, void 0];
      } else if (childRoot.patchFlag > 0 && childRoot.patchFlag & 2048) {
        return getChildRoot(childRoot);
      }
      const index = rawChildren.indexOf(childRoot);
      const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
      const setRoot = (updatedRoot) => {
        rawChildren[index] = updatedRoot;
        if (dynamicChildren) {
          if (dynamicIndex > -1) {
            dynamicChildren[dynamicIndex] = updatedRoot;
          } else if (updatedRoot.patchFlag > 0) {
            vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
          }
        }
      };
      return [normalizeVNode(childRoot), setRoot];
    };
    function filterSingleRoot(children, recurse = true) {
      let singleRoot;
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isVNode(child)) {
          if (child.type !== Comment || child.children === "v-if") {
            if (singleRoot) {
              return;
            } else {
              singleRoot = child;
              if (recurse && singleRoot.patchFlag > 0 && singleRoot.patchFlag & 2048) {
                return filterSingleRoot(singleRoot.children);
              }
            }
          }
        } else {
          return;
        }
      }
      return singleRoot;
    }
    const getFunctionalFallthrough = (attrs) => {
      let res;
      for (const key in attrs) {
        if (key === "class" || key === "style" || isOn(key)) {
          (res || (res = {}))[key] = attrs[key];
        }
      }
      return res;
    };
    const filterModelListeners = (attrs, props) => {
      const res = {};
      for (const key in attrs) {
        if (!isModelListener(key) || !(key.slice(9) in props)) {
          res[key] = attrs[key];
        }
      }
      return res;
    };
    const isElementRoot = (vnode) => {
      return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
    };
    function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
      const { props: prevProps, children: prevChildren, component } = prevVNode;
      const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
      const emits = component.emitsOptions;
      if ((prevChildren || nextChildren) && isHmrUpdating) {
        return true;
      }
      if (nextVNode.dirs || nextVNode.transition) {
        return true;
      }
      if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024) {
          return true;
        }
        if (patchFlag & 16) {
          if (!prevProps) {
            return !!nextProps;
          }
          return hasPropsChanged(prevProps, nextProps, emits);
        } else if (patchFlag & 8) {
          const dynamicProps = nextVNode.dynamicProps;
          for (let i = 0; i < dynamicProps.length; i++) {
            const key = dynamicProps[i];
            if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
              return true;
            }
          }
        }
      } else {
        if (prevChildren || nextChildren) {
          if (!nextChildren || !nextChildren.$stable) {
            return true;
          }
        }
        if (prevProps === nextProps) {
          return false;
        }
        if (!prevProps) {
          return !!nextProps;
        }
        if (!nextProps) {
          return true;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      }
      return false;
    }
    function hasPropsChanged(prevProps, nextProps, emitsOptions) {
      const nextKeys = Object.keys(nextProps);
      if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
      }
      for (let i = 0; i < nextKeys.length; i++) {
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
          return true;
        }
      }
      return false;
    }
    function updateHOCHostEl({ vnode, parent }, el) {
      while (parent) {
        const root = parent.subTree;
        if (root.suspense && root.suspense.activeBranch === vnode) {
          root.el = vnode.el;
        }
        if (root === vnode) {
          (vnode = parent.vnode).el = el;
          parent = parent.parent;
        } else {
          break;
        }
      }
    }
    const isSuspense = (type2) => type2.__isSuspense;
    let suspenseId = 0;
    const SuspenseImpl = {
      name: "Suspense",
      // In order to make Suspense tree-shakable, we need to avoid importing it
      // directly in the renderer. The renderer checks for the __isSuspense flag
      // on a vnode's type and calls the `process` method, passing in renderer
      // internals.
      __isSuspense: true,
      process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
        if (n1 == null) {
          mountSuspense(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            rendererInternals
          );
        } else {
          if (parentSuspense && parentSuspense.deps > 0 && !n1.suspense.isInFallback) {
            n2.suspense = n1.suspense;
            n2.suspense.vnode = n2;
            n2.el = n1.el;
            return;
          }
          patchSuspense(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            namespace,
            slotScopeIds,
            optimized,
            rendererInternals
          );
        }
      },
      hydrate: hydrateSuspense,
      normalize: normalizeSuspenseChildren
    };
    const Suspense = SuspenseImpl;
    function triggerEvent(vnode, name) {
      const eventListener = vnode.props && vnode.props[name];
      if (isFunction$1(eventListener)) {
        eventListener();
      }
    }
    function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
      const {
        p: patch,
        o: { createElement }
      } = rendererInternals;
      const hiddenContainer = createElement("div");
      const suspense = vnode.suspense = createSuspenseBoundary(
        vnode,
        parentSuspense,
        parentComponent,
        container,
        hiddenContainer,
        anchor,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
      patch(
        null,
        suspense.pendingBranch = vnode.ssContent,
        hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds
      );
      if (suspense.deps > 0) {
        triggerEvent(vnode, "onPending");
        triggerEvent(vnode, "onFallback");
        patch(
          null,
          vnode.ssFallback,
          container,
          anchor,
          parentComponent,
          null,
          // fallback tree will not have suspense context
          namespace,
          slotScopeIds
        );
        setActiveBranch(suspense, vnode.ssFallback);
      } else {
        suspense.resolve(false, true);
      }
    }
    function patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
      const suspense = n2.suspense = n1.suspense;
      suspense.vnode = n2;
      n2.el = n1.el;
      const newBranch = n2.ssContent;
      const newFallback = n2.ssFallback;
      const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
      if (pendingBranch) {
        suspense.pendingBranch = newBranch;
        if (isSameVNodeType(newBranch, pendingBranch)) {
          patch(
            pendingBranch,
            newBranch,
            suspense.hiddenContainer,
            null,
            parentComponent,
            suspense,
            namespace,
            slotScopeIds,
            optimized
          );
          if (suspense.deps <= 0) {
            suspense.resolve();
          } else if (isInFallback) {
            if (!isHydrating) {
              patch(
                activeBranch,
                newFallback,
                container,
                anchor,
                parentComponent,
                null,
                // fallback tree will not have suspense context
                namespace,
                slotScopeIds,
                optimized
              );
              setActiveBranch(suspense, newFallback);
            }
          }
        } else {
          suspense.pendingId = suspenseId++;
          if (isHydrating) {
            suspense.isHydrating = false;
            suspense.activeBranch = pendingBranch;
          } else {
            unmount(pendingBranch, parentComponent, suspense);
          }
          suspense.deps = 0;
          suspense.effects.length = 0;
          suspense.hiddenContainer = createElement("div");
          if (isInFallback) {
            patch(
              null,
              newBranch,
              suspense.hiddenContainer,
              null,
              parentComponent,
              suspense,
              namespace,
              slotScopeIds,
              optimized
            );
            if (suspense.deps <= 0) {
              suspense.resolve();
            } else {
              patch(
                activeBranch,
                newFallback,
                container,
                anchor,
                parentComponent,
                null,
                // fallback tree will not have suspense context
                namespace,
                slotScopeIds,
                optimized
              );
              setActiveBranch(suspense, newFallback);
            }
          } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
            patch(
              activeBranch,
              newBranch,
              container,
              anchor,
              parentComponent,
              suspense,
              namespace,
              slotScopeIds,
              optimized
            );
            suspense.resolve(true);
          } else {
            patch(
              null,
              newBranch,
              suspense.hiddenContainer,
              null,
              parentComponent,
              suspense,
              namespace,
              slotScopeIds,
              optimized
            );
            if (suspense.deps <= 0) {
              suspense.resolve();
            }
          }
        }
      } else {
        if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
          patch(
            activeBranch,
            newBranch,
            container,
            anchor,
            parentComponent,
            suspense,
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newBranch);
        } else {
          triggerEvent(n2, "onPending");
          suspense.pendingBranch = newBranch;
          if (newBranch.shapeFlag & 512) {
            suspense.pendingId = newBranch.component.suspenseId;
          } else {
            suspense.pendingId = suspenseId++;
          }
          patch(
            null,
            newBranch,
            suspense.hiddenContainer,
            null,
            parentComponent,
            suspense,
            namespace,
            slotScopeIds,
            optimized
          );
          if (suspense.deps <= 0) {
            suspense.resolve();
          } else {
            const { timeout: timeout2, pendingId } = suspense;
            if (timeout2 > 0) {
              setTimeout(() => {
                if (suspense.pendingId === pendingId) {
                  suspense.fallback(newFallback);
                }
              }, timeout2);
            } else if (timeout2 === 0) {
              suspense.fallback(newFallback);
            }
          }
        }
      }
    }
    let hasWarned = false;
    function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
      if (!hasWarned) {
        hasWarned = true;
        console[console.info ? "info" : "log"](
          `<Suspense> is an experimental feature and its API will likely change.`
        );
      }
      const {
        p: patch,
        m: move,
        um: unmount,
        n: next,
        o: { parentNode, remove: remove2 }
      } = rendererInternals;
      let parentSuspenseId;
      const isSuspensible = isVNodeSuspensible(vnode);
      if (isSuspensible) {
        if (parentSuspense && parentSuspense.pendingBranch) {
          parentSuspenseId = parentSuspense.pendingId;
          parentSuspense.deps++;
        }
      }
      const timeout2 = vnode.props ? toNumber$1(vnode.props.timeout) : void 0;
      if (true) {
        assertNumber(timeout2, `Suspense timeout`);
      }
      const initialAnchor = anchor;
      const suspense = {
        vnode,
        parent: parentSuspense,
        parentComponent,
        namespace,
        container,
        hiddenContainer,
        deps: 0,
        pendingId: suspenseId++,
        timeout: typeof timeout2 === "number" ? timeout2 : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: !isHydrating,
        isHydrating,
        isUnmounted: false,
        effects: [],
        resolve(resume = false, sync = false) {
          if (true) {
            if (!resume && !suspense.pendingBranch) {
              throw new Error(
                `suspense.resolve() is called without a pending branch.`
              );
            }
            if (suspense.isUnmounted) {
              throw new Error(
                `suspense.resolve() is called on an already unmounted suspense boundary.`
              );
            }
          }
          const {
            vnode: vnode2,
            activeBranch,
            pendingBranch,
            pendingId,
            effects,
            parentComponent: parentComponent2,
            container: container2
          } = suspense;
          let delayEnter = false;
          if (suspense.isHydrating) {
            suspense.isHydrating = false;
          } else if (!resume) {
            delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
            if (delayEnter) {
              activeBranch.transition.afterLeave = () => {
                if (pendingId === suspense.pendingId) {
                  move(
                    pendingBranch,
                    container2,
                    anchor === initialAnchor ? next(activeBranch) : anchor,
                    0
                  );
                  queuePostFlushCb(effects);
                }
              };
            }
            if (activeBranch) {
              if (parentNode(activeBranch.el) === container2) {
                anchor = next(activeBranch);
              }
              unmount(activeBranch, parentComponent2, suspense, true);
            }
            if (!delayEnter) {
              move(pendingBranch, container2, anchor, 0);
            }
          }
          setActiveBranch(suspense, pendingBranch);
          suspense.pendingBranch = null;
          suspense.isInFallback = false;
          let parent = suspense.parent;
          let hasUnresolvedAncestor = false;
          while (parent) {
            if (parent.pendingBranch) {
              parent.effects.push(...effects);
              hasUnresolvedAncestor = true;
              break;
            }
            parent = parent.parent;
          }
          if (!hasUnresolvedAncestor && !delayEnter) {
            queuePostFlushCb(effects);
          }
          suspense.effects = [];
          if (isSuspensible) {
            if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
              parentSuspense.deps--;
              if (parentSuspense.deps === 0 && !sync) {
                parentSuspense.resolve();
              }
            }
          }
          triggerEvent(vnode2, "onResolve");
        },
        fallback(fallbackVNode) {
          if (!suspense.pendingBranch) {
            return;
          }
          const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, namespace: namespace2 } = suspense;
          triggerEvent(vnode2, "onFallback");
          const anchor2 = next(activeBranch);
          const mountFallback = () => {
            if (!suspense.isInFallback) {
              return;
            }
            patch(
              null,
              fallbackVNode,
              container2,
              anchor2,
              parentComponent2,
              null,
              // fallback tree will not have suspense context
              namespace2,
              slotScopeIds,
              optimized
            );
            setActiveBranch(suspense, fallbackVNode);
          };
          const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
          if (delayEnter) {
            activeBranch.transition.afterLeave = mountFallback;
          }
          suspense.isInFallback = true;
          unmount(
            activeBranch,
            parentComponent2,
            null,
            // no suspense so unmount hooks fire now
            true
            // shouldRemove
          );
          if (!delayEnter) {
            mountFallback();
          }
        },
        move(container2, anchor2, type2) {
          suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type2);
          suspense.container = container2;
        },
        next() {
          return suspense.activeBranch && next(suspense.activeBranch);
        },
        registerDep(instance, setupRenderEffect, optimized2) {
          const isInPendingSuspense = !!suspense.pendingBranch;
          if (isInPendingSuspense) {
            suspense.deps++;
          }
          const hydratedEl = instance.vnode.el;
          instance.asyncDep.catch((err) => {
            handleError(err, instance, 0);
          }).then((asyncSetupResult) => {
            if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
              return;
            }
            instance.asyncResolved = true;
            const { vnode: vnode2 } = instance;
            if (true) {
              pushWarningContext(vnode2);
            }
            handleSetupResult(instance, asyncSetupResult, false);
            if (hydratedEl) {
              vnode2.el = hydratedEl;
            }
            const placeholder = !hydratedEl && instance.subTree.el;
            setupRenderEffect(
              instance,
              vnode2,
              // component may have been moved before resolve.
              // if this is not a hydration, instance.subTree will be the comment
              // placeholder.
              parentNode(hydratedEl || instance.subTree.el),
              // anchor will not be used if this is hydration, so only need to
              // consider the comment placeholder case.
              hydratedEl ? null : next(instance.subTree),
              suspense,
              namespace,
              optimized2
            );
            if (placeholder) {
              remove2(placeholder);
            }
            updateHOCHostEl(instance, vnode2.el);
            if (true) {
              popWarningContext();
            }
            if (isInPendingSuspense && --suspense.deps === 0) {
              suspense.resolve();
            }
          });
        },
        unmount(parentSuspense2, doRemove) {
          suspense.isUnmounted = true;
          if (suspense.activeBranch) {
            unmount(
              suspense.activeBranch,
              parentComponent,
              parentSuspense2,
              doRemove
            );
          }
          if (suspense.pendingBranch) {
            unmount(
              suspense.pendingBranch,
              parentComponent,
              parentSuspense2,
              doRemove
            );
          }
        }
      };
      return suspense;
    }
    function hydrateSuspense(node, vnode, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals, hydrateNode) {
      const suspense = vnode.suspense = createSuspenseBoundary(
        vnode,
        parentSuspense,
        parentComponent,
        node.parentNode,
        // eslint-disable-next-line no-restricted-globals
        document.createElement("div"),
        null,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals,
        true
      );
      const result = hydrateNode(
        node,
        suspense.pendingBranch = vnode.ssContent,
        parentComponent,
        suspense,
        slotScopeIds,
        optimized
      );
      if (suspense.deps === 0) {
        suspense.resolve(false, true);
      }
      return result;
    }
    function normalizeSuspenseChildren(vnode) {
      const { shapeFlag, children } = vnode;
      const isSlotChildren = shapeFlag & 32;
      vnode.ssContent = normalizeSuspenseSlot(
        isSlotChildren ? children.default : children
      );
      vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
    }
    function normalizeSuspenseSlot(s) {
      let block;
      if (isFunction$1(s)) {
        const trackBlock = isBlockTreeEnabled && s._c;
        if (trackBlock) {
          s._d = false;
          openBlock();
        }
        s = s();
        if (trackBlock) {
          s._d = true;
          block = currentBlock;
          closeBlock();
        }
      }
      if (isArray$1(s)) {
        const singleChild = filterSingleRoot(s);
        if (!singleChild && s.filter((child) => child !== NULL_DYNAMIC_COMPONENT).length > 0) {
          warn$1(`<Suspense> slots expect a single root node.`);
        }
        s = singleChild;
      }
      s = normalizeVNode(s);
      if (block && !s.dynamicChildren) {
        s.dynamicChildren = block.filter((c) => c !== s);
      }
      return s;
    }
    function queueEffectWithSuspense(fn, suspense) {
      if (suspense && suspense.pendingBranch) {
        if (isArray$1(fn)) {
          suspense.effects.push(...fn);
        } else {
          suspense.effects.push(fn);
        }
      } else {
        queuePostFlushCb(fn);
      }
    }
    function setActiveBranch(suspense, branch) {
      suspense.activeBranch = branch;
      const { vnode, parentComponent } = suspense;
      let el = branch.el;
      while (!el && branch.component) {
        branch = branch.component.subTree;
        el = branch.el;
      }
      vnode.el = el;
      if (parentComponent && parentComponent.subTree === vnode) {
        parentComponent.vnode.el = el;
        updateHOCHostEl(parentComponent, el);
      }
    }
    function isVNodeSuspensible(vnode) {
      const suspensible = vnode.props && vnode.props.suspensible;
      return suspensible != null && suspensible !== false;
    }
    const Fragment = Symbol.for("v-fgt");
    const Text = Symbol.for("v-txt");
    const Comment = Symbol.for("v-cmt");
    const Static = Symbol.for("v-stc");
    const blockStack = [];
    let currentBlock = null;
    function openBlock(disableTracking = false) {
      blockStack.push(currentBlock = disableTracking ? null : []);
    }
    function closeBlock() {
      blockStack.pop();
      currentBlock = blockStack[blockStack.length - 1] || null;
    }
    let isBlockTreeEnabled = 1;
    function setBlockTracking(value, inVOnce = false) {
      isBlockTreeEnabled += value;
      if (value < 0 && currentBlock && inVOnce) {
        currentBlock.hasOnce = true;
      }
    }
    function setupBlock(vnode) {
      vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
      closeBlock();
      if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    function createElementBlock(type2, props, children, patchFlag, dynamicProps, shapeFlag) {
      return setupBlock(
        createBaseVNode(
          type2,
          props,
          children,
          patchFlag,
          dynamicProps,
          shapeFlag,
          true
        )
      );
    }
    function createBlock(type2, props, children, patchFlag, dynamicProps) {
      return setupBlock(
        createVNode(
          type2,
          props,
          children,
          patchFlag,
          dynamicProps,
          true
        )
      );
    }
    function isVNode(value) {
      return value ? value.__v_isVNode === true : false;
    }
    function isSameVNodeType(n1, n2) {
      if (n2.shapeFlag & 6 && n1.component) {
        const dirtyInstances = hmrDirtyComponents.get(n2.type);
        if (dirtyInstances && dirtyInstances.has(n1.component)) {
          n1.shapeFlag &= ~256;
          n2.shapeFlag &= ~512;
          return false;
        }
      }
      return n1.type === n2.type && n1.key === n2.key;
    }
    let vnodeArgsTransformer;
    function transformVNodeArgs(transformer) {
      vnodeArgsTransformer = transformer;
    }
    const createVNodeWithArgsTransform = (...args) => {
      return _createVNode(
        ...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args
      );
    };
    const normalizeKey = ({ key }) => key != null ? key : null;
    const normalizeRef = ({
      ref: ref3,
      ref_key,
      ref_for
    }) => {
      if (typeof ref3 === "number") {
        ref3 = "" + ref3;
      }
      return ref3 != null ? isString$1(ref3) || isRef(ref3) || isFunction$1(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
    };
    function createBaseVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type2 === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
      const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type: type2,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetStart: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null,
        ctx: currentRenderingInstance
      };
      if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        if (shapeFlag & 128) {
          type2.normalize(vnode);
        }
      } else if (children) {
        vnode.shapeFlag |= isString$1(children) ? 8 : 16;
      }
      if (vnode.key !== vnode.key) {
        warn$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
      }
      if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
      !isBlockNode && // has current parent block
      currentBlock && // presence of a patch flag indicates this node needs patching on updates.
      // component nodes also should always be patched, because even if the
      // component doesn't need to update, it needs to persist the instance on to
      // the next vnode so that it can be properly unmounted later.
      (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
      // vnode should not be considered dynamic due to handler caching.
      vnode.patchFlag !== 32) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    const createVNode = true ? createVNodeWithArgsTransform : _createVNode;
    function _createVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
      if (!type2 || type2 === NULL_DYNAMIC_COMPONENT) {
        if (!type2) {
          warn$1(`Invalid vnode type when creating vnode: ${type2}.`);
        }
        type2 = Comment;
      }
      if (isVNode(type2)) {
        const cloned = cloneVNode(
          type2,
          props,
          true
          /* mergeRef: true */
        );
        if (children) {
          normalizeChildren(cloned, children);
        }
        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
          if (cloned.shapeFlag & 6) {
            currentBlock[currentBlock.indexOf(type2)] = cloned;
          } else {
            currentBlock.push(cloned);
          }
        }
        cloned.patchFlag = -2;
        return cloned;
      }
      if (isClassComponent(type2)) {
        type2 = type2.__vccOpts;
      }
      if (props) {
        props = guardReactiveProps(props);
        let { class: klass, style } = props;
        if (klass && !isString$1(klass)) {
          props.class = normalizeClass(klass);
        }
        if (isObject(style)) {
          if (isProxy(style) && !isArray$1(style)) {
            style = extend({}, style);
          }
          props.style = normalizeStyle(style);
        }
      }
      const shapeFlag = isString$1(type2) ? 1 : isSuspense(type2) ? 128 : isTeleport(type2) ? 64 : isObject(type2) ? 4 : isFunction$1(type2) ? 2 : 0;
      if (shapeFlag & 4 && isProxy(type2)) {
        type2 = toRaw(type2);
        warn$1(
          `Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`,
          `
  Component that was made reactive: `,
          type2
        );
      }
      return createBaseVNode(
        type2,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        isBlockNode,
        true
      );
    }
    function guardReactiveProps(props) {
      if (!props) return null;
      return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
    }
    function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
      const { props, ref: ref3, patchFlag, children, transition } = vnode;
      const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
      const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref ? (
          // #2078 in the case of <component :is="vnode" ref="extra"/>
          // if the vnode itself already has a ref, cloneVNode will need to merge
          // the refs so the single vnode can be set on multiple refs
          mergeRef && ref3 ? isArray$1(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
        ) : ref3,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children: patchFlag === -1 && isArray$1(children) ? children.map(deepCloneVNode) : children,
        target: vnode.target,
        targetStart: vnode.targetStart,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor,
        ctx: vnode.ctx,
        ce: vnode.ce
      };
      if (transition && cloneTransition) {
        setTransitionHooks(
          cloned,
          transition.clone(cloned)
        );
      }
      return cloned;
    }
    function deepCloneVNode(vnode) {
      const cloned = cloneVNode(vnode);
      if (isArray$1(vnode.children)) {
        cloned.children = vnode.children.map(deepCloneVNode);
      }
      return cloned;
    }
    function createTextVNode(text = " ", flag = 0) {
      return createVNode(Text, null, text, flag);
    }
    function createStaticVNode(content, numberOfNodes) {
      const vnode = createVNode(Static, null, content);
      vnode.staticCount = numberOfNodes;
      return vnode;
    }
    function createCommentVNode(text = "", asBlock = false) {
      return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
    }
    function normalizeVNode(child) {
      if (child == null || typeof child === "boolean") {
        return createVNode(Comment);
      } else if (isArray$1(child)) {
        return createVNode(
          Fragment,
          null,
          // #3666, avoid reference pollution when reusing vnode
          child.slice()
        );
      } else if (isVNode(child)) {
        return cloneIfMounted(child);
      } else {
        return createVNode(Text, null, String(child));
      }
    }
    function cloneIfMounted(child) {
      return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
    }
    function normalizeChildren(vnode, children) {
      let type2 = 0;
      const { shapeFlag } = vnode;
      if (children == null) {
        children = null;
      } else if (isArray$1(children)) {
        type2 = 16;
      } else if (typeof children === "object") {
        if (shapeFlag & (1 | 64)) {
          const slot = children.default;
          if (slot) {
            slot._c && (slot._d = false);
            normalizeChildren(vnode, slot());
            slot._c && (slot._d = true);
          }
          return;
        } else {
          type2 = 32;
          const slotFlag = children._;
          if (!slotFlag && !isInternalObject(children)) {
            children._ctx = currentRenderingInstance;
          } else if (slotFlag === 3 && currentRenderingInstance) {
            if (currentRenderingInstance.slots._ === 1) {
              children._ = 1;
            } else {
              children._ = 2;
              vnode.patchFlag |= 1024;
            }
          }
        }
      } else if (isFunction$1(children)) {
        children = { default: children, _ctx: currentRenderingInstance };
        type2 = 32;
      } else {
        children = String(children);
        if (shapeFlag & 64) {
          type2 = 16;
          children = [createTextVNode(children)];
        } else {
          type2 = 8;
        }
      }
      vnode.children = children;
      vnode.shapeFlag |= type2;
    }
    function mergeProps(...args) {
      const ret = {};
      for (let i = 0; i < args.length; i++) {
        const toMerge = args[i];
        for (const key in toMerge) {
          if (key === "class") {
            if (ret.class !== toMerge.class) {
              ret.class = normalizeClass([ret.class, toMerge.class]);
            }
          } else if (key === "style") {
            ret.style = normalizeStyle([ret.style, toMerge.style]);
          } else if (isOn(key)) {
            const existing = ret[key];
            const incoming = toMerge[key];
            if (incoming && existing !== incoming && !(isArray$1(existing) && existing.includes(incoming))) {
              ret[key] = existing ? [].concat(existing, incoming) : incoming;
            }
          } else if (key !== "") {
            ret[key] = toMerge[key];
          }
        }
      }
      return ret;
    }
    function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
      callWithAsyncErrorHandling(hook, instance, 7, [
        vnode,
        prevVNode
      ]);
    }
    const emptyAppContext = createAppContext();
    let uid = 0;
    function createComponentInstance(vnode, parent, suspense) {
      const type2 = vnode.type;
      const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
      const instance = {
        uid: uid++,
        vnode,
        type: type2,
        parent,
        appContext,
        root: null,
        // to be immediately set
        next: null,
        subTree: null,
        // will be set synchronously right after creation
        effect: null,
        update: null,
        // will be set synchronously right after creation
        job: null,
        scope: new EffectScope(
          true
          /* detached */
        ),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        ids: parent ? parent.ids : ["", 0, 0],
        accessCache: null,
        renderCache: [],
        // local resolved assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type2, appContext),
        emitsOptions: normalizeEmitsOptions(type2, appContext),
        // emit
        emit: null,
        // to be set immediately
        emitted: null,
        // props default value
        propsDefaults: EMPTY_OBJ,
        // inheritAttrs
        inheritAttrs: type2.inheritAttrs,
        // state
        ctx: EMPTY_OBJ,
        data: EMPTY_OBJ,
        props: EMPTY_OBJ,
        attrs: EMPTY_OBJ,
        slots: EMPTY_OBJ,
        refs: EMPTY_OBJ,
        setupState: EMPTY_OBJ,
        setupContext: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
      };
      if (true) {
        instance.ctx = createDevRenderContext(instance);
      } else {
        instance.ctx = { _: instance };
      }
      instance.root = parent ? parent.root : instance;
      instance.emit = emit.bind(null, instance);
      if (vnode.ce) {
        vnode.ce(instance);
      }
      return instance;
    }
    let currentInstance = null;
    const getCurrentInstance = () => currentInstance || currentRenderingInstance;
    let internalSetCurrentInstance;
    let setInSSRSetupState;
    {
      const g = getGlobalThis();
      const registerGlobalSetter = (key, setter) => {
        let setters;
        if (!(setters = g[key])) setters = g[key] = [];
        setters.push(setter);
        return (v) => {
          if (setters.length > 1) setters.forEach((set) => set(v));
          else setters[0](v);
        };
      };
      internalSetCurrentInstance = registerGlobalSetter(
        `__VUE_INSTANCE_SETTERS__`,
        (v) => currentInstance = v
      );
      setInSSRSetupState = registerGlobalSetter(
        `__VUE_SSR_SETTERS__`,
        (v) => isInSSRComponentSetup = v
      );
    }
    const setCurrentInstance = (instance) => {
      const prev = currentInstance;
      internalSetCurrentInstance(instance);
      instance.scope.on();
      return () => {
        instance.scope.off();
        internalSetCurrentInstance(prev);
      };
    };
    const unsetCurrentInstance = () => {
      currentInstance && currentInstance.scope.off();
      internalSetCurrentInstance(null);
    };
    const isBuiltInTag = /* @__PURE__ */ makeMap("slot,component");
    function validateComponentName(name, { isNativeTag }) {
      if (isBuiltInTag(name) || isNativeTag(name)) {
        warn$1(
          "Do not use built-in or reserved HTML elements as component id: " + name
        );
      }
    }
    function isStatefulComponent(instance) {
      return instance.vnode.shapeFlag & 4;
    }
    let isInSSRComponentSetup = false;
    function setupComponent(instance, isSSR = false, optimized = false) {
      isSSR && setInSSRSetupState(isSSR);
      const { props, children } = instance.vnode;
      const isStateful = isStatefulComponent(instance);
      initProps(instance, props, isStateful, isSSR);
      initSlots(instance, children, optimized);
      const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
      isSSR && setInSSRSetupState(false);
      return setupResult;
    }
    function setupStatefulComponent(instance, isSSR) {
      var _a;
      const Component = instance.type;
      if (true) {
        if (Component.name) {
          validateComponentName(Component.name, instance.appContext.config);
        }
        if (Component.components) {
          const names2 = Object.keys(Component.components);
          for (let i = 0; i < names2.length; i++) {
            validateComponentName(names2[i], instance.appContext.config);
          }
        }
        if (Component.directives) {
          const names2 = Object.keys(Component.directives);
          for (let i = 0; i < names2.length; i++) {
            validateDirectiveName(names2[i]);
          }
        }
        if (Component.compilerOptions && isRuntimeOnly()) {
          warn$1(
            `"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`
          );
        }
      }
      instance.accessCache = /* @__PURE__ */ Object.create(null);
      instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
      if (true) {
        exposePropsOnRenderContext(instance);
      }
      const { setup } = Component;
      if (setup) {
        pauseTracking();
        const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
        const reset = setCurrentInstance(instance);
        const setupResult = callWithErrorHandling(
          setup,
          instance,
          0,
          [
            true ? shallowReadonly(instance.props) : instance.props,
            setupContext
          ]
        );
        const isAsyncSetup = isPromise$1(setupResult);
        resetTracking();
        reset();
        if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
          markAsyncBoundary(instance);
        }
        if (isAsyncSetup) {
          setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
          if (isSSR) {
            return setupResult.then((resolvedResult) => {
              handleSetupResult(instance, resolvedResult, isSSR);
            }).catch((e) => {
              handleError(e, instance, 0);
            });
          } else {
            instance.asyncDep = setupResult;
            if (!instance.suspense) {
              const name = (_a = Component.name) != null ? _a : "Anonymous";
              warn$1(
                `Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
              );
            }
          }
        } else {
          handleSetupResult(instance, setupResult, isSSR);
        }
      } else {
        finishComponentSetup(instance, isSSR);
      }
    }
    function handleSetupResult(instance, setupResult, isSSR) {
      if (isFunction$1(setupResult)) {
        if (instance.type.__ssrInlineRender) {
          instance.ssrRender = setupResult;
        } else {
          instance.render = setupResult;
        }
      } else if (isObject(setupResult)) {
        if (isVNode(setupResult)) {
          warn$1(
            `setup() should not return VNodes directly - return a render function instead.`
          );
        }
        if (true) {
          instance.devtoolsRawSetupState = setupResult;
        }
        instance.setupState = proxyRefs(setupResult);
        if (true) {
          exposeSetupStateOnRenderContext(instance);
        }
      } else if (setupResult !== void 0) {
        warn$1(
          `setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`
        );
      }
      finishComponentSetup(instance, isSSR);
    }
    let compile$2;
    let installWithProxy;
    function registerRuntimeCompiler(_compile) {
      compile$2 = _compile;
      installWithProxy = (i) => {
        if (i.render._rc) {
          i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
        }
      };
    }
    const isRuntimeOnly = () => !compile$2;
    function finishComponentSetup(instance, isSSR, skipOptions) {
      const Component = instance.type;
      if (!instance.render) {
        if (!isSSR && compile$2 && !Component.render) {
          const template = Component.template || resolveMergedOptions(instance).template;
          if (template) {
            if (true) {
              startMeasure(instance, `compile`);
            }
            const { isCustomElement, compilerOptions } = instance.appContext.config;
            const { delimiters, compilerOptions: componentCompilerOptions } = Component;
            const finalCompilerOptions = extend(
              extend(
                {
                  isCustomElement,
                  delimiters
                },
                compilerOptions
              ),
              componentCompilerOptions
            );
            Component.render = compile$2(template, finalCompilerOptions);
            if (true) {
              endMeasure(instance, `compile`);
            }
          }
        }
        instance.render = Component.render || NOOP;
        if (installWithProxy) {
          installWithProxy(instance);
        }
      }
      if (true) {
        const reset = setCurrentInstance(instance);
        pauseTracking();
        try {
          applyOptions(instance);
        } finally {
          resetTracking();
          reset();
        }
      }
      if (!Component.render && instance.render === NOOP && !isSSR) {
        if (!compile$2 && Component.template) {
          warn$1(
            `Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
          );
        } else {
          warn$1(`Component is missing template or render function: `, Component);
        }
      }
    }
    const attrsProxyHandlers = true ? {
      get(target, key) {
        markAttrsAccessed();
        track(target, "get", "");
        return target[key];
      },
      set() {
        warn$1(`setupContext.attrs is readonly.`);
        return false;
      },
      deleteProperty() {
        warn$1(`setupContext.attrs is readonly.`);
        return false;
      }
    } : {
      get(target, key) {
        track(target, "get", "");
        return target[key];
      }
    };
    function getSlotsProxy(instance) {
      return new Proxy(instance.slots, {
        get(target, key) {
          track(instance, "get", "$slots");
          return target[key];
        }
      });
    }
    function createSetupContext(instance) {
      const expose = (exposed) => {
        if (true) {
          if (instance.exposed) {
            warn$1(`expose() should be called only once per setup().`);
          }
          if (exposed != null) {
            let exposedType = typeof exposed;
            if (exposedType === "object") {
              if (isArray$1(exposed)) {
                exposedType = "array";
              } else if (isRef(exposed)) {
                exposedType = "ref";
              }
            }
            if (exposedType !== "object") {
              warn$1(
                `expose() should be passed a plain object, received ${exposedType}.`
              );
            }
          }
        }
        instance.exposed = exposed || {};
      };
      if (true) {
        let attrsProxy;
        let slotsProxy;
        return Object.freeze({
          get attrs() {
            return attrsProxy || (attrsProxy = new Proxy(instance.attrs, attrsProxyHandlers));
          },
          get slots() {
            return slotsProxy || (slotsProxy = getSlotsProxy(instance));
          },
          get emit() {
            return (event, ...args) => instance.emit(event, ...args);
          },
          expose
        });
      } else {
        return {
          attrs: new Proxy(instance.attrs, attrsProxyHandlers),
          slots: instance.slots,
          emit: instance.emit,
          expose
        };
      }
    }
    function getComponentPublicInstance(instance) {
      if (instance.exposed) {
        return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
          get(target, key) {
            if (key in target) {
              return target[key];
            } else if (key in publicPropertiesMap) {
              return publicPropertiesMap[key](instance);
            }
          },
          has(target, key) {
            return key in target || key in publicPropertiesMap;
          }
        }));
      } else {
        return instance.proxy;
      }
    }
    const classifyRE = /(?:^|[-_])(\w)/g;
    const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
    function getComponentName(Component, includeInferred = true) {
      return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
    }
    function formatComponentName(instance, Component, isRoot = false) {
      let name = getComponentName(Component);
      if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) {
          name = match[1];
        }
      }
      if (!name && instance && instance.parent) {
        const inferFromRegistry = (registry) => {
          for (const key in registry) {
            if (registry[key] === Component) {
              return key;
            }
          }
        };
        name = inferFromRegistry(
          instance.components || instance.parent.type.components
        ) || inferFromRegistry(instance.appContext.components);
      }
      return name ? classify(name) : isRoot ? `App` : `Anonymous`;
    }
    function isClassComponent(value) {
      return isFunction$1(value) && "__vccOpts" in value;
    }
    const computed = (getterOrOptions, debugOptions) => {
      const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
      if (true) {
        const i = getCurrentInstance();
        if (i && i.appContext.config.warnRecursiveComputed) {
          c._warnRecursive = true;
        }
      }
      return c;
    };
    function h(type2, propsOrChildren, children) {
      const l = arguments.length;
      if (l === 2) {
        if (isObject(propsOrChildren) && !isArray$1(propsOrChildren)) {
          if (isVNode(propsOrChildren)) {
            return createVNode(type2, null, [propsOrChildren]);
          }
          return createVNode(type2, propsOrChildren);
        } else {
          return createVNode(type2, null, propsOrChildren);
        }
      } else {
        if (l > 3) {
          children = Array.prototype.slice.call(arguments, 2);
        } else if (l === 3 && isVNode(children)) {
          children = [children];
        }
        return createVNode(type2, propsOrChildren, children);
      }
    }
    function initCustomFormatter() {
      if (typeof window === "undefined") {
        return;
      }
      const vueStyle = { style: "color:#3ba776" };
      const numberStyle = { style: "color:#1677ff" };
      const stringStyle = { style: "color:#f5222d" };
      const keywordStyle = { style: "color:#eb2f96" };
      const formatter = {
        __vue_custom_formatter: true,
        header(obj) {
          if (!isObject(obj)) {
            return null;
          }
          if (obj.__isVue) {
            return ["div", vueStyle, `VueInstance`];
          } else if (isRef(obj)) {
            return [
              "div",
              {},
              ["span", vueStyle, genRefFlag(obj)],
              "<",
              // avoid debugger accessing value affecting behavior
              formatValue("_value" in obj ? obj._value : obj),
              `>`
            ];
          } else if (isReactive(obj)) {
            return [
              "div",
              {},
              ["span", vueStyle, isShallow(obj) ? "ShallowReactive" : "Reactive"],
              "<",
              formatValue(obj),
              `>${isReadonly(obj) ? ` (readonly)` : ``}`
            ];
          } else if (isReadonly(obj)) {
            return [
              "div",
              {},
              ["span", vueStyle, isShallow(obj) ? "ShallowReadonly" : "Readonly"],
              "<",
              formatValue(obj),
              ">"
            ];
          }
          return null;
        },
        hasBody(obj) {
          return obj && obj.__isVue;
        },
        body(obj) {
          if (obj && obj.__isVue) {
            return [
              "div",
              {},
              ...formatInstance(obj.$)
            ];
          }
        }
      };
      function formatInstance(instance) {
        const blocks = [];
        if (instance.type.props && instance.props) {
          blocks.push(createInstanceBlock("props", toRaw(instance.props)));
        }
        if (instance.setupState !== EMPTY_OBJ) {
          blocks.push(createInstanceBlock("setup", instance.setupState));
        }
        if (instance.data !== EMPTY_OBJ) {
          blocks.push(createInstanceBlock("data", toRaw(instance.data)));
        }
        const computed2 = extractKeys(instance, "computed");
        if (computed2) {
          blocks.push(createInstanceBlock("computed", computed2));
        }
        const injected = extractKeys(instance, "inject");
        if (injected) {
          blocks.push(createInstanceBlock("injected", injected));
        }
        blocks.push([
          "div",
          {},
          [
            "span",
            {
              style: keywordStyle.style + ";opacity:0.66"
            },
            "$ (internal): "
          ],
          ["object", { object: instance }]
        ]);
        return blocks;
      }
      function createInstanceBlock(type2, target) {
        target = extend({}, target);
        if (!Object.keys(target).length) {
          return ["span", {}];
        }
        return [
          "div",
          { style: "line-height:1.25em;margin-bottom:0.6em" },
          [
            "div",
            {
              style: "color:#476582"
            },
            type2
          ],
          [
            "div",
            {
              style: "padding-left:1.25em"
            },
            ...Object.keys(target).map((key) => {
              return [
                "div",
                {},
                ["span", keywordStyle, key + ": "],
                formatValue(target[key], false)
              ];
            })
          ]
        ];
      }
      function formatValue(v, asRaw = true) {
        if (typeof v === "number") {
          return ["span", numberStyle, v];
        } else if (typeof v === "string") {
          return ["span", stringStyle, JSON.stringify(v)];
        } else if (typeof v === "boolean") {
          return ["span", keywordStyle, v];
        } else if (isObject(v)) {
          return ["object", { object: asRaw ? toRaw(v) : v }];
        } else {
          return ["span", stringStyle, String(v)];
        }
      }
      function extractKeys(instance, type2) {
        const Comp = instance.type;
        if (isFunction$1(Comp)) {
          return;
        }
        const extracted = {};
        for (const key in instance.ctx) {
          if (isKeyOfType(Comp, key, type2)) {
            extracted[key] = instance.ctx[key];
          }
        }
        return extracted;
      }
      function isKeyOfType(Comp, key, type2) {
        const opts = Comp[type2];
        if (isArray$1(opts) && opts.includes(key) || isObject(opts) && key in opts) {
          return true;
        }
        if (Comp.extends && isKeyOfType(Comp.extends, key, type2)) {
          return true;
        }
        if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key, type2))) {
          return true;
        }
      }
      function genRefFlag(v) {
        if (isShallow(v)) {
          return `ShallowRef`;
        }
        if (v.effect) {
          return `ComputedRef`;
        }
        return `Ref`;
      }
      if (window.devtoolsFormatters) {
        window.devtoolsFormatters.push(formatter);
      } else {
        window.devtoolsFormatters = [formatter];
      }
    }
    function withMemo(memo, render2, cache, index) {
      const cached = cache[index];
      if (cached && isMemoSame(cached, memo)) {
        return cached;
      }
      const ret = render2();
      ret.memo = memo.slice();
      ret.cacheIndex = index;
      return cache[index] = ret;
    }
    function isMemoSame(cached, memo) {
      const prev = cached.memo;
      if (prev.length != memo.length) {
        return false;
      }
      for (let i = 0; i < prev.length; i++) {
        if (hasChanged(prev[i], memo[i])) {
          return false;
        }
      }
      if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(cached);
      }
      return true;
    }
    const version = "3.5.13";
    const warn = true ? warn$1 : NOOP;
    const ErrorTypeStrings = ErrorTypeStrings$1;
    const devtools = true ? devtools$1 : void 0;
    const setDevtoolsHook = true ? setDevtoolsHook$1 : NOOP;
    const _ssrUtils = {
      createComponentInstance,
      setupComponent,
      renderComponentRoot,
      setCurrentRenderingInstance,
      isVNode,
      normalizeVNode,
      getComponentPublicInstance,
      ensureValidVNode,
      pushWarningContext,
      popWarningContext
    };
    const ssrUtils = _ssrUtils;
    const resolveFilter = null;
    const compatUtils = null;
    const DeprecationTypes = null;
    /**
    * @vue/runtime-dom v3.5.13
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    let policy = void 0;
    const tt = typeof window !== "undefined" && window.trustedTypes;
    if (tt) {
      try {
        policy = /* @__PURE__ */ tt.createPolicy("vue", {
          createHTML: (val) => val
        });
      } catch (e) {
        warn(`Error creating trusted types policy: ${e}`);
      }
    }
    const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
    const svgNS = "http://www.w3.org/2000/svg";
    const mathmlNS = "http://www.w3.org/1998/Math/MathML";
    const doc = typeof document !== "undefined" ? document : null;
    const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
    const nodeOps = {
      insert: (child, parent, anchor) => {
        parent.insertBefore(child, anchor || null);
      },
      remove: (child) => {
        const parent = child.parentNode;
        if (parent) {
          parent.removeChild(child);
        }
      },
      createElement: (tag, namespace, is, props) => {
        const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
        if (tag === "select" && props && props.multiple != null) {
          el.setAttribute("multiple", props.multiple);
        }
        return el;
      },
      createText: (text) => doc.createTextNode(text),
      createComment: (text) => doc.createComment(text),
      setText: (node, text) => {
        node.nodeValue = text;
      },
      setElementText: (el, text) => {
        el.textContent = text;
      },
      parentNode: (node) => node.parentNode,
      nextSibling: (node) => node.nextSibling,
      querySelector: (selector) => doc.querySelector(selector),
      setScopeId(el, id2) {
        el.setAttribute(id2, "");
      },
      // __UNSAFE__
      // Reason: innerHTML.
      // Static content here can only come from compiled templates.
      // As long as the user only uses trusted templates, this is safe.
      insertStaticContent(content, parent, anchor, namespace, start, end) {
        const before2 = anchor ? anchor.previousSibling : parent.lastChild;
        if (start && (start === end || start.nextSibling)) {
          while (true) {
            parent.insertBefore(start.cloneNode(true), anchor);
            if (start === end || !(start = start.nextSibling)) break;
          }
        } else {
          templateContainer.innerHTML = unsafeToTrustedHTML(
            namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
          );
          const template = templateContainer.content;
          if (namespace === "svg" || namespace === "mathml") {
            const wrapper = template.firstChild;
            while (wrapper.firstChild) {
              template.appendChild(wrapper.firstChild);
            }
            template.removeChild(wrapper);
          }
          parent.insertBefore(template, anchor);
        }
        return [
          // first
          before2 ? before2.nextSibling : parent.firstChild,
          // last
          anchor ? anchor.previousSibling : parent.lastChild
        ];
      }
    };
    const TRANSITION = "transition";
    const ANIMATION = "animation";
    const vtcKey = Symbol("_vtc");
    const DOMTransitionPropsValidators = {
      name: String,
      type: String,
      css: {
        type: Boolean,
        default: true
      },
      duration: [String, Number, Object],
      enterFromClass: String,
      enterActiveClass: String,
      enterToClass: String,
      appearFromClass: String,
      appearActiveClass: String,
      appearToClass: String,
      leaveFromClass: String,
      leaveActiveClass: String,
      leaveToClass: String
    };
    const TransitionPropsValidators = /* @__PURE__ */ extend(
      {},
      BaseTransitionPropsValidators,
      DOMTransitionPropsValidators
    );
    const decorate$1 = (t) => {
      t.displayName = "Transition";
      t.props = TransitionPropsValidators;
      return t;
    };
    const Transition = /* @__PURE__ */ decorate$1(
      (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots)
    );
    const callHook = (hook, args = []) => {
      if (isArray$1(hook)) {
        hook.forEach((h2) => h2(...args));
      } else if (hook) {
        hook(...args);
      }
    };
    const hasExplicitCallback = (hook) => {
      return hook ? isArray$1(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
    };
    function resolveTransitionProps(rawProps) {
      const baseProps = {};
      for (const key in rawProps) {
        if (!(key in DOMTransitionPropsValidators)) {
          baseProps[key] = rawProps[key];
        }
      }
      if (rawProps.css === false) {
        return baseProps;
      }
      const {
        name = "v",
        type: type2,
        duration,
        enterFromClass = `${name}-enter-from`,
        enterActiveClass = `${name}-enter-active`,
        enterToClass = `${name}-enter-to`,
        appearFromClass = enterFromClass,
        appearActiveClass = enterActiveClass,
        appearToClass = enterToClass,
        leaveFromClass = `${name}-leave-from`,
        leaveActiveClass = `${name}-leave-active`,
        leaveToClass = `${name}-leave-to`
      } = rawProps;
      const durations = normalizeDuration(duration);
      const enterDuration = durations && durations[0];
      const leaveDuration = durations && durations[1];
      const {
        onBeforeEnter,
        onEnter,
        onEnterCancelled,
        onLeave,
        onLeaveCancelled,
        onBeforeAppear = onBeforeEnter,
        onAppear = onEnter,
        onAppearCancelled = onEnterCancelled
      } = baseProps;
      const finishEnter = (el, isAppear, done, isCancelled) => {
        el._enterCancelled = isCancelled;
        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
      };
      const finishLeave = (el, done) => {
        el._isLeaving = false;
        removeTransitionClass(el, leaveFromClass);
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
        done && done();
      };
      const makeEnterHook = (isAppear) => {
        return (el, done) => {
          const hook = isAppear ? onAppear : onEnter;
          const resolve2 = () => finishEnter(el, isAppear, done);
          callHook(hook, [el, resolve2]);
          nextFrame(() => {
            removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
            addTransitionClass(el, isAppear ? appearToClass : enterToClass);
            if (!hasExplicitCallback(hook)) {
              whenTransitionEnds(el, type2, enterDuration, resolve2);
            }
          });
        };
      };
      return extend(baseProps, {
        onBeforeEnter(el) {
          callHook(onBeforeEnter, [el]);
          addTransitionClass(el, enterFromClass);
          addTransitionClass(el, enterActiveClass);
        },
        onBeforeAppear(el) {
          callHook(onBeforeAppear, [el]);
          addTransitionClass(el, appearFromClass);
          addTransitionClass(el, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave(el, done) {
          el._isLeaving = true;
          const resolve2 = () => finishLeave(el, done);
          addTransitionClass(el, leaveFromClass);
          if (!el._enterCancelled) {
            forceReflow();
            addTransitionClass(el, leaveActiveClass);
          } else {
            addTransitionClass(el, leaveActiveClass);
            forceReflow();
          }
          nextFrame(() => {
            if (!el._isLeaving) {
              return;
            }
            removeTransitionClass(el, leaveFromClass);
            addTransitionClass(el, leaveToClass);
            if (!hasExplicitCallback(onLeave)) {
              whenTransitionEnds(el, type2, leaveDuration, resolve2);
            }
          });
          callHook(onLeave, [el, resolve2]);
        },
        onEnterCancelled(el) {
          finishEnter(el, false, void 0, true);
          callHook(onEnterCancelled, [el]);
        },
        onAppearCancelled(el) {
          finishEnter(el, true, void 0, true);
          callHook(onAppearCancelled, [el]);
        },
        onLeaveCancelled(el) {
          finishLeave(el);
          callHook(onLeaveCancelled, [el]);
        }
      });
    }
    function normalizeDuration(duration) {
      if (duration == null) {
        return null;
      } else if (isObject(duration)) {
        return [NumberOf(duration.enter), NumberOf(duration.leave)];
      } else {
        const n = NumberOf(duration);
        return [n, n];
      }
    }
    function NumberOf(val) {
      const res = toNumber$1(val);
      if (true) {
        assertNumber(res, "<transition> explicit duration");
      }
      return res;
    }
    function addTransitionClass(el, cls) {
      cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
      (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
    }
    function removeTransitionClass(el, cls) {
      cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
      const _vtc = el[vtcKey];
      if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) {
          el[vtcKey] = void 0;
        }
      }
    }
    function nextFrame(cb) {
      requestAnimationFrame(() => {
        requestAnimationFrame(cb);
      });
    }
    let endId = 0;
    function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
      const id2 = el._endId = ++endId;
      const resolveIfNotStale = () => {
        if (id2 === el._endId) {
          resolve2();
        }
      };
      if (explicitTimeout != null) {
        return setTimeout(resolveIfNotStale, explicitTimeout);
      }
      const { type: type2, timeout: timeout2, propCount } = getTransitionInfo(el, expectedType);
      if (!type2) {
        return resolve2();
      }
      const endEvent = type2 + "end";
      let ended = 0;
      const end = () => {
        el.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
      };
      const onEnd = (e) => {
        if (e.target === el && ++ended >= propCount) {
          end();
        }
      };
      setTimeout(() => {
        if (ended < propCount) {
          end();
        }
      }, timeout2 + 1);
      el.addEventListener(endEvent, onEnd);
    }
    function getTransitionInfo(el, expectedType) {
      const styles = window.getComputedStyle(el);
      const getStyleProperties = (key) => (styles[key] || "").split(", ");
      const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
      const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
      const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
      const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
      const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
      const animationTimeout = getTimeout(animationDelays, animationDurations);
      let type2 = null;
      let timeout2 = 0;
      let propCount = 0;
      if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
          type2 = TRANSITION;
          timeout2 = transitionTimeout;
          propCount = transitionDurations.length;
        }
      } else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
          type2 = ANIMATION;
          timeout2 = animationTimeout;
          propCount = animationDurations.length;
        }
      } else {
        timeout2 = Math.max(transitionTimeout, animationTimeout);
        type2 = timeout2 > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
        propCount = type2 ? type2 === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
      }
      const hasTransform = type2 === TRANSITION && /\b(transform|all)(,|$)/.test(
        getStyleProperties(`${TRANSITION}Property`).toString()
      );
      return {
        type: type2,
        timeout: timeout2,
        propCount,
        hasTransform
      };
    }
    function getTimeout(delays, durations) {
      while (delays.length < durations.length) {
        delays = delays.concat(delays);
      }
      return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
    }
    function toMs(s) {
      if (s === "auto") return 0;
      return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
    }
    function forceReflow() {
      return document.body.offsetHeight;
    }
    function patchClass(el, value, isSVG) {
      const transitionClasses = el[vtcKey];
      if (transitionClasses) {
        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
      }
      if (value == null) {
        el.removeAttribute("class");
      } else if (isSVG) {
        el.setAttribute("class", value);
      } else {
        el.className = value;
      }
    }
    const vShowOriginalDisplay = Symbol("_vod");
    const vShowHidden = Symbol("_vsh");
    const vShow = {
      beforeMount(el, { value }, { transition }) {
        el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
        if (transition && value) {
          transition.beforeEnter(el);
        } else {
          setDisplay(el, value);
        }
      },
      mounted(el, { value }, { transition }) {
        if (transition && value) {
          transition.enter(el);
        }
      },
      updated(el, { value, oldValue }, { transition }) {
        if (!value === !oldValue) return;
        if (transition) {
          if (value) {
            transition.beforeEnter(el);
            setDisplay(el, true);
            transition.enter(el);
          } else {
            transition.leave(el, () => {
              setDisplay(el, false);
            });
          }
        } else {
          setDisplay(el, value);
        }
      },
      beforeUnmount(el, { value }) {
        setDisplay(el, value);
      }
    };
    if (true) {
      vShow.name = "show";
    }
    function setDisplay(el, value) {
      el.style.display = value ? el[vShowOriginalDisplay] : "none";
      el[vShowHidden] = !value;
    }
    function initVShowForSSR() {
      vShow.getSSRProps = ({ value }) => {
        if (!value) {
          return { style: { display: "none" } };
        }
      };
    }
    const CSS_VAR_TEXT = Symbol(true ? "CSS_VAR_TEXT" : "");
    function useCssVars(getter) {
      const instance = getCurrentInstance();
      if (!instance) {
        warn(`useCssVars is called without current active component instance.`);
        return;
      }
      const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
        Array.from(
          document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)
        ).forEach((node) => setVarsOnNode(node, vars));
      };
      if (true) {
        instance.getCssVars = () => getter(instance.proxy);
      }
      const setVars = () => {
        const vars = getter(instance.proxy);
        if (instance.ce) {
          setVarsOnNode(instance.ce, vars);
        } else {
          setVarsOnVNode(instance.subTree, vars);
        }
        updateTeleports(vars);
      };
      onBeforeUpdate(() => {
        queuePostFlushCb(setVars);
      });
      onMounted(() => {
        watch(setVars, NOOP, { flush: "post" });
        const ob = new MutationObserver(setVars);
        ob.observe(instance.subTree.el.parentNode, { childList: true });
        onUnmounted(() => ob.disconnect());
      });
    }
    function setVarsOnVNode(vnode, vars) {
      if (vnode.shapeFlag & 128) {
        const suspense = vnode.suspense;
        vnode = suspense.activeBranch;
        if (suspense.pendingBranch && !suspense.isHydrating) {
          suspense.effects.push(() => {
            setVarsOnVNode(suspense.activeBranch, vars);
          });
        }
      }
      while (vnode.component) {
        vnode = vnode.component.subTree;
      }
      if (vnode.shapeFlag & 1 && vnode.el) {
        setVarsOnNode(vnode.el, vars);
      } else if (vnode.type === Fragment) {
        vnode.children.forEach((c) => setVarsOnVNode(c, vars));
      } else if (vnode.type === Static) {
        let { el, anchor } = vnode;
        while (el) {
          setVarsOnNode(el, vars);
          if (el === anchor) break;
          el = el.nextSibling;
        }
      }
    }
    function setVarsOnNode(el, vars) {
      if (el.nodeType === 1) {
        const style = el.style;
        let cssText = "";
        for (const key in vars) {
          style.setProperty(`--${key}`, vars[key]);
          cssText += `--${key}: ${vars[key]};`;
        }
        style[CSS_VAR_TEXT] = cssText;
      }
    }
    const displayRE = /(^|;)\s*display\s*:/;
    function patchStyle(el, prev, next) {
      const style = el.style;
      const isCssString = isString$1(next);
      let hasControlledDisplay = false;
      if (next && !isCssString) {
        if (prev) {
          if (!isString$1(prev)) {
            for (const key in prev) {
              if (next[key] == null) {
                setStyle(style, key, "");
              }
            }
          } else {
            for (const prevStyle of prev.split(";")) {
              const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
              if (next[key] == null) {
                setStyle(style, key, "");
              }
            }
          }
        }
        for (const key in next) {
          if (key === "display") {
            hasControlledDisplay = true;
          }
          setStyle(style, key, next[key]);
        }
      } else {
        if (isCssString) {
          if (prev !== next) {
            const cssVarText = style[CSS_VAR_TEXT];
            if (cssVarText) {
              next += ";" + cssVarText;
            }
            style.cssText = next;
            hasControlledDisplay = displayRE.test(next);
          }
        } else if (prev) {
          el.removeAttribute("style");
        }
      }
      if (vShowOriginalDisplay in el) {
        el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
        if (el[vShowHidden]) {
          style.display = "none";
        }
      }
    }
    const semicolonRE = /[^\\];\s*$/;
    const importantRE = /\s*!important$/;
    function setStyle(style, name, val) {
      if (isArray$1(val)) {
        val.forEach((v) => setStyle(style, name, v));
      } else {
        if (val == null) val = "";
        if (true) {
          if (semicolonRE.test(val)) {
            warn(
              `Unexpected semicolon at the end of '${name}' style value: '${val}'`
            );
          }
        }
        if (name.startsWith("--")) {
          style.setProperty(name, val);
        } else {
          const prefixed = autoPrefix(style, name);
          if (importantRE.test(val)) {
            style.setProperty(
              hyphenate(prefixed),
              val.replace(importantRE, ""),
              "important"
            );
          } else {
            style[prefixed] = val;
          }
        }
      }
    }
    const prefixes = ["Webkit", "Moz", "ms"];
    const prefixCache = {};
    function autoPrefix(style, rawName) {
      const cached = prefixCache[rawName];
      if (cached) {
        return cached;
      }
      let name = camelize(rawName);
      if (name !== "filter" && name in style) {
        return prefixCache[rawName] = name;
      }
      name = capitalize$1(name);
      for (let i = 0; i < prefixes.length; i++) {
        const prefixed = prefixes[i] + name;
        if (prefixed in style) {
          return prefixCache[rawName] = prefixed;
        }
      }
      return rawName;
    }
    const xlinkNS = "http://www.w3.org/1999/xlink";
    function patchAttr(el, key, value, isSVG, instance, isBoolean2 = isSpecialBooleanAttr(key)) {
      if (isSVG && key.startsWith("xlink:")) {
        if (value == null) {
          el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        } else {
          el.setAttributeNS(xlinkNS, key, value);
        }
      } else {
        if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
          el.removeAttribute(key);
        } else {
          el.setAttribute(
            key,
            isBoolean2 ? "" : isSymbol$2(value) ? String(value) : value
          );
        }
      }
    }
    function patchDOMProp(el, key, value, parentComponent, attrName) {
      if (key === "innerHTML" || key === "textContent") {
        if (value != null) {
          el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
        }
        return;
      }
      const tag = el.tagName;
      if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
      !tag.includes("-")) {
        const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
        const newValue = value == null ? (
          // #11647: value should be set as empty string for null and undefined,
          // but <input type="checkbox"> should be set as 'on'.
          el.type === "checkbox" ? "on" : ""
        ) : String(value);
        if (oldValue !== newValue || !("_value" in el)) {
          el.value = newValue;
        }
        if (value == null) {
          el.removeAttribute(key);
        }
        el._value = value;
        return;
      }
      let needRemove = false;
      if (value === "" || value == null) {
        const type2 = typeof el[key];
        if (type2 === "boolean") {
          value = includeBooleanAttr(value);
        } else if (value == null && type2 === "string") {
          value = "";
          needRemove = true;
        } else if (type2 === "number") {
          value = 0;
          needRemove = true;
        }
      }
      try {
        el[key] = value;
      } catch (e) {
        if (!needRemove) {
          warn(
            `Failed setting prop "${key}" on <${tag.toLowerCase()}>: value ${value} is invalid.`,
            e
          );
        }
      }
      needRemove && el.removeAttribute(attrName || key);
    }
    function addEventListener(el, event, handler, options) {
      el.addEventListener(event, handler, options);
    }
    function removeEventListener(el, event, handler, options) {
      el.removeEventListener(event, handler, options);
    }
    const veiKey = Symbol("_vei");
    function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
      const invokers = el[veiKey] || (el[veiKey] = {});
      const existingInvoker = invokers[rawName];
      if (nextValue && existingInvoker) {
        existingInvoker.value = true ? sanitizeEventValue(nextValue, rawName) : nextValue;
      } else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
          const invoker = invokers[rawName] = createInvoker(
            true ? sanitizeEventValue(nextValue, rawName) : nextValue,
            instance
          );
          addEventListener(el, name, invoker, options);
        } else if (existingInvoker) {
          removeEventListener(el, name, existingInvoker, options);
          invokers[rawName] = void 0;
        }
      }
    }
    const optionsModifierRE = /(?:Once|Passive|Capture)$/;
    function parseName(name) {
      let options;
      if (optionsModifierRE.test(name)) {
        options = {};
        let m;
        while (m = name.match(optionsModifierRE)) {
          name = name.slice(0, name.length - m[0].length);
          options[m[0].toLowerCase()] = true;
        }
      }
      const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
      return [event, options];
    }
    let cachedNow = 0;
    const p = /* @__PURE__ */ Promise.resolve();
    const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
    function createInvoker(initialValue, instance) {
      const invoker = (e) => {
        if (!e._vts) {
          e._vts = Date.now();
        } else if (e._vts <= invoker.attached) {
          return;
        }
        callWithAsyncErrorHandling(
          patchStopImmediatePropagation(e, invoker.value),
          instance,
          5,
          [e]
        );
      };
      invoker.value = initialValue;
      invoker.attached = getNow();
      return invoker;
    }
    function sanitizeEventValue(value, propName) {
      if (isFunction$1(value) || isArray$1(value)) {
        return value;
      }
      warn(
        `Wrong type passed as event handler to ${propName} - did you forget @ or : in front of your prop?
  Expected function or array of functions, received type ${typeof value}.`
      );
      return NOOP;
    }
    function patchStopImmediatePropagation(e, value) {
      if (isArray$1(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = () => {
          originalStop.call(e);
          e._stopped = true;
        };
        return value.map(
          (fn) => (e2) => !e2._stopped && fn && fn(e2)
        );
      } else {
        return value;
      }
    }
    const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
    key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
    const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
      const isSVG = namespace === "svg";
      if (key === "class") {
        patchClass(el, nextValue, isSVG);
      } else if (key === "style") {
        patchStyle(el, prevValue, nextValue);
      } else if (isOn(key)) {
        if (!isModelListener(key)) {
          patchEvent(el, key, prevValue, nextValue, parentComponent);
        }
      } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
        patchDOMProp(el, key, nextValue);
        if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
          patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
        }
      } else if (
        // #11081 force set props for possible async custom element
        el._isVueCE && (/[A-Z]/.test(key) || !isString$1(nextValue))
      ) {
        patchDOMProp(el, camelize(key), nextValue, parentComponent, key);
      } else {
        if (key === "true-value") {
          el._trueValue = nextValue;
        } else if (key === "false-value") {
          el._falseValue = nextValue;
        }
        patchAttr(el, key, nextValue, isSVG);
      }
    };
    function shouldSetAsProp(el, key, value, isSVG) {
      if (isSVG) {
        if (key === "innerHTML" || key === "textContent") {
          return true;
        }
        if (key in el && isNativeOn(key) && isFunction$1(value)) {
          return true;
        }
        return false;
      }
      if (key === "spellcheck" || key === "draggable" || key === "translate") {
        return false;
      }
      if (key === "form") {
        return false;
      }
      if (key === "list" && el.tagName === "INPUT") {
        return false;
      }
      if (key === "type" && el.tagName === "TEXTAREA") {
        return false;
      }
      if (key === "width" || key === "height") {
        const tag = el.tagName;
        if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
          return false;
        }
      }
      if (isNativeOn(key) && isString$1(value)) {
        return false;
      }
      return key in el;
    }
    const REMOVAL = {};
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function defineCustomElement(options, extraOptions, _createApp) {
      const Comp = /* @__PURE__ */ defineComponent(options, extraOptions);
      if (isPlainObject$2(Comp)) extend(Comp, extraOptions);
      class VueCustomElement extends VueElement {
        constructor(initialProps) {
          super(Comp, initialProps, _createApp);
        }
      }
      VueCustomElement.def = Comp;
      return VueCustomElement;
    }
    /*! #__NO_SIDE_EFFECTS__ */
    const defineSSRCustomElement = /* @__NO_SIDE_EFFECTS__ */ (options, extraOptions) => {
      return /* @__PURE__ */ defineCustomElement(options, extraOptions, createSSRApp);
    };
    const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
    };
    class VueElement extends BaseClass {
      constructor(_def, _props = {}, _createApp = createApp) {
        super();
        this._def = _def;
        this._props = _props;
        this._createApp = _createApp;
        this._isVueCE = true;
        this._instance = null;
        this._app = null;
        this._nonce = this._def.nonce;
        this._connected = false;
        this._resolved = false;
        this._numberProps = null;
        this._styleChildren = /* @__PURE__ */ new WeakSet();
        this._ob = null;
        if (this.shadowRoot && _createApp !== createApp) {
          this._root = this.shadowRoot;
        } else {
          if (this.shadowRoot) {
            warn(
              `Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use \`defineSSRCustomElement\`.`
            );
          }
          if (_def.shadowRoot !== false) {
            this.attachShadow({ mode: "open" });
            this._root = this.shadowRoot;
          } else {
            this._root = this;
          }
        }
        if (!this._def.__asyncLoader) {
          this._resolveProps(this._def);
        }
      }
      connectedCallback() {
        if (!this.isConnected) return;
        if (!this.shadowRoot) {
          this._parseSlots();
        }
        this._connected = true;
        let parent = this;
        while (parent = parent && (parent.parentNode || parent.host)) {
          if (parent instanceof VueElement) {
            this._parent = parent;
            break;
          }
        }
        if (!this._instance) {
          if (this._resolved) {
            this._setParent();
            this._update();
          } else {
            if (parent && parent._pendingResolve) {
              this._pendingResolve = parent._pendingResolve.then(() => {
                this._pendingResolve = void 0;
                this._resolveDef();
              });
            } else {
              this._resolveDef();
            }
          }
        }
      }
      _setParent(parent = this._parent) {
        if (parent) {
          this._instance.parent = parent._instance;
          this._instance.provides = parent._instance.provides;
        }
      }
      disconnectedCallback() {
        this._connected = false;
        nextTick(() => {
          if (!this._connected) {
            if (this._ob) {
              this._ob.disconnect();
              this._ob = null;
            }
            this._app && this._app.unmount();
            if (this._instance) this._instance.ce = void 0;
            this._app = this._instance = null;
          }
        });
      }
      /**
       * resolve inner component definition (handle possible async component)
       */
      _resolveDef() {
        if (this._pendingResolve) {
          return;
        }
        for (let i = 0; i < this.attributes.length; i++) {
          this._setAttr(this.attributes[i].name);
        }
        this._ob = new MutationObserver((mutations) => {
          for (const m of mutations) {
            this._setAttr(m.attributeName);
          }
        });
        this._ob.observe(this, { attributes: true });
        const resolve2 = (def2, isAsync = false) => {
          this._resolved = true;
          this._pendingResolve = void 0;
          const { props, styles } = def2;
          let numberProps;
          if (props && !isArray$1(props)) {
            for (const key in props) {
              const opt = props[key];
              if (opt === Number || opt && opt.type === Number) {
                if (key in this._props) {
                  this._props[key] = toNumber$1(this._props[key]);
                }
                (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[camelize(key)] = true;
              }
            }
          }
          this._numberProps = numberProps;
          if (isAsync) {
            this._resolveProps(def2);
          }
          if (this.shadowRoot) {
            this._applyStyles(styles);
          } else if (styles) {
            warn(
              "Custom element style injection is not supported when using shadowRoot: false"
            );
          }
          this._mount(def2);
        };
        const asyncDef = this._def.__asyncLoader;
        if (asyncDef) {
          this._pendingResolve = asyncDef().then(
            (def2) => resolve2(this._def = def2, true)
          );
        } else {
          resolve2(this._def);
        }
      }
      _mount(def2) {
        if (!def2.name) {
          def2.name = "VueElement";
        }
        this._app = this._createApp(def2);
        if (def2.configureApp) {
          def2.configureApp(this._app);
        }
        this._app._ceVNode = this._createVNode();
        this._app.mount(this._root);
        const exposed = this._instance && this._instance.exposed;
        if (!exposed) return;
        for (const key in exposed) {
          if (!hasOwn(this, key)) {
            Object.defineProperty(this, key, {
              // unwrap ref to be consistent with public instance behavior
              get: () => unref(exposed[key])
            });
          } else if (true) {
            warn(`Exposed property "${key}" already exists on custom element.`);
          }
        }
      }
      _resolveProps(def2) {
        const { props } = def2;
        const declaredPropKeys = isArray$1(props) ? props : Object.keys(props || {});
        for (const key of Object.keys(this)) {
          if (key[0] !== "_" && declaredPropKeys.includes(key)) {
            this._setProp(key, this[key]);
          }
        }
        for (const key of declaredPropKeys.map(camelize)) {
          Object.defineProperty(this, key, {
            get() {
              return this._getProp(key);
            },
            set(val) {
              this._setProp(key, val, true, true);
            }
          });
        }
      }
      _setAttr(key) {
        if (key.startsWith("data-v-")) return;
        const has = this.hasAttribute(key);
        let value = has ? this.getAttribute(key) : REMOVAL;
        const camelKey = camelize(key);
        if (has && this._numberProps && this._numberProps[camelKey]) {
          value = toNumber$1(value);
        }
        this._setProp(camelKey, value, false, true);
      }
      /**
       * @internal
       */
      _getProp(key) {
        return this._props[key];
      }
      /**
       * @internal
       */
      _setProp(key, val, shouldReflect = true, shouldUpdate = false) {
        if (val !== this._props[key]) {
          if (val === REMOVAL) {
            delete this._props[key];
          } else {
            this._props[key] = val;
            if (key === "key" && this._app) {
              this._app._ceVNode.key = val;
            }
          }
          if (shouldUpdate && this._instance) {
            this._update();
          }
          if (shouldReflect) {
            const ob = this._ob;
            ob && ob.disconnect();
            if (val === true) {
              this.setAttribute(hyphenate(key), "");
            } else if (typeof val === "string" || typeof val === "number") {
              this.setAttribute(hyphenate(key), val + "");
            } else if (!val) {
              this.removeAttribute(hyphenate(key));
            }
            ob && ob.observe(this, { attributes: true });
          }
        }
      }
      _update() {
        render(this._createVNode(), this._root);
      }
      _createVNode() {
        const baseProps = {};
        if (!this.shadowRoot) {
          baseProps.onVnodeMounted = baseProps.onVnodeUpdated = this._renderSlots.bind(this);
        }
        const vnode = createVNode(this._def, extend(baseProps, this._props));
        if (!this._instance) {
          vnode.ce = (instance) => {
            this._instance = instance;
            instance.ce = this;
            instance.isCE = true;
            if (true) {
              instance.ceReload = (newStyles) => {
                if (this._styles) {
                  this._styles.forEach((s) => this._root.removeChild(s));
                  this._styles.length = 0;
                }
                this._applyStyles(newStyles);
                this._instance = null;
                this._update();
              };
            }
            const dispatch = (event, args) => {
              this.dispatchEvent(
                new CustomEvent(
                  event,
                  isPlainObject$2(args[0]) ? extend({ detail: args }, args[0]) : { detail: args }
                )
              );
            };
            instance.emit = (event, ...args) => {
              dispatch(event, args);
              if (hyphenate(event) !== event) {
                dispatch(hyphenate(event), args);
              }
            };
            this._setParent();
          };
        }
        return vnode;
      }
      _applyStyles(styles, owner) {
        if (!styles) return;
        if (owner) {
          if (owner === this._def || this._styleChildren.has(owner)) {
            return;
          }
          this._styleChildren.add(owner);
        }
        const nonce = this._nonce;
        for (let i = styles.length - 1; i >= 0; i--) {
          const s = document.createElement("style");
          if (nonce) s.setAttribute("nonce", nonce);
          s.textContent = styles[i];
          this.shadowRoot.prepend(s);
          if (true) {
            if (owner) {
              if (owner.__hmrId) {
                if (!this._childStyles) this._childStyles = /* @__PURE__ */ new Map();
                let entry = this._childStyles.get(owner.__hmrId);
                if (!entry) {
                  this._childStyles.set(owner.__hmrId, entry = []);
                }
                entry.push(s);
              }
            } else {
              (this._styles || (this._styles = [])).push(s);
            }
          }
        }
      }
      /**
       * Only called when shadowRoot is false
       */
      _parseSlots() {
        const slots = this._slots = {};
        let n;
        while (n = this.firstChild) {
          const slotName = n.nodeType === 1 && n.getAttribute("slot") || "default";
          (slots[slotName] || (slots[slotName] = [])).push(n);
          this.removeChild(n);
        }
      }
      /**
       * Only called when shadowRoot is false
       */
      _renderSlots() {
        const outlets = (this._teleportTarget || this).querySelectorAll("slot");
        const scopeId = this._instance.type.__scopeId;
        for (let i = 0; i < outlets.length; i++) {
          const o = outlets[i];
          const slotName = o.getAttribute("name") || "default";
          const content = this._slots[slotName];
          const parent = o.parentNode;
          if (content) {
            for (const n of content) {
              if (scopeId && n.nodeType === 1) {
                const id2 = scopeId + "-s";
                const walker = document.createTreeWalker(n, 1);
                n.setAttribute(id2, "");
                let child;
                while (child = walker.nextNode()) {
                  child.setAttribute(id2, "");
                }
              }
              parent.insertBefore(n, o);
            }
          } else {
            while (o.firstChild) parent.insertBefore(o.firstChild, o);
          }
          parent.removeChild(o);
        }
      }
      /**
       * @internal
       */
      _injectChildStyle(comp) {
        this._applyStyles(comp.styles, comp);
      }
      /**
       * @internal
       */
      _removeChildStyle(comp) {
        if (true) {
          this._styleChildren.delete(comp);
          if (this._childStyles && comp.__hmrId) {
            const oldStyles = this._childStyles.get(comp.__hmrId);
            if (oldStyles) {
              oldStyles.forEach((s) => this._root.removeChild(s));
              oldStyles.length = 0;
            }
          }
        }
      }
    }
    function useHost(caller) {
      const instance = getCurrentInstance();
      const el = instance && instance.ce;
      if (el) {
        return el;
      } else if (true) {
        if (!instance) {
          warn(
            `${caller || "useHost"} called without an active component instance.`
          );
        } else {
          warn(
            `${caller || "useHost"} can only be used in components defined via defineCustomElement.`
          );
        }
      }
      return null;
    }
    function useShadowRoot() {
      const el = true ? useHost("useShadowRoot") : useHost();
      return el && el.shadowRoot;
    }
    function useCssModule(name = "$style") {
      {
        const instance = getCurrentInstance();
        if (!instance) {
          warn(`useCssModule must be called inside setup()`);
          return EMPTY_OBJ;
        }
        const modules = instance.type.__cssModules;
        if (!modules) {
          warn(`Current instance does not have CSS modules injected.`);
          return EMPTY_OBJ;
        }
        const mod = modules[name];
        if (!mod) {
          warn(`Current instance does not have CSS module named "${name}".`);
          return EMPTY_OBJ;
        }
        return mod;
      }
    }
    const positionMap = /* @__PURE__ */ new WeakMap();
    const newPositionMap = /* @__PURE__ */ new WeakMap();
    const moveCbKey = Symbol("_moveCb");
    const enterCbKey = Symbol("_enterCb");
    const decorate = (t) => {
      delete t.props.mode;
      return t;
    };
    const TransitionGroupImpl = /* @__PURE__ */ decorate({
      name: "TransitionGroup",
      props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
      }),
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevChildren;
        let children;
        onUpdated(() => {
          if (!prevChildren.length) {
            return;
          }
          const moveClass = props.moveClass || `${props.name || "v"}-move`;
          if (!hasCSSTransform(
            prevChildren[0].el,
            instance.vnode.el,
            moveClass
          )) {
            return;
          }
          prevChildren.forEach(callPendingCbs);
          prevChildren.forEach(recordPosition);
          const movedChildren = prevChildren.filter(applyTranslation);
          forceReflow();
          movedChildren.forEach((c) => {
            const el = c.el;
            const style = el.style;
            addTransitionClass(el, moveClass);
            style.transform = style.webkitTransform = style.transitionDuration = "";
            const cb = el[moveCbKey] = (e) => {
              if (e && e.target !== el) {
                return;
              }
              if (!e || /transform$/.test(e.propertyName)) {
                el.removeEventListener("transitionend", cb);
                el[moveCbKey] = null;
                removeTransitionClass(el, moveClass);
              }
            };
            el.addEventListener("transitionend", cb);
          });
        });
        return () => {
          const rawProps = toRaw(props);
          const cssTransitionProps = resolveTransitionProps(rawProps);
          let tag = rawProps.tag || Fragment;
          prevChildren = [];
          if (children) {
            for (let i = 0; i < children.length; i++) {
              const child = children[i];
              if (child.el && child.el instanceof Element) {
                prevChildren.push(child);
                setTransitionHooks(
                  child,
                  resolveTransitionHooks(
                    child,
                    cssTransitionProps,
                    state,
                    instance
                  )
                );
                positionMap.set(
                  child,
                  child.el.getBoundingClientRect()
                );
              }
            }
          }
          children = slots.default ? getTransitionRawChildren(slots.default()) : [];
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (child.key != null) {
              setTransitionHooks(
                child,
                resolveTransitionHooks(child, cssTransitionProps, state, instance)
              );
            } else if (child.type !== Text) {
              warn(`<TransitionGroup> children must be keyed.`);
            }
          }
          return createVNode(tag, null, children);
        };
      }
    });
    const TransitionGroup = TransitionGroupImpl;
    function callPendingCbs(c) {
      const el = c.el;
      if (el[moveCbKey]) {
        el[moveCbKey]();
      }
      if (el[enterCbKey]) {
        el[enterCbKey]();
      }
    }
    function recordPosition(c) {
      newPositionMap.set(c, c.el.getBoundingClientRect());
    }
    function applyTranslation(c) {
      const oldPos = positionMap.get(c);
      const newPos = newPositionMap.get(c);
      const dx = oldPos.left - newPos.left;
      const dy = oldPos.top - newPos.top;
      if (dx || dy) {
        const s = c.el.style;
        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = "0s";
        return c;
      }
    }
    function hasCSSTransform(el, root, moveClass) {
      const clone2 = el.cloneNode();
      const _vtc = el[vtcKey];
      if (_vtc) {
        _vtc.forEach((cls) => {
          cls.split(/\s+/).forEach((c) => c && clone2.classList.remove(c));
        });
      }
      moveClass.split(/\s+/).forEach((c) => c && clone2.classList.add(c));
      clone2.style.display = "none";
      const container = root.nodeType === 1 ? root : root.parentNode;
      container.appendChild(clone2);
      const { hasTransform } = getTransitionInfo(clone2);
      container.removeChild(clone2);
      return hasTransform;
    }
    const getModelAssigner = (vnode) => {
      const fn = vnode.props["onUpdate:modelValue"] || false;
      return isArray$1(fn) ? (value) => invokeArrayFns(fn, value) : fn;
    };
    function onCompositionStart(e) {
      e.target.composing = true;
    }
    function onCompositionEnd(e) {
      const target = e.target;
      if (target.composing) {
        target.composing = false;
        target.dispatchEvent(new Event("input"));
      }
    }
    const assignKey = Symbol("_assign");
    const vModelText = {
      created(el, { modifiers: { lazy, trim: trim2, number } }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        const castToNumber = number || vnode.props && vnode.props.type === "number";
        addEventListener(el, lazy ? "change" : "input", (e) => {
          if (e.target.composing) return;
          let domValue = el.value;
          if (trim2) {
            domValue = domValue.trim();
          }
          if (castToNumber) {
            domValue = looseToNumber(domValue);
          }
          el[assignKey](domValue);
        });
        if (trim2) {
          addEventListener(el, "change", () => {
            el.value = el.value.trim();
          });
        }
        if (!lazy) {
          addEventListener(el, "compositionstart", onCompositionStart);
          addEventListener(el, "compositionend", onCompositionEnd);
          addEventListener(el, "change", onCompositionEnd);
        }
      },
      // set value on mounted so it's after min/max for type="range"
      mounted(el, { value }) {
        el.value = value == null ? "" : value;
      },
      beforeUpdate(el, { value, oldValue, modifiers: { lazy, trim: trim2, number } }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        if (el.composing) return;
        const elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? looseToNumber(el.value) : el.value;
        const newValue = value == null ? "" : value;
        if (elValue === newValue) {
          return;
        }
        if (document.activeElement === el && el.type !== "range") {
          if (lazy && value === oldValue) {
            return;
          }
          if (trim2 && el.value.trim() === newValue) {
            return;
          }
        }
        el.value = newValue;
      }
    };
    const vModelCheckbox = {
      // #4096 array checkboxes need to be deep traversed
      deep: true,
      created(el, _, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        addEventListener(el, "change", () => {
          const modelValue = el._modelValue;
          const elementValue = getValue(el);
          const checked = el.checked;
          const assign = el[assignKey];
          if (isArray$1(modelValue)) {
            const index = looseIndexOf(modelValue, elementValue);
            const found = index !== -1;
            if (checked && !found) {
              assign(modelValue.concat(elementValue));
            } else if (!checked && found) {
              const filtered = [...modelValue];
              filtered.splice(index, 1);
              assign(filtered);
            }
          } else if (isSet$1(modelValue)) {
            const cloned = new Set(modelValue);
            if (checked) {
              cloned.add(elementValue);
            } else {
              cloned.delete(elementValue);
            }
            assign(cloned);
          } else {
            assign(getCheckboxValue(el, checked));
          }
        });
      },
      // set initial checked on mount to wait for true-value/false-value
      mounted: setChecked,
      beforeUpdate(el, binding, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        setChecked(el, binding, vnode);
      }
    };
    function setChecked(el, { value, oldValue }, vnode) {
      el._modelValue = value;
      let checked;
      if (isArray$1(value)) {
        checked = looseIndexOf(value, vnode.props.value) > -1;
      } else if (isSet$1(value)) {
        checked = value.has(vnode.props.value);
      } else {
        if (value === oldValue) return;
        checked = looseEqual(value, getCheckboxValue(el, true));
      }
      if (el.checked !== checked) {
        el.checked = checked;
      }
    }
    const vModelRadio = {
      created(el, { value }, vnode) {
        el.checked = looseEqual(value, vnode.props.value);
        el[assignKey] = getModelAssigner(vnode);
        addEventListener(el, "change", () => {
          el[assignKey](getValue(el));
        });
      },
      beforeUpdate(el, { value, oldValue }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        if (value !== oldValue) {
          el.checked = looseEqual(value, vnode.props.value);
        }
      }
    };
    const vModelSelect = {
      // <select multiple> value need to be deep traversed
      deep: true,
      created(el, { value, modifiers: { number } }, vnode) {
        const isSetModel = isSet$1(value);
        addEventListener(el, "change", () => {
          const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(
            (o) => number ? looseToNumber(getValue(o)) : getValue(o)
          );
          el[assignKey](
            el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
          );
          el._assigning = true;
          nextTick(() => {
            el._assigning = false;
          });
        });
        el[assignKey] = getModelAssigner(vnode);
      },
      // set value in mounted & updated because <select> relies on its children
      // <option>s.
      mounted(el, { value }) {
        setSelected(el, value);
      },
      beforeUpdate(el, _binding, vnode) {
        el[assignKey] = getModelAssigner(vnode);
      },
      updated(el, { value }) {
        if (!el._assigning) {
          setSelected(el, value);
        }
      }
    };
    function setSelected(el, value) {
      const isMultiple = el.multiple;
      const isArrayValue = isArray$1(value);
      if (isMultiple && !isArrayValue && !isSet$1(value)) {
        warn(
          `<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(value).slice(8, -1)}.`
        );
        return;
      }
      for (let i = 0, l = el.options.length; i < l; i++) {
        const option = el.options[i];
        const optionValue = getValue(option);
        if (isMultiple) {
          if (isArrayValue) {
            const optionType = typeof optionValue;
            if (optionType === "string" || optionType === "number") {
              option.selected = value.some((v) => String(v) === String(optionValue));
            } else {
              option.selected = looseIndexOf(value, optionValue) > -1;
            }
          } else {
            option.selected = value.has(optionValue);
          }
        } else if (looseEqual(getValue(option), value)) {
          if (el.selectedIndex !== i) el.selectedIndex = i;
          return;
        }
      }
      if (!isMultiple && el.selectedIndex !== -1) {
        el.selectedIndex = -1;
      }
    }
    function getValue(el) {
      return "_value" in el ? el._value : el.value;
    }
    function getCheckboxValue(el, checked) {
      const key = checked ? "_trueValue" : "_falseValue";
      return key in el ? el[key] : checked;
    }
    const vModelDynamic = {
      created(el, binding, vnode) {
        callModelHook(el, binding, vnode, null, "created");
      },
      mounted(el, binding, vnode) {
        callModelHook(el, binding, vnode, null, "mounted");
      },
      beforeUpdate(el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
      },
      updated(el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, "updated");
      }
    };
    function resolveDynamicModel(tagName, type2) {
      switch (tagName) {
        case "SELECT":
          return vModelSelect;
        case "TEXTAREA":
          return vModelText;
        default:
          switch (type2) {
            case "checkbox":
              return vModelCheckbox;
            case "radio":
              return vModelRadio;
            default:
              return vModelText;
          }
      }
    }
    function callModelHook(el, binding, vnode, prevVNode, hook) {
      const modelToUse = resolveDynamicModel(
        el.tagName,
        vnode.props && vnode.props.type
      );
      const fn = modelToUse[hook];
      fn && fn(el, binding, vnode, prevVNode);
    }
    function initVModelForSSR() {
      vModelText.getSSRProps = ({ value }) => ({ value });
      vModelRadio.getSSRProps = ({ value }, vnode) => {
        if (vnode.props && looseEqual(vnode.props.value, value)) {
          return { checked: true };
        }
      };
      vModelCheckbox.getSSRProps = ({ value }, vnode) => {
        if (isArray$1(value)) {
          if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {
            return { checked: true };
          }
        } else if (isSet$1(value)) {
          if (vnode.props && value.has(vnode.props.value)) {
            return { checked: true };
          }
        } else if (value) {
          return { checked: true };
        }
      };
      vModelDynamic.getSSRProps = (binding, vnode) => {
        if (typeof vnode.type !== "string") {
          return;
        }
        const modelToUse = resolveDynamicModel(
          // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
          vnode.type.toUpperCase(),
          vnode.props && vnode.props.type
        );
        if (modelToUse.getSSRProps) {
          return modelToUse.getSSRProps(binding, vnode);
        }
      };
    }
    const systemModifiers = ["ctrl", "shift", "alt", "meta"];
    const modifierGuards = {
      stop: (e) => e.stopPropagation(),
      prevent: (e) => e.preventDefault(),
      self: (e) => e.target !== e.currentTarget,
      ctrl: (e) => !e.ctrlKey,
      shift: (e) => !e.shiftKey,
      alt: (e) => !e.altKey,
      meta: (e) => !e.metaKey,
      left: (e) => "button" in e && e.button !== 0,
      middle: (e) => "button" in e && e.button !== 1,
      right: (e) => "button" in e && e.button !== 2,
      exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
    };
    const withModifiers = (fn, modifiers) => {
      const cache = fn._withMods || (fn._withMods = {});
      const cacheKey = modifiers.join(".");
      return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
        for (let i = 0; i < modifiers.length; i++) {
          const guard = modifierGuards[modifiers[i]];
          if (guard && guard(event, modifiers)) return;
        }
        return fn(event, ...args);
      });
    };
    const keyNames = {
      esc: "escape",
      space: " ",
      up: "arrow-up",
      left: "arrow-left",
      right: "arrow-right",
      down: "arrow-down",
      delete: "backspace"
    };
    const withKeys = (fn, modifiers) => {
      const cache = fn._withKeys || (fn._withKeys = {});
      const cacheKey = modifiers.join(".");
      return cache[cacheKey] || (cache[cacheKey] = (event) => {
        if (!("key" in event)) {
          return;
        }
        const eventKey = hyphenate(event.key);
        if (modifiers.some(
          (k) => k === eventKey || keyNames[k] === eventKey
        )) {
          return fn(event);
        }
      });
    };
    const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
    let renderer;
    let enabledHydration = false;
    function ensureRenderer() {
      return renderer || (renderer = createRenderer(rendererOptions));
    }
    function ensureHydrationRenderer() {
      renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);
      enabledHydration = true;
      return renderer;
    }
    const render = (...args) => {
      ensureRenderer().render(...args);
    };
    const hydrate = (...args) => {
      ensureHydrationRenderer().hydrate(...args);
    };
    const createApp = (...args) => {
      const app = ensureRenderer().createApp(...args);
      if (true) {
        injectNativeTagCheck(app);
        injectCompilerOptionsCheck(app);
      }
      const { mount } = app;
      app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container) return;
        const component = app._component;
        if (!isFunction$1(component) && !component.render && !component.template) {
          component.template = container.innerHTML;
        }
        if (container.nodeType === 1) {
          container.textContent = "";
        }
        const proxy = mount(container, false, resolveRootNamespace(container));
        if (container instanceof Element) {
          container.removeAttribute("v-cloak");
          container.setAttribute("data-v-app", "");
        }
        return proxy;
      };
      return app;
    };
    const createSSRApp = (...args) => {
      const app = ensureHydrationRenderer().createApp(...args);
      if (true) {
        injectNativeTagCheck(app);
        injectCompilerOptionsCheck(app);
      }
      const { mount } = app;
      app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (container) {
          return mount(container, true, resolveRootNamespace(container));
        }
      };
      return app;
    };
    function resolveRootNamespace(container) {
      if (container instanceof SVGElement) {
        return "svg";
      }
      if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
        return "mathml";
      }
    }
    function injectNativeTagCheck(app) {
      Object.defineProperty(app.config, "isNativeTag", {
        value: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),
        writable: false
      });
    }
    function injectCompilerOptionsCheck(app) {
      if (isRuntimeOnly()) {
        const isCustomElement = app.config.isCustomElement;
        Object.defineProperty(app.config, "isCustomElement", {
          get() {
            return isCustomElement;
          },
          set() {
            warn(
              `The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`
            );
          }
        });
        const compilerOptions = app.config.compilerOptions;
        const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
  - For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
  - For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
  - For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;
        Object.defineProperty(app.config, "compilerOptions", {
          get() {
            warn(msg);
            return compilerOptions;
          },
          set() {
            warn(msg);
          }
        });
      }
    }
    function normalizeContainer(container) {
      if (isString$1(container)) {
        const res = document.querySelector(container);
        if (!res) {
          warn(
            `Failed to mount app: mount target selector "${container}" returned null.`
          );
        }
        return res;
      }
      if (window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === "closed") {
        warn(
          `mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`
        );
      }
      return container;
    }
    let ssrDirectiveInitialized = false;
    const initDirectivesForSSR = () => {
      if (!ssrDirectiveInitialized) {
        ssrDirectiveInitialized = true;
        initVModelForSSR();
        initVShowForSSR();
      }
    };
    /**
    * vue v3.5.13
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    function initDev() {
      {
        initCustomFormatter();
      }
    }
    if (true) {
      initDev();
    }
    const compile$1 = () => {
      if (true) {
        warn(
          `Runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
        );
      }
    };
    function at(arr, indices) {
      const result = new Array(indices.length);
      const length = arr.length;
      for (let i = 0; i < indices.length; i++) {
        let index = indices[i];
        index = Number.isInteger(index) ? index : Math.trunc(index) || 0;
        if (index < 0) {
          index += length;
        }
        result[i] = arr[index];
      }
      return result;
    }
    function chunk(arr, size) {
      if (!Number.isInteger(size) || size <= 0) {
        throw new Error("Size must be an integer greater than zero.");
      }
      const chunkLength = Math.ceil(arr.length / size);
      const result = Array(chunkLength);
      for (let index = 0; index < chunkLength; index++) {
        const start = index * size;
        const end = start + size;
        result[index] = arr.slice(start, end);
      }
      return result;
    }
    function compact(arr) {
      const result = [];
      for (let i = 0; i < arr.length; i++) {
        const item = arr[i];
        if (item) {
          result.push(item);
        }
      }
      return result;
    }
    function countBy(arr, mapper) {
      const result = {};
      for (let i = 0; i < arr.length; i++) {
        const item = arr[i];
        const key = mapper(item);
        result[key] = (result[key] ?? 0) + 1;
      }
      return result;
    }
    function difference(firstArr, secondArr) {
      const secondSet = new Set(secondArr);
      return firstArr.filter((item) => !secondSet.has(item));
    }
    function differenceBy(firstArr, secondArr, mapper) {
      const mappedSecondSet = new Set(secondArr.map((item) => mapper(item)));
      return firstArr.filter((item) => {
        return !mappedSecondSet.has(mapper(item));
      });
    }
    function differenceWith(firstArr, secondArr, areItemsEqual) {
      return firstArr.filter((firstItem) => {
        return secondArr.every((secondItem) => {
          return !areItemsEqual(firstItem, secondItem);
        });
      });
    }
    function drop(arr, itemsCount) {
      itemsCount = Math.max(itemsCount, 0);
      return arr.slice(itemsCount);
    }
    function dropRight(arr, itemsCount) {
      itemsCount = Math.min(-itemsCount, 0);
      if (itemsCount === 0) {
        return arr.slice();
      }
      return arr.slice(0, itemsCount);
    }
    function dropRightWhile(arr, canContinueDropping) {
      for (let i = arr.length - 1; i >= 0; i--) {
        if (!canContinueDropping(arr[i], i, arr)) {
          return arr.slice(0, i + 1);
        }
      }
      return [];
    }
    function dropWhile(arr, canContinueDropping) {
      const dropEndIndex = arr.findIndex((item, index, arr2) => !canContinueDropping(item, index, arr2));
      if (dropEndIndex === -1) {
        return [];
      }
      return arr.slice(dropEndIndex);
    }
    function fill(array, value, start = 0, end = array.length) {
      const length = array.length;
      const finalStart = Math.max(start >= 0 ? start : length + start, 0);
      const finalEnd = Math.min(end >= 0 ? end : length + end, length);
      for (let i = finalStart; i < finalEnd; i++) {
        array[i] = value;
      }
      return array;
    }
    function flatten(arr, depth = 1) {
      const result = [];
      const flooredDepth = Math.floor(depth);
      const recursive = (arr2, currentDepth) => {
        for (let i = 0; i < arr2.length; i++) {
          const item = arr2[i];
          if (Array.isArray(item) && currentDepth < flooredDepth) {
            recursive(item, currentDepth + 1);
          } else {
            result.push(item);
          }
        }
      };
      recursive(arr, 0);
      return result;
    }
    function flatMap(arr, iteratee, depth = 1) {
      return flatten(arr.map((item) => iteratee(item)), depth);
    }
    function flattenDeep(arr) {
      return flatten(arr, Infinity);
    }
    function flatMapDeep(arr, iteratee) {
      return flattenDeep(arr.map((item) => iteratee(item)));
    }
    function forEachRight(arr, callback) {
      for (let i = arr.length - 1; i >= 0; i--) {
        const element = arr[i];
        callback(element, i, arr);
      }
    }
    function groupBy(arr, getKeyFromItem) {
      const result = {};
      for (let i = 0; i < arr.length; i++) {
        const item = arr[i];
        const key = getKeyFromItem(item);
        if (!Object.hasOwn(result, key)) {
          result[key] = [];
        }
        result[key].push(item);
      }
      return result;
    }
    function head(arr) {
      return arr[0];
    }
    function initial(arr) {
      return arr.slice(0, -1);
    }
    function intersection(firstArr, secondArr) {
      const secondSet = new Set(secondArr);
      return firstArr.filter((item) => {
        return secondSet.has(item);
      });
    }
    function intersectionBy(firstArr, secondArr, mapper) {
      const mappedSecondSet = new Set(secondArr.map(mapper));
      return firstArr.filter((item) => mappedSecondSet.has(mapper(item)));
    }
    function intersectionWith(firstArr, secondArr, areItemsEqual) {
      return firstArr.filter((firstItem) => {
        return secondArr.some((secondItem) => {
          return areItemsEqual(firstItem, secondItem);
        });
      });
    }
    function isSubset(superset, subset) {
      return difference(subset, superset).length === 0;
    }
    function isSubsetWith(superset, subset, areItemsEqual) {
      return differenceWith(subset, superset, areItemsEqual).length === 0;
    }
    function keyBy(arr, getKeyFromItem) {
      const result = {};
      for (let i = 0; i < arr.length; i++) {
        const item = arr[i];
        const key = getKeyFromItem(item);
        result[key] = item;
      }
      return result;
    }
    function last(arr) {
      return arr[arr.length - 1];
    }
    function maxBy(items2, getValue2) {
      let maxElement = items2[0];
      let max = -Infinity;
      for (let i = 0; i < items2.length; i++) {
        const element = items2[i];
        const value = getValue2(element);
        if (value > max) {
          max = value;
          maxElement = element;
        }
      }
      return maxElement;
    }
    function minBy(items2, getValue2) {
      let minElement = items2[0];
      let min = Infinity;
      for (let i = 0; i < items2.length; i++) {
        const element = items2[i];
        const value = getValue2(element);
        if (value < min) {
          min = value;
          minElement = element;
        }
      }
      return minElement;
    }
    function compareValues(a, b, order) {
      if (a < b) {
        return order === "asc" ? -1 : 1;
      }
      if (a > b) {
        return order === "asc" ? 1 : -1;
      }
      return 0;
    }
    function orderBy(arr, criteria, orders) {
      return arr.slice().sort((a, b) => {
        const ordersLength = orders.length;
        for (let i = 0; i < criteria.length; i++) {
          const order = ordersLength > i ? orders[i] : orders[ordersLength - 1];
          const criterion = criteria[i];
          const criterionIsFunction = typeof criterion === "function";
          const valueA = criterionIsFunction ? criterion(a) : a[criterion];
          const valueB = criterionIsFunction ? criterion(b) : b[criterion];
          const result = compareValues(valueA, valueB, order);
          if (result !== 0) {
            return result;
          }
        }
        return 0;
      });
    }
    function partition(arr, isInTruthy) {
      const truthy = [];
      const falsy = [];
      for (let i = 0; i < arr.length; i++) {
        const item = arr[i];
        if (isInTruthy(item)) {
          truthy.push(item);
        } else {
          falsy.push(item);
        }
      }
      return [truthy, falsy];
    }
    function pull(arr, valuesToRemove) {
      const valuesSet = new Set(valuesToRemove);
      let resultIndex = 0;
      for (let i = 0; i < arr.length; i++) {
        if (valuesSet.has(arr[i])) {
          continue;
        }
        if (!Object.hasOwn(arr, i)) {
          delete arr[resultIndex++];
          continue;
        }
        arr[resultIndex++] = arr[i];
      }
      arr.length = resultIndex;
      return arr;
    }
    function pullAt(arr, indicesToRemove) {
      const removed = at(arr, indicesToRemove);
      const indices = new Set(indicesToRemove.slice().sort((x, y) => y - x));
      for (const index of indices) {
        arr.splice(index, 1);
      }
      return removed;
    }
    function remove(arr, shouldRemoveElement) {
      const originalArr = arr.slice();
      const removed = [];
      let resultIndex = 0;
      for (let i = 0; i < arr.length; i++) {
        if (shouldRemoveElement(arr[i], i, originalArr)) {
          removed.push(arr[i]);
          continue;
        }
        if (!Object.hasOwn(arr, i)) {
          delete arr[resultIndex++];
          continue;
        }
        arr[resultIndex++] = arr[i];
      }
      arr.length = resultIndex;
      return removed;
    }
    function sample(arr) {
      const randomIndex = Math.floor(Math.random() * arr.length);
      return arr[randomIndex];
    }
    function random(minimum, maximum) {
      if (maximum == null) {
        maximum = minimum;
        minimum = 0;
      }
      if (minimum >= maximum) {
        throw new Error("Invalid input: The maximum value must be greater than the minimum value.");
      }
      return Math.random() * (maximum - minimum) + minimum;
    }
    function randomInt(minimum, maximum) {
      return Math.floor(random(minimum, maximum));
    }
    function sampleSize(array, size) {
      if (size > array.length) {
        throw new Error("Size must be less than or equal to the length of array.");
      }
      const result = new Array(size);
      const selected = /* @__PURE__ */ new Set();
      for (let step = array.length - size, resultIndex = 0; step < array.length; step++, resultIndex++) {
        let index = randomInt(0, step + 1);
        if (selected.has(index)) {
          index = step;
        }
        selected.add(index);
        result[resultIndex] = array[index];
      }
      return result;
    }
    function shuffle(arr) {
      const result = arr.slice();
      for (let i = result.length - 1; i >= 1; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [result[i], result[j]] = [result[j], result[i]];
      }
      return result;
    }
    function sortBy(arr, criteria) {
      return orderBy(arr, criteria, ["asc"]);
    }
    function tail(arr) {
      return arr.slice(1);
    }
    function isSymbol$1(value) {
      return typeof value === "symbol" || value instanceof Symbol;
    }
    function toNumber(value) {
      if (isSymbol$1(value)) {
        return NaN;
      }
      return Number(value);
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === Infinity || value === -Infinity) {
        const sign = value < 0 ? -1 : 1;
        return sign * Number.MAX_VALUE;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      const finite = toFinite(value);
      const remainder = finite % 1;
      return remainder ? finite - remainder : finite;
    }
    function take(arr, count, guard) {
      count = guard || count === void 0 ? 1 : toInteger(count);
      return arr.slice(0, count);
    }
    function takeRight(arr, count = 1, guard) {
      count = guard || count === void 0 ? 1 : toInteger(count);
      if (count <= 0 || arr == null || arr.length === 0) {
        return [];
      }
      return arr.slice(-count);
    }
    function takeRightWhile(arr, shouldContinueTaking) {
      for (let i = arr.length - 1; i >= 0; i--) {
        if (!shouldContinueTaking(arr[i])) {
          return arr.slice(i + 1);
        }
      }
      return arr.slice();
    }
    function takeWhile(arr, shouldContinueTaking) {
      const result = [];
      for (let i = 0; i < arr.length; i++) {
        const item = arr[i];
        if (!shouldContinueTaking(item)) {
          break;
        }
        result.push(item);
      }
      return result;
    }
    function toFilled(arr, value, start = 0, end = arr.length) {
      const length = arr.length;
      const finalStart = Math.max(start >= 0 ? start : length + start, 0);
      const finalEnd = Math.min(end >= 0 ? end : length + end, length);
      const newArr = arr.slice();
      for (let i = finalStart; i < finalEnd; i++) {
        newArr[i] = value;
      }
      return newArr;
    }
    function uniq(arr) {
      return Array.from(new Set(arr));
    }
    function union(arr1, arr2) {
      return uniq(arr1.concat(arr2));
    }
    function uniqBy(arr, mapper) {
      const map2 = /* @__PURE__ */ new Map();
      for (let i = 0; i < arr.length; i++) {
        const item = arr[i];
        const key = mapper(item);
        if (!map2.has(key)) {
          map2.set(key, item);
        }
      }
      return Array.from(map2.values());
    }
    function unionBy(arr1, arr2, mapper) {
      return uniqBy(arr1.concat(arr2), mapper);
    }
    function uniqWith(arr, areItemsEqual) {
      const result = [];
      for (let i = 0; i < arr.length; i++) {
        const item = arr[i];
        const isUniq = result.every((v) => !areItemsEqual(v, item));
        if (isUniq) {
          result.push(item);
        }
      }
      return result;
    }
    function unionWith(arr1, arr2, areItemsEqual) {
      return uniqWith(arr1.concat(arr2), areItemsEqual);
    }
    function unzip(zipped) {
      let maxLen = 0;
      for (let i = 0; i < zipped.length; i++) {
        if (zipped[i].length > maxLen) {
          maxLen = zipped[i].length;
        }
      }
      const result = new Array(maxLen);
      for (let i = 0; i < maxLen; i++) {
        result[i] = new Array(zipped.length);
        for (let j = 0; j < zipped.length; j++) {
          result[i][j] = zipped[j][i];
        }
      }
      return result;
    }
    function unzipWith(target, iteratee) {
      const maxLength = Math.max(...target.map((innerArray) => innerArray.length));
      const result = new Array(maxLength);
      for (let i = 0; i < maxLength; i++) {
        const group = new Array(target.length);
        for (let j = 0; j < target.length; j++) {
          group[j] = target[j][i];
        }
        result[i] = iteratee(...group);
      }
      return result;
    }
    function windowed(arr, size, step = 1, { partialWindows = false } = {}) {
      if (size <= 0 || !Number.isInteger(size)) {
        throw new Error("Size must be a positive integer.");
      }
      if (step <= 0 || !Number.isInteger(step)) {
        throw new Error("Step must be a positive integer.");
      }
      const result = [];
      const end = partialWindows ? arr.length : arr.length - size + 1;
      for (let i = 0; i < end; i += step) {
        result.push(arr.slice(i, i + size));
      }
      return result;
    }
    function without(array, ...values) {
      return difference(array, values);
    }
    function xor(arr1, arr2) {
      return difference(union(arr1, arr2), intersection(arr1, arr2));
    }
    function xorBy(arr1, arr2, mapper) {
      const union2 = unionBy(arr1, arr2, mapper);
      const intersection2 = intersectionBy(arr1, arr2, mapper);
      return differenceBy(union2, intersection2, mapper);
    }
    function xorWith(arr1, arr2, areElementsEqual) {
      const union2 = unionWith(arr1, arr2, areElementsEqual);
      const intersection2 = intersectionWith(arr1, arr2, areElementsEqual);
      return differenceWith(union2, intersection2, areElementsEqual);
    }
    function zip(...arrs) {
      let rowCount = 0;
      for (let i = 0; i < arrs.length; i++) {
        if (arrs[i].length > rowCount) {
          rowCount = arrs[i].length;
        }
      }
      const columnCount = arrs.length;
      const result = Array(rowCount);
      for (let i = 0; i < rowCount; ++i) {
        const row = Array(columnCount);
        for (let j = 0; j < columnCount; ++j) {
          row[j] = arrs[j][i];
        }
        result[i] = row;
      }
      return result;
    }
    function zipObject(keys, values) {
      const result = {};
      for (let i = 0; i < keys.length; i++) {
        result[keys[i]] = values[i];
      }
      return result;
    }
    function zipWith(arr1, ...rest2) {
      const arrs = [arr1, ...rest2.slice(0, -1)];
      const combine = rest2[rest2.length - 1];
      const maxIndex = Math.max(...arrs.map((arr) => arr.length));
      const result = Array(maxIndex);
      for (let i = 0; i < maxIndex; i++) {
        const elements = arrs.map((arr) => arr[i]);
        result[i] = combine(...elements);
      }
      return result;
    }
    class AbortError extends Error {
      constructor(message = "The operation was aborted") {
        super(message);
        this.name = "AbortError";
      }
    }
    class TimeoutError extends Error {
      constructor(message = "The operation was timed out") {
        super(message);
        this.name = "TimeoutError";
      }
    }
    function after(n, func) {
      if (!Number.isInteger(n) || n < 0) {
        throw new Error(`n must be a non-negative integer.`);
      }
      let counter = 0;
      return (...args) => {
        if (++counter >= n) {
          return func(...args);
        }
        return void 0;
      };
    }
    function ary(func, n) {
      return function(...args) {
        return func.apply(this, args.slice(0, n));
      };
    }
    async function asyncNoop() {
    }
    function before(n, func) {
      if (!Number.isInteger(n) || n < 0) {
        throw new Error("n must be a non-negative integer.");
      }
      let counter = 0;
      return (...args) => {
        if (++counter < n) {
          return func(...args);
        }
        return void 0;
      };
    }
    function curry(func) {
      if (func.length === 0 || func.length === 1) {
        return func;
      }
      return function(arg) {
        return makeCurry(func, func.length, [arg]);
      };
    }
    function makeCurry(origin, argsLength, args) {
      if (args.length === argsLength) {
        return origin(...args);
      } else {
        const next = function(arg) {
          return makeCurry(origin, argsLength, [...args, arg]);
        };
        return next;
      }
    }
    function curryRight(func) {
      if (func.length === 0 || func.length === 1) {
        return func;
      }
      return function(arg) {
        return makeCurryRight(func, func.length, [arg]);
      };
    }
    function makeCurryRight(origin, argsLength, args) {
      if (args.length === argsLength) {
        return origin(...args);
      } else {
        const next = function(arg) {
          return makeCurryRight(origin, argsLength, [arg, ...args]);
        };
        return next;
      }
    }
    function debounce(func, debounceMs, { signal, edges } = {}) {
      let pendingThis = void 0;
      let pendingArgs = null;
      const leading = edges != null && edges.includes("leading");
      const trailing = edges == null || edges.includes("trailing");
      const invoke = () => {
        if (pendingArgs !== null) {
          func.apply(pendingThis, pendingArgs);
          pendingThis = void 0;
          pendingArgs = null;
        }
      };
      const onTimerEnd = () => {
        if (trailing) {
          invoke();
        }
        cancel();
      };
      let timeoutId = null;
      const schedule = () => {
        if (timeoutId != null) {
          clearTimeout(timeoutId);
        }
        timeoutId = setTimeout(() => {
          timeoutId = null;
          onTimerEnd();
        }, debounceMs);
      };
      const cancelTimer = () => {
        if (timeoutId !== null) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }
      };
      const cancel = () => {
        cancelTimer();
        pendingThis = void 0;
        pendingArgs = null;
      };
      const flush = () => {
        cancelTimer();
        invoke();
      };
      const debounced = function(...args) {
        if (signal == null ? void 0 : signal.aborted) {
          return;
        }
        pendingThis = this;
        pendingArgs = args;
        const isFirstCall = timeoutId == null;
        schedule();
        if (leading && isFirstCall) {
          invoke();
        }
      };
      debounced.schedule = schedule;
      debounced.cancel = cancel;
      debounced.flush = flush;
      signal == null ? void 0 : signal.addEventListener("abort", cancel, { once: true });
      return debounced;
    }
    function flow(...funcs) {
      return function(...args) {
        let result = funcs.length ? funcs[0].apply(this, args) : args[0];
        for (let i = 1; i < funcs.length; i++) {
          result = funcs[i].call(this, result);
        }
        return result;
      };
    }
    function flowRight(...funcs) {
      return flow(...funcs.reverse());
    }
    function identity(x) {
      return x;
    }
    function memoize(fn, options = {}) {
      const { cache = /* @__PURE__ */ new Map(), getCacheKey } = options;
      const memoizedFn = function(arg) {
        const key = getCacheKey ? getCacheKey(arg) : arg;
        if (cache.has(key)) {
          return cache.get(key);
        }
        const result = fn.call(this, arg);
        cache.set(key, result);
        return result;
      };
      memoizedFn.cache = cache;
      return memoizedFn;
    }
    function negate(func) {
      return (...args) => !func(...args);
    }
    function noop() {
    }
    function once(func) {
      let called = false;
      let cache;
      return function(...args) {
        if (!called) {
          called = true;
          cache = func(...args);
        }
        return cache;
      };
    }
    function partial(func, ...partialArgs) {
      return partialImpl(func, placeholderSymbol$1, ...partialArgs);
    }
    function partialImpl(func, placeholder, ...partialArgs) {
      const partialed = function(...providedArgs) {
        let providedArgsIndex = 0;
        const substitutedArgs = partialArgs.slice().map((arg) => arg === placeholder ? providedArgs[providedArgsIndex++] : arg);
        const remainingArgs = providedArgs.slice(providedArgsIndex);
        return func.apply(this, substitutedArgs.concat(remainingArgs));
      };
      if (func.prototype) {
        partialed.prototype = Object.create(func.prototype);
      }
      return partialed;
    }
    const placeholderSymbol$1 = Symbol("partial.placeholder");
    partial.placeholder = placeholderSymbol$1;
    function partialRight(func, ...partialArgs) {
      return partialRightImpl(func, placeholderSymbol, ...partialArgs);
    }
    function partialRightImpl(func, placeholder, ...partialArgs) {
      const partialedRight = function(...providedArgs) {
        const placeholderLength = partialArgs.filter((arg) => arg === placeholder).length;
        const rangeLength = Math.max(providedArgs.length - placeholderLength, 0);
        const remainingArgs = providedArgs.slice(0, rangeLength);
        let providedArgsIndex = rangeLength;
        const substitutedArgs = partialArgs.slice().map((arg) => arg === placeholder ? providedArgs[providedArgsIndex++] : arg);
        return func.apply(this, remainingArgs.concat(substitutedArgs));
      };
      if (func.prototype) {
        partialedRight.prototype = Object.create(func.prototype);
      }
      return partialedRight;
    }
    const placeholderSymbol = Symbol("partialRight.placeholder");
    partialRight.placeholder = placeholderSymbol;
    function rest(func, startIndex = func.length - 1) {
      return function(...args) {
        const rest2 = args.slice(startIndex);
        const params = args.slice(0, startIndex);
        while (params.length < startIndex) {
          params.push(void 0);
        }
        return func.apply(this, [...params, rest2]);
      };
    }
    function delay(ms, { signal } = {}) {
      return new Promise((resolve2, reject) => {
        const abortError = () => {
          reject(new AbortError());
        };
        const abortHandler = () => {
          clearTimeout(timeoutId);
          abortError();
        };
        if (signal == null ? void 0 : signal.aborted) {
          return abortError();
        }
        const timeoutId = setTimeout(() => {
          signal == null ? void 0 : signal.removeEventListener("abort", abortHandler);
          resolve2();
        }, ms);
        signal == null ? void 0 : signal.addEventListener("abort", abortHandler, { once: true });
      });
    }
    const DEFAULT_DELAY = 0;
    const DEFAULT_RETRIES = Number.POSITIVE_INFINITY;
    async function retry(func, _options) {
      let delay$1;
      let retries;
      let signal;
      if (typeof _options === "number") {
        delay$1 = DEFAULT_DELAY;
        retries = _options;
        signal = void 0;
      } else {
        delay$1 = (_options == null ? void 0 : _options.delay) ?? DEFAULT_DELAY;
        retries = (_options == null ? void 0 : _options.retries) ?? DEFAULT_RETRIES;
        signal = _options == null ? void 0 : _options.signal;
      }
      let error;
      for (let attempts = 0; attempts < retries; attempts++) {
        if (signal == null ? void 0 : signal.aborted) {
          throw error ?? new Error(`The retry operation was aborted due to an abort signal.`);
        }
        try {
          return await func();
        } catch (err) {
          error = err;
          const currentDelay = typeof delay$1 === "function" ? delay$1(attempts) : delay$1;
          await delay(currentDelay);
        }
      }
      throw error;
    }
    function spread(func) {
      return function(argsArr) {
        return func.apply(this, argsArr);
      };
    }
    function throttle(func, throttleMs, { signal, edges = ["leading", "trailing"] } = {}) {
      let pendingAt = null;
      const debounced = debounce(func, throttleMs, { signal, edges });
      const throttled = function(...args) {
        if (pendingAt == null) {
          pendingAt = Date.now();
        } else {
          if (Date.now() - pendingAt >= throttleMs) {
            pendingAt = Date.now();
            debounced.cancel();
          }
        }
        debounced(...args);
      };
      throttled.cancel = debounced.cancel;
      throttled.flush = debounced.flush;
      return throttled;
    }
    function unary(func) {
      return ary(func, 1);
    }
    function clamp(value, bound1, bound2) {
      if (bound2 == null) {
        return Math.min(value, bound1);
      }
      return Math.min(Math.max(value, bound1), bound2);
    }
    function inRange(value, minimum, maximum) {
      if (maximum == null) {
        maximum = minimum;
        minimum = 0;
      }
      if (minimum >= maximum) {
        throw new Error("The maximum value must be greater than the minimum value.");
      }
      return minimum <= value && value < maximum;
    }
    function sum(nums) {
      let result = 0;
      for (let i = 0; i < nums.length; i++) {
        result += nums[i];
      }
      return result;
    }
    function mean(nums) {
      return sum(nums) / nums.length;
    }
    function meanBy(items2, getValue2) {
      const nums = items2.map((x) => getValue2(x));
      return mean(nums);
    }
    function median(nums) {
      if (nums.length === 0) {
        return NaN;
      }
      const sorted = nums.slice().sort((a, b) => a - b);
      const middleIndex = Math.floor(sorted.length / 2);
      if (sorted.length % 2 === 0) {
        return (sorted[middleIndex - 1] + sorted[middleIndex]) / 2;
      } else {
        return sorted[middleIndex];
      }
    }
    function medianBy(items2, getValue2) {
      const nums = items2.map((x) => getValue2(x));
      return median(nums);
    }
    function range(start, end, step = 1) {
      if (end == null) {
        end = start;
        start = 0;
      }
      if (!Number.isInteger(step) || step === 0) {
        throw new Error(`The step value must be a non-zero integer.`);
      }
      const length = Math.max(Math.ceil((end - start) / step), 0);
      const result = new Array(length);
      for (let i = 0; i < length; i++) {
        result[i] = start + i * step;
      }
      return result;
    }
    function rangeRight(start, end, step = 1) {
      if (end == null) {
        end = start;
        start = 0;
      }
      if (!Number.isInteger(step) || step === 0) {
        throw new Error(`The step value must be a non-zero integer.`);
      }
      const length = Math.max(Math.ceil((end - start) / step), 0);
      const result = new Array(length);
      for (let i = 0; i < length; i++) {
        result[i] = start + (length - i - 1) * step;
      }
      return result;
    }
    function round(value, precision = 0) {
      if (!Number.isInteger(precision)) {
        throw new Error("Precision must be an integer.");
      }
      const multiplier = Math.pow(10, precision);
      return Math.round(value * multiplier) / multiplier;
    }
    function sumBy(items2, getValue2) {
      let result = 0;
      for (let i = 0; i < items2.length; i++) {
        result += getValue2(items2[i]);
      }
      return result;
    }
    function isPrimitive(value) {
      return value == null || typeof value !== "object" && typeof value !== "function";
    }
    function isTypedArray(x) {
      return ArrayBuffer.isView(x) && !(x instanceof DataView);
    }
    function clone(obj) {
      if (isPrimitive(obj)) {
        return obj;
      }
      if (Array.isArray(obj) || isTypedArray(obj) || obj instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && obj instanceof SharedArrayBuffer) {
        return obj.slice(0);
      }
      const prototype = Object.getPrototypeOf(obj);
      const Constructor = prototype.constructor;
      if (obj instanceof Date || obj instanceof Map || obj instanceof Set) {
        return new Constructor(obj);
      }
      if (obj instanceof RegExp) {
        const newRegExp = new Constructor(obj);
        newRegExp.lastIndex = obj.lastIndex;
        return newRegExp;
      }
      if (obj instanceof DataView) {
        return new Constructor(obj.buffer.slice(0));
      }
      if (obj instanceof Error) {
        const newError = new Constructor(obj.message);
        newError.stack = obj.stack;
        newError.name = obj.name;
        newError.cause = obj.cause;
        return newError;
      }
      if (typeof File !== "undefined" && obj instanceof File) {
        const newFile = new Constructor([obj], obj.name, { type: obj.type, lastModified: obj.lastModified });
        return newFile;
      }
      if (typeof obj === "object") {
        const newObject = Object.create(prototype);
        return Object.assign(newObject, obj);
      }
      return obj;
    }
    function getSymbols(object) {
      return Object.getOwnPropertySymbols(object).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object, symbol));
    }
    function getTag(value) {
      if (value == null) {
        return value === void 0 ? "[object Undefined]" : "[object Null]";
      }
      return Object.prototype.toString.call(value);
    }
    const regexpTag = "[object RegExp]";
    const stringTag = "[object String]";
    const numberTag = "[object Number]";
    const booleanTag = "[object Boolean]";
    const argumentsTag = "[object Arguments]";
    const symbolTag = "[object Symbol]";
    const dateTag = "[object Date]";
    const mapTag = "[object Map]";
    const setTag = "[object Set]";
    const arrayTag = "[object Array]";
    const functionTag = "[object Function]";
    const arrayBufferTag = "[object ArrayBuffer]";
    const objectTag = "[object Object]";
    const errorTag = "[object Error]";
    const dataViewTag = "[object DataView]";
    const uint8ArrayTag = "[object Uint8Array]";
    const uint8ClampedArrayTag = "[object Uint8ClampedArray]";
    const uint16ArrayTag = "[object Uint16Array]";
    const uint32ArrayTag = "[object Uint32Array]";
    const bigUint64ArrayTag = "[object BigUint64Array]";
    const int8ArrayTag = "[object Int8Array]";
    const int16ArrayTag = "[object Int16Array]";
    const int32ArrayTag = "[object Int32Array]";
    const bigInt64ArrayTag = "[object BigInt64Array]";
    const float32ArrayTag = "[object Float32Array]";
    const float64ArrayTag = "[object Float64Array]";
    function cloneDeepWith(obj, cloneValue) {
      return cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), cloneValue);
    }
    function cloneDeepWithImpl(valueToClone, keyToClone, objectToClone, stack2 = /* @__PURE__ */ new Map(), cloneValue = void 0) {
      const cloned = cloneValue == null ? void 0 : cloneValue(valueToClone, keyToClone, objectToClone, stack2);
      if (cloned != null) {
        return cloned;
      }
      if (isPrimitive(valueToClone)) {
        return valueToClone;
      }
      if (stack2.has(valueToClone)) {
        return stack2.get(valueToClone);
      }
      if (Array.isArray(valueToClone)) {
        const result = new Array(valueToClone.length);
        stack2.set(valueToClone, result);
        for (let i = 0; i < valueToClone.length; i++) {
          result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack2, cloneValue);
        }
        if (Object.hasOwn(valueToClone, "index")) {
          result.index = valueToClone.index;
        }
        if (Object.hasOwn(valueToClone, "input")) {
          result.input = valueToClone.input;
        }
        return result;
      }
      if (valueToClone instanceof Date) {
        return new Date(valueToClone.getTime());
      }
      if (valueToClone instanceof RegExp) {
        const result = new RegExp(valueToClone.source, valueToClone.flags);
        result.lastIndex = valueToClone.lastIndex;
        return result;
      }
      if (valueToClone instanceof Map) {
        const result = /* @__PURE__ */ new Map();
        stack2.set(valueToClone, result);
        for (const [key, value] of valueToClone) {
          result.set(key, cloneDeepWithImpl(value, key, objectToClone, stack2, cloneValue));
        }
        return result;
      }
      if (valueToClone instanceof Set) {
        const result = /* @__PURE__ */ new Set();
        stack2.set(valueToClone, result);
        for (const value of valueToClone) {
          result.add(cloneDeepWithImpl(value, void 0, objectToClone, stack2, cloneValue));
        }
        return result;
      }
      if (typeof Buffer !== "undefined" && Buffer.isBuffer(valueToClone)) {
        return valueToClone.subarray();
      }
      if (isTypedArray(valueToClone)) {
        const result = new (Object.getPrototypeOf(valueToClone)).constructor(valueToClone.length);
        stack2.set(valueToClone, result);
        for (let i = 0; i < valueToClone.length; i++) {
          result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack2, cloneValue);
        }
        return result;
      }
      if (valueToClone instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && valueToClone instanceof SharedArrayBuffer) {
        return valueToClone.slice(0);
      }
      if (valueToClone instanceof DataView) {
        const result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);
        stack2.set(valueToClone, result);
        copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
        return result;
      }
      if (typeof File !== "undefined" && valueToClone instanceof File) {
        const result = new File([valueToClone], valueToClone.name, {
          type: valueToClone.type
        });
        stack2.set(valueToClone, result);
        copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
        return result;
      }
      if (valueToClone instanceof Blob) {
        const result = new Blob([valueToClone], { type: valueToClone.type });
        stack2.set(valueToClone, result);
        copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
        return result;
      }
      if (valueToClone instanceof Error) {
        const result = new valueToClone.constructor();
        stack2.set(valueToClone, result);
        result.message = valueToClone.message;
        result.name = valueToClone.name;
        result.stack = valueToClone.stack;
        result.cause = valueToClone.cause;
        copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
        return result;
      }
      if (typeof valueToClone === "object" && isCloneableObject(valueToClone)) {
        const result = Object.create(Object.getPrototypeOf(valueToClone));
        stack2.set(valueToClone, result);
        copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
        return result;
      }
      return valueToClone;
    }
    function copyProperties(target, source, objectToClone = target, stack2, cloneValue) {
      const keys = [...Object.keys(source), ...getSymbols(source)];
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const descriptor = Object.getOwnPropertyDescriptor(target, key);
        if (descriptor == null || descriptor.writable) {
          target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack2, cloneValue);
        }
      }
    }
    function isCloneableObject(object) {
      switch (getTag(object)) {
        case argumentsTag:
        case arrayTag:
        case arrayBufferTag:
        case dataViewTag:
        case booleanTag:
        case dateTag:
        case float32ArrayTag:
        case float64ArrayTag:
        case int8ArrayTag:
        case int16ArrayTag:
        case int32ArrayTag:
        case mapTag:
        case numberTag:
        case objectTag:
        case regexpTag:
        case setTag:
        case stringTag:
        case symbolTag:
        case uint8ArrayTag:
        case uint8ClampedArrayTag:
        case uint16ArrayTag:
        case uint32ArrayTag: {
          return true;
        }
        default: {
          return false;
        }
      }
    }
    function cloneDeep(obj) {
      return cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), void 0);
    }
    function findKey(obj, predicate) {
      const keys = Object.keys(obj);
      return keys.find((key) => predicate(obj[key], key, obj));
    }
    function isPlainObject$1(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      const proto = Object.getPrototypeOf(value);
      const hasObjectPrototype = proto === null || proto === Object.prototype || Object.getPrototypeOf(proto) === null;
      if (!hasObjectPrototype) {
        return false;
      }
      return Object.prototype.toString.call(value) === "[object Object]";
    }
    function flattenObject(object, { delimiter = "." } = {}) {
      return flattenObjectImpl(object, "", delimiter);
    }
    function flattenObjectImpl(object, prefix = "", delimiter = ".") {
      const result = {};
      const keys = Object.keys(object);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = object[key];
        const prefixedKey = prefix ? `${prefix}${delimiter}${key}` : key;
        if (isPlainObject$1(value) && Object.keys(value).length > 0) {
          Object.assign(result, flattenObjectImpl(value, prefixedKey, delimiter));
          continue;
        }
        if (Array.isArray(value)) {
          Object.assign(result, flattenObjectImpl(value, prefixedKey, delimiter));
          continue;
        }
        result[prefixedKey] = value;
      }
      return result;
    }
    function invert(obj) {
      const result = {};
      const keys = Object.keys(obj);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = obj[key];
        result[value] = key;
      }
      return result;
    }
    function mapKeys(object, getNewKey) {
      const result = {};
      const keys = Object.keys(object);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = object[key];
        result[getNewKey(value, key, object)] = value;
      }
      return result;
    }
    function mapValues(object, getNewValue) {
      const result = {};
      const keys = Object.keys(object);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = object[key];
        result[key] = getNewValue(value, key, object);
      }
      return result;
    }
    function merge(target, source) {
      const sourceKeys = Object.keys(source);
      for (let i = 0; i < sourceKeys.length; i++) {
        const key = sourceKeys[i];
        const sourceValue = source[key];
        const targetValue = target[key];
        if (Array.isArray(sourceValue)) {
          if (Array.isArray(targetValue)) {
            target[key] = merge(targetValue, sourceValue);
          } else {
            target[key] = merge([], sourceValue);
          }
        } else if (isPlainObject$1(sourceValue)) {
          if (isPlainObject$1(targetValue)) {
            target[key] = merge(targetValue, sourceValue);
          } else {
            target[key] = merge({}, sourceValue);
          }
        } else if (targetValue === void 0 || sourceValue !== void 0) {
          target[key] = sourceValue;
        }
      }
      return target;
    }
    function isObjectLike(value) {
      return typeof value === "object" && value !== null;
    }
    function mergeWith(target, source, merge2) {
      const sourceKeys = Object.keys(source);
      for (let i = 0; i < sourceKeys.length; i++) {
        const key = sourceKeys[i];
        const sourceValue = source[key];
        const targetValue = target[key];
        const merged = merge2(targetValue, sourceValue, key, target, source);
        if (merged != null) {
          target[key] = merged;
        } else if (Array.isArray(sourceValue)) {
          target[key] = mergeWith(targetValue ?? [], sourceValue, merge2);
        } else if (isObjectLike(targetValue) && isObjectLike(sourceValue)) {
          target[key] = mergeWith(targetValue ?? {}, sourceValue, merge2);
        } else if (targetValue === void 0 || sourceValue !== void 0) {
          target[key] = sourceValue;
        }
      }
      return target;
    }
    function omit(obj, keys) {
      const result = { ...obj };
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        delete result[key];
      }
      return result;
    }
    function omitBy(obj, shouldOmit) {
      const result = {};
      const keys = Object.keys(obj);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = obj[key];
        if (!shouldOmit(value, key)) {
          result[key] = value;
        }
      }
      return result;
    }
    function pick(obj, keys) {
      const result = {};
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (Object.hasOwn(obj, key)) {
          result[key] = obj[key];
        }
      }
      return result;
    }
    function pickBy(obj, shouldPick) {
      const result = {};
      const keys = Object.keys(obj);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = obj[key];
        if (shouldPick(value, key)) {
          result[key] = value;
        }
      }
      return result;
    }
    function isArray(value) {
      return Array.isArray(value);
    }
    function capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
    }
    const CASE_SPLIT_PATTERN = new RegExp("\\p{Lu}?\\p{Ll}+|[0-9]+|\\p{Lu}+(?!\\p{Ll})|\\p{Emoji_Presentation}|\\p{Extended_Pictographic}|\\p{L}+", "gu");
    function words(str) {
      return Array.from(str.match(CASE_SPLIT_PATTERN) ?? []);
    }
    function camelCase(str) {
      const words$1 = words(str);
      if (words$1.length === 0) {
        return "";
      }
      const [first, ...rest2] = words$1;
      return `${first.toLowerCase()}${rest2.map((word) => capitalize(word)).join("")}`;
    }
    function toCamelCaseKeys(obj) {
      if (isArray(obj)) {
        return obj.map((item) => toCamelCaseKeys(item));
      }
      if (isPlainObject$1(obj)) {
        const result = {};
        const keys = Object.keys(obj);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const camelKey = camelCase(key);
          const camelCaseKeys = toCamelCaseKeys(obj[key]);
          result[camelKey] = camelCaseKeys;
        }
        return result;
      }
      return obj;
    }
    function toMerged(target, source) {
      return merge(cloneDeep(target), source);
    }
    function isPlainObject(object) {
      var _a;
      if (typeof object !== "object") {
        return false;
      }
      if (object == null) {
        return false;
      }
      if (Object.getPrototypeOf(object) === null) {
        return true;
      }
      if (Object.prototype.toString.call(object) !== "[object Object]") {
        const tag = object[Symbol.toStringTag];
        if (tag == null) {
          return false;
        }
        const isTagReadonly = !((_a = Object.getOwnPropertyDescriptor(object, Symbol.toStringTag)) == null ? void 0 : _a.writable);
        if (isTagReadonly) {
          return false;
        }
        return object.toString() === `[object ${tag}]`;
      }
      let proto = object;
      while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
      }
      return Object.getPrototypeOf(object) === proto;
    }
    function snakeCase(str) {
      const words$1 = words(str);
      return words$1.map((word) => word.toLowerCase()).join("_");
    }
    function toSnakeCaseKeys(obj) {
      if (isArray(obj)) {
        return obj.map((item) => toSnakeCaseKeys(item));
      }
      if (isPlainObject(obj)) {
        const result = {};
        const keys = Object.keys(obj);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const snakeKey = snakeCase(key);
          const snakeCaseKeys = toSnakeCaseKeys(obj[key]);
          result[snakeKey] = snakeCaseKeys;
        }
        return result;
      }
      return obj;
    }
    function isArrayBuffer(value) {
      return value instanceof ArrayBuffer;
    }
    function isBlob(x) {
      if (typeof Blob === "undefined") {
        return false;
      }
      return x instanceof Blob;
    }
    function isBoolean(x) {
      return typeof x === "boolean";
    }
    function isBrowser() {
      return typeof window !== "undefined" && (window == null ? void 0 : window.document) != null;
    }
    function isBuffer(x) {
      return typeof Buffer !== "undefined" && Buffer.isBuffer(x);
    }
    function isDate(value) {
      return value instanceof Date;
    }
    function eq(value, other) {
      return value === other || Number.isNaN(value) && Number.isNaN(other);
    }
    function isEqualWith(a, b, areValuesEqual) {
      return isEqualWithImpl(a, b, void 0, void 0, void 0, void 0, areValuesEqual);
    }
    function isEqualWithImpl(a, b, property, aParent, bParent, stack2, areValuesEqual) {
      const result = areValuesEqual(a, b, property, aParent, bParent, stack2);
      if (result !== void 0) {
        return result;
      }
      if (typeof a === typeof b) {
        switch (typeof a) {
          case "bigint":
          case "string":
          case "boolean":
          case "symbol":
          case "undefined": {
            return a === b;
          }
          case "number": {
            return a === b || Object.is(a, b);
          }
          case "function": {
            return a === b;
          }
          case "object": {
            return areObjectsEqual(a, b, stack2, areValuesEqual);
          }
        }
      }
      return areObjectsEqual(a, b, stack2, areValuesEqual);
    }
    function areObjectsEqual(a, b, stack2, areValuesEqual) {
      if (Object.is(a, b)) {
        return true;
      }
      let aTag = getTag(a);
      let bTag = getTag(b);
      if (aTag === argumentsTag) {
        aTag = objectTag;
      }
      if (bTag === argumentsTag) {
        bTag = objectTag;
      }
      if (aTag !== bTag) {
        return false;
      }
      switch (aTag) {
        case stringTag:
          return a.toString() === b.toString();
        case numberTag: {
          const x = a.valueOf();
          const y = b.valueOf();
          return eq(x, y);
        }
        case booleanTag:
        case dateTag:
        case symbolTag:
          return Object.is(a.valueOf(), b.valueOf());
        case regexpTag: {
          return a.source === b.source && a.flags === b.flags;
        }
        case functionTag: {
          return a === b;
        }
      }
      stack2 = stack2 ?? /* @__PURE__ */ new Map();
      const aStack = stack2.get(a);
      const bStack = stack2.get(b);
      if (aStack != null && bStack != null) {
        return aStack === b;
      }
      stack2.set(a, b);
      stack2.set(b, a);
      try {
        switch (aTag) {
          case mapTag: {
            if (a.size !== b.size) {
              return false;
            }
            for (const [key, value] of a.entries()) {
              if (!b.has(key) || !isEqualWithImpl(value, b.get(key), key, a, b, stack2, areValuesEqual)) {
                return false;
              }
            }
            return true;
          }
          case setTag: {
            if (a.size !== b.size) {
              return false;
            }
            const aValues = Array.from(a.values());
            const bValues = Array.from(b.values());
            for (let i = 0; i < aValues.length; i++) {
              const aValue = aValues[i];
              const index = bValues.findIndex((bValue) => {
                return isEqualWithImpl(aValue, bValue, void 0, a, b, stack2, areValuesEqual);
              });
              if (index === -1) {
                return false;
              }
              bValues.splice(index, 1);
            }
            return true;
          }
          case arrayTag:
          case uint8ArrayTag:
          case uint8ClampedArrayTag:
          case uint16ArrayTag:
          case uint32ArrayTag:
          case bigUint64ArrayTag:
          case int8ArrayTag:
          case int16ArrayTag:
          case int32ArrayTag:
          case bigInt64ArrayTag:
          case float32ArrayTag:
          case float64ArrayTag: {
            if (typeof Buffer !== "undefined" && Buffer.isBuffer(a) !== Buffer.isBuffer(b)) {
              return false;
            }
            if (a.length !== b.length) {
              return false;
            }
            for (let i = 0; i < a.length; i++) {
              if (!isEqualWithImpl(a[i], b[i], i, a, b, stack2, areValuesEqual)) {
                return false;
              }
            }
            return true;
          }
          case arrayBufferTag: {
            if (a.byteLength !== b.byteLength) {
              return false;
            }
            return areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack2, areValuesEqual);
          }
          case dataViewTag: {
            if (a.byteLength !== b.byteLength || a.byteOffset !== b.byteOffset) {
              return false;
            }
            return areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack2, areValuesEqual);
          }
          case errorTag: {
            return a.name === b.name && a.message === b.message;
          }
          case objectTag: {
            const areEqualInstances = areObjectsEqual(a.constructor, b.constructor, stack2, areValuesEqual) || isPlainObject$1(a) && isPlainObject$1(b);
            if (!areEqualInstances) {
              return false;
            }
            const aKeys = [...Object.keys(a), ...getSymbols(a)];
            const bKeys = [...Object.keys(b), ...getSymbols(b)];
            if (aKeys.length !== bKeys.length) {
              return false;
            }
            for (let i = 0; i < aKeys.length; i++) {
              const propKey = aKeys[i];
              const aProp = a[propKey];
              if (!Object.hasOwn(b, propKey)) {
                return false;
              }
              const bProp = b[propKey];
              if (!isEqualWithImpl(aProp, bProp, propKey, a, b, stack2, areValuesEqual)) {
                return false;
              }
            }
            return true;
          }
          default: {
            return false;
          }
        }
      } finally {
        stack2.delete(a);
        stack2.delete(b);
      }
    }
    function isEqual(a, b) {
      return isEqualWith(a, b, noop);
    }
    function isError(value) {
      return value instanceof Error;
    }
    function isFile(x) {
      if (typeof File === "undefined") {
        return false;
      }
      return isBlob(x) && x instanceof File;
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isJSON(value) {
      if (typeof value !== "string") {
        return false;
      }
      try {
        JSON.parse(value);
        return true;
      } catch {
        return false;
      }
    }
    function isJSONValue(value) {
      switch (typeof value) {
        case "object": {
          return value === null || isJSONArray(value) || isJSONObject(value);
        }
        case "string":
        case "number":
        case "boolean": {
          return true;
        }
        default: {
          return false;
        }
      }
    }
    function isJSONArray(value) {
      if (!Array.isArray(value)) {
        return false;
      }
      return value.every((item) => isJSONValue(item));
    }
    function isJSONObject(obj) {
      if (!isPlainObject$1(obj)) {
        return false;
      }
      const keys = Reflect.ownKeys(obj);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = obj[key];
        if (typeof key !== "string") {
          return false;
        }
        if (!isJSONValue(value)) {
          return false;
        }
      }
      return true;
    }
    function isLength(value) {
      return Number.isSafeInteger(value) && value >= 0;
    }
    function isMap(value) {
      return value instanceof Map;
    }
    function isNil(x) {
      return x == null;
    }
    function isNode() {
      var _a;
      return typeof process !== "undefined" && ((_a = process == null ? void 0 : process.versions) == null ? void 0 : _a.node) != null;
    }
    function isNotNil(x) {
      return x != null;
    }
    function isNull(x) {
      return x === null;
    }
    function isPromise(value) {
      return value instanceof Promise;
    }
    function isRegExp(value) {
      return value instanceof RegExp;
    }
    function isSet(value) {
      return value instanceof Set;
    }
    function isString(value) {
      return typeof value === "string";
    }
    function isSymbol(value) {
      return typeof value === "symbol";
    }
    function isUndefined(x) {
      return x === void 0;
    }
    function isWeakMap(value) {
      return value instanceof WeakMap;
    }
    function isWeakSet(value) {
      return value instanceof WeakSet;
    }
    class Semaphore {
      constructor(capacity) {
        __publicField(this, "capacity");
        __publicField(this, "available");
        __publicField(this, "deferredTasks", []);
        this.capacity = capacity;
        this.available = capacity;
      }
      async acquire() {
        if (this.available > 0) {
          this.available--;
          return;
        }
        return new Promise((resolve2) => {
          this.deferredTasks.push(resolve2);
        });
      }
      release() {
        const deferredTask = this.deferredTasks.shift();
        if (deferredTask != null) {
          deferredTask();
          return;
        }
        if (this.available < this.capacity) {
          this.available++;
        }
      }
    }
    class Mutex {
      constructor() {
        __publicField(this, "semaphore", new Semaphore(1));
      }
      get isLocked() {
        return this.semaphore.available === 0;
      }
      async acquire() {
        return this.semaphore.acquire();
      }
      release() {
        this.semaphore.release();
      }
    }
    async function timeout(ms) {
      await delay(ms);
      throw new TimeoutError();
    }
    async function withTimeout(run, ms) {
      return Promise.race([run(), timeout(ms)]);
    }
    function constantCase(str) {
      const words$1 = words(str);
      return words$1.map((word) => word.toUpperCase()).join("_");
    }
    const deburrMap = new Map(Object.entries({
      : "Ae",
      : "D",
      : "O",
      : "Th",
      : "ss",
      : "ae",
      : "d",
      : "o",
      : "th",
      : "D",
      : "d",
      : "H",
      : "h",
      : "i",
      : "IJ",
      : "ij",
      : "k",
      : "L",
      : "l",
      : "L",
      : "l",
      : "'n",
      : "N",
      : "n",
      : "Oe",
      : "oe",
      : "T",
      : "t",
      : "s"
    }));
    function deburr(str) {
      str = str.normalize("NFD");
      let result = "";
      for (let i = 0; i < str.length; i++) {
        const char = str[i];
        if (char >= "" && char <= "" || char >= "" && char <= "") {
          continue;
        }
        result += deburrMap.get(char) ?? char;
      }
      return result;
    }
    const htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    function escape$1(str) {
      return str.replace(/[&<>"']/g, (match) => htmlEscapes[match]);
    }
    function escapeRegExp(str) {
      return str.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&");
    }
    function kebabCase(str) {
      const words$1 = words(str);
      return words$1.map((word) => word.toLowerCase()).join("-");
    }
    function lowerCase(str) {
      const words$1 = words(str);
      return words$1.map((word) => word.toLowerCase()).join(" ");
    }
    function lowerFirst(str) {
      return str.substring(0, 1).toLowerCase() + str.substring(1);
    }
    function pad(str, length, chars = " ") {
      return str.padStart(Math.floor((length - str.length) / 2) + str.length, chars).padEnd(length, chars);
    }
    function pascalCase(str) {
      const words$1 = words(str);
      return words$1.map((word) => capitalize(word)).join("");
    }
    function reverseString(value) {
      return [...value].reverse().join("");
    }
    function startCase(str) {
      const words$1 = words(str.trim());
      let result = "";
      for (let i = 0; i < words$1.length; i++) {
        const word = words$1[i];
        if (result) {
          result += " ";
        }
        result += word[0].toUpperCase() + word.slice(1).toLowerCase();
      }
      return result;
    }
    function trimEnd(str, chars) {
      if (chars === void 0) {
        return str.trimEnd();
      }
      let endIndex = str.length;
      switch (typeof chars) {
        case "string": {
          if (chars.length !== 1) {
            throw new Error(`The 'chars' parameter should be a single character string.`);
          }
          while (endIndex > 0 && str[endIndex - 1] === chars) {
            endIndex--;
          }
          break;
        }
        case "object": {
          while (endIndex > 0 && chars.includes(str[endIndex - 1])) {
            endIndex--;
          }
        }
      }
      return str.substring(0, endIndex);
    }
    function trimStart(str, chars) {
      if (chars === void 0) {
        return str.trimStart();
      }
      let startIndex = 0;
      switch (typeof chars) {
        case "string": {
          while (startIndex < str.length && str[startIndex] === chars) {
            startIndex++;
          }
          break;
        }
        case "object": {
          while (startIndex < str.length && chars.includes(str[startIndex])) {
            startIndex++;
          }
        }
      }
      return str.substring(startIndex);
    }
    function trim(str, chars) {
      if (chars === void 0) {
        return str.trim();
      }
      return trimStart(trimEnd(str, chars), chars);
    }
    const htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    function unescape$1(str) {
      return str.replace(/&(?:amp|lt|gt|quot|#(0+)?39);/g, (match) => htmlUnescapes[match] || "'");
    }
    function upperCase(str) {
      const words$1 = words(str);
      let result = "";
      for (let i = 0; i < words$1.length; i++) {
        result += words$1[i].toUpperCase();
        if (i < words$1.length - 1) {
          result += " ";
        }
      }
      return result;
    }
    function upperFirst(str) {
      return str.substring(0, 1).toUpperCase() + str.substring(1);
    }
    function attempt(func) {
      try {
        return [null, func()];
      } catch (error) {
        return [error, null];
      }
    }
    async function attemptAsync(func) {
      try {
        const result = await func();
        return [null, result];
      } catch (error) {
        return [error, null];
      }
    }
    function invariant(condition, message) {
      if (condition) {
        return;
      }
      throw new Error(message);
    }
    function getDefaultsFromSchema(schema) {
      const result = {};
      const properties2 = schema.properties || {};
      const requiredProps = Array.isArray(schema.required) ? schema.required : [];
      console.log("getDefaultsFromSchema");
      for (const [key, value] of Object.entries(properties2)) {
        console.log(key);
        console.log(value);
        result[key] = {
          required: requiredProps.includes(key),
          value: value.default ?? ""
        };
        if ("nodeType" in value) {
          result[key].type = value.nodeType;
        }
      }
      return result;
    }
    function getCredentialsFromSchema(schema) {
      const result = {};
      const properties2 = schema.properties || {};
      const requiredProps = Array.isArray(schema.required) ? schema.required : [];
      for (const [key, value] of Object.entries(properties2)) {
        console.log(value);
        if (Array.isArray(value)) {
        }
        const isPassword = value.format === "password";
        result[key] = {
          type: isPassword ? "password" : "text",
          required: requiredProps.includes(key),
          value: value.default ?? ""
        };
      }
      return result;
    }
    function extendPatternWithPWD(pattern2) {
      const original = new RegExp(`^${pattern2}$`);
      const pwd = /^__PWD__$/;
      const combined = new RegExp(`(?:${original.source}|${pwd.source})`);
      return combined.source;
    }
    function patchPasswordPatterns(schema) {
      if (!("properties" in schema)) return;
      const props = schema.properties;
      for (const [key, value] of Object.entries(props)) {
        const prop = value;
        if (prop.format === "password" && typeof prop.pattern === "string") {
          prop.pattern = extendPatternWithPWD(prop.pattern);
          prop.minLength = 0;
        }
      }
    }
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs(x) {
      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
    }
    function getDefaultExportFromNamespaceIfPresent(n) {
      return n && Object.prototype.hasOwnProperty.call(n, "default") ? n["default"] : n;
    }
    function getDefaultExportFromNamespaceIfNotNamed(n) {
      return n && Object.prototype.hasOwnProperty.call(n, "default") && Object.keys(n).length === 1 ? n["default"] : n;
    }
    function getAugmentedNamespace(n) {
      if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
      var f = n.default;
      if (typeof f == "function") {
        var a = function a2() {
          if (this instanceof a2) {
            return Reflect.construct(f, arguments, this.constructor);
          }
          return f.apply(this, arguments);
        };
        a.prototype = f.prototype;
      } else a = {};
      Object.defineProperty(a, "__esModule", { value: true });
      Object.keys(n).forEach(function(k) {
        var d = Object.getOwnPropertyDescriptor(n, k);
        Object.defineProperty(a, k, d.get ? d : {
          enumerable: true,
          get: function() {
            return n[k];
          }
        });
      });
      return a;
    }
    var ajv$1 = { exports: {} };
    var core$1 = {};
    var validate = {};
    var boolSchema = {};
    var errors = {};
    var codegen = {};
    var code$1 = {};
    var hasRequiredCode$1;
    function requireCode$1() {
      if (hasRequiredCode$1) return code$1;
      hasRequiredCode$1 = 1;
      (function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
        class _CodeOrName {
        }
        exports._CodeOrName = _CodeOrName;
        exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
        class Name extends _CodeOrName {
          constructor(s) {
            super();
            if (!exports.IDENTIFIER.test(s))
              throw new Error("CodeGen: name must be a valid identifier");
            this.str = s;
          }
          toString() {
            return this.str;
          }
          emptyStr() {
            return false;
          }
          get names() {
            return { [this.str]: 1 };
          }
        }
        exports.Name = Name;
        class _Code extends _CodeOrName {
          constructor(code2) {
            super();
            this._items = typeof code2 === "string" ? [code2] : code2;
          }
          toString() {
            return this.str;
          }
          emptyStr() {
            if (this._items.length > 1)
              return false;
            const item = this._items[0];
            return item === "" || item === '""';
          }
          get str() {
            var _a;
            return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
          }
          get names() {
            var _a;
            return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names2, c) => {
              if (c instanceof Name)
                names2[c.str] = (names2[c.str] || 0) + 1;
              return names2;
            }, {});
          }
        }
        exports._Code = _Code;
        exports.nil = new _Code("");
        function _(strs, ...args) {
          const code2 = [strs[0]];
          let i = 0;
          while (i < args.length) {
            addCodeArg(code2, args[i]);
            code2.push(strs[++i]);
          }
          return new _Code(code2);
        }
        exports._ = _;
        const plus = new _Code("+");
        function str(strs, ...args) {
          const expr = [safeStringify(strs[0])];
          let i = 0;
          while (i < args.length) {
            expr.push(plus);
            addCodeArg(expr, args[i]);
            expr.push(plus, safeStringify(strs[++i]));
          }
          optimize(expr);
          return new _Code(expr);
        }
        exports.str = str;
        function addCodeArg(code2, arg) {
          if (arg instanceof _Code)
            code2.push(...arg._items);
          else if (arg instanceof Name)
            code2.push(arg);
          else
            code2.push(interpolate(arg));
        }
        exports.addCodeArg = addCodeArg;
        function optimize(expr) {
          let i = 1;
          while (i < expr.length - 1) {
            if (expr[i] === plus) {
              const res = mergeExprItems(expr[i - 1], expr[i + 1]);
              if (res !== void 0) {
                expr.splice(i - 1, 3, res);
                continue;
              }
              expr[i++] = "+";
            }
            i++;
          }
        }
        function mergeExprItems(a, b) {
          if (b === '""')
            return a;
          if (a === '""')
            return b;
          if (typeof a == "string") {
            if (b instanceof Name || a[a.length - 1] !== '"')
              return;
            if (typeof b != "string")
              return `${a.slice(0, -1)}${b}"`;
            if (b[0] === '"')
              return a.slice(0, -1) + b.slice(1);
            return;
          }
          if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
            return `"${a}${b.slice(1)}`;
          return;
        }
        function strConcat(c1, c2) {
          return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
        }
        exports.strConcat = strConcat;
        function interpolate(x) {
          return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
        }
        function stringify(x) {
          return new _Code(safeStringify(x));
        }
        exports.stringify = stringify;
        function safeStringify(x) {
          return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
        }
        exports.safeStringify = safeStringify;
        function getProperty(key) {
          return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
        }
        exports.getProperty = getProperty;
        function getEsmExportName(key) {
          if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
            return new _Code(`${key}`);
          }
          throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
        }
        exports.getEsmExportName = getEsmExportName;
        function regexpCode(rx) {
          return new _Code(rx.toString());
        }
        exports.regexpCode = regexpCode;
      })(code$1);
      return code$1;
    }
    var scope = {};
    var hasRequiredScope;
    function requireScope() {
      if (hasRequiredScope) return scope;
      hasRequiredScope = 1;
      (function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
        const code_1 = requireCode$1();
        class ValueError extends Error {
          constructor(name) {
            super(`CodeGen: "code" for ${name} not defined`);
            this.value = name.value;
          }
        }
        var UsedValueState;
        (function(UsedValueState2) {
          UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
          UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
        })(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
        exports.varKinds = {
          const: new code_1.Name("const"),
          let: new code_1.Name("let"),
          var: new code_1.Name("var")
        };
        class Scope {
          constructor({ prefixes: prefixes2, parent } = {}) {
            this._names = {};
            this._prefixes = prefixes2;
            this._parent = parent;
          }
          toName(nameOrPrefix) {
            return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
          }
          name(prefix) {
            return new code_1.Name(this._newName(prefix));
          }
          _newName(prefix) {
            const ng = this._names[prefix] || this._nameGroup(prefix);
            return `${prefix}${ng.index++}`;
          }
          _nameGroup(prefix) {
            var _a, _b;
            if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
              throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
            }
            return this._names[prefix] = { prefix, index: 0 };
          }
        }
        exports.Scope = Scope;
        class ValueScopeName extends code_1.Name {
          constructor(prefix, nameStr) {
            super(nameStr);
            this.prefix = prefix;
          }
          setValue(value, { property, itemIndex }) {
            this.value = value;
            this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
          }
        }
        exports.ValueScopeName = ValueScopeName;
        const line = (0, code_1._)`\n`;
        class ValueScope extends Scope {
          constructor(opts) {
            super(opts);
            this._values = {};
            this._scope = opts.scope;
            this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
          }
          get() {
            return this._scope;
          }
          name(prefix) {
            return new ValueScopeName(prefix, this._newName(prefix));
          }
          value(nameOrPrefix, value) {
            var _a;
            if (value.ref === void 0)
              throw new Error("CodeGen: ref must be passed in value");
            const name = this.toName(nameOrPrefix);
            const { prefix } = name;
            const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
            let vs = this._values[prefix];
            if (vs) {
              const _name = vs.get(valueKey);
              if (_name)
                return _name;
            } else {
              vs = this._values[prefix] = /* @__PURE__ */ new Map();
            }
            vs.set(valueKey, name);
            const s = this._scope[prefix] || (this._scope[prefix] = []);
            const itemIndex = s.length;
            s[itemIndex] = value.ref;
            name.setValue(value, { property: prefix, itemIndex });
            return name;
          }
          getValue(prefix, keyOrRef) {
            const vs = this._values[prefix];
            if (!vs)
              return;
            return vs.get(keyOrRef);
          }
          scopeRefs(scopeName, values = this._values) {
            return this._reduceValues(values, (name) => {
              if (name.scopePath === void 0)
                throw new Error(`CodeGen: name "${name}" has no value`);
              return (0, code_1._)`${scopeName}${name.scopePath}`;
            });
          }
          scopeCode(values = this._values, usedValues, getCode) {
            return this._reduceValues(values, (name) => {
              if (name.value === void 0)
                throw new Error(`CodeGen: name "${name}" has no value`);
              return name.value.code;
            }, usedValues, getCode);
          }
          _reduceValues(values, valueCode, usedValues = {}, getCode) {
            let code2 = code_1.nil;
            for (const prefix in values) {
              const vs = values[prefix];
              if (!vs)
                continue;
              const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
              vs.forEach((name) => {
                if (nameSet.has(name))
                  return;
                nameSet.set(name, UsedValueState.Started);
                let c = valueCode(name);
                if (c) {
                  const def2 = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
                  code2 = (0, code_1._)`${code2}${def2} ${name} = ${c};${this.opts._n}`;
                } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
                  code2 = (0, code_1._)`${code2}${c}${this.opts._n}`;
                } else {
                  throw new ValueError(name);
                }
                nameSet.set(name, UsedValueState.Completed);
              });
            }
            return code2;
          }
        }
        exports.ValueScope = ValueScope;
      })(scope);
      return scope;
    }
    var hasRequiredCodegen;
    function requireCodegen() {
      if (hasRequiredCodegen) return codegen;
      hasRequiredCodegen = 1;
      (function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
        const code_1 = requireCode$1();
        const scope_1 = requireScope();
        var code_2 = requireCode$1();
        Object.defineProperty(exports, "_", { enumerable: true, get: function() {
          return code_2._;
        } });
        Object.defineProperty(exports, "str", { enumerable: true, get: function() {
          return code_2.str;
        } });
        Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
          return code_2.strConcat;
        } });
        Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
          return code_2.nil;
        } });
        Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
          return code_2.getProperty;
        } });
        Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
          return code_2.stringify;
        } });
        Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
          return code_2.regexpCode;
        } });
        Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
          return code_2.Name;
        } });
        var scope_2 = requireScope();
        Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
          return scope_2.Scope;
        } });
        Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
          return scope_2.ValueScope;
        } });
        Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
          return scope_2.ValueScopeName;
        } });
        Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
          return scope_2.varKinds;
        } });
        exports.operators = {
          GT: new code_1._Code(">"),
          GTE: new code_1._Code(">="),
          LT: new code_1._Code("<"),
          LTE: new code_1._Code("<="),
          EQ: new code_1._Code("==="),
          NEQ: new code_1._Code("!=="),
          NOT: new code_1._Code("!"),
          OR: new code_1._Code("||"),
          AND: new code_1._Code("&&"),
          ADD: new code_1._Code("+")
        };
        class Node {
          optimizeNodes() {
            return this;
          }
          optimizeNames(_names, _constants) {
            return this;
          }
        }
        class Def extends Node {
          constructor(varKind, name, rhs) {
            super();
            this.varKind = varKind;
            this.name = name;
            this.rhs = rhs;
          }
          render({ es5, _n }) {
            const varKind = es5 ? scope_1.varKinds.var : this.varKind;
            const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
            return `${varKind} ${this.name}${rhs};` + _n;
          }
          optimizeNames(names2, constants) {
            if (!names2[this.name.str])
              return;
            if (this.rhs)
              this.rhs = optimizeExpr(this.rhs, names2, constants);
            return this;
          }
          get names() {
            return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
          }
        }
        class Assign extends Node {
          constructor(lhs, rhs, sideEffects) {
            super();
            this.lhs = lhs;
            this.rhs = rhs;
            this.sideEffects = sideEffects;
          }
          render({ _n }) {
            return `${this.lhs} = ${this.rhs};` + _n;
          }
          optimizeNames(names2, constants) {
            if (this.lhs instanceof code_1.Name && !names2[this.lhs.str] && !this.sideEffects)
              return;
            this.rhs = optimizeExpr(this.rhs, names2, constants);
            return this;
          }
          get names() {
            const names2 = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
            return addExprNames(names2, this.rhs);
          }
        }
        class AssignOp extends Assign {
          constructor(lhs, op, rhs, sideEffects) {
            super(lhs, rhs, sideEffects);
            this.op = op;
          }
          render({ _n }) {
            return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
          }
        }
        class Label extends Node {
          constructor(label) {
            super();
            this.label = label;
            this.names = {};
          }
          render({ _n }) {
            return `${this.label}:` + _n;
          }
        }
        class Break extends Node {
          constructor(label) {
            super();
            this.label = label;
            this.names = {};
          }
          render({ _n }) {
            const label = this.label ? ` ${this.label}` : "";
            return `break${label};` + _n;
          }
        }
        class Throw extends Node {
          constructor(error) {
            super();
            this.error = error;
          }
          render({ _n }) {
            return `throw ${this.error};` + _n;
          }
          get names() {
            return this.error.names;
          }
        }
        class AnyCode extends Node {
          constructor(code2) {
            super();
            this.code = code2;
          }
          render({ _n }) {
            return `${this.code};` + _n;
          }
          optimizeNodes() {
            return `${this.code}` ? this : void 0;
          }
          optimizeNames(names2, constants) {
            this.code = optimizeExpr(this.code, names2, constants);
            return this;
          }
          get names() {
            return this.code instanceof code_1._CodeOrName ? this.code.names : {};
          }
        }
        class ParentNode extends Node {
          constructor(nodes = []) {
            super();
            this.nodes = nodes;
          }
          render(opts) {
            return this.nodes.reduce((code2, n) => code2 + n.render(opts), "");
          }
          optimizeNodes() {
            const { nodes } = this;
            let i = nodes.length;
            while (i--) {
              const n = nodes[i].optimizeNodes();
              if (Array.isArray(n))
                nodes.splice(i, 1, ...n);
              else if (n)
                nodes[i] = n;
              else
                nodes.splice(i, 1);
            }
            return nodes.length > 0 ? this : void 0;
          }
          optimizeNames(names2, constants) {
            const { nodes } = this;
            let i = nodes.length;
            while (i--) {
              const n = nodes[i];
              if (n.optimizeNames(names2, constants))
                continue;
              subtractNames(names2, n.names);
              nodes.splice(i, 1);
            }
            return nodes.length > 0 ? this : void 0;
          }
          get names() {
            return this.nodes.reduce((names2, n) => addNames(names2, n.names), {});
          }
        }
        class BlockNode extends ParentNode {
          render(opts) {
            return "{" + opts._n + super.render(opts) + "}" + opts._n;
          }
        }
        class Root extends ParentNode {
        }
        class Else extends BlockNode {
        }
        Else.kind = "else";
        class If extends BlockNode {
          constructor(condition, nodes) {
            super(nodes);
            this.condition = condition;
          }
          render(opts) {
            let code2 = `if(${this.condition})` + super.render(opts);
            if (this.else)
              code2 += "else " + this.else.render(opts);
            return code2;
          }
          optimizeNodes() {
            super.optimizeNodes();
            const cond = this.condition;
            if (cond === true)
              return this.nodes;
            let e = this.else;
            if (e) {
              const ns = e.optimizeNodes();
              e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
            }
            if (e) {
              if (cond === false)
                return e instanceof If ? e : e.nodes;
              if (this.nodes.length)
                return this;
              return new If(not2(cond), e instanceof If ? [e] : e.nodes);
            }
            if (cond === false || !this.nodes.length)
              return void 0;
            return this;
          }
          optimizeNames(names2, constants) {
            var _a;
            this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants);
            if (!(super.optimizeNames(names2, constants) || this.else))
              return;
            this.condition = optimizeExpr(this.condition, names2, constants);
            return this;
          }
          get names() {
            const names2 = super.names;
            addExprNames(names2, this.condition);
            if (this.else)
              addNames(names2, this.else.names);
            return names2;
          }
        }
        If.kind = "if";
        class For extends BlockNode {
        }
        For.kind = "for";
        class ForLoop extends For {
          constructor(iteration) {
            super();
            this.iteration = iteration;
          }
          render(opts) {
            return `for(${this.iteration})` + super.render(opts);
          }
          optimizeNames(names2, constants) {
            if (!super.optimizeNames(names2, constants))
              return;
            this.iteration = optimizeExpr(this.iteration, names2, constants);
            return this;
          }
          get names() {
            return addNames(super.names, this.iteration.names);
          }
        }
        class ForRange extends For {
          constructor(varKind, name, from, to) {
            super();
            this.varKind = varKind;
            this.name = name;
            this.from = from;
            this.to = to;
          }
          render(opts) {
            const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
            const { name, from, to } = this;
            return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
          }
          get names() {
            const names2 = addExprNames(super.names, this.from);
            return addExprNames(names2, this.to);
          }
        }
        class ForIter extends For {
          constructor(loop, varKind, name, iterable) {
            super();
            this.loop = loop;
            this.varKind = varKind;
            this.name = name;
            this.iterable = iterable;
          }
          render(opts) {
            return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
          }
          optimizeNames(names2, constants) {
            if (!super.optimizeNames(names2, constants))
              return;
            this.iterable = optimizeExpr(this.iterable, names2, constants);
            return this;
          }
          get names() {
            return addNames(super.names, this.iterable.names);
          }
        }
        class Func extends BlockNode {
          constructor(name, args, async) {
            super();
            this.name = name;
            this.args = args;
            this.async = async;
          }
          render(opts) {
            const _async = this.async ? "async " : "";
            return `${_async}function ${this.name}(${this.args})` + super.render(opts);
          }
        }
        Func.kind = "func";
        class Return extends ParentNode {
          render(opts) {
            return "return " + super.render(opts);
          }
        }
        Return.kind = "return";
        class Try extends BlockNode {
          render(opts) {
            let code2 = "try" + super.render(opts);
            if (this.catch)
              code2 += this.catch.render(opts);
            if (this.finally)
              code2 += this.finally.render(opts);
            return code2;
          }
          optimizeNodes() {
            var _a, _b;
            super.optimizeNodes();
            (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
            (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
            return this;
          }
          optimizeNames(names2, constants) {
            var _a, _b;
            super.optimizeNames(names2, constants);
            (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants);
            (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names2, constants);
            return this;
          }
          get names() {
            const names2 = super.names;
            if (this.catch)
              addNames(names2, this.catch.names);
            if (this.finally)
              addNames(names2, this.finally.names);
            return names2;
          }
        }
        class Catch extends BlockNode {
          constructor(error) {
            super();
            this.error = error;
          }
          render(opts) {
            return `catch(${this.error})` + super.render(opts);
          }
        }
        Catch.kind = "catch";
        class Finally extends BlockNode {
          render(opts) {
            return "finally" + super.render(opts);
          }
        }
        Finally.kind = "finally";
        class CodeGen {
          constructor(extScope, opts = {}) {
            this._values = {};
            this._blockStarts = [];
            this._constants = {};
            this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
            this._extScope = extScope;
            this._scope = new scope_1.Scope({ parent: extScope });
            this._nodes = [new Root()];
          }
          toString() {
            return this._root.render(this.opts);
          }
          // returns unique name in the internal scope
          name(prefix) {
            return this._scope.name(prefix);
          }
          // reserves unique name in the external scope
          scopeName(prefix) {
            return this._extScope.name(prefix);
          }
          // reserves unique name in the external scope and assigns value to it
          scopeValue(prefixOrName, value) {
            const name = this._extScope.value(prefixOrName, value);
            const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
            vs.add(name);
            return name;
          }
          getScopeValue(prefix, keyOrRef) {
            return this._extScope.getValue(prefix, keyOrRef);
          }
          // return code that assigns values in the external scope to the names that are used internally
          // (same names that were returned by gen.scopeName or gen.scopeValue)
          scopeRefs(scopeName) {
            return this._extScope.scopeRefs(scopeName, this._values);
          }
          scopeCode() {
            return this._extScope.scopeCode(this._values);
          }
          _def(varKind, nameOrPrefix, rhs, constant) {
            const name = this._scope.toName(nameOrPrefix);
            if (rhs !== void 0 && constant)
              this._constants[name.str] = rhs;
            this._leafNode(new Def(varKind, name, rhs));
            return name;
          }
          // `const` declaration (`var` in es5 mode)
          const(nameOrPrefix, rhs, _constant) {
            return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
          }
          // `let` declaration with optional assignment (`var` in es5 mode)
          let(nameOrPrefix, rhs, _constant) {
            return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
          }
          // `var` declaration with optional assignment
          var(nameOrPrefix, rhs, _constant) {
            return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
          }
          // assignment code
          assign(lhs, rhs, sideEffects) {
            return this._leafNode(new Assign(lhs, rhs, sideEffects));
          }
          // `+=` code
          add(lhs, rhs) {
            return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
          }
          // appends passed SafeExpr to code or executes Block
          code(c) {
            if (typeof c == "function")
              c();
            else if (c !== code_1.nil)
              this._leafNode(new AnyCode(c));
            return this;
          }
          // returns code for object literal for the passed argument list of key-value pairs
          object(...keyValues) {
            const code2 = ["{"];
            for (const [key, value] of keyValues) {
              if (code2.length > 1)
                code2.push(",");
              code2.push(key);
              if (key !== value || this.opts.es5) {
                code2.push(":");
                (0, code_1.addCodeArg)(code2, value);
              }
            }
            code2.push("}");
            return new code_1._Code(code2);
          }
          // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
          if(condition, thenBody, elseBody) {
            this._blockNode(new If(condition));
            if (thenBody && elseBody) {
              this.code(thenBody).else().code(elseBody).endIf();
            } else if (thenBody) {
              this.code(thenBody).endIf();
            } else if (elseBody) {
              throw new Error('CodeGen: "else" body without "then" body');
            }
            return this;
          }
          // `else if` clause - invalid without `if` or after `else` clauses
          elseIf(condition) {
            return this._elseNode(new If(condition));
          }
          // `else` clause - only valid after `if` or `else if` clauses
          else() {
            return this._elseNode(new Else());
          }
          // end `if` statement (needed if gen.if was used only with condition)
          endIf() {
            return this._endBlockNode(If, Else);
          }
          _for(node, forBody) {
            this._blockNode(node);
            if (forBody)
              this.code(forBody).endFor();
            return this;
          }
          // a generic `for` clause (or statement if `forBody` is passed)
          for(iteration, forBody) {
            return this._for(new ForLoop(iteration), forBody);
          }
          // `for` statement for a range of values
          forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
            const name = this._scope.toName(nameOrPrefix);
            return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
          }
          // `for-of` statement (in es5 mode replace with a normal for loop)
          forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
            const name = this._scope.toName(nameOrPrefix);
            if (this.opts.es5) {
              const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
              return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
                this.var(name, (0, code_1._)`${arr}[${i}]`);
                forBody(name);
              });
            }
            return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
          }
          // `for-in` statement.
          // With option `ownProperties` replaced with a `for-of` loop for object keys
          forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
            if (this.opts.ownProperties) {
              return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
            }
            const name = this._scope.toName(nameOrPrefix);
            return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
          }
          // end `for` loop
          endFor() {
            return this._endBlockNode(For);
          }
          // `label` statement
          label(label) {
            return this._leafNode(new Label(label));
          }
          // `break` statement
          break(label) {
            return this._leafNode(new Break(label));
          }
          // `return` statement
          return(value) {
            const node = new Return();
            this._blockNode(node);
            this.code(value);
            if (node.nodes.length !== 1)
              throw new Error('CodeGen: "return" should have one node');
            return this._endBlockNode(Return);
          }
          // `try` statement
          try(tryBody, catchCode, finallyCode) {
            if (!catchCode && !finallyCode)
              throw new Error('CodeGen: "try" without "catch" and "finally"');
            const node = new Try();
            this._blockNode(node);
            this.code(tryBody);
            if (catchCode) {
              const error = this.name("e");
              this._currNode = node.catch = new Catch(error);
              catchCode(error);
            }
            if (finallyCode) {
              this._currNode = node.finally = new Finally();
              this.code(finallyCode);
            }
            return this._endBlockNode(Catch, Finally);
          }
          // `throw` statement
          throw(error) {
            return this._leafNode(new Throw(error));
          }
          // start self-balancing block
          block(body, nodeCount) {
            this._blockStarts.push(this._nodes.length);
            if (body)
              this.code(body).endBlock(nodeCount);
            return this;
          }
          // end the current self-balancing block
          endBlock(nodeCount) {
            const len = this._blockStarts.pop();
            if (len === void 0)
              throw new Error("CodeGen: not in self-balancing block");
            const toClose = this._nodes.length - len;
            if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
              throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
            }
            this._nodes.length = len;
            return this;
          }
          // `function` heading (or definition if funcBody is passed)
          func(name, args = code_1.nil, async, funcBody) {
            this._blockNode(new Func(name, args, async));
            if (funcBody)
              this.code(funcBody).endFunc();
            return this;
          }
          // end function definition
          endFunc() {
            return this._endBlockNode(Func);
          }
          optimize(n = 1) {
            while (n-- > 0) {
              this._root.optimizeNodes();
              this._root.optimizeNames(this._root.names, this._constants);
            }
          }
          _leafNode(node) {
            this._currNode.nodes.push(node);
            return this;
          }
          _blockNode(node) {
            this._currNode.nodes.push(node);
            this._nodes.push(node);
          }
          _endBlockNode(N1, N2) {
            const n = this._currNode;
            if (n instanceof N1 || N2 && n instanceof N2) {
              this._nodes.pop();
              return this;
            }
            throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
          }
          _elseNode(node) {
            const n = this._currNode;
            if (!(n instanceof If)) {
              throw new Error('CodeGen: "else" without "if"');
            }
            this._currNode = n.else = node;
            return this;
          }
          get _root() {
            return this._nodes[0];
          }
          get _currNode() {
            const ns = this._nodes;
            return ns[ns.length - 1];
          }
          set _currNode(node) {
            const ns = this._nodes;
            ns[ns.length - 1] = node;
          }
        }
        exports.CodeGen = CodeGen;
        function addNames(names2, from) {
          for (const n in from)
            names2[n] = (names2[n] || 0) + (from[n] || 0);
          return names2;
        }
        function addExprNames(names2, from) {
          return from instanceof code_1._CodeOrName ? addNames(names2, from.names) : names2;
        }
        function optimizeExpr(expr, names2, constants) {
          if (expr instanceof code_1.Name)
            return replaceName(expr);
          if (!canOptimize(expr))
            return expr;
          return new code_1._Code(expr._items.reduce((items2, c) => {
            if (c instanceof code_1.Name)
              c = replaceName(c);
            if (c instanceof code_1._Code)
              items2.push(...c._items);
            else
              items2.push(c);
            return items2;
          }, []));
          function replaceName(n) {
            const c = constants[n.str];
            if (c === void 0 || names2[n.str] !== 1)
              return n;
            delete names2[n.str];
            return c;
          }
          function canOptimize(e) {
            return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names2[c.str] === 1 && constants[c.str] !== void 0);
          }
        }
        function subtractNames(names2, from) {
          for (const n in from)
            names2[n] = (names2[n] || 0) - (from[n] || 0);
        }
        function not2(x) {
          return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
        }
        exports.not = not2;
        const andCode = mappend(exports.operators.AND);
        function and(...args) {
          return args.reduce(andCode);
        }
        exports.and = and;
        const orCode = mappend(exports.operators.OR);
        function or(...args) {
          return args.reduce(orCode);
        }
        exports.or = or;
        function mappend(op) {
          return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
        }
        function par(x) {
          return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
        }
      })(codegen);
      return codegen;
    }
    var util = {};
    var hasRequiredUtil;
    function requireUtil() {
      if (hasRequiredUtil) return util;
      hasRequiredUtil = 1;
      "use strict";
      Object.defineProperty(util, "__esModule", { value: true });
      util.checkStrictMode = util.getErrorPath = util.Type = util.useFunc = util.setEvaluated = util.evaluatedPropsToName = util.mergeEvaluated = util.eachItem = util.unescapeJsonPointer = util.escapeJsonPointer = util.escapeFragment = util.unescapeFragment = util.schemaRefOrVal = util.schemaHasRulesButRef = util.schemaHasRules = util.checkUnknownRules = util.alwaysValidSchema = util.toHash = void 0;
      const codegen_1 = requireCodegen();
      const code_1 = requireCode$1();
      function toHash(arr) {
        const hash = {};
        for (const item of arr)
          hash[item] = true;
        return hash;
      }
      util.toHash = toHash;
      function alwaysValidSchema(it, schema) {
        if (typeof schema == "boolean")
          return schema;
        if (Object.keys(schema).length === 0)
          return true;
        checkUnknownRules(it, schema);
        return !schemaHasRules(schema, it.self.RULES.all);
      }
      util.alwaysValidSchema = alwaysValidSchema;
      function checkUnknownRules(it, schema = it.schema) {
        const { opts, self: self2 } = it;
        if (!opts.strictSchema)
          return;
        if (typeof schema === "boolean")
          return;
        const rules2 = self2.RULES.keywords;
        for (const key in schema) {
          if (!rules2[key])
            checkStrictMode(it, `unknown keyword: "${key}"`);
        }
      }
      util.checkUnknownRules = checkUnknownRules;
      function schemaHasRules(schema, rules2) {
        if (typeof schema == "boolean")
          return !schema;
        for (const key in schema)
          if (rules2[key])
            return true;
        return false;
      }
      util.schemaHasRules = schemaHasRules;
      function schemaHasRulesButRef(schema, RULES) {
        if (typeof schema == "boolean")
          return !schema;
        for (const key in schema)
          if (key !== "$ref" && RULES.all[key])
            return true;
        return false;
      }
      util.schemaHasRulesButRef = schemaHasRulesButRef;
      function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword2, $data) {
        if (!$data) {
          if (typeof schema == "number" || typeof schema == "boolean")
            return schema;
          if (typeof schema == "string")
            return (0, codegen_1._)`${schema}`;
        }
        return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword2)}`;
      }
      util.schemaRefOrVal = schemaRefOrVal;
      function unescapeFragment(str) {
        return unescapeJsonPointer(decodeURIComponent(str));
      }
      util.unescapeFragment = unescapeFragment;
      function escapeFragment(str) {
        return encodeURIComponent(escapeJsonPointer(str));
      }
      util.escapeFragment = escapeFragment;
      function escapeJsonPointer(str) {
        if (typeof str == "number")
          return `${str}`;
        return str.replace(/~/g, "~0").replace(/\//g, "~1");
      }
      util.escapeJsonPointer = escapeJsonPointer;
      function unescapeJsonPointer(str) {
        return str.replace(/~1/g, "/").replace(/~0/g, "~");
      }
      util.unescapeJsonPointer = unescapeJsonPointer;
      function eachItem(xs, f) {
        if (Array.isArray(xs)) {
          for (const x of xs)
            f(x);
        } else {
          f(xs);
        }
      }
      util.eachItem = eachItem;
      function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
        return (gen, from, to, toName) => {
          const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
          return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
        };
      }
      util.mergeEvaluated = {
        props: makeMergeEvaluated({
          mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
            gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
          }),
          mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
            if (from === true) {
              gen.assign(to, true);
            } else {
              gen.assign(to, (0, codegen_1._)`${to} || {}`);
              setEvaluated(gen, to, from);
            }
          }),
          mergeValues: (from, to) => from === true ? true : { ...from, ...to },
          resultToName: evaluatedPropsToName
        }),
        items: makeMergeEvaluated({
          mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
          mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
          mergeValues: (from, to) => from === true ? true : Math.max(from, to),
          resultToName: (gen, items2) => gen.var("items", items2)
        })
      };
      function evaluatedPropsToName(gen, ps) {
        if (ps === true)
          return gen.var("props", true);
        const props = gen.var("props", (0, codegen_1._)`{}`);
        if (ps !== void 0)
          setEvaluated(gen, props, ps);
        return props;
      }
      util.evaluatedPropsToName = evaluatedPropsToName;
      function setEvaluated(gen, props, ps) {
        Object.keys(ps).forEach((p2) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p2)}`, true));
      }
      util.setEvaluated = setEvaluated;
      const snippets = {};
      function useFunc(gen, f) {
        return gen.scopeValue("func", {
          ref: f,
          code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
        });
      }
      util.useFunc = useFunc;
      var Type;
      (function(Type2) {
        Type2[Type2["Num"] = 0] = "Num";
        Type2[Type2["Str"] = 1] = "Str";
      })(Type || (util.Type = Type = {}));
      function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
        if (dataProp instanceof codegen_1.Name) {
          const isNumber = dataPropType === Type.Num;
          return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
        }
        return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
      }
      util.getErrorPath = getErrorPath;
      function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
        if (!mode)
          return;
        msg = `strict mode: ${msg}`;
        if (mode === true)
          throw new Error(msg);
        it.self.logger.warn(msg);
      }
      util.checkStrictMode = checkStrictMode;
      return util;
    }
    var names = {};
    var hasRequiredNames;
    function requireNames() {
      if (hasRequiredNames) return names;
      hasRequiredNames = 1;
      "use strict";
      Object.defineProperty(names, "__esModule", { value: true });
      const codegen_1 = requireCodegen();
      const names$1 = {
        // validation function arguments
        data: new codegen_1.Name("data"),
        // data passed to validation function
        // args passed from referencing schema
        valCxt: new codegen_1.Name("valCxt"),
        // validation/data context - should not be used directly, it is destructured to the names below
        instancePath: new codegen_1.Name("instancePath"),
        parentData: new codegen_1.Name("parentData"),
        parentDataProperty: new codegen_1.Name("parentDataProperty"),
        rootData: new codegen_1.Name("rootData"),
        // root data - same as the data passed to the first/top validation function
        dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
        // used to support recursiveRef and dynamicRef
        // function scoped variables
        vErrors: new codegen_1.Name("vErrors"),
        // null or array of validation errors
        errors: new codegen_1.Name("errors"),
        // counter of validation errors
        this: new codegen_1.Name("this"),
        // "globals"
        self: new codegen_1.Name("self"),
        scope: new codegen_1.Name("scope"),
        // JTD serialize/parse name for JSON string and position
        json: new codegen_1.Name("json"),
        jsonPos: new codegen_1.Name("jsonPos"),
        jsonLen: new codegen_1.Name("jsonLen"),
        jsonPart: new codegen_1.Name("jsonPart")
      };
      names.default = names$1;
      return names;
    }
    var hasRequiredErrors;
    function requireErrors() {
      if (hasRequiredErrors) return errors;
      hasRequiredErrors = 1;
      (function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
        const codegen_1 = requireCodegen();
        const util_1 = requireUtil();
        const names_1 = requireNames();
        exports.keywordError = {
          message: ({ keyword: keyword2 }) => (0, codegen_1.str)`must pass "${keyword2}" keyword validation`
        };
        exports.keyword$DataError = {
          message: ({ keyword: keyword2, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword2}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword2}" keyword is invalid ($data)`
        };
        function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
          const { it } = cxt;
          const { gen, compositeRule, allErrors } = it;
          const errObj = errorObjectCode(cxt, error, errorPaths);
          if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
            addError(gen, errObj);
          } else {
            returnErrors(it, (0, codegen_1._)`[${errObj}]`);
          }
        }
        exports.reportError = reportError;
        function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
          const { it } = cxt;
          const { gen, compositeRule, allErrors } = it;
          const errObj = errorObjectCode(cxt, error, errorPaths);
          addError(gen, errObj);
          if (!(compositeRule || allErrors)) {
            returnErrors(it, names_1.default.vErrors);
          }
        }
        exports.reportExtraError = reportExtraError;
        function resetErrorsCount(gen, errsCount) {
          gen.assign(names_1.default.errors, errsCount);
          gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
        }
        exports.resetErrorsCount = resetErrorsCount;
        function extendErrors({ gen, keyword: keyword2, schemaValue, data, errsCount, it }) {
          if (errsCount === void 0)
            throw new Error("ajv implementation error");
          const err = gen.name("err");
          gen.forRange("i", errsCount, names_1.default.errors, (i) => {
            gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
            gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
            gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword2}`);
            if (it.opts.verbose) {
              gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
              gen.assign((0, codegen_1._)`${err}.data`, data);
            }
          });
        }
        exports.extendErrors = extendErrors;
        function addError(gen, errObj) {
          const err = gen.const("err", errObj);
          gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
          gen.code((0, codegen_1._)`${names_1.default.errors}++`);
        }
        function returnErrors(it, errs) {
          const { gen, validateName, schemaEnv } = it;
          if (schemaEnv.$async) {
            gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
          } else {
            gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
            gen.return(false);
          }
        }
        const E = {
          keyword: new codegen_1.Name("keyword"),
          schemaPath: new codegen_1.Name("schemaPath"),
          // also used in JTD errors
          params: new codegen_1.Name("params"),
          propertyName: new codegen_1.Name("propertyName"),
          message: new codegen_1.Name("message"),
          schema: new codegen_1.Name("schema"),
          parentSchema: new codegen_1.Name("parentSchema")
        };
        function errorObjectCode(cxt, error, errorPaths) {
          const { createErrors } = cxt.it;
          if (createErrors === false)
            return (0, codegen_1._)`{}`;
          return errorObject(cxt, error, errorPaths);
        }
        function errorObject(cxt, error, errorPaths = {}) {
          const { gen, it } = cxt;
          const keyValues = [
            errorInstancePath(it, errorPaths),
            errorSchemaPath(cxt, errorPaths)
          ];
          extraErrorProps(cxt, error, keyValues);
          return gen.object(...keyValues);
        }
        function errorInstancePath({ errorPath }, { instancePath }) {
          const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
          return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
        }
        function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
          let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword2}`;
          if (schemaPath) {
            schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
          }
          return [E.schemaPath, schPath];
        }
        function extraErrorProps(cxt, { params, message }, keyValues) {
          const { keyword: keyword2, data, schemaValue, it } = cxt;
          const { opts, propertyName, topSchemaRef, schemaPath } = it;
          keyValues.push([E.keyword, keyword2], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
          if (opts.messages) {
            keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
          }
          if (opts.verbose) {
            keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
          }
          if (propertyName)
            keyValues.push([E.propertyName, propertyName]);
        }
      })(errors);
      return errors;
    }
    var hasRequiredBoolSchema;
    function requireBoolSchema() {
      if (hasRequiredBoolSchema) return boolSchema;
      hasRequiredBoolSchema = 1;
      "use strict";
      Object.defineProperty(boolSchema, "__esModule", { value: true });
      boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
      const errors_1 = requireErrors();
      const codegen_1 = requireCodegen();
      const names_1 = requireNames();
      const boolError = {
        message: "boolean schema is false"
      };
      function topBoolOrEmptySchema(it) {
        const { gen, schema, validateName } = it;
        if (schema === false) {
          falseSchemaError(it, false);
        } else if (typeof schema == "object" && schema.$async === true) {
          gen.return(names_1.default.data);
        } else {
          gen.assign((0, codegen_1._)`${validateName}.errors`, null);
          gen.return(true);
        }
      }
      boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
      function boolOrEmptySchema(it, valid) {
        const { gen, schema } = it;
        if (schema === false) {
          gen.var(valid, false);
          falseSchemaError(it);
        } else {
          gen.var(valid, true);
        }
      }
      boolSchema.boolOrEmptySchema = boolOrEmptySchema;
      function falseSchemaError(it, overrideAllErrors) {
        const { gen, data } = it;
        const cxt = {
          gen,
          keyword: "false schema",
          data,
          schema: false,
          schemaCode: false,
          schemaValue: false,
          params: {},
          it
        };
        (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
      }
      return boolSchema;
    }
    var dataType = {};
    var rules = {};
    var hasRequiredRules;
    function requireRules() {
      if (hasRequiredRules) return rules;
      hasRequiredRules = 1;
      "use strict";
      Object.defineProperty(rules, "__esModule", { value: true });
      rules.getRules = rules.isJSONType = void 0;
      const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
      const jsonTypes = new Set(_jsonTypes);
      function isJSONType(x) {
        return typeof x == "string" && jsonTypes.has(x);
      }
      rules.isJSONType = isJSONType;
      function getRules() {
        const groups = {
          number: { type: "number", rules: [] },
          string: { type: "string", rules: [] },
          array: { type: "array", rules: [] },
          object: { type: "object", rules: [] }
        };
        return {
          types: { ...groups, integer: true, boolean: true, null: true },
          rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
          post: { rules: [] },
          all: {},
          keywords: {}
        };
      }
      rules.getRules = getRules;
      return rules;
    }
    var applicability = {};
    var hasRequiredApplicability;
    function requireApplicability() {
      if (hasRequiredApplicability) return applicability;
      hasRequiredApplicability = 1;
      "use strict";
      Object.defineProperty(applicability, "__esModule", { value: true });
      applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
      function schemaHasRulesForType({ schema, self: self2 }, type2) {
        const group = self2.RULES.types[type2];
        return group && group !== true && shouldUseGroup(schema, group);
      }
      applicability.schemaHasRulesForType = schemaHasRulesForType;
      function shouldUseGroup(schema, group) {
        return group.rules.some((rule) => shouldUseRule(schema, rule));
      }
      applicability.shouldUseGroup = shouldUseGroup;
      function shouldUseRule(schema, rule) {
        var _a;
        return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
      }
      applicability.shouldUseRule = shouldUseRule;
      return applicability;
    }
    var hasRequiredDataType;
    function requireDataType() {
      if (hasRequiredDataType) return dataType;
      hasRequiredDataType = 1;
      "use strict";
      Object.defineProperty(dataType, "__esModule", { value: true });
      dataType.reportTypeError = dataType.checkDataTypes = dataType.checkDataType = dataType.coerceAndCheckDataType = dataType.getJSONTypes = dataType.getSchemaTypes = dataType.DataType = void 0;
      const rules_1 = requireRules();
      const applicability_1 = requireApplicability();
      const errors_1 = requireErrors();
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      var DataType;
      (function(DataType2) {
        DataType2[DataType2["Correct"] = 0] = "Correct";
        DataType2[DataType2["Wrong"] = 1] = "Wrong";
      })(DataType || (dataType.DataType = DataType = {}));
      function getSchemaTypes(schema) {
        const types2 = getJSONTypes(schema.type);
        const hasNull = types2.includes("null");
        if (hasNull) {
          if (schema.nullable === false)
            throw new Error("type: null contradicts nullable: false");
        } else {
          if (!types2.length && schema.nullable !== void 0) {
            throw new Error('"nullable" cannot be used without "type"');
          }
          if (schema.nullable === true)
            types2.push("null");
        }
        return types2;
      }
      dataType.getSchemaTypes = getSchemaTypes;
      function getJSONTypes(ts) {
        const types2 = Array.isArray(ts) ? ts : ts ? [ts] : [];
        if (types2.every(rules_1.isJSONType))
          return types2;
        throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
      }
      dataType.getJSONTypes = getJSONTypes;
      function coerceAndCheckDataType(it, types2) {
        const { gen, data, opts } = it;
        const coerceTo = coerceToTypes(types2, opts.coerceTypes);
        const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types2[0]));
        if (checkTypes) {
          const wrongType = checkDataTypes(types2, data, opts.strictNumbers, DataType.Wrong);
          gen.if(wrongType, () => {
            if (coerceTo.length)
              coerceData(it, types2, coerceTo);
            else
              reportTypeError(it);
          });
        }
        return checkTypes;
      }
      dataType.coerceAndCheckDataType = coerceAndCheckDataType;
      const COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
      function coerceToTypes(types2, coerceTypes) {
        return coerceTypes ? types2.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
      }
      function coerceData(it, types2, coerceTo) {
        const { gen, data, opts } = it;
        const dataType2 = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
        const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
        if (opts.coerceTypes === "array") {
          gen.if((0, codegen_1._)`${dataType2} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType2, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types2, data, opts.strictNumbers), () => gen.assign(coerced, data)));
        }
        gen.if((0, codegen_1._)`${coerced} !== undefined`);
        for (const t of coerceTo) {
          if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
            coerceSpecificType(t);
          }
        }
        gen.else();
        reportTypeError(it);
        gen.endIf();
        gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
          gen.assign(data, coerced);
          assignParentData(it, coerced);
        });
        function coerceSpecificType(t) {
          switch (t) {
            case "string":
              gen.elseIf((0, codegen_1._)`${dataType2} == "number" || ${dataType2} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
              return;
            case "number":
              gen.elseIf((0, codegen_1._)`${dataType2} == "boolean" || ${data} === null
                || (${dataType2} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
              return;
            case "integer":
              gen.elseIf((0, codegen_1._)`${dataType2} === "boolean" || ${data} === null
                || (${dataType2} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
              return;
            case "boolean":
              gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
              return;
            case "null":
              gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
              gen.assign(coerced, null);
              return;
            case "array":
              gen.elseIf((0, codegen_1._)`${dataType2} === "string" || ${dataType2} === "number"
                || ${dataType2} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
          }
        }
      }
      function assignParentData({ gen, parentData, parentDataProperty }, expr) {
        gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
      }
      function checkDataType(dataType2, data, strictNums, correct = DataType.Correct) {
        const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
        let cond;
        switch (dataType2) {
          case "null":
            return (0, codegen_1._)`${data} ${EQ} null`;
          case "array":
            cond = (0, codegen_1._)`Array.isArray(${data})`;
            break;
          case "object":
            cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
            break;
          case "integer":
            cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
            break;
          case "number":
            cond = numCond();
            break;
          default:
            return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType2}`;
        }
        return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
        function numCond(_cond = codegen_1.nil) {
          return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
        }
      }
      dataType.checkDataType = checkDataType;
      function checkDataTypes(dataTypes, data, strictNums, correct) {
        if (dataTypes.length === 1) {
          return checkDataType(dataTypes[0], data, strictNums, correct);
        }
        let cond;
        const types2 = (0, util_1.toHash)(dataTypes);
        if (types2.array && types2.object) {
          const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
          cond = types2.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
          delete types2.null;
          delete types2.array;
          delete types2.object;
        } else {
          cond = codegen_1.nil;
        }
        if (types2.number)
          delete types2.integer;
        for (const t in types2)
          cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
        return cond;
      }
      dataType.checkDataTypes = checkDataTypes;
      const typeError = {
        message: ({ schema }) => `must be ${schema}`,
        params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
      };
      function reportTypeError(it) {
        const cxt = getTypeErrorContext(it);
        (0, errors_1.reportError)(cxt, typeError);
      }
      dataType.reportTypeError = reportTypeError;
      function getTypeErrorContext(it) {
        const { gen, data, schema } = it;
        const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
        return {
          gen,
          keyword: "type",
          data,
          schema: schema.type,
          schemaCode,
          schemaValue: schemaCode,
          parentSchema: schema,
          params: {},
          it
        };
      }
      return dataType;
    }
    var defaults = {};
    var hasRequiredDefaults;
    function requireDefaults() {
      if (hasRequiredDefaults) return defaults;
      hasRequiredDefaults = 1;
      "use strict";
      Object.defineProperty(defaults, "__esModule", { value: true });
      defaults.assignDefaults = void 0;
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      function assignDefaults(it, ty) {
        const { properties: properties2, items: items2 } = it.schema;
        if (ty === "object" && properties2) {
          for (const key in properties2) {
            assignDefault(it, key, properties2[key].default);
          }
        } else if (ty === "array" && Array.isArray(items2)) {
          items2.forEach((sch, i) => assignDefault(it, i, sch.default));
        }
      }
      defaults.assignDefaults = assignDefaults;
      function assignDefault(it, prop, defaultValue) {
        const { gen, compositeRule, data, opts } = it;
        if (defaultValue === void 0)
          return;
        const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
        if (compositeRule) {
          (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
          return;
        }
        let condition = (0, codegen_1._)`${childData} === undefined`;
        if (opts.useDefaults === "empty") {
          condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
        }
        gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
      }
      return defaults;
    }
    var keyword = {};
    var code = {};
    var hasRequiredCode;
    function requireCode() {
      if (hasRequiredCode) return code;
      hasRequiredCode = 1;
      "use strict";
      Object.defineProperty(code, "__esModule", { value: true });
      code.validateUnion = code.validateArray = code.usePattern = code.callValidateCode = code.schemaProperties = code.allSchemaProperties = code.noPropertyInData = code.propertyInData = code.isOwnProperty = code.hasPropFunc = code.reportMissingProp = code.checkMissingProp = code.checkReportMissingProp = void 0;
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const names_1 = requireNames();
      const util_2 = requireUtil();
      function checkReportMissingProp(cxt, prop) {
        const { gen, data, it } = cxt;
        gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
          cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
          cxt.error();
        });
      }
      code.checkReportMissingProp = checkReportMissingProp;
      function checkMissingProp({ gen, data, it: { opts } }, properties2, missing) {
        return (0, codegen_1.or)(...properties2.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
      }
      code.checkMissingProp = checkMissingProp;
      function reportMissingProp(cxt, missing) {
        cxt.setParams({ missingProperty: missing }, true);
        cxt.error();
      }
      code.reportMissingProp = reportMissingProp;
      function hasPropFunc(gen) {
        return gen.scopeValue("func", {
          // eslint-disable-next-line @typescript-eslint/unbound-method
          ref: Object.prototype.hasOwnProperty,
          code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
        });
      }
      code.hasPropFunc = hasPropFunc;
      function isOwnProperty(gen, data, property) {
        return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
      }
      code.isOwnProperty = isOwnProperty;
      function propertyInData(gen, data, property, ownProperties) {
        const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
        return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
      }
      code.propertyInData = propertyInData;
      function noPropertyInData(gen, data, property, ownProperties) {
        const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
        return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
      }
      code.noPropertyInData = noPropertyInData;
      function allSchemaProperties(schemaMap) {
        return schemaMap ? Object.keys(schemaMap).filter((p2) => p2 !== "__proto__") : [];
      }
      code.allSchemaProperties = allSchemaProperties;
      function schemaProperties(it, schemaMap) {
        return allSchemaProperties(schemaMap).filter((p2) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p2]));
      }
      code.schemaProperties = schemaProperties;
      function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
        const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
        const valCxt = [
          [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
          [names_1.default.parentData, it.parentData],
          [names_1.default.parentDataProperty, it.parentDataProperty],
          [names_1.default.rootData, names_1.default.rootData]
        ];
        if (it.opts.dynamicRef)
          valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
        const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
        return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
      }
      code.callValidateCode = callValidateCode;
      const newRegExp = (0, codegen_1._)`new RegExp`;
      function usePattern({ gen, it: { opts } }, pattern2) {
        const u = opts.unicodeRegExp ? "u" : "";
        const { regExp } = opts.code;
        const rx = regExp(pattern2, u);
        return gen.scopeValue("pattern", {
          key: rx.toString(),
          ref: rx,
          code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern2}, ${u})`
        });
      }
      code.usePattern = usePattern;
      function validateArray(cxt) {
        const { gen, data, keyword: keyword2, it } = cxt;
        const valid = gen.name("valid");
        if (it.allErrors) {
          const validArr = gen.let("valid", true);
          validateItems(() => gen.assign(validArr, false));
          return validArr;
        }
        gen.var(valid, true);
        validateItems(() => gen.break());
        return valid;
        function validateItems(notValid) {
          const len = gen.const("len", (0, codegen_1._)`${data}.length`);
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: keyword2,
              dataProp: i,
              dataPropType: util_1.Type.Num
            }, valid);
            gen.if((0, codegen_1.not)(valid), notValid);
          });
        }
      }
      code.validateArray = validateArray;
      function validateUnion(cxt) {
        const { gen, schema, keyword: keyword2, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
        if (alwaysValid && !it.opts.unevaluated)
          return;
        const valid = gen.let("valid", false);
        const schValid = gen.name("_valid");
        gen.block(() => schema.forEach((_sch, i) => {
          const schCxt = cxt.subschema({
            keyword: keyword2,
            schemaProp: i,
            compositeRule: true
          }, schValid);
          gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
          const merged = cxt.mergeValidEvaluated(schCxt, schValid);
          if (!merged)
            gen.if((0, codegen_1.not)(valid));
        }));
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
      }
      code.validateUnion = validateUnion;
      return code;
    }
    var hasRequiredKeyword;
    function requireKeyword() {
      if (hasRequiredKeyword) return keyword;
      hasRequiredKeyword = 1;
      "use strict";
      Object.defineProperty(keyword, "__esModule", { value: true });
      keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
      const codegen_1 = requireCodegen();
      const names_1 = requireNames();
      const code_1 = requireCode();
      const errors_1 = requireErrors();
      function macroKeywordCode(cxt, def2) {
        const { gen, keyword: keyword2, schema, parentSchema, it } = cxt;
        const macroSchema = def2.macro.call(it.self, schema, parentSchema, it);
        const schemaRef = useKeyword(gen, keyword2, macroSchema);
        if (it.opts.validateSchema !== false)
          it.self.validateSchema(macroSchema, true);
        const valid = gen.name("valid");
        cxt.subschema({
          schema: macroSchema,
          schemaPath: codegen_1.nil,
          errSchemaPath: `${it.errSchemaPath}/${keyword2}`,
          topSchemaRef: schemaRef,
          compositeRule: true
        }, valid);
        cxt.pass(valid, () => cxt.error(true));
      }
      keyword.macroKeywordCode = macroKeywordCode;
      function funcKeywordCode(cxt, def2) {
        var _a;
        const { gen, keyword: keyword2, schema, parentSchema, $data, it } = cxt;
        checkAsyncKeyword(it, def2);
        const validate2 = !$data && def2.compile ? def2.compile.call(it.self, schema, parentSchema, it) : def2.validate;
        const validateRef = useKeyword(gen, keyword2, validate2);
        const valid = gen.let("valid");
        cxt.block$data(valid, validateKeyword);
        cxt.ok((_a = def2.valid) !== null && _a !== void 0 ? _a : valid);
        function validateKeyword() {
          if (def2.errors === false) {
            assignValid();
            if (def2.modifying)
              modifyData(cxt);
            reportErrs(() => cxt.error());
          } else {
            const ruleErrs = def2.async ? validateAsync() : validateSync();
            if (def2.modifying)
              modifyData(cxt);
            reportErrs(() => addErrs(cxt, ruleErrs));
          }
        }
        function validateAsync() {
          const ruleErrs = gen.let("ruleErrs", null);
          gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
          return ruleErrs;
        }
        function validateSync() {
          const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
          gen.assign(validateErrs, null);
          assignValid(codegen_1.nil);
          return validateErrs;
        }
        function assignValid(_await = def2.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
          const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
          const passSchema = !("compile" in def2 && !$data || def2.schema === false);
          gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def2.modifying);
        }
        function reportErrs(errors2) {
          var _a2;
          gen.if((0, codegen_1.not)((_a2 = def2.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors2);
        }
      }
      keyword.funcKeywordCode = funcKeywordCode;
      function modifyData(cxt) {
        const { gen, data, it } = cxt;
        gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
      }
      function addErrs(cxt, errs) {
        const { gen } = cxt;
        gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
          gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
          (0, errors_1.extendErrors)(cxt);
        }, () => cxt.error());
      }
      function checkAsyncKeyword({ schemaEnv }, def2) {
        if (def2.async && !schemaEnv.$async)
          throw new Error("async keyword in sync schema");
      }
      function useKeyword(gen, keyword2, result) {
        if (result === void 0)
          throw new Error(`keyword "${keyword2}" failed to compile`);
        return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
      }
      function validSchemaType(schema, schemaType, allowUndefined = false) {
        return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
      }
      keyword.validSchemaType = validSchemaType;
      function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def2, keyword2) {
        if (Array.isArray(def2.keyword) ? !def2.keyword.includes(keyword2) : def2.keyword !== keyword2) {
          throw new Error("ajv implementation error");
        }
        const deps = def2.dependencies;
        if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
          throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
        }
        if (def2.validateSchema) {
          const valid = def2.validateSchema(schema[keyword2]);
          if (!valid) {
            const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def2.validateSchema.errors);
            if (opts.validateSchema === "log")
              self2.logger.error(msg);
            else
              throw new Error(msg);
          }
        }
      }
      keyword.validateKeywordUsage = validateKeywordUsage;
      return keyword;
    }
    var subschema = {};
    var hasRequiredSubschema;
    function requireSubschema() {
      if (hasRequiredSubschema) return subschema;
      hasRequiredSubschema = 1;
      "use strict";
      Object.defineProperty(subschema, "__esModule", { value: true });
      subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      function getSubschema(it, { keyword: keyword2, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
        if (keyword2 !== void 0 && schema !== void 0) {
          throw new Error('both "keyword" and "schema" passed, only one allowed');
        }
        if (keyword2 !== void 0) {
          const sch = it.schema[keyword2];
          return schemaProp === void 0 ? {
            schema: sch,
            schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword2)}`,
            errSchemaPath: `${it.errSchemaPath}/${keyword2}`
          } : {
            schema: sch[schemaProp],
            schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword2)}${(0, codegen_1.getProperty)(schemaProp)}`,
            errSchemaPath: `${it.errSchemaPath}/${keyword2}/${(0, util_1.escapeFragment)(schemaProp)}`
          };
        }
        if (schema !== void 0) {
          if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
            throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
          }
          return {
            schema,
            schemaPath,
            topSchemaRef,
            errSchemaPath
          };
        }
        throw new Error('either "keyword" or "schema" must be passed');
      }
      subschema.getSubschema = getSubschema;
      function extendSubschemaData(subschema2, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
        if (data !== void 0 && dataProp !== void 0) {
          throw new Error('both "data" and "dataProp" passed, only one allowed');
        }
        const { gen } = it;
        if (dataProp !== void 0) {
          const { errorPath, dataPathArr, opts } = it;
          const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
          dataContextProps(nextData);
          subschema2.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
          subschema2.parentDataProperty = (0, codegen_1._)`${dataProp}`;
          subschema2.dataPathArr = [...dataPathArr, subschema2.parentDataProperty];
        }
        if (data !== void 0) {
          const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
          dataContextProps(nextData);
          if (propertyName !== void 0)
            subschema2.propertyName = propertyName;
        }
        if (dataTypes)
          subschema2.dataTypes = dataTypes;
        function dataContextProps(_nextData) {
          subschema2.data = _nextData;
          subschema2.dataLevel = it.dataLevel + 1;
          subschema2.dataTypes = [];
          it.definedProperties = /* @__PURE__ */ new Set();
          subschema2.parentData = it.data;
          subschema2.dataNames = [...it.dataNames, _nextData];
        }
      }
      subschema.extendSubschemaData = extendSubschemaData;
      function extendSubschemaMode(subschema2, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
        if (compositeRule !== void 0)
          subschema2.compositeRule = compositeRule;
        if (createErrors !== void 0)
          subschema2.createErrors = createErrors;
        if (allErrors !== void 0)
          subschema2.allErrors = allErrors;
        subschema2.jtdDiscriminator = jtdDiscriminator;
        subschema2.jtdMetadata = jtdMetadata;
      }
      subschema.extendSubschemaMode = extendSubschemaMode;
      return subschema;
    }
    var resolve = {};
    var fastDeepEqual;
    var hasRequiredFastDeepEqual;
    function requireFastDeepEqual() {
      if (hasRequiredFastDeepEqual) return fastDeepEqual;
      hasRequiredFastDeepEqual = 1;
      "use strict";
      fastDeepEqual = function equal2(a, b) {
        if (a === b) return true;
        if (a && b && typeof a == "object" && typeof b == "object") {
          if (a.constructor !== b.constructor) return false;
          var length, i, keys;
          if (Array.isArray(a)) {
            length = a.length;
            if (length != b.length) return false;
            for (i = length; i-- !== 0; )
              if (!equal2(a[i], b[i])) return false;
            return true;
          }
          if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
          if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
          if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
          keys = Object.keys(a);
          length = keys.length;
          if (length !== Object.keys(b).length) return false;
          for (i = length; i-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
          for (i = length; i-- !== 0; ) {
            var key = keys[i];
            if (!equal2(a[key], b[key])) return false;
          }
          return true;
        }
        return a !== a && b !== b;
      };
      return fastDeepEqual;
    }
    var jsonSchemaTraverse$1 = { exports: {} };
    var jsonSchemaTraverse = jsonSchemaTraverse$1.exports;
    var hasRequiredJsonSchemaTraverse;
    function requireJsonSchemaTraverse() {
      if (hasRequiredJsonSchemaTraverse) return jsonSchemaTraverse$1.exports;
      hasRequiredJsonSchemaTraverse = 1;
      "use strict";
      var traverse2 = jsonSchemaTraverse$1.exports = function(schema, opts, cb) {
        if (typeof opts == "function") {
          cb = opts;
          opts = {};
        }
        cb = opts.cb || cb;
        var pre = typeof cb == "function" ? cb : cb.pre || function() {
        };
        var post = cb.post || function() {
        };
        _traverse(opts, pre, post, schema, "", schema);
      };
      traverse2.keywords = {
        additionalItems: true,
        items: true,
        contains: true,
        additionalProperties: true,
        propertyNames: true,
        not: true,
        if: true,
        then: true,
        else: true
      };
      traverse2.arrayKeywords = {
        items: true,
        allOf: true,
        anyOf: true,
        oneOf: true
      };
      traverse2.propsKeywords = {
        $defs: true,
        definitions: true,
        properties: true,
        patternProperties: true,
        dependencies: true
      };
      traverse2.skipKeywords = {
        default: true,
        enum: true,
        const: true,
        required: true,
        maximum: true,
        minimum: true,
        exclusiveMaximum: true,
        exclusiveMinimum: true,
        multipleOf: true,
        maxLength: true,
        minLength: true,
        pattern: true,
        format: true,
        maxItems: true,
        minItems: true,
        uniqueItems: true,
        maxProperties: true,
        minProperties: true
      };
      function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
        if (schema && typeof schema == "object" && !Array.isArray(schema)) {
          pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
          for (var key in schema) {
            var sch = schema[key];
            if (Array.isArray(sch)) {
              if (key in traverse2.arrayKeywords) {
                for (var i = 0; i < sch.length; i++)
                  _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
              }
            } else if (key in traverse2.propsKeywords) {
              if (sch && typeof sch == "object") {
                for (var prop in sch)
                  _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
              }
            } else if (key in traverse2.keywords || opts.allKeys && !(key in traverse2.skipKeywords)) {
              _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
            }
          }
          post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        }
      }
      function escapeJsonPtr(str) {
        return str.replace(/~/g, "~0").replace(/\//g, "~1");
      }
      return jsonSchemaTraverse$1.exports;
    }
    var hasRequiredResolve;
    function requireResolve() {
      if (hasRequiredResolve) return resolve;
      hasRequiredResolve = 1;
      "use strict";
      Object.defineProperty(resolve, "__esModule", { value: true });
      resolve.getSchemaRefs = resolve.resolveUrl = resolve.normalizeId = resolve._getFullPath = resolve.getFullPath = resolve.inlineRef = void 0;
      const util_1 = requireUtil();
      const equal2 = requireFastDeepEqual();
      const traverse2 = requireJsonSchemaTraverse();
      const SIMPLE_INLINED = /* @__PURE__ */ new Set([
        "type",
        "format",
        "pattern",
        "maxLength",
        "minLength",
        "maxProperties",
        "minProperties",
        "maxItems",
        "minItems",
        "maximum",
        "minimum",
        "uniqueItems",
        "multipleOf",
        "required",
        "enum",
        "const"
      ]);
      function inlineRef(schema, limit2 = true) {
        if (typeof schema == "boolean")
          return true;
        if (limit2 === true)
          return !hasRef(schema);
        if (!limit2)
          return false;
        return countKeys(schema) <= limit2;
      }
      resolve.inlineRef = inlineRef;
      const REF_KEYWORDS = /* @__PURE__ */ new Set([
        "$ref",
        "$recursiveRef",
        "$recursiveAnchor",
        "$dynamicRef",
        "$dynamicAnchor"
      ]);
      function hasRef(schema) {
        for (const key in schema) {
          if (REF_KEYWORDS.has(key))
            return true;
          const sch = schema[key];
          if (Array.isArray(sch) && sch.some(hasRef))
            return true;
          if (typeof sch == "object" && hasRef(sch))
            return true;
        }
        return false;
      }
      function countKeys(schema) {
        let count = 0;
        for (const key in schema) {
          if (key === "$ref")
            return Infinity;
          count++;
          if (SIMPLE_INLINED.has(key))
            continue;
          if (typeof schema[key] == "object") {
            (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
          }
          if (count === Infinity)
            return Infinity;
        }
        return count;
      }
      function getFullPath(resolver, id2 = "", normalize) {
        if (normalize !== false)
          id2 = normalizeId(id2);
        const p2 = resolver.parse(id2);
        return _getFullPath(resolver, p2);
      }
      resolve.getFullPath = getFullPath;
      function _getFullPath(resolver, p2) {
        const serialized = resolver.serialize(p2);
        return serialized.split("#")[0] + "#";
      }
      resolve._getFullPath = _getFullPath;
      const TRAILING_SLASH_HASH = /#\/?$/;
      function normalizeId(id2) {
        return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
      }
      resolve.normalizeId = normalizeId;
      function resolveUrl(resolver, baseId, id2) {
        id2 = normalizeId(id2);
        return resolver.resolve(baseId, id2);
      }
      resolve.resolveUrl = resolveUrl;
      const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
      function getSchemaRefs(schema, baseId) {
        if (typeof schema == "boolean")
          return {};
        const { schemaId, uriResolver } = this.opts;
        const schId = normalizeId(schema[schemaId] || baseId);
        const baseIds = { "": schId };
        const pathPrefix = getFullPath(uriResolver, schId, false);
        const localRefs = {};
        const schemaRefs = /* @__PURE__ */ new Set();
        traverse2(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
          if (parentJsonPtr === void 0)
            return;
          const fullPath = pathPrefix + jsonPtr;
          let innerBaseId = baseIds[parentJsonPtr];
          if (typeof sch[schemaId] == "string")
            innerBaseId = addRef.call(this, sch[schemaId]);
          addAnchor.call(this, sch.$anchor);
          addAnchor.call(this, sch.$dynamicAnchor);
          baseIds[jsonPtr] = innerBaseId;
          function addRef(ref2) {
            const _resolve = this.opts.uriResolver.resolve;
            ref2 = normalizeId(innerBaseId ? _resolve(innerBaseId, ref2) : ref2);
            if (schemaRefs.has(ref2))
              throw ambiguos(ref2);
            schemaRefs.add(ref2);
            let schOrRef = this.refs[ref2];
            if (typeof schOrRef == "string")
              schOrRef = this.refs[schOrRef];
            if (typeof schOrRef == "object") {
              checkAmbiguosRef(sch, schOrRef.schema, ref2);
            } else if (ref2 !== normalizeId(fullPath)) {
              if (ref2[0] === "#") {
                checkAmbiguosRef(sch, localRefs[ref2], ref2);
                localRefs[ref2] = sch;
              } else {
                this.refs[ref2] = fullPath;
              }
            }
            return ref2;
          }
          function addAnchor(anchor) {
            if (typeof anchor == "string") {
              if (!ANCHOR.test(anchor))
                throw new Error(`invalid anchor "${anchor}"`);
              addRef.call(this, `#${anchor}`);
            }
          }
        });
        return localRefs;
        function checkAmbiguosRef(sch1, sch2, ref2) {
          if (sch2 !== void 0 && !equal2(sch1, sch2))
            throw ambiguos(ref2);
        }
        function ambiguos(ref2) {
          return new Error(`reference "${ref2}" resolves to more than one schema`);
        }
      }
      resolve.getSchemaRefs = getSchemaRefs;
      return resolve;
    }
    var hasRequiredValidate;
    function requireValidate() {
      if (hasRequiredValidate) return validate;
      hasRequiredValidate = 1;
      "use strict";
      Object.defineProperty(validate, "__esModule", { value: true });
      validate.getData = validate.KeywordCxt = validate.validateFunctionCode = void 0;
      const boolSchema_1 = requireBoolSchema();
      const dataType_1 = requireDataType();
      const applicability_1 = requireApplicability();
      const dataType_2 = requireDataType();
      const defaults_1 = requireDefaults();
      const keyword_1 = requireKeyword();
      const subschema_1 = requireSubschema();
      const codegen_1 = requireCodegen();
      const names_1 = requireNames();
      const resolve_1 = requireResolve();
      const util_1 = requireUtil();
      const errors_1 = requireErrors();
      function validateFunctionCode(it) {
        if (isSchemaObj(it)) {
          checkKeywords(it);
          if (schemaCxtHasRules(it)) {
            topSchemaObjCode(it);
            return;
          }
        }
        validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
      }
      validate.validateFunctionCode = validateFunctionCode;
      function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
        if (opts.code.es5) {
          gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
            gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
            destructureValCxtES5(gen, opts);
            gen.code(body);
          });
        } else {
          gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
        }
      }
      function destructureValCxt(opts) {
        return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
      }
      function destructureValCxtES5(gen, opts) {
        gen.if(names_1.default.valCxt, () => {
          gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
          gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
          gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
          gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
          if (opts.dynamicRef)
            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
        }, () => {
          gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
          gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
          gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
          gen.var(names_1.default.rootData, names_1.default.data);
          if (opts.dynamicRef)
            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
        });
      }
      function topSchemaObjCode(it) {
        const { schema, opts, gen } = it;
        validateFunction(it, () => {
          if (opts.$comment && schema.$comment)
            commentKeyword(it);
          checkNoDefault(it);
          gen.let(names_1.default.vErrors, null);
          gen.let(names_1.default.errors, 0);
          if (opts.unevaluated)
            resetEvaluated(it);
          typeAndKeywords(it);
          returnResults(it);
        });
        return;
      }
      function resetEvaluated(it) {
        const { gen, validateName } = it;
        it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
        gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
        gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
      }
      function funcSourceUrl(schema, opts) {
        const schId = typeof schema == "object" && schema[opts.schemaId];
        return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
      }
      function subschemaCode(it, valid) {
        if (isSchemaObj(it)) {
          checkKeywords(it);
          if (schemaCxtHasRules(it)) {
            subSchemaObjCode(it, valid);
            return;
          }
        }
        (0, boolSchema_1.boolOrEmptySchema)(it, valid);
      }
      function schemaCxtHasRules({ schema, self: self2 }) {
        if (typeof schema == "boolean")
          return !schema;
        for (const key in schema)
          if (self2.RULES.all[key])
            return true;
        return false;
      }
      function isSchemaObj(it) {
        return typeof it.schema != "boolean";
      }
      function subSchemaObjCode(it, valid) {
        const { schema, gen, opts } = it;
        if (opts.$comment && schema.$comment)
          commentKeyword(it);
        updateContext(it);
        checkAsyncSchema(it);
        const errsCount = gen.const("_errs", names_1.default.errors);
        typeAndKeywords(it, errsCount);
        gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
      }
      function checkKeywords(it) {
        (0, util_1.checkUnknownRules)(it);
        checkRefsAndKeywords(it);
      }
      function typeAndKeywords(it, errsCount) {
        if (it.opts.jtd)
          return schemaKeywords(it, [], false, errsCount);
        const types2 = (0, dataType_1.getSchemaTypes)(it.schema);
        const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types2);
        schemaKeywords(it, types2, !checkedTypes, errsCount);
      }
      function checkRefsAndKeywords(it) {
        const { schema, errSchemaPath, opts, self: self2 } = it;
        if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
          self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
        }
      }
      function checkNoDefault(it) {
        const { schema, opts } = it;
        if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
          (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
        }
      }
      function updateContext(it) {
        const schId = it.schema[it.opts.schemaId];
        if (schId)
          it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
      }
      function checkAsyncSchema(it) {
        if (it.schema.$async && !it.schemaEnv.$async)
          throw new Error("async schema in sync schema");
      }
      function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
        const msg = schema.$comment;
        if (opts.$comment === true) {
          gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
        } else if (typeof opts.$comment == "function") {
          const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
          const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
          gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
        }
      }
      function returnResults(it) {
        const { gen, schemaEnv, validateName, ValidationError, opts } = it;
        if (schemaEnv.$async) {
          gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
        } else {
          gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
          if (opts.unevaluated)
            assignEvaluated(it);
          gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
        }
      }
      function assignEvaluated({ gen, evaluated, props, items: items2 }) {
        if (props instanceof codegen_1.Name)
          gen.assign((0, codegen_1._)`${evaluated}.props`, props);
        if (items2 instanceof codegen_1.Name)
          gen.assign((0, codegen_1._)`${evaluated}.items`, items2);
      }
      function schemaKeywords(it, types2, typeErrors, errsCount) {
        const { gen, schema, data, allErrors, opts, self: self2 } = it;
        const { RULES } = self2;
        if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
          gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
          return;
        }
        if (!opts.jtd)
          checkStrictTypes(it, types2);
        gen.block(() => {
          for (const group of RULES.rules)
            groupKeywords(group);
          groupKeywords(RULES.post);
        });
        function groupKeywords(group) {
          if (!(0, applicability_1.shouldUseGroup)(schema, group))
            return;
          if (group.type) {
            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
            iterateKeywords(it, group);
            if (types2.length === 1 && types2[0] === group.type && typeErrors) {
              gen.else();
              (0, dataType_2.reportTypeError)(it);
            }
            gen.endIf();
          } else {
            iterateKeywords(it, group);
          }
          if (!allErrors)
            gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
        }
      }
      function iterateKeywords(it, group) {
        const { gen, schema, opts: { useDefaults } } = it;
        if (useDefaults)
          (0, defaults_1.assignDefaults)(it, group.type);
        gen.block(() => {
          for (const rule of group.rules) {
            if ((0, applicability_1.shouldUseRule)(schema, rule)) {
              keywordCode(it, rule.keyword, rule.definition, group.type);
            }
          }
        });
      }
      function checkStrictTypes(it, types2) {
        if (it.schemaEnv.meta || !it.opts.strictTypes)
          return;
        checkContextTypes(it, types2);
        if (!it.opts.allowUnionTypes)
          checkMultipleTypes(it, types2);
        checkKeywordTypes(it, it.dataTypes);
      }
      function checkContextTypes(it, types2) {
        if (!types2.length)
          return;
        if (!it.dataTypes.length) {
          it.dataTypes = types2;
          return;
        }
        types2.forEach((t) => {
          if (!includesType(it.dataTypes, t)) {
            strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
          }
        });
        narrowSchemaTypes(it, types2);
      }
      function checkMultipleTypes(it, ts) {
        if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
          strictTypesError(it, "use allowUnionTypes to allow union type keyword");
        }
      }
      function checkKeywordTypes(it, ts) {
        const rules2 = it.self.RULES.all;
        for (const keyword2 in rules2) {
          const rule = rules2[keyword2];
          if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
            const { type: type2 } = rule.definition;
            if (type2.length && !type2.some((t) => hasApplicableType(ts, t))) {
              strictTypesError(it, `missing type "${type2.join(",")}" for keyword "${keyword2}"`);
            }
          }
        }
      }
      function hasApplicableType(schTs, kwdT) {
        return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
      }
      function includesType(ts, t) {
        return ts.includes(t) || t === "integer" && ts.includes("number");
      }
      function narrowSchemaTypes(it, withTypes) {
        const ts = [];
        for (const t of it.dataTypes) {
          if (includesType(withTypes, t))
            ts.push(t);
          else if (withTypes.includes("integer") && t === "number")
            ts.push("integer");
        }
        it.dataTypes = ts;
      }
      function strictTypesError(it, msg) {
        const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
        msg += ` at "${schemaPath}" (strictTypes)`;
        (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
      }
      class KeywordCxt {
        constructor(it, def2, keyword2) {
          (0, keyword_1.validateKeywordUsage)(it, def2, keyword2);
          this.gen = it.gen;
          this.allErrors = it.allErrors;
          this.keyword = keyword2;
          this.data = it.data;
          this.schema = it.schema[keyword2];
          this.$data = def2.$data && it.opts.$data && this.schema && this.schema.$data;
          this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword2, this.$data);
          this.schemaType = def2.schemaType;
          this.parentSchema = it.schema;
          this.params = {};
          this.it = it;
          this.def = def2;
          if (this.$data) {
            this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
          } else {
            this.schemaCode = this.schemaValue;
            if (!(0, keyword_1.validSchemaType)(this.schema, def2.schemaType, def2.allowUndefined)) {
              throw new Error(`${keyword2} value must be ${JSON.stringify(def2.schemaType)}`);
            }
          }
          if ("code" in def2 ? def2.trackErrors : def2.errors !== false) {
            this.errsCount = it.gen.const("_errs", names_1.default.errors);
          }
        }
        result(condition, successAction, failAction) {
          this.failResult((0, codegen_1.not)(condition), successAction, failAction);
        }
        failResult(condition, successAction, failAction) {
          this.gen.if(condition);
          if (failAction)
            failAction();
          else
            this.error();
          if (successAction) {
            this.gen.else();
            successAction();
            if (this.allErrors)
              this.gen.endIf();
          } else {
            if (this.allErrors)
              this.gen.endIf();
            else
              this.gen.else();
          }
        }
        pass(condition, failAction) {
          this.failResult((0, codegen_1.not)(condition), void 0, failAction);
        }
        fail(condition) {
          if (condition === void 0) {
            this.error();
            if (!this.allErrors)
              this.gen.if(false);
            return;
          }
          this.gen.if(condition);
          this.error();
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
        fail$data(condition) {
          if (!this.$data)
            return this.fail(condition);
          const { schemaCode } = this;
          this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
        }
        error(append, errorParams, errorPaths) {
          if (errorParams) {
            this.setParams(errorParams);
            this._error(append, errorPaths);
            this.setParams({});
            return;
          }
          this._error(append, errorPaths);
        }
        _error(append, errorPaths) {
          ;
          (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
        }
        $dataError() {
          (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
        }
        reset() {
          if (this.errsCount === void 0)
            throw new Error('add "trackErrors" to keyword definition');
          (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
        }
        ok(cond) {
          if (!this.allErrors)
            this.gen.if(cond);
        }
        setParams(obj, assign) {
          if (assign)
            Object.assign(this.params, obj);
          else
            this.params = obj;
        }
        block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
          this.gen.block(() => {
            this.check$data(valid, $dataValid);
            codeBlock();
          });
        }
        check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
          if (!this.$data)
            return;
          const { gen, schemaCode, schemaType, def: def2 } = this;
          gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
          if (valid !== codegen_1.nil)
            gen.assign(valid, true);
          if (schemaType.length || def2.validateSchema) {
            gen.elseIf(this.invalid$data());
            this.$dataError();
            if (valid !== codegen_1.nil)
              gen.assign(valid, false);
          }
          gen.else();
        }
        invalid$data() {
          const { gen, schemaCode, schemaType, def: def2, it } = this;
          return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
          function wrong$DataType() {
            if (schemaType.length) {
              if (!(schemaCode instanceof codegen_1.Name))
                throw new Error("ajv implementation error");
              const st = Array.isArray(schemaType) ? schemaType : [schemaType];
              return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
            }
            return codegen_1.nil;
          }
          function invalid$DataSchema() {
            if (def2.validateSchema) {
              const validateSchemaRef = gen.scopeValue("validate$data", { ref: def2.validateSchema });
              return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
            }
            return codegen_1.nil;
          }
        }
        subschema(appl, valid) {
          const subschema2 = (0, subschema_1.getSubschema)(this.it, appl);
          (0, subschema_1.extendSubschemaData)(subschema2, this.it, appl);
          (0, subschema_1.extendSubschemaMode)(subschema2, appl);
          const nextContext = { ...this.it, ...subschema2, items: void 0, props: void 0 };
          subschemaCode(nextContext, valid);
          return nextContext;
        }
        mergeEvaluated(schemaCxt, toName) {
          const { it, gen } = this;
          if (!it.opts.unevaluated)
            return;
          if (it.props !== true && schemaCxt.props !== void 0) {
            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
          }
          if (it.items !== true && schemaCxt.items !== void 0) {
            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
          }
        }
        mergeValidEvaluated(schemaCxt, valid) {
          const { it, gen } = this;
          if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
            return true;
          }
        }
      }
      validate.KeywordCxt = KeywordCxt;
      function keywordCode(it, keyword2, def2, ruleType) {
        const cxt = new KeywordCxt(it, def2, keyword2);
        if ("code" in def2) {
          def2.code(cxt, ruleType);
        } else if (cxt.$data && def2.validate) {
          (0, keyword_1.funcKeywordCode)(cxt, def2);
        } else if ("macro" in def2) {
          (0, keyword_1.macroKeywordCode)(cxt, def2);
        } else if (def2.compile || def2.validate) {
          (0, keyword_1.funcKeywordCode)(cxt, def2);
        }
      }
      const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
      const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
      function getData($data, { dataLevel, dataNames, dataPathArr }) {
        let jsonPointer;
        let data;
        if ($data === "")
          return names_1.default.rootData;
        if ($data[0] === "/") {
          if (!JSON_POINTER.test($data))
            throw new Error(`Invalid JSON-pointer: ${$data}`);
          jsonPointer = $data;
          data = names_1.default.rootData;
        } else {
          const matches2 = RELATIVE_JSON_POINTER.exec($data);
          if (!matches2)
            throw new Error(`Invalid JSON-pointer: ${$data}`);
          const up = +matches2[1];
          jsonPointer = matches2[2];
          if (jsonPointer === "#") {
            if (up >= dataLevel)
              throw new Error(errorMsg("property/index", up));
            return dataPathArr[dataLevel - up];
          }
          if (up > dataLevel)
            throw new Error(errorMsg("data", up));
          data = dataNames[dataLevel - up];
          if (!jsonPointer)
            return data;
        }
        let expr = data;
        const segments = jsonPointer.split("/");
        for (const segment of segments) {
          if (segment) {
            data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
            expr = (0, codegen_1._)`${expr} && ${data}`;
          }
        }
        return expr;
        function errorMsg(pointerType, up) {
          return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
        }
      }
      validate.getData = getData;
      return validate;
    }
    var validation_error = {};
    var hasRequiredValidation_error;
    function requireValidation_error() {
      if (hasRequiredValidation_error) return validation_error;
      hasRequiredValidation_error = 1;
      "use strict";
      Object.defineProperty(validation_error, "__esModule", { value: true });
      class ValidationError extends Error {
        constructor(errors2) {
          super("validation failed");
          this.errors = errors2;
          this.ajv = this.validation = true;
        }
      }
      validation_error.default = ValidationError;
      return validation_error;
    }
    var ref_error = {};
    var hasRequiredRef_error;
    function requireRef_error() {
      if (hasRequiredRef_error) return ref_error;
      hasRequiredRef_error = 1;
      "use strict";
      Object.defineProperty(ref_error, "__esModule", { value: true });
      const resolve_1 = requireResolve();
      class MissingRefError extends Error {
        constructor(resolver, baseId, ref2, msg) {
          super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
          this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref2);
          this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
        }
      }
      ref_error.default = MissingRefError;
      return ref_error;
    }
    var compile = {};
    var hasRequiredCompile;
    function requireCompile() {
      if (hasRequiredCompile) return compile;
      hasRequiredCompile = 1;
      "use strict";
      Object.defineProperty(compile, "__esModule", { value: true });
      compile.resolveSchema = compile.getCompilingSchema = compile.resolveRef = compile.compileSchema = compile.SchemaEnv = void 0;
      const codegen_1 = requireCodegen();
      const validation_error_1 = requireValidation_error();
      const names_1 = requireNames();
      const resolve_1 = requireResolve();
      const util_1 = requireUtil();
      const validate_1 = requireValidate();
      class SchemaEnv {
        constructor(env) {
          var _a;
          this.refs = {};
          this.dynamicAnchors = {};
          let schema;
          if (typeof env.schema == "object")
            schema = env.schema;
          this.schema = env.schema;
          this.schemaId = env.schemaId;
          this.root = env.root || this;
          this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
          this.schemaPath = env.schemaPath;
          this.localRefs = env.localRefs;
          this.meta = env.meta;
          this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
          this.refs = {};
        }
      }
      compile.SchemaEnv = SchemaEnv;
      function compileSchema(sch) {
        const _sch = getCompilingSchema.call(this, sch);
        if (_sch)
          return _sch;
        const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
        const { es5, lines } = this.opts.code;
        const { ownProperties } = this.opts;
        const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
        let _ValidationError;
        if (sch.$async) {
          _ValidationError = gen.scopeValue("Error", {
            ref: validation_error_1.default,
            code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
          });
        }
        const validateName = gen.scopeName("validate");
        sch.validateName = validateName;
        const schemaCxt = {
          gen,
          allErrors: this.opts.allErrors,
          data: names_1.default.data,
          parentData: names_1.default.parentData,
          parentDataProperty: names_1.default.parentDataProperty,
          dataNames: [names_1.default.data],
          dataPathArr: [codegen_1.nil],
          // TODO can its length be used as dataLevel if nil is removed?
          dataLevel: 0,
          dataTypes: [],
          definedProperties: /* @__PURE__ */ new Set(),
          topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
          validateName,
          ValidationError: _ValidationError,
          schema: sch.schema,
          schemaEnv: sch,
          rootId,
          baseId: sch.baseId || rootId,
          schemaPath: codegen_1.nil,
          errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
          errorPath: (0, codegen_1._)`""`,
          opts: this.opts,
          self: this
        };
        let sourceCode;
        try {
          this._compilations.add(sch);
          (0, validate_1.validateFunctionCode)(schemaCxt);
          gen.optimize(this.opts.code.optimize);
          const validateCode = gen.toString();
          sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
          if (this.opts.code.process)
            sourceCode = this.opts.code.process(sourceCode, sch);
          const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
          const validate2 = makeValidate(this, this.scope.get());
          this.scope.value(validateName, { ref: validate2 });
          validate2.errors = null;
          validate2.schema = sch.schema;
          validate2.schemaEnv = sch;
          if (sch.$async)
            validate2.$async = true;
          if (this.opts.code.source === true) {
            validate2.source = { validateName, validateCode, scopeValues: gen._values };
          }
          if (this.opts.unevaluated) {
            const { props, items: items2 } = schemaCxt;
            validate2.evaluated = {
              props: props instanceof codegen_1.Name ? void 0 : props,
              items: items2 instanceof codegen_1.Name ? void 0 : items2,
              dynamicProps: props instanceof codegen_1.Name,
              dynamicItems: items2 instanceof codegen_1.Name
            };
            if (validate2.source)
              validate2.source.evaluated = (0, codegen_1.stringify)(validate2.evaluated);
          }
          sch.validate = validate2;
          return sch;
        } catch (e) {
          delete sch.validate;
          delete sch.validateName;
          if (sourceCode)
            this.logger.error("Error compiling schema, function code:", sourceCode);
          throw e;
        } finally {
          this._compilations.delete(sch);
        }
      }
      compile.compileSchema = compileSchema;
      function resolveRef(root, baseId, ref2) {
        var _a;
        ref2 = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref2);
        const schOrFunc = root.refs[ref2];
        if (schOrFunc)
          return schOrFunc;
        let _sch = resolve2.call(this, root, ref2);
        if (_sch === void 0) {
          const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref2];
          const { schemaId } = this.opts;
          if (schema)
            _sch = new SchemaEnv({ schema, schemaId, root, baseId });
        }
        if (_sch === void 0)
          return;
        return root.refs[ref2] = inlineOrCompile.call(this, _sch);
      }
      compile.resolveRef = resolveRef;
      function inlineOrCompile(sch) {
        if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
          return sch.schema;
        return sch.validate ? sch : compileSchema.call(this, sch);
      }
      function getCompilingSchema(schEnv) {
        for (const sch of this._compilations) {
          if (sameSchemaEnv(sch, schEnv))
            return sch;
        }
      }
      compile.getCompilingSchema = getCompilingSchema;
      function sameSchemaEnv(s1, s2) {
        return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
      }
      function resolve2(root, ref2) {
        let sch;
        while (typeof (sch = this.refs[ref2]) == "string")
          ref2 = sch;
        return sch || this.schemas[ref2] || resolveSchema.call(this, root, ref2);
      }
      function resolveSchema(root, ref2) {
        const p2 = this.opts.uriResolver.parse(ref2);
        const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p2);
        let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
        if (Object.keys(root.schema).length > 0 && refPath === baseId) {
          return getJsonPointer.call(this, p2, root);
        }
        const id2 = (0, resolve_1.normalizeId)(refPath);
        const schOrRef = this.refs[id2] || this.schemas[id2];
        if (typeof schOrRef == "string") {
          const sch = resolveSchema.call(this, root, schOrRef);
          if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
            return;
          return getJsonPointer.call(this, p2, sch);
        }
        if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
          return;
        if (!schOrRef.validate)
          compileSchema.call(this, schOrRef);
        if (id2 === (0, resolve_1.normalizeId)(ref2)) {
          const { schema } = schOrRef;
          const { schemaId } = this.opts;
          const schId = schema[schemaId];
          if (schId)
            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
          return new SchemaEnv({ schema, schemaId, root, baseId });
        }
        return getJsonPointer.call(this, p2, schOrRef);
      }
      compile.resolveSchema = resolveSchema;
      const PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
        "properties",
        "patternProperties",
        "enum",
        "dependencies",
        "definitions"
      ]);
      function getJsonPointer(parsedRef, { baseId, schema, root }) {
        var _a;
        if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
          return;
        for (const part of parsedRef.fragment.slice(1).split("/")) {
          if (typeof schema === "boolean")
            return;
          const partSchema = schema[(0, util_1.unescapeFragment)(part)];
          if (partSchema === void 0)
            return;
          schema = partSchema;
          const schId = typeof schema === "object" && schema[this.opts.schemaId];
          if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
          }
        }
        let env;
        if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
          const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
          env = resolveSchema.call(this, root, $ref);
        }
        const { schemaId } = this.opts;
        env = env || new SchemaEnv({ schema, schemaId, root, baseId });
        if (env.schema !== env.root.schema)
          return env;
        return void 0;
      }
      return compile;
    }
    const $id$1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
    const description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
    const type$1 = "object";
    const required$1 = ["$data"];
    const properties$2 = { "$data": { "type": "string", "anyOf": [{ "format": "relative-json-pointer" }, { "format": "json-pointer" }] } };
    const additionalProperties$1 = false;
    const require$$9 = {
      $id: $id$1,
      description,
      type: type$1,
      required: required$1,
      properties: properties$2,
      additionalProperties: additionalProperties$1
    };
    var uri = {};
    var fastUri = { exports: {} };
    var scopedChars;
    var hasRequiredScopedChars;
    function requireScopedChars() {
      if (hasRequiredScopedChars) return scopedChars;
      hasRequiredScopedChars = 1;
      "use strict";
      const HEX = {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        a: 10,
        A: 10,
        b: 11,
        B: 11,
        c: 12,
        C: 12,
        d: 13,
        D: 13,
        e: 14,
        E: 14,
        f: 15,
        F: 15
      };
      scopedChars = {
        HEX
      };
      return scopedChars;
    }
    var utils;
    var hasRequiredUtils;
    function requireUtils() {
      if (hasRequiredUtils) return utils;
      hasRequiredUtils = 1;
      "use strict";
      const { HEX } = requireScopedChars();
      const IPV4_REG = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
      function normalizeIPv4(host) {
        if (findToken(host, ".") < 3) {
          return { host, isIPV4: false };
        }
        const matches2 = host.match(IPV4_REG) || [];
        const [address] = matches2;
        if (address) {
          return { host: stripLeadingZeros(address, "."), isIPV4: true };
        } else {
          return { host, isIPV4: false };
        }
      }
      function stringArrayToHexStripped(input, keepZero = false) {
        let acc = "";
        let strip = true;
        for (const c of input) {
          if (HEX[c] === void 0) return void 0;
          if (c !== "0" && strip === true) strip = false;
          if (!strip) acc += c;
        }
        if (keepZero && acc.length === 0) acc = "0";
        return acc;
      }
      function getIPV6(input) {
        let tokenCount = 0;
        const output = { error: false, address: "", zone: "" };
        const address = [];
        const buffer2 = [];
        let isZone = false;
        let endipv6Encountered = false;
        let endIpv6 = false;
        function consume() {
          if (buffer2.length) {
            if (isZone === false) {
              const hex = stringArrayToHexStripped(buffer2);
              if (hex !== void 0) {
                address.push(hex);
              } else {
                output.error = true;
                return false;
              }
            }
            buffer2.length = 0;
          }
          return true;
        }
        for (let i = 0; i < input.length; i++) {
          const cursor = input[i];
          if (cursor === "[" || cursor === "]") {
            continue;
          }
          if (cursor === ":") {
            if (endipv6Encountered === true) {
              endIpv6 = true;
            }
            if (!consume()) {
              break;
            }
            tokenCount++;
            address.push(":");
            if (tokenCount > 7) {
              output.error = true;
              break;
            }
            if (i - 1 >= 0 && input[i - 1] === ":") {
              endipv6Encountered = true;
            }
            continue;
          } else if (cursor === "%") {
            if (!consume()) {
              break;
            }
            isZone = true;
          } else {
            buffer2.push(cursor);
            continue;
          }
        }
        if (buffer2.length) {
          if (isZone) {
            output.zone = buffer2.join("");
          } else if (endIpv6) {
            address.push(buffer2.join(""));
          } else {
            address.push(stringArrayToHexStripped(buffer2));
          }
        }
        output.address = address.join("");
        return output;
      }
      function normalizeIPv6(host) {
        if (findToken(host, ":") < 2) {
          return { host, isIPV6: false };
        }
        const ipv6 = getIPV6(host);
        if (!ipv6.error) {
          let newHost = ipv6.address;
          let escapedHost = ipv6.address;
          if (ipv6.zone) {
            newHost += "%" + ipv6.zone;
            escapedHost += "%25" + ipv6.zone;
          }
          return { host: newHost, escapedHost, isIPV6: true };
        } else {
          return { host, isIPV6: false };
        }
      }
      function stripLeadingZeros(str, token) {
        let out = "";
        let skip = true;
        const l = str.length;
        for (let i = 0; i < l; i++) {
          const c = str[i];
          if (c === "0" && skip) {
            if (i + 1 <= l && str[i + 1] === token || i + 1 === l) {
              out += c;
              skip = false;
            }
          } else {
            if (c === token) {
              skip = true;
            } else {
              skip = false;
            }
            out += c;
          }
        }
        return out;
      }
      function findToken(str, token) {
        let ind = 0;
        for (let i = 0; i < str.length; i++) {
          if (str[i] === token) ind++;
        }
        return ind;
      }
      const RDS1 = /^\.\.?\//u;
      const RDS2 = /^\/\.(?:\/|$)/u;
      const RDS3 = /^\/\.\.(?:\/|$)/u;
      const RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;
      function removeDotSegments(input) {
        const output = [];
        while (input.length) {
          if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
          } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
          } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
          } else if (input === "." || input === "..") {
            input = "";
          } else {
            const im = input.match(RDS5);
            if (im) {
              const s = im[0];
              input = input.slice(s.length);
              output.push(s);
            } else {
              throw new Error("Unexpected dot segment condition");
            }
          }
        }
        return output.join("");
      }
      function normalizeComponentEncoding(components, esc) {
        const func = esc !== true ? escape : unescape;
        if (components.scheme !== void 0) {
          components.scheme = func(components.scheme);
        }
        if (components.userinfo !== void 0) {
          components.userinfo = func(components.userinfo);
        }
        if (components.host !== void 0) {
          components.host = func(components.host);
        }
        if (components.path !== void 0) {
          components.path = func(components.path);
        }
        if (components.query !== void 0) {
          components.query = func(components.query);
        }
        if (components.fragment !== void 0) {
          components.fragment = func(components.fragment);
        }
        return components;
      }
      function recomposeAuthority(components) {
        const uriTokens = [];
        if (components.userinfo !== void 0) {
          uriTokens.push(components.userinfo);
          uriTokens.push("@");
        }
        if (components.host !== void 0) {
          let host = unescape(components.host);
          const ipV4res = normalizeIPv4(host);
          if (ipV4res.isIPV4) {
            host = ipV4res.host;
          } else {
            const ipV6res = normalizeIPv6(ipV4res.host);
            if (ipV6res.isIPV6 === true) {
              host = `[${ipV6res.escapedHost}]`;
            } else {
              host = components.host;
            }
          }
          uriTokens.push(host);
        }
        if (typeof components.port === "number" || typeof components.port === "string") {
          uriTokens.push(":");
          uriTokens.push(String(components.port));
        }
        return uriTokens.length ? uriTokens.join("") : void 0;
      }
      ;
      utils = {
        recomposeAuthority,
        normalizeComponentEncoding,
        removeDotSegments,
        normalizeIPv4,
        normalizeIPv6,
        stringArrayToHexStripped
      };
      return utils;
    }
    var schemes;
    var hasRequiredSchemes;
    function requireSchemes() {
      if (hasRequiredSchemes) return schemes;
      hasRequiredSchemes = 1;
      "use strict";
      const UUID_REG = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu;
      const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
      function isSecure(wsComponents) {
        return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
      }
      function httpParse(components) {
        if (!components.host) {
          components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
      }
      function httpSerialize(components) {
        const secure = String(components.scheme).toLowerCase() === "https";
        if (components.port === (secure ? 443 : 80) || components.port === "") {
          components.port = void 0;
        }
        if (!components.path) {
          components.path = "/";
        }
        return components;
      }
      function wsParse(wsComponents) {
        wsComponents.secure = isSecure(wsComponents);
        wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
        wsComponents.path = void 0;
        wsComponents.query = void 0;
        return wsComponents;
      }
      function wsSerialize(wsComponents) {
        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
          wsComponents.port = void 0;
        }
        if (typeof wsComponents.secure === "boolean") {
          wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
          wsComponents.secure = void 0;
        }
        if (wsComponents.resourceName) {
          const [path, query] = wsComponents.resourceName.split("?");
          wsComponents.path = path && path !== "/" ? path : void 0;
          wsComponents.query = query;
          wsComponents.resourceName = void 0;
        }
        wsComponents.fragment = void 0;
        return wsComponents;
      }
      function urnParse(urnComponents, options) {
        if (!urnComponents.path) {
          urnComponents.error = "URN can not be parsed";
          return urnComponents;
        }
        const matches2 = urnComponents.path.match(URN_REG);
        if (matches2) {
          const scheme = options.scheme || urnComponents.scheme || "urn";
          urnComponents.nid = matches2[1].toLowerCase();
          urnComponents.nss = matches2[2];
          const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`;
          const schemeHandler = SCHEMES[urnScheme];
          urnComponents.path = void 0;
          if (schemeHandler) {
            urnComponents = schemeHandler.parse(urnComponents, options);
          }
        } else {
          urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
      }
      function urnSerialize(urnComponents, options) {
        const scheme = options.scheme || urnComponents.scheme || "urn";
        const nid = urnComponents.nid.toLowerCase();
        const urnScheme = `${scheme}:${options.nid || nid}`;
        const schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
          urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        const uriComponents = urnComponents;
        const nss = urnComponents.nss;
        uriComponents.path = `${nid || options.nid}:${nss}`;
        options.skipEscape = true;
        return uriComponents;
      }
      function urnuuidParse(urnComponents, options) {
        const uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = void 0;
        if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {
          uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
      }
      function urnuuidSerialize(uuidComponents) {
        const urnComponents = uuidComponents;
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
      }
      const http = {
        scheme: "http",
        domainHost: true,
        parse: httpParse,
        serialize: httpSerialize
      };
      const https = {
        scheme: "https",
        domainHost: http.domainHost,
        parse: httpParse,
        serialize: httpSerialize
      };
      const ws = {
        scheme: "ws",
        domainHost: true,
        parse: wsParse,
        serialize: wsSerialize
      };
      const wss = {
        scheme: "wss",
        domainHost: ws.domainHost,
        parse: ws.parse,
        serialize: ws.serialize
      };
      const urn = {
        scheme: "urn",
        parse: urnParse,
        serialize: urnSerialize,
        skipNormalize: true
      };
      const urnuuid = {
        scheme: "urn:uuid",
        parse: urnuuidParse,
        serialize: urnuuidSerialize,
        skipNormalize: true
      };
      const SCHEMES = {
        http,
        https,
        ws,
        wss,
        urn,
        "urn:uuid": urnuuid
      };
      schemes = SCHEMES;
      return schemes;
    }
    var fastUri_1 = fastUri.exports;
    var hasRequiredFastUri;
    function requireFastUri() {
      if (hasRequiredFastUri) return fastUri.exports;
      hasRequiredFastUri = 1;
      "use strict";
      const { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = requireUtils();
      const SCHEMES = requireSchemes();
      function normalize(uri2, options) {
        if (typeof uri2 === "string") {
          uri2 = serialize(parse(uri2, options), options);
        } else if (typeof uri2 === "object") {
          uri2 = parse(serialize(uri2, options), options);
        }
        return uri2;
      }
      function resolve2(baseURI, relativeURI, options) {
        const schemelessOptions = Object.assign({ scheme: "null" }, options);
        const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
        return serialize(resolved, { ...schemelessOptions, skipEscape: true });
      }
      function resolveComponents(base, relative, options, skipNormalization) {
        const target = {};
        if (!skipNormalization) {
          base = parse(serialize(base, options), options);
          relative = parse(serialize(relative, options), options);
        }
        options = options || {};
        if (!options.tolerant && relative.scheme) {
          target.scheme = relative.scheme;
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
          } else {
            if (!relative.path) {
              target.path = base.path;
              if (relative.query !== void 0) {
                target.query = relative.query;
              } else {
                target.query = base.query;
              }
            } else {
              if (relative.path.charAt(0) === "/") {
                target.path = removeDotSegments(relative.path);
              } else {
                if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
                  target.path = "/" + relative.path;
                } else if (!base.path) {
                  target.path = relative.path;
                } else {
                  target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
                }
                target.path = removeDotSegments(target.path);
              }
              target.query = relative.query;
            }
            target.userinfo = base.userinfo;
            target.host = base.host;
            target.port = base.port;
          }
          target.scheme = base.scheme;
        }
        target.fragment = relative.fragment;
        return target;
      }
      function equal2(uriA, uriB, options) {
        if (typeof uriA === "string") {
          uriA = unescape(uriA);
          uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true });
        } else if (typeof uriA === "object") {
          uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
        }
        if (typeof uriB === "string") {
          uriB = unescape(uriB);
          uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true });
        } else if (typeof uriB === "object") {
          uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
        }
        return uriA.toLowerCase() === uriB.toLowerCase();
      }
      function serialize(cmpts, opts) {
        const components = {
          host: cmpts.host,
          scheme: cmpts.scheme,
          userinfo: cmpts.userinfo,
          port: cmpts.port,
          path: cmpts.path,
          query: cmpts.query,
          nid: cmpts.nid,
          nss: cmpts.nss,
          uuid: cmpts.uuid,
          fragment: cmpts.fragment,
          reference: cmpts.reference,
          resourceName: cmpts.resourceName,
          secure: cmpts.secure,
          error: ""
        };
        const options = Object.assign({}, opts);
        const uriTokens = [];
        const schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
        if (components.path !== void 0) {
          if (!options.skipEscape) {
            components.path = escape(components.path);
            if (components.scheme !== void 0) {
              components.path = components.path.split("%3A").join(":");
            }
          } else {
            components.path = unescape(components.path);
          }
        }
        if (options.reference !== "suffix" && components.scheme) {
          uriTokens.push(components.scheme, ":");
        }
        const authority = recomposeAuthority(components);
        if (authority !== void 0) {
          if (options.reference !== "suffix") {
            uriTokens.push("//");
          }
          uriTokens.push(authority);
          if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
          }
        }
        if (components.path !== void 0) {
          let s = components.path;
          if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
          }
          if (authority === void 0) {
            s = s.replace(/^\/\//u, "/%2F");
          }
          uriTokens.push(s);
        }
        if (components.query !== void 0) {
          uriTokens.push("?", components.query);
        }
        if (components.fragment !== void 0) {
          uriTokens.push("#", components.fragment);
        }
        return uriTokens.join("");
      }
      const hexLookUp = Array.from({ length: 127 }, (_v, k) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)));
      function nonSimpleDomain(value) {
        let code2 = 0;
        for (let i = 0, len = value.length; i < len; ++i) {
          code2 = value.charCodeAt(i);
          if (code2 > 126 || hexLookUp[code2]) {
            return true;
          }
        }
        return false;
      }
      const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
      function parse(uri2, opts) {
        const options = Object.assign({}, opts);
        const parsed = {
          scheme: void 0,
          userinfo: void 0,
          host: "",
          port: void 0,
          path: "",
          query: void 0,
          fragment: void 0
        };
        const gotEncoding = uri2.indexOf("%") !== -1;
        let isIP = false;
        if (options.reference === "suffix") uri2 = (options.scheme ? options.scheme + ":" : "") + "//" + uri2;
        const matches2 = uri2.match(URI_PARSE);
        if (matches2) {
          parsed.scheme = matches2[1];
          parsed.userinfo = matches2[3];
          parsed.host = matches2[4];
          parsed.port = parseInt(matches2[5], 10);
          parsed.path = matches2[6] || "";
          parsed.query = matches2[7];
          parsed.fragment = matches2[8];
          if (isNaN(parsed.port)) {
            parsed.port = matches2[5];
          }
          if (parsed.host) {
            const ipv4result = normalizeIPv4(parsed.host);
            if (ipv4result.isIPV4 === false) {
              const ipv6result = normalizeIPv6(ipv4result.host);
              parsed.host = ipv6result.host.toLowerCase();
              isIP = ipv6result.isIPV6;
            } else {
              parsed.host = ipv4result.host;
              isIP = true;
            }
          }
          if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {
            parsed.reference = "same-document";
          } else if (parsed.scheme === void 0) {
            parsed.reference = "relative";
          } else if (parsed.fragment === void 0) {
            parsed.reference = "absolute";
          } else {
            parsed.reference = "uri";
          }
          if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
            parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
          }
          const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || "").toLowerCase()];
          if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
              try {
                parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
              } catch (e) {
                parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
              }
            }
          }
          if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
            if (gotEncoding && parsed.scheme !== void 0) {
              parsed.scheme = unescape(parsed.scheme);
            }
            if (gotEncoding && parsed.host !== void 0) {
              parsed.host = unescape(parsed.host);
            }
            if (parsed.path) {
              parsed.path = escape(unescape(parsed.path));
            }
            if (parsed.fragment) {
              parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
            }
          }
          if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(parsed, options);
          }
        } else {
          parsed.error = parsed.error || "URI can not be parsed.";
        }
        return parsed;
      }
      const fastUri$1 = {
        SCHEMES,
        normalize,
        resolve: resolve2,
        resolveComponents,
        equal: equal2,
        serialize,
        parse
      };
      fastUri.exports = fastUri$1;
      fastUri.exports.default = fastUri$1;
      fastUri.exports.fastUri = fastUri$1;
      return fastUri.exports;
    }
    var hasRequiredUri;
    function requireUri() {
      if (hasRequiredUri) return uri;
      hasRequiredUri = 1;
      "use strict";
      Object.defineProperty(uri, "__esModule", { value: true });
      const uri$1 = requireFastUri();
      uri$1.code = 'require("ajv/dist/runtime/uri").default';
      uri.default = uri$1;
      return uri;
    }
    var hasRequiredCore$1;
    function requireCore$1() {
      if (hasRequiredCore$1) return core$1;
      hasRequiredCore$1 = 1;
      (function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
        var validate_1 = requireValidate();
        Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
          return validate_1.KeywordCxt;
        } });
        var codegen_1 = requireCodegen();
        Object.defineProperty(exports, "_", { enumerable: true, get: function() {
          return codegen_1._;
        } });
        Object.defineProperty(exports, "str", { enumerable: true, get: function() {
          return codegen_1.str;
        } });
        Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
          return codegen_1.stringify;
        } });
        Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
          return codegen_1.nil;
        } });
        Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
          return codegen_1.Name;
        } });
        Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
          return codegen_1.CodeGen;
        } });
        const validation_error_1 = requireValidation_error();
        const ref_error_1 = requireRef_error();
        const rules_1 = requireRules();
        const compile_1 = requireCompile();
        const codegen_2 = requireCodegen();
        const resolve_1 = requireResolve();
        const dataType_1 = requireDataType();
        const util_1 = requireUtil();
        const $dataRefSchema = require$$9;
        const uri_1 = requireUri();
        const defaultRegExp = (str, flags) => new RegExp(str, flags);
        defaultRegExp.code = "new RegExp";
        const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
        const EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
          "validate",
          "serialize",
          "parse",
          "wrapper",
          "root",
          "schema",
          "keyword",
          "pattern",
          "formats",
          "validate$data",
          "func",
          "obj",
          "Error"
        ]);
        const removedOptions = {
          errorDataPath: "",
          format: "`validateFormats: false` can be used instead.",
          nullable: '"nullable" keyword is supported by default.',
          jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
          extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
          missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
          processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
          sourceCode: "Use option `code: {source: true}`",
          strictDefaults: "It is default now, see option `strict`.",
          strictKeywords: "It is default now, see option `strict`.",
          uniqueItems: '"uniqueItems" keyword is always validated.',
          unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
          cache: "Map is used as cache, schema object as key.",
          serialize: "Map is used as cache, schema object as key.",
          ajvErrors: "It is default now."
        };
        const deprecatedOptions = {
          ignoreKeywordsWithRef: "",
          jsPropertySyntax: "",
          unicode: '"minLength"/"maxLength" account for unicode characters by default.'
        };
        const MAX_EXPRESSION = 200;
        function requiredOptions(o) {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
          const s = o.strict;
          const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
          const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
          const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
          const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
          return {
            strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
            strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
            strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
            strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
            strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
            code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
            loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
            loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
            meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
            messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
            inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
            schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
            addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
            validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
            validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
            unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
            int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
            uriResolver
          };
        }
        class Ajv2 {
          constructor(opts = {}) {
            this.schemas = {};
            this.refs = {};
            this.formats = {};
            this._compilations = /* @__PURE__ */ new Set();
            this._loading = {};
            this._cache = /* @__PURE__ */ new Map();
            opts = this.opts = { ...opts, ...requiredOptions(opts) };
            const { es5, lines } = this.opts.code;
            this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
            this.logger = getLogger(opts.logger);
            const formatOpt = opts.validateFormats;
            opts.validateFormats = false;
            this.RULES = (0, rules_1.getRules)();
            checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
            checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
            this._metaOpts = getMetaSchemaOptions.call(this);
            if (opts.formats)
              addInitialFormats.call(this);
            this._addVocabularies();
            this._addDefaultMetaSchema();
            if (opts.keywords)
              addInitialKeywords.call(this, opts.keywords);
            if (typeof opts.meta == "object")
              this.addMetaSchema(opts.meta);
            addInitialSchemas.call(this);
            opts.validateFormats = formatOpt;
          }
          _addVocabularies() {
            this.addKeyword("$async");
          }
          _addDefaultMetaSchema() {
            const { $data, meta, schemaId } = this.opts;
            let _dataRefSchema = $dataRefSchema;
            if (schemaId === "id") {
              _dataRefSchema = { ...$dataRefSchema };
              _dataRefSchema.id = _dataRefSchema.$id;
              delete _dataRefSchema.$id;
            }
            if (meta && $data)
              this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
          }
          defaultMeta() {
            const { meta, schemaId } = this.opts;
            return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
          }
          validate(schemaKeyRef, data) {
            let v;
            if (typeof schemaKeyRef == "string") {
              v = this.getSchema(schemaKeyRef);
              if (!v)
                throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
            } else {
              v = this.compile(schemaKeyRef);
            }
            const valid = v(data);
            if (!("$async" in v))
              this.errors = v.errors;
            return valid;
          }
          compile(schema, _meta) {
            const sch = this._addSchema(schema, _meta);
            return sch.validate || this._compileSchemaEnv(sch);
          }
          compileAsync(schema, meta) {
            if (typeof this.opts.loadSchema != "function") {
              throw new Error("options.loadSchema should be a function");
            }
            const { loadSchema } = this.opts;
            return runCompileAsync.call(this, schema, meta);
            async function runCompileAsync(_schema, _meta) {
              await loadMetaSchema.call(this, _schema.$schema);
              const sch = this._addSchema(_schema, _meta);
              return sch.validate || _compileAsync.call(this, sch);
            }
            async function loadMetaSchema($ref) {
              if ($ref && !this.getSchema($ref)) {
                await runCompileAsync.call(this, { $ref }, true);
              }
            }
            async function _compileAsync(sch) {
              try {
                return this._compileSchemaEnv(sch);
              } catch (e) {
                if (!(e instanceof ref_error_1.default))
                  throw e;
                checkLoaded.call(this, e);
                await loadMissingSchema.call(this, e.missingSchema);
                return _compileAsync.call(this, sch);
              }
            }
            function checkLoaded({ missingSchema: ref2, missingRef }) {
              if (this.refs[ref2]) {
                throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
              }
            }
            async function loadMissingSchema(ref2) {
              const _schema = await _loadSchema.call(this, ref2);
              if (!this.refs[ref2])
                await loadMetaSchema.call(this, _schema.$schema);
              if (!this.refs[ref2])
                this.addSchema(_schema, ref2, meta);
            }
            async function _loadSchema(ref2) {
              const p2 = this._loading[ref2];
              if (p2)
                return p2;
              try {
                return await (this._loading[ref2] = loadSchema(ref2));
              } finally {
                delete this._loading[ref2];
              }
            }
          }
          // Adds schema to the instance
          addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
            if (Array.isArray(schema)) {
              for (const sch of schema)
                this.addSchema(sch, void 0, _meta, _validateSchema);
              return this;
            }
            let id2;
            if (typeof schema === "object") {
              const { schemaId } = this.opts;
              id2 = schema[schemaId];
              if (id2 !== void 0 && typeof id2 != "string") {
                throw new Error(`schema ${schemaId} must be string`);
              }
            }
            key = (0, resolve_1.normalizeId)(key || id2);
            this._checkUnique(key);
            this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
            return this;
          }
          // Add schema that will be used to validate other schemas
          // options in META_IGNORE_OPTIONS are alway set to false
          addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
            this.addSchema(schema, key, true, _validateSchema);
            return this;
          }
          //  Validate schema against its meta-schema
          validateSchema(schema, throwOrLogError) {
            if (typeof schema == "boolean")
              return true;
            let $schema2;
            $schema2 = schema.$schema;
            if ($schema2 !== void 0 && typeof $schema2 != "string") {
              throw new Error("$schema must be a string");
            }
            $schema2 = $schema2 || this.opts.defaultMeta || this.defaultMeta();
            if (!$schema2) {
              this.logger.warn("meta-schema not available");
              this.errors = null;
              return true;
            }
            const valid = this.validate($schema2, schema);
            if (!valid && throwOrLogError) {
              const message = "schema is invalid: " + this.errorsText();
              if (this.opts.validateSchema === "log")
                this.logger.error(message);
              else
                throw new Error(message);
            }
            return valid;
          }
          // Get compiled schema by `key` or `ref`.
          // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
          getSchema(keyRef) {
            let sch;
            while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
              keyRef = sch;
            if (sch === void 0) {
              const { schemaId } = this.opts;
              const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
              sch = compile_1.resolveSchema.call(this, root, keyRef);
              if (!sch)
                return;
              this.refs[keyRef] = sch;
            }
            return sch.validate || this._compileSchemaEnv(sch);
          }
          // Remove cached schema(s).
          // If no parameter is passed all schemas but meta-schemas are removed.
          // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
          // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
          removeSchema(schemaKeyRef) {
            if (schemaKeyRef instanceof RegExp) {
              this._removeAllSchemas(this.schemas, schemaKeyRef);
              this._removeAllSchemas(this.refs, schemaKeyRef);
              return this;
            }
            switch (typeof schemaKeyRef) {
              case "undefined":
                this._removeAllSchemas(this.schemas);
                this._removeAllSchemas(this.refs);
                this._cache.clear();
                return this;
              case "string": {
                const sch = getSchEnv.call(this, schemaKeyRef);
                if (typeof sch == "object")
                  this._cache.delete(sch.schema);
                delete this.schemas[schemaKeyRef];
                delete this.refs[schemaKeyRef];
                return this;
              }
              case "object": {
                const cacheKey = schemaKeyRef;
                this._cache.delete(cacheKey);
                let id2 = schemaKeyRef[this.opts.schemaId];
                if (id2) {
                  id2 = (0, resolve_1.normalizeId)(id2);
                  delete this.schemas[id2];
                  delete this.refs[id2];
                }
                return this;
              }
              default:
                throw new Error("ajv.removeSchema: invalid parameter");
            }
          }
          // add "vocabulary" - a collection of keywords
          addVocabulary(definitions2) {
            for (const def2 of definitions2)
              this.addKeyword(def2);
            return this;
          }
          addKeyword(kwdOrDef, def2) {
            let keyword2;
            if (typeof kwdOrDef == "string") {
              keyword2 = kwdOrDef;
              if (typeof def2 == "object") {
                this.logger.warn("these parameters are deprecated, see docs for addKeyword");
                def2.keyword = keyword2;
              }
            } else if (typeof kwdOrDef == "object" && def2 === void 0) {
              def2 = kwdOrDef;
              keyword2 = def2.keyword;
              if (Array.isArray(keyword2) && !keyword2.length) {
                throw new Error("addKeywords: keyword must be string or non-empty array");
              }
            } else {
              throw new Error("invalid addKeywords parameters");
            }
            checkKeyword.call(this, keyword2, def2);
            if (!def2) {
              (0, util_1.eachItem)(keyword2, (kwd) => addRule.call(this, kwd));
              return this;
            }
            keywordMetaschema.call(this, def2);
            const definition = {
              ...def2,
              type: (0, dataType_1.getJSONTypes)(def2.type),
              schemaType: (0, dataType_1.getJSONTypes)(def2.schemaType)
            };
            (0, util_1.eachItem)(keyword2, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
            return this;
          }
          getKeyword(keyword2) {
            const rule = this.RULES.all[keyword2];
            return typeof rule == "object" ? rule.definition : !!rule;
          }
          // Remove keyword
          removeKeyword(keyword2) {
            const { RULES } = this;
            delete RULES.keywords[keyword2];
            delete RULES.all[keyword2];
            for (const group of RULES.rules) {
              const i = group.rules.findIndex((rule) => rule.keyword === keyword2);
              if (i >= 0)
                group.rules.splice(i, 1);
            }
            return this;
          }
          // Add format
          addFormat(name, format2) {
            if (typeof format2 == "string")
              format2 = new RegExp(format2);
            this.formats[name] = format2;
            return this;
          }
          errorsText(errors2 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
            if (!errors2 || errors2.length === 0)
              return "No errors";
            return errors2.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
          }
          $dataMetaSchema(metaSchema, keywordsJsonPointers) {
            const rules2 = this.RULES.all;
            metaSchema = JSON.parse(JSON.stringify(metaSchema));
            for (const jsonPointer of keywordsJsonPointers) {
              const segments = jsonPointer.split("/").slice(1);
              let keywords = metaSchema;
              for (const seg of segments)
                keywords = keywords[seg];
              for (const key in rules2) {
                const rule = rules2[key];
                if (typeof rule != "object")
                  continue;
                const { $data } = rule.definition;
                const schema = keywords[key];
                if ($data && schema)
                  keywords[key] = schemaOrData(schema);
              }
            }
            return metaSchema;
          }
          _removeAllSchemas(schemas, regex) {
            for (const keyRef in schemas) {
              const sch = schemas[keyRef];
              if (!regex || regex.test(keyRef)) {
                if (typeof sch == "string") {
                  delete schemas[keyRef];
                } else if (sch && !sch.meta) {
                  this._cache.delete(sch.schema);
                  delete schemas[keyRef];
                }
              }
            }
          }
          _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
            let id2;
            const { schemaId } = this.opts;
            if (typeof schema == "object") {
              id2 = schema[schemaId];
            } else {
              if (this.opts.jtd)
                throw new Error("schema must be object");
              else if (typeof schema != "boolean")
                throw new Error("schema must be object or boolean");
            }
            let sch = this._cache.get(schema);
            if (sch !== void 0)
              return sch;
            baseId = (0, resolve_1.normalizeId)(id2 || baseId);
            const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
            sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
            this._cache.set(sch.schema, sch);
            if (addSchema && !baseId.startsWith("#")) {
              if (baseId)
                this._checkUnique(baseId);
              this.refs[baseId] = sch;
            }
            if (validateSchema)
              this.validateSchema(schema, true);
            return sch;
          }
          _checkUnique(id2) {
            if (this.schemas[id2] || this.refs[id2]) {
              throw new Error(`schema with key or id "${id2}" already exists`);
            }
          }
          _compileSchemaEnv(sch) {
            if (sch.meta)
              this._compileMetaSchema(sch);
            else
              compile_1.compileSchema.call(this, sch);
            if (!sch.validate)
              throw new Error("ajv implementation error");
            return sch.validate;
          }
          _compileMetaSchema(sch) {
            const currentOpts = this.opts;
            this.opts = this._metaOpts;
            try {
              compile_1.compileSchema.call(this, sch);
            } finally {
              this.opts = currentOpts;
            }
          }
        }
        Ajv2.ValidationError = validation_error_1.default;
        Ajv2.MissingRefError = ref_error_1.default;
        exports.default = Ajv2;
        function checkOptions(checkOpts, options, msg, log = "error") {
          for (const key in checkOpts) {
            const opt = key;
            if (opt in options)
              this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
          }
        }
        function getSchEnv(keyRef) {
          keyRef = (0, resolve_1.normalizeId)(keyRef);
          return this.schemas[keyRef] || this.refs[keyRef];
        }
        function addInitialSchemas() {
          const optsSchemas = this.opts.schemas;
          if (!optsSchemas)
            return;
          if (Array.isArray(optsSchemas))
            this.addSchema(optsSchemas);
          else
            for (const key in optsSchemas)
              this.addSchema(optsSchemas[key], key);
        }
        function addInitialFormats() {
          for (const name in this.opts.formats) {
            const format2 = this.opts.formats[name];
            if (format2)
              this.addFormat(name, format2);
          }
        }
        function addInitialKeywords(defs) {
          if (Array.isArray(defs)) {
            this.addVocabulary(defs);
            return;
          }
          this.logger.warn("keywords option as map is deprecated, pass array");
          for (const keyword2 in defs) {
            const def2 = defs[keyword2];
            if (!def2.keyword)
              def2.keyword = keyword2;
            this.addKeyword(def2);
          }
        }
        function getMetaSchemaOptions() {
          const metaOpts = { ...this.opts };
          for (const opt of META_IGNORE_OPTIONS)
            delete metaOpts[opt];
          return metaOpts;
        }
        const noLogs = { log() {
        }, warn() {
        }, error() {
        } };
        function getLogger(logger) {
          if (logger === false)
            return noLogs;
          if (logger === void 0)
            return console;
          if (logger.log && logger.warn && logger.error)
            return logger;
          throw new Error("logger must implement log, warn and error methods");
        }
        const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
        function checkKeyword(keyword2, def2) {
          const { RULES } = this;
          (0, util_1.eachItem)(keyword2, (kwd) => {
            if (RULES.keywords[kwd])
              throw new Error(`Keyword ${kwd} is already defined`);
            if (!KEYWORD_NAME.test(kwd))
              throw new Error(`Keyword ${kwd} has invalid name`);
          });
          if (!def2)
            return;
          if (def2.$data && !("code" in def2 || "validate" in def2)) {
            throw new Error('$data keyword must have "code" or "validate" function');
          }
        }
        function addRule(keyword2, definition, dataType2) {
          var _a;
          const post = definition === null || definition === void 0 ? void 0 : definition.post;
          if (dataType2 && post)
            throw new Error('keyword with "post" flag cannot have "type"');
          const { RULES } = this;
          let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType2);
          if (!ruleGroup) {
            ruleGroup = { type: dataType2, rules: [] };
            RULES.rules.push(ruleGroup);
          }
          RULES.keywords[keyword2] = true;
          if (!definition)
            return;
          const rule = {
            keyword: keyword2,
            definition: {
              ...definition,
              type: (0, dataType_1.getJSONTypes)(definition.type),
              schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
            }
          };
          if (definition.before)
            addBeforeRule.call(this, ruleGroup, rule, definition.before);
          else
            ruleGroup.rules.push(rule);
          RULES.all[keyword2] = rule;
          (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
        }
        function addBeforeRule(ruleGroup, rule, before2) {
          const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before2);
          if (i >= 0) {
            ruleGroup.rules.splice(i, 0, rule);
          } else {
            ruleGroup.rules.push(rule);
            this.logger.warn(`rule ${before2} is not defined`);
          }
        }
        function keywordMetaschema(def2) {
          let { metaSchema } = def2;
          if (metaSchema === void 0)
            return;
          if (def2.$data && this.opts.$data)
            metaSchema = schemaOrData(metaSchema);
          def2.validateSchema = this.compile(metaSchema, true);
        }
        const $dataRef = {
          $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
        };
        function schemaOrData(schema) {
          return { anyOf: [schema, $dataRef] };
        }
      })(core$1);
      return core$1;
    }
    var draft7 = {};
    var core = {};
    var id = {};
    var hasRequiredId;
    function requireId() {
      if (hasRequiredId) return id;
      hasRequiredId = 1;
      "use strict";
      Object.defineProperty(id, "__esModule", { value: true });
      const def2 = {
        keyword: "id",
        code() {
          throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
        }
      };
      id.default = def2;
      return id;
    }
    var ref = {};
    var hasRequiredRef;
    function requireRef() {
      if (hasRequiredRef) return ref;
      hasRequiredRef = 1;
      "use strict";
      Object.defineProperty(ref, "__esModule", { value: true });
      ref.callRef = ref.getValidate = void 0;
      const ref_error_1 = requireRef_error();
      const code_1 = requireCode();
      const codegen_1 = requireCodegen();
      const names_1 = requireNames();
      const compile_1 = requireCompile();
      const util_1 = requireUtil();
      const def2 = {
        keyword: "$ref",
        schemaType: "string",
        code(cxt) {
          const { gen, schema: $ref, it } = cxt;
          const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it;
          const { root } = env;
          if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
            return callRootRef();
          const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
          if (schOrEnv === void 0)
            throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
          if (schOrEnv instanceof compile_1.SchemaEnv)
            return callValidate(schOrEnv);
          return inlineRefSchema(schOrEnv);
          function callRootRef() {
            if (env === root)
              return callRef(cxt, validateName, env, env.$async);
            const rootName = gen.scopeValue("root", { ref: root });
            return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
          }
          function callValidate(sch) {
            const v = getValidate(cxt, sch);
            callRef(cxt, v, sch, sch.$async);
          }
          function inlineRefSchema(sch) {
            const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
            const valid = gen.name("valid");
            const schCxt = cxt.subschema({
              schema: sch,
              dataTypes: [],
              schemaPath: codegen_1.nil,
              topSchemaRef: schName,
              errSchemaPath: $ref
            }, valid);
            cxt.mergeEvaluated(schCxt);
            cxt.ok(valid);
          }
        }
      };
      function getValidate(cxt, sch) {
        const { gen } = cxt;
        return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
      }
      ref.getValidate = getValidate;
      function callRef(cxt, v, sch, $async) {
        const { gen, it } = cxt;
        const { allErrors, schemaEnv: env, opts } = it;
        const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
        if ($async)
          callAsyncRef();
        else
          callSyncRef();
        function callAsyncRef() {
          if (!env.$async)
            throw new Error("async schema referenced by sync schema");
          const valid = gen.let("valid");
          gen.try(() => {
            gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
            addEvaluatedFrom(v);
            if (!allErrors)
              gen.assign(valid, true);
          }, (e) => {
            gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
            addErrorsFrom(e);
            if (!allErrors)
              gen.assign(valid, false);
          });
          cxt.ok(valid);
        }
        function callSyncRef() {
          cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
        }
        function addErrorsFrom(source) {
          const errs = (0, codegen_1._)`${source}.errors`;
          gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
          gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        }
        function addEvaluatedFrom(source) {
          var _a;
          if (!it.opts.unevaluated)
            return;
          const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
          if (it.props !== true) {
            if (schEvaluated && !schEvaluated.dynamicProps) {
              if (schEvaluated.props !== void 0) {
                it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
              }
            } else {
              const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
              it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
            }
          }
          if (it.items !== true) {
            if (schEvaluated && !schEvaluated.dynamicItems) {
              if (schEvaluated.items !== void 0) {
                it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
              }
            } else {
              const items2 = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
              it.items = util_1.mergeEvaluated.items(gen, items2, it.items, codegen_1.Name);
            }
          }
        }
      }
      ref.callRef = callRef;
      ref.default = def2;
      return ref;
    }
    var hasRequiredCore;
    function requireCore() {
      if (hasRequiredCore) return core;
      hasRequiredCore = 1;
      "use strict";
      Object.defineProperty(core, "__esModule", { value: true });
      const id_1 = requireId();
      const ref_1 = requireRef();
      const core$12 = [
        "$schema",
        "$id",
        "$defs",
        "$vocabulary",
        { keyword: "$comment" },
        "definitions",
        id_1.default,
        ref_1.default
      ];
      core.default = core$12;
      return core;
    }
    var validation = {};
    var limitNumber = {};
    var hasRequiredLimitNumber;
    function requireLimitNumber() {
      if (hasRequiredLimitNumber) return limitNumber;
      hasRequiredLimitNumber = 1;
      "use strict";
      Object.defineProperty(limitNumber, "__esModule", { value: true });
      const codegen_1 = requireCodegen();
      const ops = codegen_1.operators;
      const KWDs = {
        maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
        minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
        exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
        exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
      };
      const error = {
        message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword2].okStr} ${schemaCode}`,
        params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
      };
      const def2 = {
        keyword: Object.keys(KWDs),
        type: "number",
        schemaType: "number",
        $data: true,
        error,
        code(cxt) {
          const { keyword: keyword2, data, schemaCode } = cxt;
          cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword2].fail} ${schemaCode} || isNaN(${data})`);
        }
      };
      limitNumber.default = def2;
      return limitNumber;
    }
    var multipleOf = {};
    var hasRequiredMultipleOf;
    function requireMultipleOf() {
      if (hasRequiredMultipleOf) return multipleOf;
      hasRequiredMultipleOf = 1;
      "use strict";
      Object.defineProperty(multipleOf, "__esModule", { value: true });
      const codegen_1 = requireCodegen();
      const error = {
        message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
        params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
      };
      const def2 = {
        keyword: "multipleOf",
        type: "number",
        schemaType: "number",
        $data: true,
        error,
        code(cxt) {
          const { gen, data, schemaCode, it } = cxt;
          const prec = it.opts.multipleOfPrecision;
          const res = gen.let("res");
          const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
          cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
        }
      };
      multipleOf.default = def2;
      return multipleOf;
    }
    var limitLength = {};
    var ucs2length = {};
    var hasRequiredUcs2length;
    function requireUcs2length() {
      if (hasRequiredUcs2length) return ucs2length;
      hasRequiredUcs2length = 1;
      "use strict";
      Object.defineProperty(ucs2length, "__esModule", { value: true });
      function ucs2length$1(str) {
        const len = str.length;
        let length = 0;
        let pos = 0;
        let value;
        while (pos < len) {
          length++;
          value = str.charCodeAt(pos++);
          if (value >= 55296 && value <= 56319 && pos < len) {
            value = str.charCodeAt(pos);
            if ((value & 64512) === 56320)
              pos++;
          }
        }
        return length;
      }
      ucs2length.default = ucs2length$1;
      ucs2length$1.code = 'require("ajv/dist/runtime/ucs2length").default';
      return ucs2length;
    }
    var hasRequiredLimitLength;
    function requireLimitLength() {
      if (hasRequiredLimitLength) return limitLength;
      hasRequiredLimitLength = 1;
      "use strict";
      Object.defineProperty(limitLength, "__esModule", { value: true });
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const ucs2length_1 = requireUcs2length();
      const error = {
        message({ keyword: keyword2, schemaCode }) {
          const comp = keyword2 === "maxLength" ? "more" : "fewer";
          return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
        },
        params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
      };
      const def2 = {
        keyword: ["maxLength", "minLength"],
        type: "string",
        schemaType: "number",
        $data: true,
        error,
        code(cxt) {
          const { keyword: keyword2, data, schemaCode, it } = cxt;
          const op = keyword2 === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
          const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
          cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
        }
      };
      limitLength.default = def2;
      return limitLength;
    }
    var pattern = {};
    var hasRequiredPattern;
    function requirePattern() {
      if (hasRequiredPattern) return pattern;
      hasRequiredPattern = 1;
      "use strict";
      Object.defineProperty(pattern, "__esModule", { value: true });
      const code_1 = requireCode();
      const codegen_1 = requireCodegen();
      const error = {
        message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
        params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
      };
      const def2 = {
        keyword: "pattern",
        type: "string",
        schemaType: "string",
        $data: true,
        error,
        code(cxt) {
          const { data, $data, schema, schemaCode, it } = cxt;
          const u = it.opts.unicodeRegExp ? "u" : "";
          const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
          cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
        }
      };
      pattern.default = def2;
      return pattern;
    }
    var limitProperties = {};
    var hasRequiredLimitProperties;
    function requireLimitProperties() {
      if (hasRequiredLimitProperties) return limitProperties;
      hasRequiredLimitProperties = 1;
      "use strict";
      Object.defineProperty(limitProperties, "__esModule", { value: true });
      const codegen_1 = requireCodegen();
      const error = {
        message({ keyword: keyword2, schemaCode }) {
          const comp = keyword2 === "maxProperties" ? "more" : "fewer";
          return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
        },
        params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
      };
      const def2 = {
        keyword: ["maxProperties", "minProperties"],
        type: "object",
        schemaType: "number",
        $data: true,
        error,
        code(cxt) {
          const { keyword: keyword2, data, schemaCode } = cxt;
          const op = keyword2 === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
          cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
        }
      };
      limitProperties.default = def2;
      return limitProperties;
    }
    var required = {};
    var hasRequiredRequired;
    function requireRequired() {
      if (hasRequiredRequired) return required;
      hasRequiredRequired = 1;
      "use strict";
      Object.defineProperty(required, "__esModule", { value: true });
      const code_1 = requireCode();
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const error = {
        message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
        params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
      };
      const def2 = {
        keyword: "required",
        type: "object",
        schemaType: "array",
        $data: true,
        error,
        code(cxt) {
          const { gen, schema, schemaCode, data, $data, it } = cxt;
          const { opts } = it;
          if (!$data && schema.length === 0)
            return;
          const useLoop = schema.length >= opts.loopRequired;
          if (it.allErrors)
            allErrorsMode();
          else
            exitOnErrorMode();
          if (opts.strictRequired) {
            const props = cxt.parentSchema.properties;
            const { definedProperties } = cxt.it;
            for (const requiredKey of schema) {
              if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
                const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
                const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
                (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
              }
            }
          }
          function allErrorsMode() {
            if (useLoop || $data) {
              cxt.block$data(codegen_1.nil, loopAllRequired);
            } else {
              for (const prop of schema) {
                (0, code_1.checkReportMissingProp)(cxt, prop);
              }
            }
          }
          function exitOnErrorMode() {
            const missing = gen.let("missing");
            if (useLoop || $data) {
              const valid = gen.let("valid", true);
              cxt.block$data(valid, () => loopUntilMissing(missing, valid));
              cxt.ok(valid);
            } else {
              gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
              (0, code_1.reportMissingProp)(cxt, missing);
              gen.else();
            }
          }
          function loopAllRequired() {
            gen.forOf("prop", schemaCode, (prop) => {
              cxt.setParams({ missingProperty: prop });
              gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
            });
          }
          function loopUntilMissing(missing, valid) {
            cxt.setParams({ missingProperty: missing });
            gen.forOf(missing, schemaCode, () => {
              gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.error();
                gen.break();
              });
            }, codegen_1.nil);
          }
        }
      };
      required.default = def2;
      return required;
    }
    var limitItems = {};
    var hasRequiredLimitItems;
    function requireLimitItems() {
      if (hasRequiredLimitItems) return limitItems;
      hasRequiredLimitItems = 1;
      "use strict";
      Object.defineProperty(limitItems, "__esModule", { value: true });
      const codegen_1 = requireCodegen();
      const error = {
        message({ keyword: keyword2, schemaCode }) {
          const comp = keyword2 === "maxItems" ? "more" : "fewer";
          return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
        },
        params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
      };
      const def2 = {
        keyword: ["maxItems", "minItems"],
        type: "array",
        schemaType: "number",
        $data: true,
        error,
        code(cxt) {
          const { keyword: keyword2, data, schemaCode } = cxt;
          const op = keyword2 === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
          cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
        }
      };
      limitItems.default = def2;
      return limitItems;
    }
    var uniqueItems = {};
    var equal = {};
    var hasRequiredEqual;
    function requireEqual() {
      if (hasRequiredEqual) return equal;
      hasRequiredEqual = 1;
      "use strict";
      Object.defineProperty(equal, "__esModule", { value: true });
      const equal$1 = requireFastDeepEqual();
      equal$1.code = 'require("ajv/dist/runtime/equal").default';
      equal.default = equal$1;
      return equal;
    }
    var hasRequiredUniqueItems;
    function requireUniqueItems() {
      if (hasRequiredUniqueItems) return uniqueItems;
      hasRequiredUniqueItems = 1;
      "use strict";
      Object.defineProperty(uniqueItems, "__esModule", { value: true });
      const dataType_1 = requireDataType();
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const equal_1 = requireEqual();
      const error = {
        message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
        params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
      };
      const def2 = {
        keyword: "uniqueItems",
        type: "array",
        schemaType: "boolean",
        $data: true,
        error,
        code(cxt) {
          const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
          if (!$data && !schema)
            return;
          const valid = gen.let("valid");
          const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
          cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
          cxt.ok(valid);
          function validateUniqueItems() {
            const i = gen.let("i", (0, codegen_1._)`${data}.length`);
            const j = gen.let("j");
            cxt.setParams({ i, j });
            gen.assign(valid, true);
            gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
          }
          function canOptimize() {
            return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
          }
          function loopN(i, j) {
            const item = gen.name("item");
            const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
            const indices = gen.const("indices", (0, codegen_1._)`{}`);
            gen.for((0, codegen_1._)`;${i}--;`, () => {
              gen.let(item, (0, codegen_1._)`${data}[${i}]`);
              gen.if(wrongType, (0, codegen_1._)`continue`);
              if (itemTypes.length > 1)
                gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
              gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
                gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
                cxt.error();
                gen.assign(valid, false).break();
              }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
            });
          }
          function loopN2(i, j) {
            const eql = (0, util_1.useFunc)(gen, equal_1.default);
            const outer = gen.name("outer");
            gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
              cxt.error();
              gen.assign(valid, false).break(outer);
            })));
          }
        }
      };
      uniqueItems.default = def2;
      return uniqueItems;
    }
    var _const = {};
    var hasRequired_const;
    function require_const() {
      if (hasRequired_const) return _const;
      hasRequired_const = 1;
      "use strict";
      Object.defineProperty(_const, "__esModule", { value: true });
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const equal_1 = requireEqual();
      const error = {
        message: "must be equal to constant",
        params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
      };
      const def2 = {
        keyword: "const",
        $data: true,
        error,
        code(cxt) {
          const { gen, data, $data, schemaCode, schema } = cxt;
          if ($data || schema && typeof schema == "object") {
            cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
          } else {
            cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
          }
        }
      };
      _const.default = def2;
      return _const;
    }
    var _enum = {};
    var hasRequired_enum;
    function require_enum() {
      if (hasRequired_enum) return _enum;
      hasRequired_enum = 1;
      "use strict";
      Object.defineProperty(_enum, "__esModule", { value: true });
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const equal_1 = requireEqual();
      const error = {
        message: "must be equal to one of the allowed values",
        params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
      };
      const def2 = {
        keyword: "enum",
        schemaType: "array",
        $data: true,
        error,
        code(cxt) {
          const { gen, data, $data, schema, schemaCode, it } = cxt;
          if (!$data && schema.length === 0)
            throw new Error("enum must have non-empty array");
          const useLoop = schema.length >= it.opts.loopEnum;
          let eql;
          const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
          let valid;
          if (useLoop || $data) {
            valid = gen.let("valid");
            cxt.block$data(valid, loopEnum);
          } else {
            if (!Array.isArray(schema))
              throw new Error("ajv implementation error");
            const vSchema = gen.const("vSchema", schemaCode);
            valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
          }
          cxt.pass(valid);
          function loopEnum() {
            gen.assign(valid, false);
            gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
          }
          function equalCode(vSchema, i) {
            const sch = schema[i];
            return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
          }
        }
      };
      _enum.default = def2;
      return _enum;
    }
    var hasRequiredValidation;
    function requireValidation() {
      if (hasRequiredValidation) return validation;
      hasRequiredValidation = 1;
      "use strict";
      Object.defineProperty(validation, "__esModule", { value: true });
      const limitNumber_1 = requireLimitNumber();
      const multipleOf_1 = requireMultipleOf();
      const limitLength_1 = requireLimitLength();
      const pattern_1 = requirePattern();
      const limitProperties_1 = requireLimitProperties();
      const required_1 = requireRequired();
      const limitItems_1 = requireLimitItems();
      const uniqueItems_1 = requireUniqueItems();
      const const_1 = require_const();
      const enum_1 = require_enum();
      const validation$1 = [
        // number
        limitNumber_1.default,
        multipleOf_1.default,
        // string
        limitLength_1.default,
        pattern_1.default,
        // object
        limitProperties_1.default,
        required_1.default,
        // array
        limitItems_1.default,
        uniqueItems_1.default,
        // any
        { keyword: "type", schemaType: ["string", "array"] },
        { keyword: "nullable", schemaType: "boolean" },
        const_1.default,
        enum_1.default
      ];
      validation.default = validation$1;
      return validation;
    }
    var applicator = {};
    var additionalItems = {};
    var hasRequiredAdditionalItems;
    function requireAdditionalItems() {
      if (hasRequiredAdditionalItems) return additionalItems;
      hasRequiredAdditionalItems = 1;
      "use strict";
      Object.defineProperty(additionalItems, "__esModule", { value: true });
      additionalItems.validateAdditionalItems = void 0;
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const error = {
        message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
        params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
      };
      const def2 = {
        keyword: "additionalItems",
        type: "array",
        schemaType: ["boolean", "object"],
        before: "uniqueItems",
        error,
        code(cxt) {
          const { parentSchema, it } = cxt;
          const { items: items2 } = parentSchema;
          if (!Array.isArray(items2)) {
            (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
            return;
          }
          validateAdditionalItems(cxt, items2);
        }
      };
      function validateAdditionalItems(cxt, items2) {
        const { gen, schema, data, keyword: keyword2, it } = cxt;
        it.items = true;
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        if (schema === false) {
          cxt.setParams({ len: items2.length });
          cxt.pass((0, codegen_1._)`${len} <= ${items2.length}`);
        } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
          const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items2.length}`);
          gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
          cxt.ok(valid);
        }
        function validateItems(valid) {
          gen.forRange("i", items2.length, len, (i) => {
            cxt.subschema({ keyword: keyword2, dataProp: i, dataPropType: util_1.Type.Num }, valid);
            if (!it.allErrors)
              gen.if((0, codegen_1.not)(valid), () => gen.break());
          });
        }
      }
      additionalItems.validateAdditionalItems = validateAdditionalItems;
      additionalItems.default = def2;
      return additionalItems;
    }
    var prefixItems = {};
    var items = {};
    var hasRequiredItems;
    function requireItems() {
      if (hasRequiredItems) return items;
      hasRequiredItems = 1;
      "use strict";
      Object.defineProperty(items, "__esModule", { value: true });
      items.validateTuple = void 0;
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const code_1 = requireCode();
      const def2 = {
        keyword: "items",
        type: "array",
        schemaType: ["object", "array", "boolean"],
        before: "uniqueItems",
        code(cxt) {
          const { schema, it } = cxt;
          if (Array.isArray(schema))
            return validateTuple(cxt, "additionalItems", schema);
          it.items = true;
          if ((0, util_1.alwaysValidSchema)(it, schema))
            return;
          cxt.ok((0, code_1.validateArray)(cxt));
        }
      };
      function validateTuple(cxt, extraItems, schArr = cxt.schema) {
        const { gen, parentSchema, data, keyword: keyword2, it } = cxt;
        checkStrictTuple(parentSchema);
        if (it.opts.unevaluated && schArr.length && it.items !== true) {
          it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
        }
        const valid = gen.name("valid");
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        schArr.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
            keyword: keyword2,
            schemaProp: i,
            dataProp: i
          }, valid));
          cxt.ok(valid);
        });
        function checkStrictTuple(sch) {
          const { opts, errSchemaPath } = it;
          const l = schArr.length;
          const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
          if (opts.strictTuples && !fullTuple) {
            const msg = `"${keyword2}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
            (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
          }
        }
      }
      items.validateTuple = validateTuple;
      items.default = def2;
      return items;
    }
    var hasRequiredPrefixItems;
    function requirePrefixItems() {
      if (hasRequiredPrefixItems) return prefixItems;
      hasRequiredPrefixItems = 1;
      "use strict";
      Object.defineProperty(prefixItems, "__esModule", { value: true });
      const items_1 = requireItems();
      const def2 = {
        keyword: "prefixItems",
        type: "array",
        schemaType: ["array"],
        before: "uniqueItems",
        code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
      };
      prefixItems.default = def2;
      return prefixItems;
    }
    var items2020 = {};
    var hasRequiredItems2020;
    function requireItems2020() {
      if (hasRequiredItems2020) return items2020;
      hasRequiredItems2020 = 1;
      "use strict";
      Object.defineProperty(items2020, "__esModule", { value: true });
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const code_1 = requireCode();
      const additionalItems_1 = requireAdditionalItems();
      const error = {
        message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
        params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
      };
      const def2 = {
        keyword: "items",
        type: "array",
        schemaType: ["object", "boolean"],
        before: "uniqueItems",
        error,
        code(cxt) {
          const { schema, parentSchema, it } = cxt;
          const { prefixItems: prefixItems2 } = parentSchema;
          it.items = true;
          if ((0, util_1.alwaysValidSchema)(it, schema))
            return;
          if (prefixItems2)
            (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems2);
          else
            cxt.ok((0, code_1.validateArray)(cxt));
        }
      };
      items2020.default = def2;
      return items2020;
    }
    var contains = {};
    var hasRequiredContains;
    function requireContains() {
      if (hasRequiredContains) return contains;
      hasRequiredContains = 1;
      "use strict";
      Object.defineProperty(contains, "__esModule", { value: true });
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const error = {
        message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
        params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
      };
      const def2 = {
        keyword: "contains",
        type: "array",
        schemaType: ["object", "boolean"],
        before: "uniqueItems",
        trackErrors: true,
        error,
        code(cxt) {
          const { gen, schema, parentSchema, data, it } = cxt;
          let min;
          let max;
          const { minContains, maxContains } = parentSchema;
          if (it.opts.next) {
            min = minContains === void 0 ? 1 : minContains;
            max = maxContains;
          } else {
            min = 1;
          }
          const len = gen.const("len", (0, codegen_1._)`${data}.length`);
          cxt.setParams({ min, max });
          if (max === void 0 && min === 0) {
            (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
            return;
          }
          if (max !== void 0 && min > max) {
            (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
            cxt.fail();
            return;
          }
          if ((0, util_1.alwaysValidSchema)(it, schema)) {
            let cond = (0, codegen_1._)`${len} >= ${min}`;
            if (max !== void 0)
              cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
            cxt.pass(cond);
            return;
          }
          it.items = true;
          const valid = gen.name("valid");
          if (max === void 0 && min === 1) {
            validateItems(valid, () => gen.if(valid, () => gen.break()));
          } else if (min === 0) {
            gen.let(valid, true);
            if (max !== void 0)
              gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
          } else {
            gen.let(valid, false);
            validateItemsWithCount();
          }
          cxt.result(valid, () => cxt.reset());
          function validateItemsWithCount() {
            const schValid = gen.name("_valid");
            const count = gen.let("count", 0);
            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
          }
          function validateItems(_valid, block) {
            gen.forRange("i", 0, len, (i) => {
              cxt.subschema({
                keyword: "contains",
                dataProp: i,
                dataPropType: util_1.Type.Num,
                compositeRule: true
              }, _valid);
              block();
            });
          }
          function checkLimits(count) {
            gen.code((0, codegen_1._)`${count}++`);
            if (max === void 0) {
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
            } else {
              gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
              if (min === 1)
                gen.assign(valid, true);
              else
                gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
            }
          }
        }
      };
      contains.default = def2;
      return contains;
    }
    var dependencies = {};
    var hasRequiredDependencies;
    function requireDependencies() {
      if (hasRequiredDependencies) return dependencies;
      hasRequiredDependencies = 1;
      (function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
        const codegen_1 = requireCodegen();
        const util_1 = requireUtil();
        const code_1 = requireCode();
        exports.error = {
          message: ({ params: { property, depsCount, deps } }) => {
            const property_ies = depsCount === 1 ? "property" : "properties";
            return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
          },
          params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
      missingProperty: ${missingProperty},
      depsCount: ${depsCount},
      deps: ${deps}}`
          // TODO change to reference
        };
        const def2 = {
          keyword: "dependencies",
          type: "object",
          schemaType: "object",
          error: exports.error,
          code(cxt) {
            const [propDeps, schDeps] = splitDependencies(cxt);
            validatePropertyDeps(cxt, propDeps);
            validateSchemaDeps(cxt, schDeps);
          }
        };
        function splitDependencies({ schema }) {
          const propertyDeps = {};
          const schemaDeps = {};
          for (const key in schema) {
            if (key === "__proto__")
              continue;
            const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
            deps[key] = schema[key];
          }
          return [propertyDeps, schemaDeps];
        }
        function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
          const { gen, data, it } = cxt;
          if (Object.keys(propertyDeps).length === 0)
            return;
          const missing = gen.let("missing");
          for (const prop in propertyDeps) {
            const deps = propertyDeps[prop];
            if (deps.length === 0)
              continue;
            const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
            cxt.setParams({
              property: prop,
              depsCount: deps.length,
              deps: deps.join(", ")
            });
            if (it.allErrors) {
              gen.if(hasProperty, () => {
                for (const depProp of deps) {
                  (0, code_1.checkReportMissingProp)(cxt, depProp);
                }
              });
            } else {
              gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
              (0, code_1.reportMissingProp)(cxt, missing);
              gen.else();
            }
          }
        }
        exports.validatePropertyDeps = validatePropertyDeps;
        function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
          const { gen, data, keyword: keyword2, it } = cxt;
          const valid = gen.name("valid");
          for (const prop in schemaDeps) {
            if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
              continue;
            gen.if(
              (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
              () => {
                const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop }, valid);
                cxt.mergeValidEvaluated(schCxt, valid);
              },
              () => gen.var(valid, true)
              // TODO var
            );
            cxt.ok(valid);
          }
        }
        exports.validateSchemaDeps = validateSchemaDeps;
        exports.default = def2;
      })(dependencies);
      return dependencies;
    }
    var propertyNames = {};
    var hasRequiredPropertyNames;
    function requirePropertyNames() {
      if (hasRequiredPropertyNames) return propertyNames;
      hasRequiredPropertyNames = 1;
      "use strict";
      Object.defineProperty(propertyNames, "__esModule", { value: true });
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const error = {
        message: "property name must be valid",
        params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
      };
      const def2 = {
        keyword: "propertyNames",
        type: "object",
        schemaType: ["object", "boolean"],
        error,
        code(cxt) {
          const { gen, schema, data, it } = cxt;
          if ((0, util_1.alwaysValidSchema)(it, schema))
            return;
          const valid = gen.name("valid");
          gen.forIn("key", data, (key) => {
            cxt.setParams({ propertyName: key });
            cxt.subschema({
              keyword: "propertyNames",
              data: key,
              dataTypes: ["string"],
              propertyName: key,
              compositeRule: true
            }, valid);
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error(true);
              if (!it.allErrors)
                gen.break();
            });
          });
          cxt.ok(valid);
        }
      };
      propertyNames.default = def2;
      return propertyNames;
    }
    var additionalProperties = {};
    var hasRequiredAdditionalProperties;
    function requireAdditionalProperties() {
      if (hasRequiredAdditionalProperties) return additionalProperties;
      hasRequiredAdditionalProperties = 1;
      "use strict";
      Object.defineProperty(additionalProperties, "__esModule", { value: true });
      const code_1 = requireCode();
      const codegen_1 = requireCodegen();
      const names_1 = requireNames();
      const util_1 = requireUtil();
      const error = {
        message: "must NOT have additional properties",
        params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
      };
      const def2 = {
        keyword: "additionalProperties",
        type: ["object"],
        schemaType: ["boolean", "object"],
        allowUndefined: true,
        trackErrors: true,
        error,
        code(cxt) {
          const { gen, schema, parentSchema, data, errsCount, it } = cxt;
          if (!errsCount)
            throw new Error("ajv implementation error");
          const { allErrors, opts } = it;
          it.props = true;
          if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
            return;
          const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
          const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
          checkAdditionalProperties();
          cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
          function checkAdditionalProperties() {
            gen.forIn("key", data, (key) => {
              if (!props.length && !patProps.length)
                additionalPropertyCode(key);
              else
                gen.if(isAdditional(key), () => additionalPropertyCode(key));
            });
          }
          function isAdditional(key) {
            let definedProp;
            if (props.length > 8) {
              const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
              definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
            } else if (props.length) {
              definedProp = (0, codegen_1.or)(...props.map((p2) => (0, codegen_1._)`${key} === ${p2}`));
            } else {
              definedProp = codegen_1.nil;
            }
            if (patProps.length) {
              definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p2) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p2)}.test(${key})`));
            }
            return (0, codegen_1.not)(definedProp);
          }
          function deleteAdditional(key) {
            gen.code((0, codegen_1._)`delete ${data}[${key}]`);
          }
          function additionalPropertyCode(key) {
            if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
              deleteAdditional(key);
              return;
            }
            if (schema === false) {
              cxt.setParams({ additionalProperty: key });
              cxt.error();
              if (!allErrors)
                gen.break();
              return;
            }
            if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
              const valid = gen.name("valid");
              if (opts.removeAdditional === "failing") {
                applyAdditionalSchema(key, valid, false);
                gen.if((0, codegen_1.not)(valid), () => {
                  cxt.reset();
                  deleteAdditional(key);
                });
              } else {
                applyAdditionalSchema(key, valid);
                if (!allErrors)
                  gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            }
          }
          function applyAdditionalSchema(key, valid, errors2) {
            const subschema2 = {
              keyword: "additionalProperties",
              dataProp: key,
              dataPropType: util_1.Type.Str
            };
            if (errors2 === false) {
              Object.assign(subschema2, {
                compositeRule: true,
                createErrors: false,
                allErrors: false
              });
            }
            cxt.subschema(subschema2, valid);
          }
        }
      };
      additionalProperties.default = def2;
      return additionalProperties;
    }
    var properties$1 = {};
    var hasRequiredProperties;
    function requireProperties() {
      if (hasRequiredProperties) return properties$1;
      hasRequiredProperties = 1;
      "use strict";
      Object.defineProperty(properties$1, "__esModule", { value: true });
      const validate_1 = requireValidate();
      const code_1 = requireCode();
      const util_1 = requireUtil();
      const additionalProperties_1 = requireAdditionalProperties();
      const def2 = {
        keyword: "properties",
        type: "object",
        schemaType: "object",
        code(cxt) {
          const { gen, schema, parentSchema, data, it } = cxt;
          if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
            additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
          }
          const allProps = (0, code_1.allSchemaProperties)(schema);
          for (const prop of allProps) {
            it.definedProperties.add(prop);
          }
          if (it.opts.unevaluated && allProps.length && it.props !== true) {
            it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
          }
          const properties2 = allProps.filter((p2) => !(0, util_1.alwaysValidSchema)(it, schema[p2]));
          if (properties2.length === 0)
            return;
          const valid = gen.name("valid");
          for (const prop of properties2) {
            if (hasDefault(prop)) {
              applyPropertySchema(prop);
            } else {
              gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
              applyPropertySchema(prop);
              if (!it.allErrors)
                gen.else().var(valid, true);
              gen.endIf();
            }
            cxt.it.definedProperties.add(prop);
            cxt.ok(valid);
          }
          function hasDefault(prop) {
            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
          }
          function applyPropertySchema(prop) {
            cxt.subschema({
              keyword: "properties",
              schemaProp: prop,
              dataProp: prop
            }, valid);
          }
        }
      };
      properties$1.default = def2;
      return properties$1;
    }
    var patternProperties = {};
    var hasRequiredPatternProperties;
    function requirePatternProperties() {
      if (hasRequiredPatternProperties) return patternProperties;
      hasRequiredPatternProperties = 1;
      "use strict";
      Object.defineProperty(patternProperties, "__esModule", { value: true });
      const code_1 = requireCode();
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const util_2 = requireUtil();
      const def2 = {
        keyword: "patternProperties",
        type: "object",
        schemaType: "object",
        code(cxt) {
          const { gen, schema, data, parentSchema, it } = cxt;
          const { opts } = it;
          const patterns = (0, code_1.allSchemaProperties)(schema);
          const alwaysValidPatterns = patterns.filter((p2) => (0, util_1.alwaysValidSchema)(it, schema[p2]));
          if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
            return;
          }
          const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
          const valid = gen.name("valid");
          if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
          }
          const { props } = it;
          validatePatternProperties();
          function validatePatternProperties() {
            for (const pat of patterns) {
              if (checkProperties)
                checkMatchingProperties(pat);
              if (it.allErrors) {
                validateProperties(pat);
              } else {
                gen.var(valid, true);
                validateProperties(pat);
                gen.if(valid);
              }
            }
          }
          function checkMatchingProperties(pat) {
            for (const prop in checkProperties) {
              if (new RegExp(pat).test(prop)) {
                (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
              }
            }
          }
          function validateProperties(pat) {
            gen.forIn("key", data, (key) => {
              gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
                const alwaysValid = alwaysValidPatterns.includes(pat);
                if (!alwaysValid) {
                  cxt.subschema({
                    keyword: "patternProperties",
                    schemaProp: pat,
                    dataProp: key,
                    dataPropType: util_2.Type.Str
                  }, valid);
                }
                if (it.opts.unevaluated && props !== true) {
                  gen.assign((0, codegen_1._)`${props}[${key}]`, true);
                } else if (!alwaysValid && !it.allErrors) {
                  gen.if((0, codegen_1.not)(valid), () => gen.break());
                }
              });
            });
          }
        }
      };
      patternProperties.default = def2;
      return patternProperties;
    }
    var not = {};
    var hasRequiredNot;
    function requireNot() {
      if (hasRequiredNot) return not;
      hasRequiredNot = 1;
      "use strict";
      Object.defineProperty(not, "__esModule", { value: true });
      const util_1 = requireUtil();
      const def2 = {
        keyword: "not",
        schemaType: ["object", "boolean"],
        trackErrors: true,
        code(cxt) {
          const { gen, schema, it } = cxt;
          if ((0, util_1.alwaysValidSchema)(it, schema)) {
            cxt.fail();
            return;
          }
          const valid = gen.name("valid");
          cxt.subschema({
            keyword: "not",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, valid);
          cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
        },
        error: { message: "must NOT be valid" }
      };
      not.default = def2;
      return not;
    }
    var anyOf = {};
    var hasRequiredAnyOf;
    function requireAnyOf() {
      if (hasRequiredAnyOf) return anyOf;
      hasRequiredAnyOf = 1;
      "use strict";
      Object.defineProperty(anyOf, "__esModule", { value: true });
      const code_1 = requireCode();
      const def2 = {
        keyword: "anyOf",
        schemaType: "array",
        trackErrors: true,
        code: code_1.validateUnion,
        error: { message: "must match a schema in anyOf" }
      };
      anyOf.default = def2;
      return anyOf;
    }
    var oneOf = {};
    var hasRequiredOneOf;
    function requireOneOf() {
      if (hasRequiredOneOf) return oneOf;
      hasRequiredOneOf = 1;
      "use strict";
      Object.defineProperty(oneOf, "__esModule", { value: true });
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const error = {
        message: "must match exactly one schema in oneOf",
        params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
      };
      const def2 = {
        keyword: "oneOf",
        schemaType: "array",
        trackErrors: true,
        error,
        code(cxt) {
          const { gen, schema, parentSchema, it } = cxt;
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          if (it.opts.discriminator && parentSchema.discriminator)
            return;
          const schArr = schema;
          const valid = gen.let("valid", false);
          const passing = gen.let("passing", null);
          const schValid = gen.name("_valid");
          cxt.setParams({ passing });
          gen.block(validateOneOf);
          cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
          function validateOneOf() {
            schArr.forEach((sch, i) => {
              let schCxt;
              if ((0, util_1.alwaysValidSchema)(it, sch)) {
                gen.var(schValid, true);
              } else {
                schCxt = cxt.subschema({
                  keyword: "oneOf",
                  schemaProp: i,
                  compositeRule: true
                }, schValid);
              }
              if (i > 0) {
                gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
              }
              gen.if(schValid, () => {
                gen.assign(valid, true);
                gen.assign(passing, i);
                if (schCxt)
                  cxt.mergeEvaluated(schCxt, codegen_1.Name);
              });
            });
          }
        }
      };
      oneOf.default = def2;
      return oneOf;
    }
    var allOf = {};
    var hasRequiredAllOf;
    function requireAllOf() {
      if (hasRequiredAllOf) return allOf;
      hasRequiredAllOf = 1;
      "use strict";
      Object.defineProperty(allOf, "__esModule", { value: true });
      const util_1 = requireUtil();
      const def2 = {
        keyword: "allOf",
        schemaType: "array",
        code(cxt) {
          const { gen, schema, it } = cxt;
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const valid = gen.name("valid");
          schema.forEach((sch, i) => {
            if ((0, util_1.alwaysValidSchema)(it, sch))
              return;
            const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
            cxt.ok(valid);
            cxt.mergeEvaluated(schCxt);
          });
        }
      };
      allOf.default = def2;
      return allOf;
    }
    var _if = {};
    var hasRequired_if;
    function require_if() {
      if (hasRequired_if) return _if;
      hasRequired_if = 1;
      "use strict";
      Object.defineProperty(_if, "__esModule", { value: true });
      const codegen_1 = requireCodegen();
      const util_1 = requireUtil();
      const error = {
        message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
        params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
      };
      const def2 = {
        keyword: "if",
        schemaType: ["object", "boolean"],
        trackErrors: true,
        error,
        code(cxt) {
          const { gen, parentSchema, it } = cxt;
          if (parentSchema.then === void 0 && parentSchema.else === void 0) {
            (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
          }
          const hasThen = hasSchema(it, "then");
          const hasElse = hasSchema(it, "else");
          if (!hasThen && !hasElse)
            return;
          const valid = gen.let("valid", true);
          const schValid = gen.name("_valid");
          validateIf();
          cxt.reset();
          if (hasThen && hasElse) {
            const ifClause = gen.let("ifClause");
            cxt.setParams({ ifClause });
            gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
          } else if (hasThen) {
            gen.if(schValid, validateClause("then"));
          } else {
            gen.if((0, codegen_1.not)(schValid), validateClause("else"));
          }
          cxt.pass(valid, () => cxt.error(true));
          function validateIf() {
            const schCxt = cxt.subschema({
              keyword: "if",
              compositeRule: true,
              createErrors: false,
              allErrors: false
            }, schValid);
            cxt.mergeEvaluated(schCxt);
          }
          function validateClause(keyword2, ifClause) {
            return () => {
              const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
              gen.assign(valid, schValid);
              cxt.mergeValidEvaluated(schCxt, valid);
              if (ifClause)
                gen.assign(ifClause, (0, codegen_1._)`${keyword2}`);
              else
                cxt.setParams({ ifClause: keyword2 });
            };
          }
        }
      };
      function hasSchema(it, keyword2) {
        const schema = it.schema[keyword2];
        return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
      }
      _if.default = def2;
      return _if;
    }
    var thenElse = {};
    var hasRequiredThenElse;
    function requireThenElse() {
      if (hasRequiredThenElse) return thenElse;
      hasRequiredThenElse = 1;
      "use strict";
      Object.defineProperty(thenElse, "__esModule", { value: true });
      const util_1 = requireUtil();
      const def2 = {
        keyword: ["then", "else"],
        schemaType: ["object", "boolean"],
        code({ keyword: keyword2, parentSchema, it }) {
          if (parentSchema.if === void 0)
            (0, util_1.checkStrictMode)(it, `"${keyword2}" without "if" is ignored`);
        }
      };
      thenElse.default = def2;
      return thenElse;
    }
    var hasRequiredApplicator;
    function requireApplicator() {
      if (hasRequiredApplicator) return applicator;
      hasRequiredApplicator = 1;
      "use strict";
      Object.defineProperty(applicator, "__esModule", { value: true });
      const additionalItems_1 = requireAdditionalItems();
      const prefixItems_1 = requirePrefixItems();
      const items_1 = requireItems();
      const items2020_1 = requireItems2020();
      const contains_1 = requireContains();
      const dependencies_1 = requireDependencies();
      const propertyNames_1 = requirePropertyNames();
      const additionalProperties_1 = requireAdditionalProperties();
      const properties_1 = requireProperties();
      const patternProperties_1 = requirePatternProperties();
      const not_1 = requireNot();
      const anyOf_1 = requireAnyOf();
      const oneOf_1 = requireOneOf();
      const allOf_1 = requireAllOf();
      const if_1 = require_if();
      const thenElse_1 = requireThenElse();
      function getApplicator(draft2020 = false) {
        const applicator2 = [
          // any
          not_1.default,
          anyOf_1.default,
          oneOf_1.default,
          allOf_1.default,
          if_1.default,
          thenElse_1.default,
          // object
          propertyNames_1.default,
          additionalProperties_1.default,
          dependencies_1.default,
          properties_1.default,
          patternProperties_1.default
        ];
        if (draft2020)
          applicator2.push(prefixItems_1.default, items2020_1.default);
        else
          applicator2.push(additionalItems_1.default, items_1.default);
        applicator2.push(contains_1.default);
        return applicator2;
      }
      applicator.default = getApplicator;
      return applicator;
    }
    var format$1 = {};
    var format = {};
    var hasRequiredFormat$1;
    function requireFormat$1() {
      if (hasRequiredFormat$1) return format;
      hasRequiredFormat$1 = 1;
      "use strict";
      Object.defineProperty(format, "__esModule", { value: true });
      const codegen_1 = requireCodegen();
      const error = {
        message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
        params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
      };
      const def2 = {
        keyword: "format",
        type: ["number", "string"],
        schemaType: "string",
        $data: true,
        error,
        code(cxt, ruleType) {
          const { gen, data, $data, schema, schemaCode, it } = cxt;
          const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
          if (!opts.validateFormats)
            return;
          if ($data)
            validate$DataFormat();
          else
            validateFormat();
          function validate$DataFormat() {
            const fmts = gen.scopeValue("formats", {
              ref: self2.formats,
              code: opts.code.formats
            });
            const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
            const fType = gen.let("fType");
            const format2 = gen.let("format");
            gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format2, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format2, fDef));
            cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
            function unknownFmt() {
              if (opts.strictSchema === false)
                return codegen_1.nil;
              return (0, codegen_1._)`${schemaCode} && !${format2}`;
            }
            function invalidFmt() {
              const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : (0, codegen_1._)`${format2}(${data})`;
              const validData = (0, codegen_1._)`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
              return (0, codegen_1._)`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
            }
          }
          function validateFormat() {
            const formatDef = self2.formats[schema];
            if (!formatDef) {
              unknownFormat();
              return;
            }
            if (formatDef === true)
              return;
            const [fmtType, format2, fmtRef] = getFormat(formatDef);
            if (fmtType === ruleType)
              cxt.pass(validCondition());
            function unknownFormat() {
              if (opts.strictSchema === false) {
                self2.logger.warn(unknownMsg());
                return;
              }
              throw new Error(unknownMsg());
              function unknownMsg() {
                return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
              }
            }
            function getFormat(fmtDef) {
              const code2 = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
              const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code: code2 });
              if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
                return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
              }
              return ["string", fmtDef, fmt];
            }
            function validCondition() {
              if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
                if (!schemaEnv.$async)
                  throw new Error("async format in sync schema");
                return (0, codegen_1._)`await ${fmtRef}(${data})`;
              }
              return typeof format2 == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
            }
          }
        }
      };
      format.default = def2;
      return format;
    }
    var hasRequiredFormat;
    function requireFormat() {
      if (hasRequiredFormat) return format$1;
      hasRequiredFormat = 1;
      "use strict";
      Object.defineProperty(format$1, "__esModule", { value: true });
      const format_1 = requireFormat$1();
      const format2 = [format_1.default];
      format$1.default = format2;
      return format$1;
    }
    var metadata = {};
    var hasRequiredMetadata;
    function requireMetadata() {
      if (hasRequiredMetadata) return metadata;
      hasRequiredMetadata = 1;
      "use strict";
      Object.defineProperty(metadata, "__esModule", { value: true });
      metadata.contentVocabulary = metadata.metadataVocabulary = void 0;
      metadata.metadataVocabulary = [
        "title",
        "description",
        "default",
        "deprecated",
        "readOnly",
        "writeOnly",
        "examples"
      ];
      metadata.contentVocabulary = [
        "contentMediaType",
        "contentEncoding",
        "contentSchema"
      ];
      return metadata;
    }
    var hasRequiredDraft7;
    function requireDraft7() {
      if (hasRequiredDraft7) return draft7;
      hasRequiredDraft7 = 1;
      "use strict";
      Object.defineProperty(draft7, "__esModule", { value: true });
      const core_1 = requireCore();
      const validation_1 = requireValidation();
      const applicator_1 = requireApplicator();
      const format_1 = requireFormat();
      const metadata_1 = requireMetadata();
      const draft7Vocabularies = [
        core_1.default,
        validation_1.default,
        (0, applicator_1.default)(),
        format_1.default,
        metadata_1.metadataVocabulary,
        metadata_1.contentVocabulary
      ];
      draft7.default = draft7Vocabularies;
      return draft7;
    }
    var discriminator = {};
    var types = {};
    var hasRequiredTypes;
    function requireTypes() {
      if (hasRequiredTypes) return types;
      hasRequiredTypes = 1;
      "use strict";
      Object.defineProperty(types, "__esModule", { value: true });
      types.DiscrError = void 0;
      var DiscrError;
      (function(DiscrError2) {
        DiscrError2["Tag"] = "tag";
        DiscrError2["Mapping"] = "mapping";
      })(DiscrError || (types.DiscrError = DiscrError = {}));
      return types;
    }
    var hasRequiredDiscriminator;
    function requireDiscriminator() {
      if (hasRequiredDiscriminator) return discriminator;
      hasRequiredDiscriminator = 1;
      "use strict";
      Object.defineProperty(discriminator, "__esModule", { value: true });
      const codegen_1 = requireCodegen();
      const types_1 = requireTypes();
      const compile_1 = requireCompile();
      const ref_error_1 = requireRef_error();
      const util_1 = requireUtil();
      const error = {
        message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
        params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
      };
      const def2 = {
        keyword: "discriminator",
        type: "object",
        schemaType: "object",
        error,
        code(cxt) {
          const { gen, data, schema, parentSchema, it } = cxt;
          const { oneOf: oneOf2 } = parentSchema;
          if (!it.opts.discriminator) {
            throw new Error("discriminator: requires discriminator option");
          }
          const tagName = schema.propertyName;
          if (typeof tagName != "string")
            throw new Error("discriminator: requires propertyName");
          if (schema.mapping)
            throw new Error("discriminator: mapping is not supported");
          if (!oneOf2)
            throw new Error("discriminator: requires oneOf keyword");
          const valid = gen.let("valid", false);
          const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
          gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
          cxt.ok(valid);
          function validateMapping() {
            const mapping = getMapping();
            gen.if(false);
            for (const tagValue in mapping) {
              gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
              gen.assign(valid, applyTagSchema(mapping[tagValue]));
            }
            gen.else();
            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
            gen.endIf();
          }
          function applyTagSchema(schemaProp) {
            const _valid = gen.name("valid");
            const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
            cxt.mergeEvaluated(schCxt, codegen_1.Name);
            return _valid;
          }
          function getMapping() {
            var _a;
            const oneOfMapping = {};
            const topRequired = hasRequired(parentSchema);
            let tagRequired = true;
            for (let i = 0; i < oneOf2.length; i++) {
              let sch = oneOf2[i];
              if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
                const ref2 = sch.$ref;
                sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref2);
                if (sch instanceof compile_1.SchemaEnv)
                  sch = sch.schema;
                if (sch === void 0)
                  throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref2);
              }
              const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
              if (typeof propSch != "object") {
                throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
              }
              tagRequired = tagRequired && (topRequired || hasRequired(sch));
              addMappings(propSch, i);
            }
            if (!tagRequired)
              throw new Error(`discriminator: "${tagName}" must be required`);
            return oneOfMapping;
            function hasRequired({ required: required2 }) {
              return Array.isArray(required2) && required2.includes(tagName);
            }
            function addMappings(sch, i) {
              if (sch.const) {
                addMapping(sch.const, i);
              } else if (sch.enum) {
                for (const tagValue of sch.enum) {
                  addMapping(tagValue, i);
                }
              } else {
                throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
              }
            }
            function addMapping(tagValue, i) {
              if (typeof tagValue != "string" || tagValue in oneOfMapping) {
                throw new Error(`discriminator: "${tagName}" values must be unique strings`);
              }
              oneOfMapping[tagValue] = i;
            }
          }
        }
      };
      discriminator.default = def2;
      return discriminator;
    }
    const $schema = "http://json-schema.org/draft-07/schema#";
    const $id = "http://json-schema.org/draft-07/schema#";
    const title = "Core schema meta-schema";
    const definitions = { "schemaArray": { "type": "array", "minItems": 1, "items": { "$ref": "#" } }, "nonNegativeInteger": { "type": "integer", "minimum": 0 }, "nonNegativeIntegerDefault0": { "allOf": [{ "$ref": "#/definitions/nonNegativeInteger" }, { "default": 0 }] }, "simpleTypes": { "enum": ["array", "boolean", "integer", "null", "number", "object", "string"] }, "stringArray": { "type": "array", "items": { "type": "string" }, "uniqueItems": true, "default": [] } };
    const type = ["object", "boolean"];
    const properties = { "$id": { "type": "string", "format": "uri-reference" }, "$schema": { "type": "string", "format": "uri" }, "$ref": { "type": "string", "format": "uri-reference" }, "$comment": { "type": "string" }, "title": { "type": "string" }, "description": { "type": "string" }, "default": true, "readOnly": { "type": "boolean", "default": false }, "examples": { "type": "array", "items": true }, "multipleOf": { "type": "number", "exclusiveMinimum": 0 }, "maximum": { "type": "number" }, "exclusiveMaximum": { "type": "number" }, "minimum": { "type": "number" }, "exclusiveMinimum": { "type": "number" }, "maxLength": { "$ref": "#/definitions/nonNegativeInteger" }, "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "pattern": { "type": "string", "format": "regex" }, "additionalItems": { "$ref": "#" }, "items": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/schemaArray" }], "default": true }, "maxItems": { "$ref": "#/definitions/nonNegativeInteger" }, "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "uniqueItems": { "type": "boolean", "default": false }, "contains": { "$ref": "#" }, "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" }, "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "required": { "$ref": "#/definitions/stringArray" }, "additionalProperties": { "$ref": "#" }, "definitions": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "properties": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "patternProperties": { "type": "object", "additionalProperties": { "$ref": "#" }, "propertyNames": { "format": "regex" }, "default": {} }, "dependencies": { "type": "object", "additionalProperties": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/stringArray" }] } }, "propertyNames": { "$ref": "#" }, "const": true, "enum": { "type": "array", "items": true, "minItems": 1, "uniqueItems": true }, "type": { "anyOf": [{ "$ref": "#/definitions/simpleTypes" }, { "type": "array", "items": { "$ref": "#/definitions/simpleTypes" }, "minItems": 1, "uniqueItems": true }] }, "format": { "type": "string" }, "contentMediaType": { "type": "string" }, "contentEncoding": { "type": "string" }, "if": { "$ref": "#" }, "then": { "$ref": "#" }, "else": { "$ref": "#" }, "allOf": { "$ref": "#/definitions/schemaArray" }, "anyOf": { "$ref": "#/definitions/schemaArray" }, "oneOf": { "$ref": "#/definitions/schemaArray" }, "not": { "$ref": "#" } };
    const require$$3 = {
      $schema,
      $id,
      title,
      definitions,
      type,
      properties,
      "default": true
    };
    var ajv = ajv$1.exports;
    var hasRequiredAjv;
    function requireAjv() {
      if (hasRequiredAjv) return ajv$1.exports;
      hasRequiredAjv = 1;
      (function(module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
        const core_1 = requireCore$1();
        const draft7_1 = requireDraft7();
        const discriminator_1 = requireDiscriminator();
        const draft7MetaSchema = require$$3;
        const META_SUPPORT_DATA = ["/properties"];
        const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
        class Ajv2 extends core_1.default {
          _addVocabularies() {
            super._addVocabularies();
            draft7_1.default.forEach((v) => this.addVocabulary(v));
            if (this.opts.discriminator)
              this.addKeyword(discriminator_1.default);
          }
          _addDefaultMetaSchema() {
            super._addDefaultMetaSchema();
            if (!this.opts.meta)
              return;
            const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
            this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
            this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
          }
          defaultMeta() {
            return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
          }
        }
        exports.Ajv = Ajv2;
        module.exports = exports = Ajv2;
        module.exports.Ajv = Ajv2;
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.default = Ajv2;
        var validate_1 = requireValidate();
        Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
          return validate_1.KeywordCxt;
        } });
        var codegen_1 = requireCodegen();
        Object.defineProperty(exports, "_", { enumerable: true, get: function() {
          return codegen_1._;
        } });
        Object.defineProperty(exports, "str", { enumerable: true, get: function() {
          return codegen_1.str;
        } });
        Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
          return codegen_1.stringify;
        } });
        Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
          return codegen_1.nil;
        } });
        Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
          return codegen_1.Name;
        } });
        Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
          return codegen_1.CodeGen;
        } });
        var validation_error_1 = requireValidation_error();
        Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
          return validation_error_1.default;
        } });
        var ref_error_1 = requireRef_error();
        Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
          return ref_error_1.default;
        } });
      })(ajv$1, ajv$1.exports);
      return ajv$1.exports;
    }
    var ajvExports = requireAjv();
    const Ajv = /* @__PURE__ */ getDefaultExportFromCjs(ajvExports);
    var dist$3 = { exports: {} };
    var formats = {};
    var hasRequiredFormats;
    function requireFormats() {
      if (hasRequiredFormats) return formats;
      hasRequiredFormats = 1;
      (function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
        function fmtDef(validate2, compare) {
          return { validate: validate2, compare };
        }
        exports.fullFormats = {
          // date: http://tools.ietf.org/html/rfc3339#section-5.6
          date: fmtDef(date, compareDate),
          // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
          time: fmtDef(getTime(true), compareTime),
          "date-time": fmtDef(getDateTime(true), compareDateTime),
          "iso-time": fmtDef(getTime(), compareIsoTime),
          "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
          // duration: https://tools.ietf.org/html/rfc3339#appendix-A
          duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
          uri: uri2,
          "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
          // uri-template: https://tools.ietf.org/html/rfc6570
          "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
          // For the source: https://gist.github.com/dperini/729294
          // For test cases: https://mathiasbynens.be/demo/url-regex
          url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
          email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
          hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
          // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
          ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
          ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
          regex,
          // uuid: http://tools.ietf.org/html/rfc4122
          uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
          // JSON-pointer: https://tools.ietf.org/html/rfc6901
          // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
          "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
          "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
          // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
          "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
          // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
          // byte: https://github.com/miguelmota/is-base64
          byte,
          // signed 32 bit integer
          int32: { type: "number", validate: validateInt32 },
          // signed 64 bit integer
          int64: { type: "number", validate: validateInt64 },
          // C-type float
          float: { type: "number", validate: validateNumber },
          // C-type double
          double: { type: "number", validate: validateNumber },
          // hint to the UI to hide input strings
          password: true,
          // unchecked string payload
          binary: true
        };
        exports.fastFormats = {
          ...exports.fullFormats,
          date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
          time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
          "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
          "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
          "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
          // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
          uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
          "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
          // email (sources from jsen validator):
          // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
          // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
          email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
        };
        exports.formatNames = Object.keys(exports.fullFormats);
        function isLeapYear(year) {
          return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
        }
        const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
        const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        function date(str) {
          const matches2 = DATE.exec(str);
          if (!matches2)
            return false;
          const year = +matches2[1];
          const month = +matches2[2];
          const day = +matches2[3];
          return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
        }
        function compareDate(d1, d2) {
          if (!(d1 && d2))
            return void 0;
          if (d1 > d2)
            return 1;
          if (d1 < d2)
            return -1;
          return 0;
        }
        const TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
        function getTime(strictTimeZone) {
          return function time(str) {
            const matches2 = TIME.exec(str);
            if (!matches2)
              return false;
            const hr = +matches2[1];
            const min = +matches2[2];
            const sec = +matches2[3];
            const tz = matches2[4];
            const tzSign = matches2[5] === "-" ? -1 : 1;
            const tzH = +(matches2[6] || 0);
            const tzM = +(matches2[7] || 0);
            if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
              return false;
            if (hr <= 23 && min <= 59 && sec < 60)
              return true;
            const utcMin = min - tzM * tzSign;
            const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
            return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
          };
        }
        function compareTime(s1, s2) {
          if (!(s1 && s2))
            return void 0;
          const t1 = (/* @__PURE__ */ new Date("2020-01-01T" + s1)).valueOf();
          const t2 = (/* @__PURE__ */ new Date("2020-01-01T" + s2)).valueOf();
          if (!(t1 && t2))
            return void 0;
          return t1 - t2;
        }
        function compareIsoTime(t1, t2) {
          if (!(t1 && t2))
            return void 0;
          const a1 = TIME.exec(t1);
          const a2 = TIME.exec(t2);
          if (!(a1 && a2))
            return void 0;
          t1 = a1[1] + a1[2] + a1[3];
          t2 = a2[1] + a2[2] + a2[3];
          if (t1 > t2)
            return 1;
          if (t1 < t2)
            return -1;
          return 0;
        }
        const DATE_TIME_SEPARATOR = /t|\s/i;
        function getDateTime(strictTimeZone) {
          const time = getTime(strictTimeZone);
          return function date_time(str) {
            const dateTime = str.split(DATE_TIME_SEPARATOR);
            return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1]);
          };
        }
        function compareDateTime(dt1, dt2) {
          if (!(dt1 && dt2))
            return void 0;
          const d1 = new Date(dt1).valueOf();
          const d2 = new Date(dt2).valueOf();
          if (!(d1 && d2))
            return void 0;
          return d1 - d2;
        }
        function compareIsoDateTime(dt1, dt2) {
          if (!(dt1 && dt2))
            return void 0;
          const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
          const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
          const res = compareDate(d1, d2);
          if (res === void 0)
            return void 0;
          return res || compareTime(t1, t2);
        }
        const NOT_URI_FRAGMENT = /\/|:/;
        const URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
        function uri2(str) {
          return NOT_URI_FRAGMENT.test(str) && URI.test(str);
        }
        const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
        function byte(str) {
          BYTE.lastIndex = 0;
          return BYTE.test(str);
        }
        const MIN_INT32 = -(2 ** 31);
        const MAX_INT32 = 2 ** 31 - 1;
        function validateInt32(value) {
          return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
        }
        function validateInt64(value) {
          return Number.isInteger(value);
        }
        function validateNumber() {
          return true;
        }
        const Z_ANCHOR = /[^\\]\\Z/;
        function regex(str) {
          if (Z_ANCHOR.test(str))
            return false;
          try {
            new RegExp(str);
            return true;
          } catch (e) {
            return false;
          }
        }
      })(formats);
      return formats;
    }
    var limit = {};
    var hasRequiredLimit;
    function requireLimit() {
      if (hasRequiredLimit) return limit;
      hasRequiredLimit = 1;
      (function(exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.formatLimitDefinition = void 0;
        const ajv_1 = requireAjv();
        const codegen_1 = requireCodegen();
        const ops = codegen_1.operators;
        const KWDs = {
          formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
          formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
          formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
          formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
        };
        const error = {
          message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1.str)`should be ${KWDs[keyword2].okStr} ${schemaCode}`,
          params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
        };
        exports.formatLimitDefinition = {
          keyword: Object.keys(KWDs),
          type: "string",
          schemaType: "string",
          $data: true,
          error,
          code(cxt) {
            const { gen, data, schemaCode, keyword: keyword2, it } = cxt;
            const { opts, self: self2 } = it;
            if (!opts.validateFormats)
              return;
            const fCxt = new ajv_1.KeywordCxt(it, self2.RULES.all.format.definition, "format");
            if (fCxt.$data)
              validate$DataFormat();
            else
              validateFormat();
            function validate$DataFormat() {
              const fmts = gen.scopeValue("formats", {
                ref: self2.formats,
                code: opts.code.formats
              });
              const fmt = gen.const("fmt", (0, codegen_1._)`${fmts}[${fCxt.schemaCode}]`);
              cxt.fail$data((0, codegen_1.or)((0, codegen_1._)`typeof ${fmt} != "object"`, (0, codegen_1._)`${fmt} instanceof RegExp`, (0, codegen_1._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
            }
            function validateFormat() {
              const format2 = fCxt.schema;
              const fmtDef = self2.formats[format2];
              if (!fmtDef || fmtDef === true)
                return;
              if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
                throw new Error(`"${keyword2}": format "${format2}" does not define "compare" function`);
              }
              const fmt = gen.scopeValue("formats", {
                key: format2,
                ref: fmtDef,
                code: opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(format2)}` : void 0
              });
              cxt.fail$data(compareCode(fmt));
            }
            function compareCode(fmt) {
              return (0, codegen_1._)`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword2].fail} 0`;
            }
          },
          dependencies: ["format"]
        };
        const formatLimitPlugin = (ajv2) => {
          ajv2.addKeyword(exports.formatLimitDefinition);
          return ajv2;
        };
        exports.default = formatLimitPlugin;
      })(limit);
      return limit;
    }
    var dist$2 = dist$3.exports;
    var hasRequiredDist$1;
    function requireDist$1() {
      if (hasRequiredDist$1) return dist$3.exports;
      hasRequiredDist$1 = 1;
      (function(module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const formats_1 = requireFormats();
        const limit_1 = requireLimit();
        const codegen_1 = requireCodegen();
        const fullName = new codegen_1.Name("fullFormats");
        const fastName = new codegen_1.Name("fastFormats");
        const formatsPlugin = (ajv2, opts = { keywords: true }) => {
          if (Array.isArray(opts)) {
            addFormats2(ajv2, opts, formats_1.fullFormats, fullName);
            return ajv2;
          }
          const [formats2, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
          const list = opts.formats || formats_1.formatNames;
          addFormats2(ajv2, list, formats2, exportName);
          if (opts.keywords)
            (0, limit_1.default)(ajv2);
          return ajv2;
        };
        formatsPlugin.get = (name, mode = "full") => {
          const formats2 = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
          const f = formats2[name];
          if (!f)
            throw new Error(`Unknown format "${name}"`);
          return f;
        };
        function addFormats2(ajv2, list, fs, exportName) {
          var _a;
          var _b;
          (_a = (_b = ajv2.opts.code).formats) !== null && _a !== void 0 ? _a : _b.formats = (0, codegen_1._)`require("ajv-formats/dist/formats").${exportName}`;
          for (const f of list)
            ajv2.addFormat(f, fs[f]);
        }
        module.exports = exports = formatsPlugin;
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.default = formatsPlugin;
      })(dist$3, dist$3.exports);
      return dist$3.exports;
    }
    var distExports$1 = requireDist$1();
    const addFormats = /* @__PURE__ */ getDefaultExportFromCjs(distExports$1);
    var dist$1 = { exports: {} };
    var dist = dist$1.exports;
    var hasRequiredDist;
    function requireDist() {
      if (hasRequiredDist) return dist$1.exports;
      hasRequiredDist = 1;
      (function(module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        const ajv_1 = requireAjv();
        const codegen_1 = requireCodegen();
        const code_1 = requireCode$1();
        const validate_1 = requireValidate();
        const errors_1 = requireErrors();
        const names_1 = requireNames();
        const keyword2 = "errorMessage";
        const used = new ajv_1.Name("emUsed");
        const KEYWORD_PROPERTY_PARAMS = {
          required: "missingProperty",
          dependencies: "property",
          dependentRequired: "property"
        };
        const INTERPOLATION = /\$\{[^}]+\}/;
        const INTERPOLATION_REPLACE = /\$\{([^}]+)\}/g;
        const EMPTY_STR = /^""\s*\+\s*|\s*\+\s*""$/g;
        function errorMessage(options) {
          return {
            keyword: keyword2,
            schemaType: ["string", "object"],
            post: true,
            code(cxt) {
              const { gen, data, schema, schemaValue, it } = cxt;
              if (it.createErrors === false)
                return;
              const sch = schema;
              const instancePath = codegen_1.strConcat(names_1.default.instancePath, it.errorPath);
              gen.if(ajv_1._`${names_1.default.errors} > 0`, () => {
                if (typeof sch == "object") {
                  const [kwdPropErrors, kwdErrors] = keywordErrorsConfig(sch);
                  if (kwdErrors)
                    processKeywordErrors(kwdErrors);
                  if (kwdPropErrors)
                    processKeywordPropErrors(kwdPropErrors);
                  processChildErrors(childErrorsConfig(sch));
                }
                const schMessage = typeof sch == "string" ? sch : sch._;
                if (schMessage)
                  processAllErrors(schMessage);
                if (!options.keepErrors)
                  removeUsedErrors();
              });
              function childErrorsConfig({ properties: properties2, items: items2 }) {
                const errors2 = {};
                if (properties2) {
                  errors2.props = {};
                  for (const p2 in properties2)
                    errors2.props[p2] = [];
                }
                if (items2) {
                  errors2.items = {};
                  for (let i = 0; i < items2.length; i++)
                    errors2.items[i] = [];
                }
                return errors2;
              }
              function keywordErrorsConfig(emSchema) {
                let propErrors;
                let errors2;
                for (const k in emSchema) {
                  if (k === "properties" || k === "items")
                    continue;
                  const kwdSch = emSchema[k];
                  if (typeof kwdSch == "object") {
                    propErrors || (propErrors = {});
                    const errMap = propErrors[k] = {};
                    for (const p2 in kwdSch)
                      errMap[p2] = [];
                  } else {
                    errors2 || (errors2 = {});
                    errors2[k] = [];
                  }
                }
                return [propErrors, errors2];
              }
              function processKeywordErrors(kwdErrors) {
                const kwdErrs = gen.const("emErrors", ajv_1.stringify(kwdErrors));
                const templates = gen.const("templates", getTemplatesCode(kwdErrors, schema));
                gen.forOf("err", names_1.default.vErrors, (err) => gen.if(matchKeywordError(err, kwdErrs), () => gen.code(ajv_1._`${kwdErrs}[${err}.keyword].push(${err})`).assign(ajv_1._`${err}.${used}`, true)));
                const { singleError } = options;
                if (singleError) {
                  const message = gen.let("message", ajv_1._`""`);
                  const paramsErrors = gen.let("paramsErrors", ajv_1._`[]`);
                  loopErrors((key) => {
                    gen.if(message, () => gen.code(ajv_1._`${message} += ${typeof singleError == "string" ? singleError : ";"}`));
                    gen.code(ajv_1._`${message} += ${errMessage(key)}`);
                    gen.assign(paramsErrors, ajv_1._`${paramsErrors}.concat(${kwdErrs}[${key}])`);
                  });
                  errors_1.reportError(cxt, { message, params: ajv_1._`{errors: ${paramsErrors}}` });
                } else {
                  loopErrors((key) => errors_1.reportError(cxt, {
                    message: errMessage(key),
                    params: ajv_1._`{errors: ${kwdErrs}[${key}]}`
                  }));
                }
                function loopErrors(body) {
                  gen.forIn("key", kwdErrs, (key) => gen.if(ajv_1._`${kwdErrs}[${key}].length`, () => body(key)));
                }
                function errMessage(key) {
                  return ajv_1._`${key} in ${templates} ? ${templates}[${key}]() : ${schemaValue}[${key}]`;
                }
              }
              function processKeywordPropErrors(kwdPropErrors) {
                const kwdErrs = gen.const("emErrors", ajv_1.stringify(kwdPropErrors));
                const templatesCode = [];
                for (const k in kwdPropErrors) {
                  templatesCode.push([
                    k,
                    getTemplatesCode(kwdPropErrors[k], schema[k])
                  ]);
                }
                const templates = gen.const("templates", gen.object(...templatesCode));
                const kwdPropParams = gen.scopeValue("obj", {
                  ref: KEYWORD_PROPERTY_PARAMS,
                  code: ajv_1.stringify(KEYWORD_PROPERTY_PARAMS)
                });
                const propParam = gen.let("emPropParams");
                const paramsErrors = gen.let("emParamsErrors");
                gen.forOf("err", names_1.default.vErrors, (err) => gen.if(matchKeywordError(err, kwdErrs), () => {
                  gen.assign(propParam, ajv_1._`${kwdPropParams}[${err}.keyword]`);
                  gen.assign(paramsErrors, ajv_1._`${kwdErrs}[${err}.keyword][${err}.params[${propParam}]]`);
                  gen.if(paramsErrors, () => gen.code(ajv_1._`${paramsErrors}.push(${err})`).assign(ajv_1._`${err}.${used}`, true));
                }));
                gen.forIn("key", kwdErrs, (key) => gen.forIn("keyProp", ajv_1._`${kwdErrs}[${key}]`, (keyProp) => {
                  gen.assign(paramsErrors, ajv_1._`${kwdErrs}[${key}][${keyProp}]`);
                  gen.if(ajv_1._`${paramsErrors}.length`, () => {
                    const tmpl = gen.const("tmpl", ajv_1._`${templates}[${key}] && ${templates}[${key}][${keyProp}]`);
                    errors_1.reportError(cxt, {
                      message: ajv_1._`${tmpl} ? ${tmpl}() : ${schemaValue}[${key}][${keyProp}]`,
                      params: ajv_1._`{errors: ${paramsErrors}}`
                    });
                  });
                }));
              }
              function processChildErrors(childErrors) {
                const { props, items: items2 } = childErrors;
                if (!props && !items2)
                  return;
                const isObj = ajv_1._`typeof ${data} == "object"`;
                const isArr = ajv_1._`Array.isArray(${data})`;
                const childErrs = gen.let("emErrors");
                let childKwd;
                let childProp;
                const templates = gen.let("templates");
                if (props && items2) {
                  childKwd = gen.let("emChildKwd");
                  gen.if(isObj);
                  gen.if(isArr, () => {
                    init(items2, schema.items);
                    gen.assign(childKwd, ajv_1.str`items`);
                  }, () => {
                    init(props, schema.properties);
                    gen.assign(childKwd, ajv_1.str`properties`);
                  });
                  childProp = ajv_1._`[${childKwd}]`;
                } else if (items2) {
                  gen.if(isArr);
                  init(items2, schema.items);
                  childProp = ajv_1._`.items`;
                } else if (props) {
                  gen.if(codegen_1.and(isObj, codegen_1.not(isArr)));
                  init(props, schema.properties);
                  childProp = ajv_1._`.properties`;
                }
                gen.forOf("err", names_1.default.vErrors, (err) => ifMatchesChildError(err, childErrs, (child) => gen.code(ajv_1._`${childErrs}[${child}].push(${err})`).assign(ajv_1._`${err}.${used}`, true)));
                gen.forIn("key", childErrs, (key) => gen.if(ajv_1._`${childErrs}[${key}].length`, () => {
                  errors_1.reportError(cxt, {
                    message: ajv_1._`${key} in ${templates} ? ${templates}[${key}]() : ${schemaValue}${childProp}[${key}]`,
                    params: ajv_1._`{errors: ${childErrs}[${key}]}`
                  });
                  gen.assign(ajv_1._`${names_1.default.vErrors}[${names_1.default.errors}-1].instancePath`, ajv_1._`${instancePath} + "/" + ${key}.replace(/~/g, "~0").replace(/\\//g, "~1")`);
                }));
                gen.endIf();
                function init(children, msgs) {
                  gen.assign(childErrs, ajv_1.stringify(children));
                  gen.assign(templates, getTemplatesCode(children, msgs));
                }
              }
              function processAllErrors(schMessage) {
                const errs = gen.const("emErrs", ajv_1._`[]`);
                gen.forOf("err", names_1.default.vErrors, (err) => gen.if(matchAnyError(err), () => gen.code(ajv_1._`${errs}.push(${err})`).assign(ajv_1._`${err}.${used}`, true)));
                gen.if(ajv_1._`${errs}.length`, () => errors_1.reportError(cxt, {
                  message: templateExpr(schMessage),
                  params: ajv_1._`{errors: ${errs}}`
                }));
              }
              function removeUsedErrors() {
                const errs = gen.const("emErrs", ajv_1._`[]`);
                gen.forOf("err", names_1.default.vErrors, (err) => gen.if(ajv_1._`!${err}.${used}`, () => gen.code(ajv_1._`${errs}.push(${err})`)));
                gen.assign(names_1.default.vErrors, errs).assign(names_1.default.errors, ajv_1._`${errs}.length`);
              }
              function matchKeywordError(err, kwdErrs) {
                return codegen_1.and(
                  ajv_1._`${err}.keyword !== ${keyword2}`,
                  ajv_1._`!${err}.${used}`,
                  ajv_1._`${err}.instancePath === ${instancePath}`,
                  ajv_1._`${err}.keyword in ${kwdErrs}`,
                  // TODO match the end of the string?
                  ajv_1._`${err}.schemaPath.indexOf(${it.errSchemaPath}) === 0`,
                  ajv_1._`/^\\/[^\\/]*$/.test(${err}.schemaPath.slice(${it.errSchemaPath.length}))`
                );
              }
              function ifMatchesChildError(err, childErrs, thenBody) {
                gen.if(codegen_1.and(ajv_1._`${err}.keyword !== ${keyword2}`, ajv_1._`!${err}.${used}`, ajv_1._`${err}.instancePath.indexOf(${instancePath}) === 0`), () => {
                  const childRegex = gen.scopeValue("pattern", {
                    ref: /^\/([^/]*)(?:\/|$)/,
                    code: ajv_1._`new RegExp("^\\\/([^/]*)(?:\\\/|$)")`
                  });
                  const matches2 = gen.const("emMatches", ajv_1._`${childRegex}.exec(${err}.instancePath.slice(${instancePath}.length))`);
                  const child = gen.const("emChild", ajv_1._`${matches2} && ${matches2}[1].replace(/~1/g, "/").replace(/~0/g, "~")`);
                  gen.if(ajv_1._`${child} !== undefined && ${child} in ${childErrs}`, () => thenBody(child));
                });
              }
              function matchAnyError(err) {
                return codegen_1.and(ajv_1._`${err}.keyword !== ${keyword2}`, ajv_1._`!${err}.${used}`, codegen_1.or(ajv_1._`${err}.instancePath === ${instancePath}`, codegen_1.and(ajv_1._`${err}.instancePath.indexOf(${instancePath}) === 0`, ajv_1._`${err}.instancePath[${instancePath}.length] === "/"`)), ajv_1._`${err}.schemaPath.indexOf(${it.errSchemaPath}) === 0`, ajv_1._`${err}.schemaPath[${it.errSchemaPath}.length] === "/"`);
              }
              function getTemplatesCode(keys, msgs) {
                const templatesCode = [];
                for (const k in keys) {
                  const msg = msgs[k];
                  if (INTERPOLATION.test(msg))
                    templatesCode.push([k, templateFunc(msg)]);
                }
                return gen.object(...templatesCode);
              }
              function templateExpr(msg) {
                if (!INTERPOLATION.test(msg))
                  return ajv_1.stringify(msg);
                return new code_1._Code(code_1.safeStringify(msg).replace(INTERPOLATION_REPLACE, (_s, ptr) => `" + JSON.stringify(${validate_1.getData(ptr, it)}) + "`).replace(EMPTY_STR, ""));
              }
              function templateFunc(msg) {
                return ajv_1._`function(){return ${templateExpr(msg)}}`;
              }
            },
            metaSchema: {
              anyOf: [
                { type: "string" },
                {
                  type: "object",
                  properties: {
                    properties: { $ref: "#/$defs/stringMap" },
                    items: { $ref: "#/$defs/stringList" },
                    required: { $ref: "#/$defs/stringOrMap" },
                    dependencies: { $ref: "#/$defs/stringOrMap" }
                  },
                  additionalProperties: { type: "string" }
                }
              ],
              $defs: {
                stringMap: {
                  type: "object",
                  additionalProperties: { type: "string" }
                },
                stringOrMap: {
                  anyOf: [{ type: "string" }, { $ref: "#/$defs/stringMap" }]
                },
                stringList: { type: "array", items: { type: "string" } }
              }
            }
          };
        }
        const ajvErrors = (ajv2, options = {}) => {
          if (!ajv2.opts.allErrors)
            throw new Error("ajv-errors: Ajv option allErrors must be true");
          if (ajv2.opts.jsPropertySyntax) {
            throw new Error("ajv-errors: ajv option jsPropertySyntax is not supported");
          }
          return ajv2.addKeyword(errorMessage(options));
        };
        exports.default = ajvErrors;
        module.exports = ajvErrors;
        module.exports.default = ajvErrors;
      })(dist$1, dist$1.exports);
      return dist$1.exports;
    }
    var distExports = requireDist();
    const addErrors = /* @__PURE__ */ getDefaultExportFromCjs(distExports);
    class ValidatorService {
      constructor(options) {
        __publicField(this, "ajv");
        this.ajv = new Ajv({
          allErrors: true,
          useDefaults: "empty",
          verbose: true,
          validateFormats: true,
          strict: true,
          coerceTypes: true,
          ...options
        });
        console.log(this.ajv.schemas);
        addFormats(this.ajv);
        addErrors(this.ajv);
        this.ajv.addKeyword("nodeType");
      }
      createValidator(schema) {
        return this.ajv.compile(schema);
      }
      resetCache() {
        this.ajv.cache.clear();
      }
      errors(errors2, options) {
        return this.ajv.errorsText(errors2, options);
      }
    }
    const validatorService = new ValidatorService();
    var jsonpointer$1 = {};
    var hasRequiredJsonpointer;
    function requireJsonpointer() {
      if (hasRequiredJsonpointer) return jsonpointer$1;
      hasRequiredJsonpointer = 1;
      var hasExcape = /~/;
      var escapeMatcher = /~[01]/g;
      function escapeReplacer(m) {
        switch (m) {
          case "~1":
            return "/";
          case "~0":
            return "~";
        }
        throw new Error("Invalid tilde escape: " + m);
      }
      function untilde(str) {
        if (!hasExcape.test(str)) return str;
        return str.replace(escapeMatcher, escapeReplacer);
      }
      function setter(obj, pointer, value) {
        var part;
        var hasNextPart;
        for (var p2 = 1, len = pointer.length; p2 < len; ) {
          if (pointer[p2] === "constructor" || pointer[p2] === "prototype" || pointer[p2] === "__proto__") return obj;
          part = untilde(pointer[p2++]);
          hasNextPart = len > p2;
          if (typeof obj[part] === "undefined") {
            if (Array.isArray(obj) && part === "-") {
              part = obj.length;
            }
            if (hasNextPart) {
              if (pointer[p2] !== "" && pointer[p2] < Infinity || pointer[p2] === "-") obj[part] = [];
              else obj[part] = {};
            }
          }
          if (!hasNextPart) break;
          obj = obj[part];
        }
        var oldValue = obj[part];
        if (value === void 0) delete obj[part];
        else obj[part] = value;
        return oldValue;
      }
      function compilePointer(pointer) {
        if (typeof pointer === "string") {
          pointer = pointer.split("/");
          if (pointer[0] === "") return pointer;
          throw new Error("Invalid JSON pointer.");
        } else if (Array.isArray(pointer)) {
          for (const part of pointer) {
            if (typeof part !== "string" && typeof part !== "number") {
              throw new Error("Invalid JSON pointer. Must be of type string or number.");
            }
          }
          return pointer;
        }
        throw new Error("Invalid JSON pointer.");
      }
      function get(obj, pointer) {
        if (typeof obj !== "object") throw new Error("Invalid input object.");
        pointer = compilePointer(pointer);
        var len = pointer.length;
        if (len === 1) return obj;
        for (var p2 = 1; p2 < len; ) {
          obj = obj[untilde(pointer[p2++])];
          if (len === p2) return obj;
          if (typeof obj !== "object" || obj === null) return void 0;
        }
      }
      function set(obj, pointer, value) {
        if (typeof obj !== "object") throw new Error("Invalid input object.");
        pointer = compilePointer(pointer);
        if (pointer.length === 0) throw new Error("Invalid JSON pointer for set.");
        return setter(obj, pointer, value);
      }
      function compile2(pointer) {
        var compiled = compilePointer(pointer);
        return {
          get: function(object) {
            return get(object, compiled);
          },
          set: function(object, value) {
            return set(object, compiled, value);
          }
        };
      }
      jsonpointer$1.get = get;
      jsonpointer$1.set = set;
      jsonpointer$1.compile = compile2;
      return jsonpointer$1;
    }
    var jsonpointerExports = requireJsonpointer();
    const jsonpointer = /* @__PURE__ */ getDefaultExportFromCjs(jsonpointerExports);
    const _export_sfc = (sfc, props) => {
      const target = sfc.__vccOpts || sfc;
      for (const [key, val] of props) {
        target[key] = val;
      }
      return target;
    };
    const _sfc_main$7 = {
      name: "NodeRedVueApp",
      props: {
        node: {
          type: Object,
          required: true
        },
        validator: {
          type: Function,
          required: true
        }
      },
      data() {
        return {
          localNode: this.node,
          errors: {}
        };
      },
      beforeMount() {
        this.validator(this.localNode);
        Object.keys(this.localNode._def.defaults).forEach((prop) => {
          this.$watch(
            () => this.localNode[prop],
            (newVal) => {
              this.validate();
            },
            { deep: true }
          );
        });
        Object.keys(this.localNode._def.credentials).forEach((prop) => {
          if (this.localNode._def.credentials[prop].type === "password" && this.localNode.credentials[`has_${prop}`]) {
            this.localNode.credentials[prop] = "__PWD__";
          }
          this.$watch(
            () => this.localNode.credentials[prop],
            (newVal, oldVal) => {
              this.validate();
              if (this.localNode._def.credentials[prop].type === "password" && newVal !== oldVal) {
                this.localNode.credentials[`has_${prop}`] = !!newVal;
              }
            },
            { deep: true }
          );
        });
      },
      beforeUnmount() {
        var _a, _b;
        (_a = $("#node-dialog-ok")) == null ? void 0 : _a.prop("disabled", false).removeClass("disabled");
        (_b = $("#node-config-dialog-ok")) == null ? void 0 : _b.prop("disabled", false).removeClass("disabled");
        $("#red-ui-workspace").get(0).style.setProperty("pointer-events", "");
        Object.keys(this.localNode._def.credentials).forEach((prop) => {
          if (this.localNode._def.credentials[prop].type === "password" && this.localNode.credentials[`has_${prop}`] && this.localNode.credentials[prop] === "__PWD__") {
            this.localNode.credentials[prop] = void 0;
          }
        });
      },
      methods: {
        validate() {
          var _a, _b;
          const valid = this.validator(this.localNode);
          if (!valid) {
            const errors2 = this.validator.errors;
            this.errors = errors2.reduce((acc, error) => {
              const errorValue = jsonpointer.get(
                this.localNode,
                error.instancePath
              );
              if (error.parentSchema.format === "password" && errorValue === "__PWD__") {
                console.log(
                  "password fields with value equal to __PWD__ should not be an error"
                );
                return acc;
              } else {
                const key = `node${error.instancePath.replaceAll("/", ".")}`;
                acc[key] = error.message;
                return acc;
              }
            }, {});
          } else {
            this.errors = {};
          }
          if (Object.keys(this.errors).length) {
            (_a = $("#node-dialog-ok")) == null ? void 0 : _a.prop("disabled", true).addClass("disabled");
            (_b = $("#node-config-dialog-ok")) == null ? void 0 : _b.prop("disabled", true).addClass("disabled");
            $("#red-ui-workspace").get(0).style.setProperty("pointer-events", "none", "important");
          } else {
            $("#node-dialog-ok").prop("disabled", false).removeClass("disabled");
            $("#node-config-dialog-ok").prop("disabled", false).removeClass("disabled");
            $("#red-ui-workspace").get(0).style.setProperty("pointer-events", "");
          }
        }
      }
    };
    const _hoisted_1$7 = { style: { "width": "100%" } };
    function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_NodeRedNodeForm = resolveComponent("NodeRedNodeForm");
      return openBlock(), createElementBlock("div", _hoisted_1$7, [
        createVNode(_component_NodeRedNodeForm, {
          node: $data.localNode,
          errors: $data.errors,
          style: { "width": "100%" }
        }, null, 8, ["node", "errors"])
      ]);
    }
    const NodeRedVueApp = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7]]);
    const _sfc_main$6 = {
      props: {
        value: String,
        type: {
          type: String,
          default: "text",
          validator: function(value) {
            return ["text", "password"].includes(value);
          }
        },
        placeholder: String,
        error: {
          type: String,
          default: ""
        }
      },
      emits: ["update:value", "input"],
      data() {
        return {
          internalValue: "",
          secretPattern: "*************"
        };
      },
      beforeMount() {
        this.internalValue = this.value;
        this.onBlur();
      },
      methods: {
        onInput(event) {
          this.internalValue = event.target.value;
          this.$emit("update:value", this.internalValue);
          this.$emit("input", this.internalValue);
        },
        onFocus() {
          if (this.type === "password" && this.internalValue === this.secretPattern) {
            this.internalValue = "";
          }
        },
        onBlur() {
          if (this.type === "password" && this.value === "__PWD__") {
            this.internalValue = this.secretPattern;
          }
        }
      }
    };
    const _hoisted_1$6 = { style: { "display": "flex", "flex-direction": "column", "width": "100%" } };
    const _hoisted_2$6 = ["type", "value", "placeholder"];
    const _hoisted_3$4 = {
      key: 0,
      class: "node-red-vue-input-error-message"
    };
    function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$6, [
        createBaseVNode("input", {
          ref: "inputField",
          type: $props.type,
          value: $data.internalValue,
          placeholder: $props.placeholder,
          onInput: _cache[0] || (_cache[0] = (...args) => $options.onInput && $options.onInput(...args)),
          onFocus: _cache[1] || (_cache[1] = (...args) => $options.onFocus && $options.onFocus(...args)),
          onBlur: _cache[2] || (_cache[2] = (...args) => $options.onBlur && $options.onBlur(...args)),
          style: { "flex": "1", "width": "100%" }
        }, null, 40, _hoisted_2$6),
        $props.error ? (openBlock(), createElementBlock("div", _hoisted_3$4, toDisplayString($props.error), 1)) : createCommentVNode("", true)
      ]);
    }
    const NodeRedInput = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6]]);
    const TYPED_INPUT_TYPES = [
      "msg",
      "flow",
      "global",
      "str",
      "num",
      "bool",
      "json",
      "bin",
      "re",
      "jsonata",
      "date",
      "env",
      "node",
      "cred"
    ];
    const _sfc_main$5 = {
      props: {
        value: {
          type: Object,
          required: true,
          validator: function(obj) {
            if (false) {
              console.warn("Prop 'value' must be an object.");
              return false;
            }
            const isValid = obj.hasOwnProperty("value") && obj.hasOwnProperty("type") && typeof obj.value === "string" && typeof obj.type === "string";
            if (!isValid) {
              console.warn(
                "Validation failed for prop 'value': It must be an object with 'value' and 'type' properties being strings.",
                obj
              );
            }
            return isValid;
          }
        },
        types: {
          type: Array,
          default: () => TYPED_INPUT_TYPES
        },
        error: {
          type: String,
          default: ""
        }
      },
      emits: ["update:value"],
      computed: {
        isProvidedValueTypeValid() {
          const type2 = this.value.type;
          const types2 = this.types;
          return types2.includes(type2);
        }
      },
      watch: {
        isProvidedValueTypeValid: {
          handler(newValue) {
            if (!newValue) {
              console.warn(
                `Validation failed: this.value.type (${this.value.type}) must be one of the provided types (${this.types}).`
              );
            }
          },
          immediate: true
        }
      },
      mounted() {
        const inputElement = this.$refs.typedInput;
        this.$input = $(inputElement).typedInput({
          default: this.value.type || this.types[0],
          types: this.types
        });
        this.$input.typedInput("value", this.value.value || "");
        this.$input.typedInput("type", this.value.type || this.types[0]);
        this.$nextTick(() => {
          const observer = new MutationObserver((mutations) => {
            for (const mutation of mutations) {
              if (mutation.attributeName === "value") {
                this.onChange();
              }
            }
          });
          observer.observe(inputElement, {
            attributes: true,
            attributeFilter: ["value"]
          });
          this._observer = observer;
        });
        this.$input.on("change", () => {
          this.onChange();
        });
      },
      watch: {
        error(newVal) {
          this.$nextTick(() => {
            const targetDiv = this.$el.querySelector(
              ".red-ui-typedInput-container"
            );
            if (newVal) {
              targetDiv.classList.add("input-error");
            } else {
              targetDiv.classList.remove("input-error");
            }
          });
        }
      },
      methods: {
        onChange() {
          const newValue = this.$input.typedInput("value");
          const newType = this.$input.typedInput("type");
          if (this.value.value !== newValue || this.value.type !== newType) {
            this.$emit("update:value", {
              value: newValue,
              type: newType
            });
          }
        }
      }
    };
    const _hoisted_1$5 = { style: { "display": "flex", "flex-direction": "column", "width": "100%" } };
    const _hoisted_2$5 = {
      type: "text",
      ref: "typedInput",
      class: "node-red-typed-input",
      style: { "flex": "1", "width": "100%" }
    };
    const _hoisted_3$3 = {
      key: 0,
      class: "node-red-vue-input-error-message"
    };
    function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$5, [
        createBaseVNode("input", _hoisted_2$5, null, 512),
        $props.error ? (openBlock(), createElementBlock("div", _hoisted_3$3, toDisplayString($props.error), 1)) : createCommentVNode("", true)
      ]);
    }
    const NodeRedTypedInput = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
    const _sfc_main$4 = {
      props: {
        value: String,
        type: String,
        error: {
          type: String,
          default: ""
        }
      },
      emits: ["update:value"],
      computed: {
        inputPrefix() {
          return "node-input-" + Math.random().toString(36).substring(2, 9);
        },
        inputId() {
          return this.inputPrefix + "-" + this.value;
        }
      },
      mounted() {
        RED.editor.prepareConfigNodeSelect(
          this,
          this.value,
          this.type,
          this.inputPrefix
        );
        const input = $("#" + this.inputId);
        input.on("change", () => {
          this.$emit("update:value", input.val());
        });
        input.val(this.value || "_ADD_");
      }
    };
    const _hoisted_1$4 = { style: { "display": "flex", "flex-direction": "column", "width": "100%" } };
    const _hoisted_2$4 = ["id"];
    const _hoisted_3$2 = {
      key: 0,
      class: "node-red-vue-input-error-message"
    };
    function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$4, [
        createBaseVNode("input", {
          type: "text",
          id: $options.inputId,
          style: { "width": "100%" }
        }, null, 8, _hoisted_2$4),
        $props.error ? (openBlock(), createElementBlock("div", _hoisted_3$2, toDisplayString($props.error), 1)) : createCommentVNode("", true)
      ]);
    }
    const NodeRedConfigInput = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
    const _sfc_main$3 = {
      props: {
        value: String | Array,
        options: {
          type: Array,
          required: true,
          validator: function(value) {
            if (!Array.isArray(value)) {
              console.warn("Prop 'options' must be an array.");
              return false;
            }
            const isValid = value.every((item) => {
              const isObject2 = typeof item === "object" && item !== null;
              if (!isObject2) return false;
              return item.hasOwnProperty("value") && item.hasOwnProperty("label") && typeof item.value === "string" && typeof item.label === "string";
            });
            if (!isValid) {
              console.warn(
                "Validation failed for prop 'options': Each item must be an object with 'value' and 'label' properties being strings.",
                value
              );
            }
            return isValid;
          }
        },
        multiple: {
          type: Boolean,
          default: false
        },
        error: {
          type: String,
          default: ""
        }
      },
      emits: ["update:value"],
      mounted() {
        const inputElement = this.$refs.selectInput;
        const $selectInput = $(inputElement);
        $selectInput.typedInput({
          types: [
            {
              multiple: this.multiple,
              options: this.options
            }
          ]
        });
        $selectInput.typedInput(
          "value",
          Array.isArray(this.value) ? this.value.join(",") : this.value
        );
        $selectInput.on("change", () => {
          var _a;
          const newValue = this.multiple ? (_a = $selectInput.typedInput("value")) == null ? void 0 : _a.split(",") : $selectInput.typedInput("value");
          this.$emit("update:value", newValue);
        });
      }
    };
    const _hoisted_1$3 = { style: { "display": "flex", "flex-direction": "column", "width": "100%" } };
    const _hoisted_2$3 = {
      type: "text",
      ref: "selectInput",
      class: "node-input-select",
      style: { "width": "100%" }
    };
    const _hoisted_3$1 = {
      key: 0,
      class: "node-red-vue-input-error-message"
    };
    function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$3, [
        createBaseVNode("input", _hoisted_2$3, null, 512),
        $props.error ? (openBlock(), createElementBlock("div", _hoisted_3$1, toDisplayString($props.error), 1)) : createCommentVNode("", true)
      ]);
    }
    const NodeRedSelectInput = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
    const _sfc_main$2 = {
      props: {
        value: String,
        language: {
          type: String,
          default: "json",
          validator: function(value) {
            const allowedLanguages = [
              "text",
              "json",
              "javascript",
              "html",
              "css",
              "markdown",
              "sql",
              "yaml"
            ];
            const isValid = allowedLanguages.includes(value);
            if (!isValid) {
              console.warn(
                `[NodeRedEditorComponent] Invalid ACE editor mode prop: "${value}". Expected one of: ${allowedLanguages.join(", ")}`
              );
            }
            return isValid;
          }
        },
        error: {
          type: String,
          default: ""
        }
      },
      emits: ["update:value"],
      editor: null,
      data() {
        return {
          editorId: "node-red-editor-" + Math.random().toString(36).substring(2, 9)
        };
      },
      mounted() {
        this.mountEditor();
      },
      methods: {
        mountEditor() {
          this.$nextTick(() => {
            const containerEl = this.$refs.containerDiv;
            const editorEl = this.$refs.editorDiv;
            if (containerEl && editorEl) {
              try {
                const inlineHeight = containerEl.style.height;
                const inlineWidth = containerEl.style.width;
                if (inlineHeight) {
                  editorEl.style.height = inlineHeight;
                } else {
                  editorEl.style.height = "200px";
                }
                if (inlineWidth) {
                  editorEl.style.width = inlineWidth;
                } else {
                  editorEl.style.width = "100%";
                }
                this.createEditorInstance();
              } catch (e) {
                console.error(
                  "[NodeRedEditorInput] Error setting initial editor style:",
                  e
                );
                this.createEditorInstance();
              }
            } else {
              console.error(
                "[NodeRedEditorInput] Container or Editor div refs not found on mount."
              );
            }
          });
        },
        createEditorInstance() {
          this.editorInstance = RED.editor.createEditor({
            id: this.editorId,
            mode: this.language,
            value: this.value
          });
          this.editorInstance.getSession().on("change", () => {
            const currentValue = this.editorInstance.getValue();
            if (currentValue !== this.value) {
              this.$emit("update:value", currentValue);
            }
          });
        }
      },
      beforeUnmount() {
        if (this.editorInstance) {
          try {
            this.editorInstance.destroy();
          } catch (err) {
            console.error(`Error destroying editor for ID ${this.editorId}:`, err);
          }
          this.editorInstance = null;
        }
      }
    };
    const _hoisted_1$2 = {
      ref: "containerDiv",
      class: "node-text-editor-container"
    };
    const _hoisted_2$2 = ["id"];
    function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$2, [
        createBaseVNode("div", {
          ref: "editorDiv",
          id: $data.editorId,
          class: "node-text-editor"
        }, null, 8, _hoisted_2$2),
        withDirectives(createBaseVNode("div", { class: "node-red-vue-input-error-message" }, toDisplayString($props.error), 513), [
          [vShow, $props.error]
        ])
      ], 512);
    }
    const NodeRedEditorInput = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
    function createNodeRedVueApp(node, form2, validator) {
      const app = createApp(NodeRedVueApp, {
        node,
        validator
      });
      app.component("NodeRedInput", NodeRedInput);
      app.component("NodeRedTypedInput", NodeRedTypedInput);
      app.component("NodeRedConfigInput", NodeRedConfigInput);
      app.component("NodeRedSelectInput", NodeRedSelectInput);
      app.component("NodeRedEditorInput", NodeRedEditorInput);
      app.component("NodeRedNodeForm", form2);
      return app;
    }
    function mountApp(node, form2, validator) {
      $$1("#app").empty();
      node._newState = cloneDeep(node);
      node._app = createNodeRedVueApp(node._newState, form2, validator);
      node._app.mount("#app");
    }
    function unmountApp(node) {
      if (node._app) {
        node._app.unmount();
        node._app = null;
      }
    }
    function getNodeState(node) {
      const state = {
        credentials: {}
      };
      Object.keys(node._def.defaults).forEach((prop) => {
        state[prop] = node[prop];
      });
      Object.keys(node._def.credentials).forEach((prop) => {
        state.credentials[prop] = node.credentials[prop];
        if (node._def.credentials[prop].type === "password") {
          state.credentials[`has_${prop}`] = node.credentials[`has_${prop}`] || false;
        }
      });
      return state;
    }
    function getChanges(o, n) {
      const changes = {};
      Object.keys(o).forEach((prop) => {
        const _o = o[prop];
        const _n = n[prop];
        if (typeof _o === "object") {
          const _changes = getChanges(_o, _n);
          if (Object.keys(_changes).length) {
            changes[prop] = _changes;
          }
        } else if (!isEqual(_o, _n)) {
          changes[prop] = _o;
        }
      });
      return changes;
    }
    function registerType(options) {
      return async function(type2) {
        try {
          const response = await fetch(`/nrg/nodes/${type2}`);
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          const { schema } = await response.json();
          const defaults2 = getDefaultsFromSchema(schema);
          if (defaults2.credentials) delete defaults2.credentials;
          const credentials = getCredentialsFromSchema(
            schema.properties.credentials
          );
          console.log("defaults", defaults2);
          console.log("credentials", credentials);
          RED.nodes.registerType(type2, {
            ...options,
            defaults: defaults2,
            credentials,
            type: type2,
            label: function() {
              return this.name;
            },
            oneditprepare: function() {
              const validator = validatorService.createValidator(schema);
              mountApp(this, options.form, validator);
            },
            oneditsave: function() {
              var _a;
              const node = this;
              unmountApp(node);
              const newState = getNodeState(node._newState);
              const oldState = getNodeState(node);
              const changes = getChanges(oldState, newState);
              const changed = !!((_a = Object.keys(changes)) == null ? void 0 : _a.length);
              if (!changed) return false;
              Object.keys(node._def.defaults).forEach((prop) => {
                var _a2, _b;
                if ((_b = (_a2 = node._def.defaults) == null ? void 0 : _a2[prop]) == null ? void 0 : _b.type) {
                  const oldConfigNodeId = node[prop];
                  const newConfigNodeId = node._newState[prop];
                  if (oldConfigNodeId !== newConfigNodeId) {
                    const oldConfigNode = RED.nodes.node(oldConfigNodeId);
                    if (oldConfigNode && oldConfigNode._def.category === "config") {
                      const parentNodeIndex = oldConfigNode.users.findIndex(
                        (_node) => _node.id === node.id
                      );
                      if (parentNodeIndex !== -1) {
                        oldConfigNode.users.splice(parentNodeIndex, 1);
                      }
                    }
                  }
                }
              });
              Object.keys(node._def.defaults).forEach((prop) => {
                var _a2, _b;
                if ((_b = (_a2 = node._def.defaults) == null ? void 0 : _a2[prop]) == null ? void 0 : _b.type) {
                  const newStateConfigNodeId = node._newState[prop];
                  const newStateConfigNode = RED.nodes.node(newStateConfigNodeId);
                  if (newStateConfigNode && newStateConfigNode._def.category === "config") {
                    const parentNodeIndex = newStateConfigNode.users.findIndex(
                      (_node) => _node.id === node.id
                    );
                    if (parentNodeIndex === -1) {
                      newStateConfigNode.users.push(node);
                    }
                  }
                }
              });
              merge(node, newState);
              return {
                changed,
                history: [
                  {
                    t: "edit",
                    node,
                    changes,
                    links: [],
                    dirty: RED.nodes.dirty(),
                    changed
                  }
                ]
              };
            },
            oneditcancel: function() {
              unmountApp(this);
            },
            oneditdelete: function() {
              unmountApp(this);
            },
            onpaletteadd: options.onPaletteAdd,
            onpaltteremove: options.onPaletteRemove
          });
        } catch (error) {
          console.error(`Error fetching node type ${type2}:`, error);
          throw error;
        }
      };
    }
    const _sfc_main$1 = {
      name: "NodeRedNodeForm",
      props: {
        node: {
          type: Object,
          required: true
        },
        errors: {
          type: Object,
          default: () => ({})
        }
      }
    };
    const _hoisted_1$1 = { class: "form-row" };
    const _hoisted_2$1 = { class: "form-row" };
    function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_NodeRedInput = resolveComponent("NodeRedInput");
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("div", _hoisted_1$1, [
          _cache[2] || (_cache[2] = createBaseVNode("label", null, [
            createBaseVNode("i", { class: "fa fa-tag" }),
            createTextVNode(" Name")
          ], -1)),
          createVNode(_component_NodeRedInput, {
            value: $props.node.name,
            "onUpdate:value": _cache[0] || (_cache[0] = ($event) => $props.node.name = $event),
            error: $props.errors["node.name"],
            placeholder: "name"
          }, null, 8, ["value", "error"])
        ]),
        createBaseVNode("div", _hoisted_2$1, [
          _cache[3] || (_cache[3] = createBaseVNode("label", null, [
            createBaseVNode("i", { class: "fa fa-tag" }),
            createTextVNode(" Hostname")
          ], -1)),
          createVNode(_component_NodeRedInput, {
            value: $props.node.host,
            "onUpdate:value": _cache[1] || (_cache[1] = ($event) => $props.node.host = $event),
            error: $props.errors["node.host"],
            placeholder: "hostname"
          }, null, 8, ["value", "error"])
        ])
      ]);
    }
    const form$1 = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1], ["__scopeId", "data-v-d1d8f032"]]);
    const remoteServer = registerType({
      category: "config",
      color: "#a6bbcf",
      form: form$1
    });
    const _sfc_main = {
      name: "NodeRedNodeForm",
      props: {
        node: {
          type: Object,
          required: true
        },
        errors: {
          type: Object,
          default: () => ({})
        }
      },
      data() {
        return {
          types: ["str", "msg", "node"],
          countries: [
            { value: "usa", label: "usa" },
            { value: "argentina", label: "argentina" },
            { value: "brasil", label: "brasil" }
          ],
          fruits: [
            { value: "apple", label: "apple" },
            { value: "melon", label: "melon" },
            { value: "raspberry", label: "raspberry" }
          ],
          numbers: [
            { value: "1", label: "1" },
            { value: "2", label: "2" },
            { value: "3", label: "3" }
          ],
          objects: [
            { value: JSON.stringify({ test: "a" }), label: "a" },
            { value: JSON.stringify({ test: "b" }), label: "b" },
            { value: JSON.stringify({ test: "c" }), label: "c" }
          ],
          arrays: [
            { value: JSON.stringify(["a"]), label: "a" },
            { value: JSON.stringify(["b"]), label: "b" },
            { value: JSON.stringify(["c"]), label: "c" }
          ]
        };
      }
    };
    const _hoisted_1 = { class: "form-row" };
    const _hoisted_2 = { class: "form-row" };
    const _hoisted_3 = { class: "form-row" };
    const _hoisted_4 = { class: "form-row" };
    const _hoisted_5 = { class: "form-row" };
    const _hoisted_6 = { class: "form-row" };
    const _hoisted_7 = { class: "form-row" };
    const _hoisted_8 = { class: "form-row" };
    const _hoisted_9 = { class: "form-row" };
    const _hoisted_10 = { class: "form-row" };
    const _hoisted_11 = { class: "form-row" };
    const _hoisted_12 = { class: "form-row" };
    const _hoisted_13 = { class: "form-row" };
    const _hoisted_14 = { class: "form-row" };
    function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_NodeRedInput = resolveComponent("NodeRedInput");
      const _component_NodeRedTypedInput = resolveComponent("NodeRedTypedInput");
      const _component_NodeRedConfigInput = resolveComponent("NodeRedConfigInput");
      const _component_NodeRedSelectInput = resolveComponent("NodeRedSelectInput");
      const _component_NodeRedEditorInput = resolveComponent("NodeRedEditorInput");
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("div", _hoisted_1, [
          _cache[14] || (_cache[14] = createBaseVNode("label", null, [
            createBaseVNode("i", { class: "fa fa-tag" }),
            createTextVNode(" Username")
          ], -1)),
          createVNode(_component_NodeRedInput, {
            value: $props.node.credentials.username,
            "onUpdate:value": _cache[0] || (_cache[0] = ($event) => $props.node.credentials.username = $event),
            error: $props.errors["node.credentials.username"]
          }, null, 8, ["value", "error"])
        ]),
        createBaseVNode("div", _hoisted_2, [
          _cache[15] || (_cache[15] = createBaseVNode("label", null, [
            createBaseVNode("i", { class: "fa fa-tag" }),
            createTextVNode(" Password")
          ], -1)),
          createVNode(_component_NodeRedInput, {
            value: $props.node.credentials.password,
            "onUpdate:value": _cache[1] || (_cache[1] = ($event) => $props.node.credentials.password = $event),
            type: "password",
            error: $props.errors["node.credentials.password"]
          }, null, 8, ["value", "error"])
        ]),
        createBaseVNode("div", _hoisted_3, [
          _cache[16] || (_cache[16] = createBaseVNode("label", null, [
            createBaseVNode("i", { class: "fa fa-tag" }),
            createTextVNode(" Password 2")
          ], -1)),
          createVNode(_component_NodeRedInput, {
            value: $props.node.credentials.password2,
            "onUpdate:value": _cache[2] || (_cache[2] = ($event) => $props.node.credentials.password2 = $event),
            type: "password",
            error: $props.errors["node.credentials.password2"]
          }, null, 8, ["value", "error"])
        ]),
        createBaseVNode("div", _hoisted_4, [
          _cache[17] || (_cache[17] = createBaseVNode("label", null, "Typed Input", -1)),
          createVNode(_component_NodeRedTypedInput, {
            value: $props.node.myProperty,
            "onUpdate:value": _cache[3] || (_cache[3] = ($event) => $props.node.myProperty = $event),
            types: $data.types,
            error: $props.errors["node.myProperty"]
          }, null, 8, ["value", "types", "error"])
        ]),
        createBaseVNode("div", _hoisted_5, [
          _cache[18] || (_cache[18] = createBaseVNode("label", null, "Typed Input 2", -1)),
          createVNode(_component_NodeRedTypedInput, {
            value: $props.node.myProperty2,
            "onUpdate:value": _cache[4] || (_cache[4] = ($event) => $props.node.myProperty2 = $event),
            error: $props.errors["node.myProperty2"]
          }, null, 8, ["value", "error"])
        ]),
        createBaseVNode("div", _hoisted_6, [
          _cache[19] || (_cache[19] = createBaseVNode("label", null, "Config Input", -1)),
          createVNode(_component_NodeRedConfigInput, {
            value: $props.node.remoteServer,
            "onUpdate:value": _cache[5] || (_cache[5] = ($event) => $props.node.remoteServer = $event),
            type: "remote-server",
            error: $props.errors["node.remoteServer"]
          }, null, 8, ["value", "error"])
        ]),
        createBaseVNode("div", _hoisted_7, [
          _cache[20] || (_cache[20] = createBaseVNode("label", null, "Config Input", -1)),
          createVNode(_component_NodeRedConfigInput, {
            value: $props.node.anotherRemoteServer,
            "onUpdate:value": _cache[6] || (_cache[6] = ($event) => $props.node.anotherRemoteServer = $event),
            type: "remote-server",
            error: $props.errors["node.anotherRemoteServer"]
          }, null, 8, ["value", "error"])
        ]),
        createBaseVNode("div", _hoisted_8, [
          _cache[21] || (_cache[21] = createBaseVNode("label", null, "Select Input", -1)),
          createVNode(_component_NodeRedSelectInput, {
            value: $props.node.country,
            "onUpdate:value": _cache[7] || (_cache[7] = ($event) => $props.node.country = $event),
            options: $data.countries,
            error: $props.errors["node.country"]
          }, null, 8, ["value", "options", "error"])
        ]),
        createBaseVNode("div", _hoisted_9, [
          _cache[22] || (_cache[22] = createBaseVNode("label", null, "MultiSelect Input", -1)),
          createVNode(_component_NodeRedSelectInput, {
            value: $props.node.fruit,
            "onUpdate:value": _cache[8] || (_cache[8] = ($event) => $props.node.fruit = $event),
            options: $data.fruits,
            multiple: "",
            error: $props.errors["node.fruit"]
          }, null, 8, ["value", "options", "error"])
        ]),
        createBaseVNode("div", _hoisted_10, [
          _cache[23] || (_cache[23] = createBaseVNode("label", null, "Select Input", -1)),
          createVNode(_component_NodeRedSelectInput, {
            value: $props.node.number,
            "onUpdate:value": _cache[9] || (_cache[9] = ($event) => $props.node.number = $event),
            options: $data.numbers,
            error: $props.errors["node.number"]
          }, null, 8, ["value", "options", "error"])
        ]),
        createBaseVNode("div", _hoisted_11, [
          _cache[24] || (_cache[24] = createBaseVNode("label", null, "Select Input", -1)),
          createVNode(_component_NodeRedSelectInput, {
            value: $props.node.object,
            "onUpdate:value": _cache[10] || (_cache[10] = ($event) => $props.node.object = $event),
            options: $data.objects,
            multiple: "",
            error: $props.errors["node.object"]
          }, null, 8, ["value", "options", "error"])
        ]),
        createBaseVNode("div", _hoisted_12, [
          _cache[25] || (_cache[25] = createBaseVNode("label", null, "Select Input", -1)),
          createVNode(_component_NodeRedSelectInput, {
            value: $props.node.array,
            "onUpdate:value": _cache[11] || (_cache[11] = ($event) => $props.node.array = $event),
            options: $data.arrays,
            error: $props.errors["node.array"]
          }, null, 8, ["value", "options", "error"])
        ]),
        createBaseVNode("div", _hoisted_13, [
          _cache[26] || (_cache[26] = createBaseVNode("label", null, "Editor with default height 200px and JSON", -1)),
          createVNode(_component_NodeRedEditorInput, {
            value: $props.node.jsontest,
            "onUpdate:value": _cache[12] || (_cache[12] = ($event) => $props.node.jsontest = $event),
            error: $props.errors["node.jsontest"]
          }, null, 8, ["value", "error"])
        ]),
        createBaseVNode("div", _hoisted_14, [
          _cache[27] || (_cache[27] = createBaseVNode("label", null, "Editor with custom height and CSS", -1)),
          createVNode(_component_NodeRedEditorInput, {
            value: $props.node.csstest,
            "onUpdate:value": _cache[13] || (_cache[13] = ($event) => $props.node.csstest = $event),
            language: "css",
            style: { "height": "100px" },
            error: $props.errors["node.csstest"]
          }, null, 8, ["value", "error"])
        ])
      ]);
    }
    const form = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__scopeId", "data-v-52a2434f"]]);
    const yourNode = registerType({
      category: "function",
      color: "#FFFFFF",
      inputs: 1,
      outputs: 1,
      icon: "vue.png",
      form,
      onPaletteAdd: () => {
        console.log("NODE TYPE REGISTERED ON THE PALETTE");
      }
    });
    async function registerNodes() {
      try {
        await Promise.all([remoteServer("remote-server"), yourNode("your-node")]);
        console.log("All node types registered in parallel");
      } catch (error) {
        console.error("Error registering node types:", error);
      }
    }
    registerNodes();
  })($);
  //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibnJnLkN3S00wanVVLmpzIiwic291cmNlcyI6WyIuLi9ub2RlX21vZHVsZXMvQHZ1ZS9zaGFyZWQvZGlzdC9zaGFyZWQuZXNtLWJ1bmRsZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQHZ1ZS9yZWFjdGl2aXR5L2Rpc3QvcmVhY3Rpdml0eS5lc20tYnVuZGxlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtY29yZS9kaXN0L3J1bnRpbWUtY29yZS5lc20tYnVuZGxlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtZG9tL2Rpc3QvcnVudGltZS1kb20uZXNtLWJ1bmRsZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLnJ1bnRpbWUuZXNtLWJ1bmRsZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2FycmF5L2F0Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvYXJyYXkvY2h1bmsubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9hcnJheS9jb21wYWN0Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvYXJyYXkvY291bnRCeS5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2FycmF5L2RpZmZlcmVuY2UubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9hcnJheS9kaWZmZXJlbmNlQnkubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9hcnJheS9kaWZmZXJlbmNlV2l0aC5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2FycmF5L2Ryb3AubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9hcnJheS9kcm9wUmlnaHQubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9hcnJheS9kcm9wUmlnaHRXaGlsZS5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2FycmF5L2Ryb3BXaGlsZS5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2FycmF5L2ZpbGwubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9hcnJheS9mbGF0dGVuLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvYXJyYXkvZmxhdE1hcC5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2FycmF5L2ZsYXR0ZW5EZWVwLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvYXJyYXkvZmxhdE1hcERlZXAubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9hcnJheS9mb3JFYWNoUmlnaHQubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9hcnJheS9ncm91cEJ5Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvYXJyYXkvaGVhZC5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2FycmF5L2luaXRpYWwubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9hcnJheS9pbnRlcnNlY3Rpb24ubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9hcnJheS9pbnRlcnNlY3Rpb25CeS5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2FycmF5L2ludGVyc2VjdGlvbldpdGgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9hcnJheS9pc1N1YnNldC5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2FycmF5L2lzU3Vic2V0V2l0aC5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2FycmF5L2tleUJ5Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvYXJyYXkvbGFzdC5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2FycmF5L21heEJ5Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvYXJyYXkvbWluQnkubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9faW50ZXJuYWwvY29tcGFyZVZhbHVlcy5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2FycmF5L29yZGVyQnkubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9hcnJheS9wYXJ0aXRpb24ubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9hcnJheS9wdWxsLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvYXJyYXkvcHVsbEF0Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvYXJyYXkvcmVtb3ZlLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvYXJyYXkvc2FtcGxlLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvbWF0aC9yYW5kb20ubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9tYXRoL3JhbmRvbUludC5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2FycmF5L3NhbXBsZVNpemUubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9hcnJheS9zaHVmZmxlLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvYXJyYXkvc29ydEJ5Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvYXJyYXkvdGFpbC5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2NvbXBhdC9wcmVkaWNhdGUvaXNTeW1ib2wubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9jb21wYXQvdXRpbC90b051bWJlci5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2NvbXBhdC91dGlsL3RvRmluaXRlLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvY29tcGF0L3V0aWwvdG9JbnRlZ2VyLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvYXJyYXkvdGFrZS5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2FycmF5L3Rha2VSaWdodC5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2FycmF5L3Rha2VSaWdodFdoaWxlLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvYXJyYXkvdGFrZVdoaWxlLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvYXJyYXkvdG9GaWxsZWQubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9hcnJheS91bmlxLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvYXJyYXkvdW5pb24ubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9hcnJheS91bmlxQnkubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9hcnJheS91bmlvbkJ5Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvYXJyYXkvdW5pcVdpdGgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9hcnJheS91bmlvbldpdGgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9hcnJheS91bnppcC5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2FycmF5L3VuemlwV2l0aC5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2FycmF5L3dpbmRvd2VkLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvYXJyYXkvd2l0aG91dC5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2FycmF5L3hvci5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2FycmF5L3hvckJ5Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvYXJyYXkveG9yV2l0aC5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2FycmF5L3ppcC5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2FycmF5L3ppcE9iamVjdC5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2FycmF5L3ppcFdpdGgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9lcnJvci9BYm9ydEVycm9yLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvZXJyb3IvVGltZW91dEVycm9yLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvZnVuY3Rpb24vYWZ0ZXIubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9mdW5jdGlvbi9hcnkubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9mdW5jdGlvbi9hc3luY05vb3AubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9mdW5jdGlvbi9iZWZvcmUubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9mdW5jdGlvbi9jdXJyeS5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2Z1bmN0aW9uL2N1cnJ5UmlnaHQubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9mdW5jdGlvbi9kZWJvdW5jZS5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2Z1bmN0aW9uL2Zsb3cubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9mdW5jdGlvbi9mbG93UmlnaHQubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9mdW5jdGlvbi9pZGVudGl0eS5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2Z1bmN0aW9uL21lbW9pemUubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9mdW5jdGlvbi9uZWdhdGUubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9mdW5jdGlvbi9ub29wLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvZnVuY3Rpb24vb25jZS5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2Z1bmN0aW9uL3BhcnRpYWwubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9mdW5jdGlvbi9wYXJ0aWFsUmlnaHQubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9mdW5jdGlvbi9yZXN0Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvcHJvbWlzZS9kZWxheS5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2Z1bmN0aW9uL3JldHJ5Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvZnVuY3Rpb24vc3ByZWFkLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvZnVuY3Rpb24vdGhyb3R0bGUubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9mdW5jdGlvbi91bmFyeS5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L21hdGgvY2xhbXAubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9tYXRoL2luUmFuZ2UubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9tYXRoL3N1bS5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L21hdGgvbWVhbi5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L21hdGgvbWVhbkJ5Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvbWF0aC9tZWRpYW4ubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9tYXRoL21lZGlhbkJ5Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvbWF0aC9yYW5nZS5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L21hdGgvcmFuZ2VSaWdodC5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L21hdGgvcm91bmQubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9tYXRoL3N1bUJ5Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvcHJlZGljYXRlL2lzUHJpbWl0aXZlLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvcHJlZGljYXRlL2lzVHlwZWRBcnJheS5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L29iamVjdC9jbG9uZS5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2NvbXBhdC9faW50ZXJuYWwvZ2V0U3ltYm9scy5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2NvbXBhdC9faW50ZXJuYWwvZ2V0VGFnLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvY29tcGF0L19pbnRlcm5hbC90YWdzLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3Qvb2JqZWN0L2Nsb25lRGVlcFdpdGgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9vYmplY3QvY2xvbmVEZWVwLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3Qvb2JqZWN0L2ZpbmRLZXkubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9wcmVkaWNhdGUvaXNQbGFpbk9iamVjdC5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L29iamVjdC9mbGF0dGVuT2JqZWN0Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3Qvb2JqZWN0L2ludmVydC5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L29iamVjdC9tYXBLZXlzLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3Qvb2JqZWN0L21hcFZhbHVlcy5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L29iamVjdC9tZXJnZS5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2NvbXBhdC9wcmVkaWNhdGUvaXNPYmplY3RMaWtlLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3Qvb2JqZWN0L21lcmdlV2l0aC5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L29iamVjdC9vbWl0Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3Qvb2JqZWN0L29taXRCeS5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L29iamVjdC9waWNrLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3Qvb2JqZWN0L3BpY2tCeS5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2NvbXBhdC9wcmVkaWNhdGUvaXNBcnJheS5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L3N0cmluZy9jYXBpdGFsaXplLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3Qvc3RyaW5nL3dvcmRzLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3Qvc3RyaW5nL2NhbWVsQ2FzZS5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L29iamVjdC90b0NhbWVsQ2FzZUtleXMubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9vYmplY3QvdG9NZXJnZWQubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9jb21wYXQvcHJlZGljYXRlL2lzUGxhaW5PYmplY3QubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9zdHJpbmcvc25ha2VDYXNlLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3Qvb2JqZWN0L3RvU25ha2VDYXNlS2V5cy5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L3ByZWRpY2F0ZS9pc0FycmF5QnVmZmVyLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvcHJlZGljYXRlL2lzQmxvYi5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L3ByZWRpY2F0ZS9pc0Jvb2xlYW4ubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9wcmVkaWNhdGUvaXNCcm93c2VyLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvcHJlZGljYXRlL2lzQnVmZmVyLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvcHJlZGljYXRlL2lzRGF0ZS5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L2NvbXBhdC91dGlsL2VxLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvcHJlZGljYXRlL2lzRXF1YWxXaXRoLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvcHJlZGljYXRlL2lzRXF1YWwubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9wcmVkaWNhdGUvaXNFcnJvci5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L3ByZWRpY2F0ZS9pc0ZpbGUubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9wcmVkaWNhdGUvaXNGdW5jdGlvbi5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L3ByZWRpY2F0ZS9pc0pTT04ubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9wcmVkaWNhdGUvaXNKU09OVmFsdWUubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9wcmVkaWNhdGUvaXNMZW5ndGgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9wcmVkaWNhdGUvaXNNYXAubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9wcmVkaWNhdGUvaXNOaWwubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9wcmVkaWNhdGUvaXNOb2RlLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvcHJlZGljYXRlL2lzTm90TmlsLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvcHJlZGljYXRlL2lzTnVsbC5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L3ByZWRpY2F0ZS9pc1Byb21pc2UubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9wcmVkaWNhdGUvaXNSZWdFeHAubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9wcmVkaWNhdGUvaXNTZXQubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9wcmVkaWNhdGUvaXNTdHJpbmcubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9wcmVkaWNhdGUvaXNTeW1ib2wubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9wcmVkaWNhdGUvaXNVbmRlZmluZWQubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9wcmVkaWNhdGUvaXNXZWFrTWFwLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvcHJlZGljYXRlL2lzV2Vha1NldC5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L3Byb21pc2Uvc2VtYXBob3JlLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvcHJvbWlzZS9tdXRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L3Byb21pc2UvdGltZW91dC5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L3Byb21pc2Uvd2l0aFRpbWVvdXQubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9zdHJpbmcvY29uc3RhbnRDYXNlLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3Qvc3RyaW5nL2RlYnVyci5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L3N0cmluZy9lc2NhcGUubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9zdHJpbmcvZXNjYXBlUmVnRXhwLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3Qvc3RyaW5nL2tlYmFiQ2FzZS5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L3N0cmluZy9sb3dlckNhc2UubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9zdHJpbmcvbG93ZXJGaXJzdC5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L3N0cmluZy9wYWQubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC9zdHJpbmcvcGFzY2FsQ2FzZS5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L3N0cmluZy9yZXZlcnNlU3RyaW5nLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3Qvc3RyaW5nL3N0YXJ0Q2FzZS5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L3N0cmluZy90cmltRW5kLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3Qvc3RyaW5nL3RyaW1TdGFydC5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L3N0cmluZy90cmltLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3Qvc3RyaW5nL3VuZXNjYXBlLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3Qvc3RyaW5nL3VwcGVyQ2FzZS5tanMiLCIuLi9ub2RlX21vZHVsZXMvZXMtdG9vbGtpdC9kaXN0L3N0cmluZy91cHBlckZpcnN0Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvdXRpbC9hdHRlbXB0Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9lcy10b29sa2l0L2Rpc3QvdXRpbC9hdHRlbXB0QXN5bmMubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2VzLXRvb2xraXQvZGlzdC91dGlsL2ludmFyaWFudC5tanMiLCIuLi9zcmMvY29yZS91dGlscy50cyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL2NvZGVnZW4vY29kZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL2NvZGVnZW4vc2NvcGUuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdXRpbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL25hbWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvZXJyb3JzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvYm9vbFNjaGVtYS5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3J1bGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvYXBwbGljYWJpbGl0eS5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2RhdGFUeXBlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvZGVmYXVsdHMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvZGUuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9rZXl3b3JkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvc3Vic2NoZW1hLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Zhc3QtZGVlcC1lcXVhbC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS10cmF2ZXJzZS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3Jlc29sdmUuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3IuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9yZWZfZXJyb3IuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9mYXN0LXVyaS9saWIvc2NvcGVkQ2hhcnMuanMiLCIuLi9ub2RlX21vZHVsZXMvZmFzdC11cmkvbGliL3V0aWxzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Zhc3QtdXJpL2xpYi9zY2hlbWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Zhc3QtdXJpL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3J1bnRpbWUvdXJpLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvcmUuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvcmUvaWQuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvcmUvcmVmLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9jb3JlL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0TnVtYmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL211bHRpcGxlT2YuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvcnVudGltZS91Y3MybGVuZ3RoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0TGVuZ3RoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL3BhdHRlcm4uanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbGltaXRQcm9wZXJ0aWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL3JlcXVpcmVkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0SXRlbXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvcnVudGltZS9lcXVhbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi91bmlxdWVJdGVtcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9jb25zdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9lbnVtLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FkZGl0aW9uYWxJdGVtcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9pdGVtcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9wcmVmaXhJdGVtcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9pdGVtczIwMjAuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvY29udGFpbnMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvZGVwZW5kZW5jaWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3Byb3BlcnR5TmFtZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWRkaXRpb25hbFByb3BlcnRpZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcHJvcGVydGllcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9wYXR0ZXJuUHJvcGVydGllcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9ub3QuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYW55T2YuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3Ivb25lT2YuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWxsT2YuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaWYuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvdGhlbkVsc2UuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Zvcm1hdC9mb3JtYXQuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Zvcm1hdC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvbWV0YWRhdGEuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2RyYWZ0Ny5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvci90eXBlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvci9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9hanYuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2LWZvcm1hdHMvZGlzdC9mb3JtYXRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Fqdi1mb3JtYXRzL2Rpc3QvbGltaXQuanMiLCIuLi9ub2RlX21vZHVsZXMvYWp2LWZvcm1hdHMvZGlzdC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9hanYtZXJyb3JzL2Rpc3QvaW5kZXguanMiLCIuLi9zcmMvY29yZS92YWxpZGF0b3Itc2VydmljZS50cyIsIi4uL3NyYy9jb3JlL2NsaWVudC92YWxpZGF0b3IudHMiLCIuLi9ub2RlX21vZHVsZXMvanNvbnBvaW50ZXIvanNvbnBvaW50ZXIuanMiLCIuLi9zcmMvY29yZS9jbGllbnQvQXBwLnZ1ZSIsIi4uL3NyYy9jb3JlL2NsaWVudC9jb21wb25lbnRzL05vZGVSZWRJbnB1dC52dWUiLCIuLi9zcmMvY29yZS9jb25zdGFudHMudHMiLCIuLi9zcmMvY29yZS9jbGllbnQvY29tcG9uZW50cy9Ob2RlUmVkVHlwZWRJbnB1dC52dWUiLCIuLi9zcmMvY29yZS9jbGllbnQvY29tcG9uZW50cy9Ob2RlUmVkQ29uZmlnSW5wdXQudnVlIiwiLi4vc3JjL2NvcmUvY2xpZW50L2NvbXBvbmVudHMvTm9kZVJlZFNlbGVjdElucHV0LnZ1ZSIsIi4uL3NyYy9jb3JlL2NsaWVudC9jb21wb25lbnRzL05vZGVSZWRFZGl0b3JJbnB1dC52dWUiLCIuLi9zcmMvY29yZS9jbGllbnQvaW5kZXgudHMiLCIuLi9zcmMvbm9kZXMvcmVtb3RlLXNlcnZlci9jbGllbnQvRm9ybS52dWUiLCIuLi9zcmMvbm9kZXMvcmVtb3RlLXNlcnZlci9jbGllbnQvaW5kZXgudHMiLCIuLi9zcmMvbm9kZXMveW91ci1ub2RlL2NsaWVudC9Gb3JtLnZ1ZSIsIi4uL3NyYy9ub2Rlcy95b3VyLW5vZGUvY2xpZW50L2luZGV4LnRzIiwiLi4vc3JjL25vZGVzL2NsaWVudC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiogQHZ1ZS9zaGFyZWQgdjMuNS4xM1xuKiAoYykgMjAxOC1wcmVzZW50IFl1eGkgKEV2YW4pIFlvdSBhbmQgVnVlIGNvbnRyaWJ1dG9yc1xuKiBAbGljZW5zZSBNSVRcbioqL1xuLyohICNfX05PX1NJREVfRUZGRUNUU19fICovXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbWFrZU1hcChzdHIpIHtcbiAgY29uc3QgbWFwID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAoY29uc3Qga2V5IG9mIHN0ci5zcGxpdChcIixcIikpIG1hcFtrZXldID0gMTtcbiAgcmV0dXJuICh2YWwpID0+IHZhbCBpbiBtYXA7XG59XG5cbmNvbnN0IEVNUFRZX09CSiA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBPYmplY3QuZnJlZXplKHt9KSA6IHt9O1xuY29uc3QgRU1QVFlfQVJSID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IE9iamVjdC5mcmVlemUoW10pIDogW107XG5jb25zdCBOT09QID0gKCkgPT4ge1xufTtcbmNvbnN0IE5PID0gKCkgPT4gZmFsc2U7XG5jb25zdCBpc09uID0gKGtleSkgPT4ga2V5LmNoYXJDb2RlQXQoMCkgPT09IDExMSAmJiBrZXkuY2hhckNvZGVBdCgxKSA9PT0gMTEwICYmIC8vIHVwcGVyY2FzZSBsZXR0ZXJcbihrZXkuY2hhckNvZGVBdCgyKSA+IDEyMiB8fCBrZXkuY2hhckNvZGVBdCgyKSA8IDk3KTtcbmNvbnN0IGlzTW9kZWxMaXN0ZW5lciA9IChrZXkpID0+IGtleS5zdGFydHNXaXRoKFwib25VcGRhdGU6XCIpO1xuY29uc3QgZXh0ZW5kID0gT2JqZWN0LmFzc2lnbjtcbmNvbnN0IHJlbW92ZSA9IChhcnIsIGVsKSA9PiB7XG4gIGNvbnN0IGkgPSBhcnIuaW5kZXhPZihlbCk7XG4gIGlmIChpID4gLTEpIHtcbiAgICBhcnIuc3BsaWNlKGksIDEpO1xuICB9XG59O1xuY29uc3QgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuY29uc3QgaGFzT3duID0gKHZhbCwga2V5KSA9PiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbCwga2V5KTtcbmNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuY29uc3QgaXNNYXAgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IE1hcF1cIjtcbmNvbnN0IGlzU2V0ID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBTZXRdXCI7XG5jb25zdCBpc0RhdGUgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IERhdGVdXCI7XG5jb25zdCBpc1JlZ0V4cCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgUmVnRXhwXVwiO1xuY29uc3QgaXNGdW5jdGlvbiA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIjtcbmNvbnN0IGlzU3RyaW5nID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIjtcbmNvbnN0IGlzU3ltYm9sID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJzeW1ib2xcIjtcbmNvbnN0IGlzT2JqZWN0ID0gKHZhbCkgPT4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCI7XG5jb25zdCBpc1Byb21pc2UgPSAodmFsKSA9PiB7XG4gIHJldHVybiAoaXNPYmplY3QodmFsKSB8fCBpc0Z1bmN0aW9uKHZhbCkpICYmIGlzRnVuY3Rpb24odmFsLnRoZW4pICYmIGlzRnVuY3Rpb24odmFsLmNhdGNoKTtcbn07XG5jb25zdCBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5jb25zdCB0b1R5cGVTdHJpbmcgPSAodmFsdWUpID0+IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuY29uc3QgdG9SYXdUeXBlID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiB0b1R5cGVTdHJpbmcodmFsdWUpLnNsaWNlKDgsIC0xKTtcbn07XG5jb25zdCBpc1BsYWluT2JqZWN0ID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG5jb25zdCBpc0ludGVnZXJLZXkgPSAoa2V5KSA9PiBpc1N0cmluZyhrZXkpICYmIGtleSAhPT0gXCJOYU5cIiAmJiBrZXlbMF0gIT09IFwiLVwiICYmIFwiXCIgKyBwYXJzZUludChrZXksIDEwKSA9PT0ga2V5O1xuY29uc3QgaXNSZXNlcnZlZFByb3AgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgLy8gdGhlIGxlYWRpbmcgY29tbWEgaXMgaW50ZW50aW9uYWwgc28gZW1wdHkgc3RyaW5nIFwiXCIgaXMgYWxzbyBpbmNsdWRlZFxuICBcIixrZXkscmVmLHJlZl9mb3IscmVmX2tleSxvblZub2RlQmVmb3JlTW91bnQsb25Wbm9kZU1vdW50ZWQsb25Wbm9kZUJlZm9yZVVwZGF0ZSxvblZub2RlVXBkYXRlZCxvblZub2RlQmVmb3JlVW5tb3VudCxvblZub2RlVW5tb3VudGVkXCJcbik7XG5jb25zdCBpc0J1aWx0SW5EaXJlY3RpdmUgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgXCJiaW5kLGNsb2FrLGVsc2UtaWYsZWxzZSxmb3IsaHRtbCxpZixtb2RlbCxvbixvbmNlLHByZSxzaG93LHNsb3QsdGV4dCxtZW1vXCJcbik7XG5jb25zdCBjYWNoZVN0cmluZ0Z1bmN0aW9uID0gKGZuKSA9PiB7XG4gIGNvbnN0IGNhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoc3RyKSA9PiB7XG4gICAgY29uc3QgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSk7XG4gIH07XG59O1xuY29uc3QgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbmNvbnN0IGNhbWVsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbihcbiAgKHN0cikgPT4ge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCAoXywgYykgPT4gYyA/IGMudG9VcHBlckNhc2UoKSA6IFwiXCIpO1xuICB9XG4pO1xuY29uc3QgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xuY29uc3QgaHlwaGVuYXRlID0gY2FjaGVTdHJpbmdGdW5jdGlvbihcbiAgKHN0cikgPT4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKClcbik7XG5jb25zdCBjYXBpdGFsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59KTtcbmNvbnN0IHRvSGFuZGxlcktleSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oXG4gIChzdHIpID0+IHtcbiAgICBjb25zdCBzID0gc3RyID8gYG9uJHtjYXBpdGFsaXplKHN0cil9YCA6IGBgO1xuICAgIHJldHVybiBzO1xuICB9XG4pO1xuY29uc3QgaGFzQ2hhbmdlZCA9ICh2YWx1ZSwgb2xkVmFsdWUpID0+ICFPYmplY3QuaXModmFsdWUsIG9sZFZhbHVlKTtcbmNvbnN0IGludm9rZUFycmF5Rm5zID0gKGZucywgLi4uYXJnKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgZm5zW2ldKC4uLmFyZyk7XG4gIH1cbn07XG5jb25zdCBkZWYgPSAob2JqLCBrZXksIHZhbHVlLCB3cml0YWJsZSA9IGZhbHNlKSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZSxcbiAgICB2YWx1ZVxuICB9KTtcbn07XG5jb25zdCBsb29zZVRvTnVtYmVyID0gKHZhbCkgPT4ge1xuICBjb25zdCBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuO1xufTtcbmNvbnN0IHRvTnVtYmVyID0gKHZhbCkgPT4ge1xuICBjb25zdCBuID0gaXNTdHJpbmcodmFsKSA/IE51bWJlcih2YWwpIDogTmFOO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuO1xufTtcbmxldCBfZ2xvYmFsVGhpcztcbmNvbnN0IGdldEdsb2JhbFRoaXMgPSAoKSA9PiB7XG4gIHJldHVybiBfZ2xvYmFsVGhpcyB8fCAoX2dsb2JhbFRoaXMgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KTtcbn07XG5jb25zdCBpZGVudFJFID0gL15bXyRhLXpBLVpcXHhBMC1cXHVGRkZGXVtfJGEtekEtWjAtOVxceEEwLVxcdUZGRkZdKiQvO1xuZnVuY3Rpb24gZ2VuUHJvcHNBY2Nlc3NFeHAobmFtZSkge1xuICByZXR1cm4gaWRlbnRSRS50ZXN0KG5hbWUpID8gYF9fcHJvcHMuJHtuYW1lfWAgOiBgX19wcm9wc1ske0pTT04uc3RyaW5naWZ5KG5hbWUpfV1gO1xufVxuZnVuY3Rpb24gZ2VuQ2FjaGVLZXkoc291cmNlLCBvcHRpb25zKSB7XG4gIHJldHVybiBzb3VyY2UgKyBKU09OLnN0cmluZ2lmeShcbiAgICBvcHRpb25zLFxuICAgIChfLCB2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIiA/IHZhbC50b1N0cmluZygpIDogdmFsXG4gICk7XG59XG5cbmNvbnN0IFBhdGNoRmxhZ3MgPSB7XG4gIFwiVEVYVFwiOiAxLFxuICBcIjFcIjogXCJURVhUXCIsXG4gIFwiQ0xBU1NcIjogMixcbiAgXCIyXCI6IFwiQ0xBU1NcIixcbiAgXCJTVFlMRVwiOiA0LFxuICBcIjRcIjogXCJTVFlMRVwiLFxuICBcIlBST1BTXCI6IDgsXG4gIFwiOFwiOiBcIlBST1BTXCIsXG4gIFwiRlVMTF9QUk9QU1wiOiAxNixcbiAgXCIxNlwiOiBcIkZVTExfUFJPUFNcIixcbiAgXCJORUVEX0hZRFJBVElPTlwiOiAzMixcbiAgXCIzMlwiOiBcIk5FRURfSFlEUkFUSU9OXCIsXG4gIFwiU1RBQkxFX0ZSQUdNRU5UXCI6IDY0LFxuICBcIjY0XCI6IFwiU1RBQkxFX0ZSQUdNRU5UXCIsXG4gIFwiS0VZRURfRlJBR01FTlRcIjogMTI4LFxuICBcIjEyOFwiOiBcIktFWUVEX0ZSQUdNRU5UXCIsXG4gIFwiVU5LRVlFRF9GUkFHTUVOVFwiOiAyNTYsXG4gIFwiMjU2XCI6IFwiVU5LRVlFRF9GUkFHTUVOVFwiLFxuICBcIk5FRURfUEFUQ0hcIjogNTEyLFxuICBcIjUxMlwiOiBcIk5FRURfUEFUQ0hcIixcbiAgXCJEWU5BTUlDX1NMT1RTXCI6IDEwMjQsXG4gIFwiMTAyNFwiOiBcIkRZTkFNSUNfU0xPVFNcIixcbiAgXCJERVZfUk9PVF9GUkFHTUVOVFwiOiAyMDQ4LFxuICBcIjIwNDhcIjogXCJERVZfUk9PVF9GUkFHTUVOVFwiLFxuICBcIkNBQ0hFRFwiOiAtMSxcbiAgXCItMVwiOiBcIkNBQ0hFRFwiLFxuICBcIkJBSUxcIjogLTIsXG4gIFwiLTJcIjogXCJCQUlMXCJcbn07XG5jb25zdCBQYXRjaEZsYWdOYW1lcyA9IHtcbiAgWzFdOiBgVEVYVGAsXG4gIFsyXTogYENMQVNTYCxcbiAgWzRdOiBgU1RZTEVgLFxuICBbOF06IGBQUk9QU2AsXG4gIFsxNl06IGBGVUxMX1BST1BTYCxcbiAgWzMyXTogYE5FRURfSFlEUkFUSU9OYCxcbiAgWzY0XTogYFNUQUJMRV9GUkFHTUVOVGAsXG4gIFsxMjhdOiBgS0VZRURfRlJBR01FTlRgLFxuICBbMjU2XTogYFVOS0VZRURfRlJBR01FTlRgLFxuICBbNTEyXTogYE5FRURfUEFUQ0hgLFxuICBbMTAyNF06IGBEWU5BTUlDX1NMT1RTYCxcbiAgWzIwNDhdOiBgREVWX1JPT1RfRlJBR01FTlRgLFxuICBbLTFdOiBgSE9JU1RFRGAsXG4gIFstMl06IGBCQUlMYFxufTtcblxuY29uc3QgU2hhcGVGbGFncyA9IHtcbiAgXCJFTEVNRU5UXCI6IDEsXG4gIFwiMVwiOiBcIkVMRU1FTlRcIixcbiAgXCJGVU5DVElPTkFMX0NPTVBPTkVOVFwiOiAyLFxuICBcIjJcIjogXCJGVU5DVElPTkFMX0NPTVBPTkVOVFwiLFxuICBcIlNUQVRFRlVMX0NPTVBPTkVOVFwiOiA0LFxuICBcIjRcIjogXCJTVEFURUZVTF9DT01QT05FTlRcIixcbiAgXCJURVhUX0NISUxEUkVOXCI6IDgsXG4gIFwiOFwiOiBcIlRFWFRfQ0hJTERSRU5cIixcbiAgXCJBUlJBWV9DSElMRFJFTlwiOiAxNixcbiAgXCIxNlwiOiBcIkFSUkFZX0NISUxEUkVOXCIsXG4gIFwiU0xPVFNfQ0hJTERSRU5cIjogMzIsXG4gIFwiMzJcIjogXCJTTE9UU19DSElMRFJFTlwiLFxuICBcIlRFTEVQT1JUXCI6IDY0LFxuICBcIjY0XCI6IFwiVEVMRVBPUlRcIixcbiAgXCJTVVNQRU5TRVwiOiAxMjgsXG4gIFwiMTI4XCI6IFwiU1VTUEVOU0VcIixcbiAgXCJDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkVcIjogMjU2LFxuICBcIjI1NlwiOiBcIkNPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRVwiLFxuICBcIkNPTVBPTkVOVF9LRVBUX0FMSVZFXCI6IDUxMixcbiAgXCI1MTJcIjogXCJDT01QT05FTlRfS0VQVF9BTElWRVwiLFxuICBcIkNPTVBPTkVOVFwiOiA2LFxuICBcIjZcIjogXCJDT01QT05FTlRcIlxufTtcblxuY29uc3QgU2xvdEZsYWdzID0ge1xuICBcIlNUQUJMRVwiOiAxLFxuICBcIjFcIjogXCJTVEFCTEVcIixcbiAgXCJEWU5BTUlDXCI6IDIsXG4gIFwiMlwiOiBcIkRZTkFNSUNcIixcbiAgXCJGT1JXQVJERURcIjogMyxcbiAgXCIzXCI6IFwiRk9SV0FSREVEXCJcbn07XG5jb25zdCBzbG90RmxhZ3NUZXh0ID0ge1xuICBbMV06IFwiU1RBQkxFXCIsXG4gIFsyXTogXCJEWU5BTUlDXCIsXG4gIFszXTogXCJGT1JXQVJERURcIlxufTtcblxuY29uc3QgR0xPQkFMU19BTExPV0VEID0gXCJJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLHBhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LE1hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCxCaWdJbnQsY29uc29sZSxFcnJvcixTeW1ib2xcIjtcbmNvbnN0IGlzR2xvYmFsbHlBbGxvd2VkID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoR0xPQkFMU19BTExPV0VEKTtcbmNvbnN0IGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCA9IGlzR2xvYmFsbHlBbGxvd2VkO1xuXG5jb25zdCByYW5nZSA9IDI7XG5mdW5jdGlvbiBnZW5lcmF0ZUNvZGVGcmFtZShzb3VyY2UsIHN0YXJ0ID0gMCwgZW5kID0gc291cmNlLmxlbmd0aCkge1xuICBzdGFydCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHN0YXJ0LCBzb3VyY2UubGVuZ3RoKSk7XG4gIGVuZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGVuZCwgc291cmNlLmxlbmd0aCkpO1xuICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBcIlwiO1xuICBsZXQgbGluZXMgPSBzb3VyY2Uuc3BsaXQoLyhcXHI/XFxuKS8pO1xuICBjb25zdCBuZXdsaW5lU2VxdWVuY2VzID0gbGluZXMuZmlsdGVyKChfLCBpZHgpID0+IGlkeCAlIDIgPT09IDEpO1xuICBsaW5lcyA9IGxpbmVzLmZpbHRlcigoXywgaWR4KSA9PiBpZHggJSAyID09PSAwKTtcbiAgbGV0IGNvdW50ID0gMDtcbiAgY29uc3QgcmVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb3VudCArPSBsaW5lc1tpXS5sZW5ndGggKyAobmV3bGluZVNlcXVlbmNlc1tpXSAmJiBuZXdsaW5lU2VxdWVuY2VzW2ldLmxlbmd0aCB8fCAwKTtcbiAgICBpZiAoY291bnQgPj0gc3RhcnQpIHtcbiAgICAgIGZvciAobGV0IGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcbiAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gbGluZXMubGVuZ3RoKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgbGluZSA9IGogKyAxO1xuICAgICAgICByZXMucHVzaChcbiAgICAgICAgICBgJHtsaW5lfSR7XCIgXCIucmVwZWF0KE1hdGgubWF4KDMgLSBTdHJpbmcobGluZSkubGVuZ3RoLCAwKSl9fCAgJHtsaW5lc1tqXX1gXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSBsaW5lc1tqXS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG5ld0xpbmVTZXFMZW5ndGggPSBuZXdsaW5lU2VxdWVuY2VzW2pdICYmIG5ld2xpbmVTZXF1ZW5jZXNbal0ubGVuZ3RoIHx8IDA7XG4gICAgICAgIGlmIChqID09PSBpKSB7XG4gICAgICAgICAgY29uc3QgcGFkID0gc3RhcnQgLSAoY291bnQgLSAobGluZUxlbmd0aCArIG5ld0xpbmVTZXFMZW5ndGgpKTtcbiAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICBlbmQgPiBjb3VudCA/IGxpbmVMZW5ndGggLSBwYWQgOiBlbmQgLSBzdGFydFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyBcIiBcIi5yZXBlYXQocGFkKSArIFwiXlwiLnJlcGVhdChsZW5ndGgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChqID4gaSkge1xuICAgICAgICAgIGlmIChlbmQgPiBjb3VudCkge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5taW4oZW5kIC0gY291bnQsIGxpbmVMZW5ndGgpLCAxKTtcbiAgICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgXCJeXCIucmVwZWF0KGxlbmd0aCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXMuam9pbihcIlxcblwiKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGUodmFsdWUpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IHZhbHVlW2ldO1xuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGlzU3RyaW5nKGl0ZW0pID8gcGFyc2VTdHJpbmdTdHlsZShpdGVtKSA6IG5vcm1hbGl6ZVN0eWxlKGl0ZW0pO1xuICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbm9ybWFsaXplZCkge1xuICAgICAgICAgIHJlc1trZXldID0gbm9ybWFsaXplZFtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmcodmFsdWUpIHx8IGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuY29uc3QgbGlzdERlbGltaXRlclJFID0gLzsoPyFbXihdKlxcKSkvZztcbmNvbnN0IHByb3BlcnR5RGVsaW1pdGVyUkUgPSAvOihbXl0rKS87XG5jb25zdCBzdHlsZUNvbW1lbnRSRSA9IC9cXC9cXCpbXl0qP1xcKlxcLy9nO1xuZnVuY3Rpb24gcGFyc2VTdHJpbmdTdHlsZShjc3NUZXh0KSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBjc3NUZXh0LnJlcGxhY2Uoc3R5bGVDb21tZW50UkUsIFwiXCIpLnNwbGl0KGxpc3REZWxpbWl0ZXJSRSkuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICBjb25zdCB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyUkUpO1xuICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJldFt0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlTdHlsZShzdHlsZXMpIHtcbiAgaWYgKCFzdHlsZXMpIHJldHVybiBcIlwiO1xuICBpZiAoaXNTdHJpbmcoc3R5bGVzKSkgcmV0dXJuIHN0eWxlcztcbiAgbGV0IHJldCA9IFwiXCI7XG4gIGZvciAoY29uc3Qga2V5IGluIHN0eWxlcykge1xuICAgIGNvbnN0IHZhbHVlID0gc3R5bGVzW2tleV07XG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBrZXkuc3RhcnRzV2l0aChgLS1gKSA/IGtleSA6IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgcmV0ICs9IGAke25vcm1hbGl6ZWRLZXl9OiR7dmFsdWV9O2A7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDbGFzcyh2YWx1ZSkge1xuICBsZXQgcmVzID0gXCJcIjtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHJlcyA9IHZhbHVlO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZUNsYXNzKHZhbHVlW2ldKTtcbiAgICAgIGlmIChub3JtYWxpemVkKSB7XG4gICAgICAgIHJlcyArPSBub3JtYWxpemVkICsgXCIgXCI7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlW25hbWVdKSB7XG4gICAgICAgIHJlcyArPSBuYW1lICsgXCIgXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXMudHJpbSgpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMocHJvcHMpIHtcbiAgaWYgKCFwcm9wcykgcmV0dXJuIG51bGw7XG4gIGxldCB7IGNsYXNzOiBrbGFzcywgc3R5bGUgfSA9IHByb3BzO1xuICBpZiAoa2xhc3MgJiYgIWlzU3RyaW5nKGtsYXNzKSkge1xuICAgIHByb3BzLmNsYXNzID0gbm9ybWFsaXplQ2xhc3Moa2xhc3MpO1xuICB9XG4gIGlmIChzdHlsZSkge1xuICAgIHByb3BzLnN0eWxlID0gbm9ybWFsaXplU3R5bGUoc3R5bGUpO1xuICB9XG4gIHJldHVybiBwcm9wcztcbn1cblxuY29uc3QgSFRNTF9UQUdTID0gXCJodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSxhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoZ3JvdXAsaDEsaDIsaDMsaDQsaDUsaDYsbmF2LHNlY3Rpb24sZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ1YnkscyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbixvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLGRldGFpbHMsZGlhbG9nLG1lbnUsc3VtbWFyeSx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdFwiO1xuY29uc3QgU1ZHX1RBR1MgPSBcInN2ZyxhbmltYXRlLGFuaW1hdGVNb3Rpb24sYW5pbWF0ZVRyYW5zZm9ybSxjaXJjbGUsY2xpcFBhdGgsY29sb3ItcHJvZmlsZSxkZWZzLGRlc2MsZGlzY2FyZCxlbGxpcHNlLGZlQmxlbmQsZmVDb2xvck1hdHJpeCxmZUNvbXBvbmVudFRyYW5zZmVyLGZlQ29tcG9zaXRlLGZlQ29udm9sdmVNYXRyaXgsZmVEaWZmdXNlTGlnaHRpbmcsZmVEaXNwbGFjZW1lbnRNYXAsZmVEaXN0YW50TGlnaHQsZmVEcm9wU2hhZG93LGZlRmxvb2QsZmVGdW5jQSxmZUZ1bmNCLGZlRnVuY0csZmVGdW5jUixmZUdhdXNzaWFuQmx1cixmZUltYWdlLGZlTWVyZ2UsZmVNZXJnZU5vZGUsZmVNb3JwaG9sb2d5LGZlT2Zmc2V0LGZlUG9pbnRMaWdodCxmZVNwZWN1bGFyTGlnaHRpbmcsZmVTcG90TGlnaHQsZmVUaWxlLGZlVHVyYnVsZW5jZSxmaWx0ZXIsZm9yZWlnbk9iamVjdCxnLGhhdGNoLGhhdGNocGF0aCxpbWFnZSxsaW5lLGxpbmVhckdyYWRpZW50LG1hcmtlcixtYXNrLG1lc2gsbWVzaGdyYWRpZW50LG1lc2hwYXRjaCxtZXNocm93LG1ldGFkYXRhLG1wYXRoLHBhdGgscGF0dGVybixwb2x5Z29uLHBvbHlsaW5lLHJhZGlhbEdyYWRpZW50LHJlY3Qsc2V0LHNvbGlkY29sb3Isc3RvcCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dFBhdGgsdGl0bGUsdHNwYW4sdW5rbm93bix1c2Usdmlld1wiO1xuY29uc3QgTUFUSF9UQUdTID0gXCJhbm5vdGF0aW9uLGFubm90YXRpb24teG1sLG1hY3Rpb24sbWFsaWduZ3JvdXAsbWFsaWdubWFyayxtYXRoLG1lbmNsb3NlLG1lcnJvcixtZmVuY2VkLG1mcmFjLG1mcmFjdGlvbixtZ2x5cGgsbWksbWxhYmVsZWR0cixtbG9uZ2RpdixtbXVsdGlzY3JpcHRzLG1uLG1vLG1vdmVyLG1wYWRkZWQsbXBoYW50b20sbXByZXNjcmlwdHMsbXJvb3QsbXJvdyxtcyxtc2NhcnJpZXMsbXNjYXJyeSxtc2dyb3VwLG1zbGluZSxtc3BhY2UsbXNxcnQsbXNyb3csbXN0YWNrLG1zdHlsZSxtc3ViLG1zdWJzdXAsbXN1cCxtdGFibGUsbXRkLG10ZXh0LG10cixtdW5kZXIsbXVuZGVyb3Zlcixub25lLHNlbWFudGljc1wiO1xuY29uc3QgVk9JRF9UQUdTID0gXCJhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGhyLGltZyxpbnB1dCxsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdiclwiO1xuY29uc3QgaXNIVE1MVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoSFRNTF9UQUdTKTtcbmNvbnN0IGlzU1ZHVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoU1ZHX1RBR1MpO1xuY29uc3QgaXNNYXRoTUxUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChNQVRIX1RBR1MpO1xuY29uc3QgaXNWb2lkVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoVk9JRF9UQUdTKTtcblxuY29uc3Qgc3BlY2lhbEJvb2xlYW5BdHRycyA9IGBpdGVtc2NvcGUsYWxsb3dmdWxsc2NyZWVuLGZvcm1ub3ZhbGlkYXRlLGlzbWFwLG5vbW9kdWxlLG5vdmFsaWRhdGUscmVhZG9ubHlgO1xuY29uc3QgaXNTcGVjaWFsQm9vbGVhbkF0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChzcGVjaWFsQm9vbGVhbkF0dHJzKTtcbmNvbnN0IGlzQm9vbGVhbkF0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgc3BlY2lhbEJvb2xlYW5BdHRycyArIGAsYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNvbnRyb2xzLGRlZmF1bHQsZGVmZXIsZGlzYWJsZWQsaGlkZGVuLGluZXJ0LGxvb3Asb3BlbixyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3MsY2hlY2tlZCxtdXRlZCxtdWx0aXBsZSxzZWxlY3RlZGBcbik7XG5mdW5jdGlvbiBpbmNsdWRlQm9vbGVhbkF0dHIodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgfHwgdmFsdWUgPT09IFwiXCI7XG59XG5jb25zdCB1bnNhZmVBdHRyQ2hhclJFID0gL1s+Lz1cIidcXHUwMDA5XFx1MDAwYVxcdTAwMGNcXHUwMDIwXS87XG5jb25zdCBhdHRyVmFsaWRhdGlvbkNhY2hlID0ge307XG5mdW5jdGlvbiBpc1NTUlNhZmVBdHRyTmFtZShuYW1lKSB7XG4gIGlmIChhdHRyVmFsaWRhdGlvbkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgcmV0dXJuIGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV07XG4gIH1cbiAgY29uc3QgaXNVbnNhZmUgPSB1bnNhZmVBdHRyQ2hhclJFLnRlc3QobmFtZSk7XG4gIGlmIChpc1Vuc2FmZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoYHVuc2FmZSBhdHRyaWJ1dGUgbmFtZTogJHtuYW1lfWApO1xuICB9XG4gIHJldHVybiBhdHRyVmFsaWRhdGlvbkNhY2hlW25hbWVdID0gIWlzVW5zYWZlO1xufVxuY29uc3QgcHJvcHNUb0F0dHJNYXAgPSB7XG4gIGFjY2VwdENoYXJzZXQ6IFwiYWNjZXB0LWNoYXJzZXRcIixcbiAgY2xhc3NOYW1lOiBcImNsYXNzXCIsXG4gIGh0bWxGb3I6IFwiZm9yXCIsXG4gIGh0dHBFcXVpdjogXCJodHRwLWVxdWl2XCJcbn07XG5jb25zdCBpc0tub3duSHRtbEF0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgYGFjY2VwdCxhY2NlcHQtY2hhcnNldCxhY2Nlc3NrZXksYWN0aW9uLGFsaWduLGFsbG93LGFsdCxhc3luYyxhdXRvY2FwaXRhbGl6ZSxhdXRvY29tcGxldGUsYXV0b2ZvY3VzLGF1dG9wbGF5LGJhY2tncm91bmQsYmdjb2xvcixib3JkZXIsYnVmZmVyZWQsY2FwdHVyZSxjaGFsbGVuZ2UsY2hhcnNldCxjaGVja2VkLGNpdGUsY2xhc3MsY29kZSxjb2RlYmFzZSxjb2xvcixjb2xzLGNvbHNwYW4sY29udGVudCxjb250ZW50ZWRpdGFibGUsY29udGV4dG1lbnUsY29udHJvbHMsY29vcmRzLGNyb3Nzb3JpZ2luLGNzcCxkYXRhLGRhdGV0aW1lLGRlY29kaW5nLGRlZmF1bHQsZGVmZXIsZGlyLGRpcm5hbWUsZGlzYWJsZWQsZG93bmxvYWQsZHJhZ2dhYmxlLGRyb3B6b25lLGVuY3R5cGUsZW50ZXJrZXloaW50LGZvcixmb3JtLGZvcm1hY3Rpb24sZm9ybWVuY3R5cGUsZm9ybW1ldGhvZCxmb3Jtbm92YWxpZGF0ZSxmb3JtdGFyZ2V0LGhlYWRlcnMsaGVpZ2h0LGhpZGRlbixoaWdoLGhyZWYsaHJlZmxhbmcsaHR0cC1lcXVpdixpY29uLGlkLGltcG9ydGFuY2UsaW5lcnQsaW50ZWdyaXR5LGlzbWFwLGl0ZW1wcm9wLGtleXR5cGUsa2luZCxsYWJlbCxsYW5nLGxhbmd1YWdlLGxvYWRpbmcsbGlzdCxsb29wLGxvdyxtYW5pZmVzdCxtYXgsbWF4bGVuZ3RoLG1pbmxlbmd0aCxtZWRpYSxtaW4sbXVsdGlwbGUsbXV0ZWQsbmFtZSxub3ZhbGlkYXRlLG9wZW4sb3B0aW11bSxwYXR0ZXJuLHBpbmcscGxhY2Vob2xkZXIscG9zdGVyLHByZWxvYWQscmFkaW9ncm91cCxyZWFkb25seSxyZWZlcnJlcnBvbGljeSxyZWwscmVxdWlyZWQscmV2ZXJzZWQscm93cyxyb3dzcGFuLHNhbmRib3gsc2NvcGUsc2NvcGVkLHNlbGVjdGVkLHNoYXBlLHNpemUsc2l6ZXMsc2xvdCxzcGFuLHNwZWxsY2hlY2ssc3JjLHNyY2RvYyxzcmNsYW5nLHNyY3NldCxzdGFydCxzdGVwLHN0eWxlLHN1bW1hcnksdGFiaW5kZXgsdGFyZ2V0LHRpdGxlLHRyYW5zbGF0ZSx0eXBlLHVzZW1hcCx2YWx1ZSx3aWR0aCx3cmFwYFxuKTtcbmNvbnN0IGlzS25vd25TdmdBdHRyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIGB4bWxucyxhY2NlbnQtaGVpZ2h0LGFjY3VtdWxhdGUsYWRkaXRpdmUsYWxpZ25tZW50LWJhc2VsaW5lLGFscGhhYmV0aWMsYW1wbGl0dWRlLGFyYWJpYy1mb3JtLGFzY2VudCxhdHRyaWJ1dGVOYW1lLGF0dHJpYnV0ZVR5cGUsYXppbXV0aCxiYXNlRnJlcXVlbmN5LGJhc2VsaW5lLXNoaWZ0LGJhc2VQcm9maWxlLGJib3gsYmVnaW4sYmlhcyxieSxjYWxjTW9kZSxjYXAtaGVpZ2h0LGNsYXNzLGNsaXAsY2xpcFBhdGhVbml0cyxjbGlwLXBhdGgsY2xpcC1ydWxlLGNvbG9yLGNvbG9yLWludGVycG9sYXRpb24sY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzLGNvbG9yLXByb2ZpbGUsY29sb3ItcmVuZGVyaW5nLGNvbnRlbnRTY3JpcHRUeXBlLGNvbnRlbnRTdHlsZVR5cGUsY3Jvc3NvcmlnaW4sY3Vyc29yLGN4LGN5LGQsZGVjZWxlcmF0ZSxkZXNjZW50LGRpZmZ1c2VDb25zdGFudCxkaXJlY3Rpb24sZGlzcGxheSxkaXZpc29yLGRvbWluYW50LWJhc2VsaW5lLGR1cixkeCxkeSxlZGdlTW9kZSxlbGV2YXRpb24sZW5hYmxlLWJhY2tncm91bmQsZW5kLGV4cG9uZW50LGZpbGwsZmlsbC1vcGFjaXR5LGZpbGwtcnVsZSxmaWx0ZXIsZmlsdGVyUmVzLGZpbHRlclVuaXRzLGZsb29kLWNvbG9yLGZsb29kLW9wYWNpdHksZm9udC1mYW1pbHksZm9udC1zaXplLGZvbnQtc2l6ZS1hZGp1c3QsZm9udC1zdHJldGNoLGZvbnQtc3R5bGUsZm9udC12YXJpYW50LGZvbnQtd2VpZ2h0LGZvcm1hdCxmcm9tLGZyLGZ4LGZ5LGcxLGcyLGdseXBoLW5hbWUsZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCxnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCxnbHlwaFJlZixncmFkaWVudFRyYW5zZm9ybSxncmFkaWVudFVuaXRzLGhhbmdpbmcsaGVpZ2h0LGhyZWYsaHJlZmxhbmcsaG9yaXotYWR2LXgsaG9yaXotb3JpZ2luLXgsaWQsaWRlb2dyYXBoaWMsaW1hZ2UtcmVuZGVyaW5nLGluLGluMixpbnRlcmNlcHQsayxrMSxrMixrMyxrNCxrZXJuZWxNYXRyaXgsa2VybmVsVW5pdExlbmd0aCxrZXJuaW5nLGtleVBvaW50cyxrZXlTcGxpbmVzLGtleVRpbWVzLGxhbmcsbGVuZ3RoQWRqdXN0LGxldHRlci1zcGFjaW5nLGxpZ2h0aW5nLWNvbG9yLGxpbWl0aW5nQ29uZUFuZ2xlLGxvY2FsLG1hcmtlci1lbmQsbWFya2VyLW1pZCxtYXJrZXItc3RhcnQsbWFya2VySGVpZ2h0LG1hcmtlclVuaXRzLG1hcmtlcldpZHRoLG1hc2ssbWFza0NvbnRlbnRVbml0cyxtYXNrVW5pdHMsbWF0aGVtYXRpY2FsLG1heCxtZWRpYSxtZXRob2QsbWluLG1vZGUsbmFtZSxudW1PY3RhdmVzLG9mZnNldCxvcGFjaXR5LG9wZXJhdG9yLG9yZGVyLG9yaWVudCxvcmllbnRhdGlvbixvcmlnaW4sb3ZlcmZsb3csb3ZlcmxpbmUtcG9zaXRpb24sb3ZlcmxpbmUtdGhpY2tuZXNzLHBhbm9zZS0xLHBhaW50LW9yZGVyLHBhdGgscGF0aExlbmd0aCxwYXR0ZXJuQ29udGVudFVuaXRzLHBhdHRlcm5UcmFuc2Zvcm0scGF0dGVyblVuaXRzLHBpbmcscG9pbnRlci1ldmVudHMscG9pbnRzLHBvaW50c0F0WCxwb2ludHNBdFkscG9pbnRzQXRaLHByZXNlcnZlQWxwaGEscHJlc2VydmVBc3BlY3RSYXRpbyxwcmltaXRpdmVVbml0cyxyLHJhZGl1cyxyZWZlcnJlclBvbGljeSxyZWZYLHJlZlkscmVsLHJlbmRlcmluZy1pbnRlbnQscmVwZWF0Q291bnQscmVwZWF0RHVyLHJlcXVpcmVkRXh0ZW5zaW9ucyxyZXF1aXJlZEZlYXR1cmVzLHJlc3RhcnQscmVzdWx0LHJvdGF0ZSxyeCxyeSxzY2FsZSxzZWVkLHNoYXBlLXJlbmRlcmluZyxzbG9wZSxzcGFjaW5nLHNwZWN1bGFyQ29uc3RhbnQsc3BlY3VsYXJFeHBvbmVudCxzcGVlZCxzcHJlYWRNZXRob2Qsc3RhcnRPZmZzZXQsc3RkRGV2aWF0aW9uLHN0ZW1oLHN0ZW12LHN0aXRjaFRpbGVzLHN0b3AtY29sb3Isc3RvcC1vcGFjaXR5LHN0cmlrZXRocm91Z2gtcG9zaXRpb24sc3RyaWtldGhyb3VnaC10aGlja25lc3Msc3RyaW5nLHN0cm9rZSxzdHJva2UtZGFzaGFycmF5LHN0cm9rZS1kYXNob2Zmc2V0LHN0cm9rZS1saW5lY2FwLHN0cm9rZS1saW5lam9pbixzdHJva2UtbWl0ZXJsaW1pdCxzdHJva2Utb3BhY2l0eSxzdHJva2Utd2lkdGgsc3R5bGUsc3VyZmFjZVNjYWxlLHN5c3RlbUxhbmd1YWdlLHRhYmluZGV4LHRhYmxlVmFsdWVzLHRhcmdldCx0YXJnZXRYLHRhcmdldFksdGV4dC1hbmNob3IsdGV4dC1kZWNvcmF0aW9uLHRleHQtcmVuZGVyaW5nLHRleHRMZW5ndGgsdG8sdHJhbnNmb3JtLHRyYW5zZm9ybS1vcmlnaW4sdHlwZSx1MSx1Mix1bmRlcmxpbmUtcG9zaXRpb24sdW5kZXJsaW5lLXRoaWNrbmVzcyx1bmljb2RlLHVuaWNvZGUtYmlkaSx1bmljb2RlLXJhbmdlLHVuaXRzLXBlci1lbSx2LWFscGhhYmV0aWMsdi1oYW5naW5nLHYtaWRlb2dyYXBoaWMsdi1tYXRoZW1hdGljYWwsdmFsdWVzLHZlY3Rvci1lZmZlY3QsdmVyc2lvbix2ZXJ0LWFkdi15LHZlcnQtb3JpZ2luLXgsdmVydC1vcmlnaW4teSx2aWV3Qm94LHZpZXdUYXJnZXQsdmlzaWJpbGl0eSx3aWR0aCx3aWR0aHMsd29yZC1zcGFjaW5nLHdyaXRpbmctbW9kZSx4LHgtaGVpZ2h0LHgxLHgyLHhDaGFubmVsU2VsZWN0b3IseGxpbms6YWN0dWF0ZSx4bGluazphcmNyb2xlLHhsaW5rOmhyZWYseGxpbms6cm9sZSx4bGluazpzaG93LHhsaW5rOnRpdGxlLHhsaW5rOnR5cGUseG1sbnM6eGxpbmsseG1sOmJhc2UseG1sOmxhbmcseG1sOnNwYWNlLHkseTEseTIseUNoYW5uZWxTZWxlY3Rvcix6LHpvb21BbmRQYW5gXG4pO1xuY29uc3QgaXNLbm93bk1hdGhNTEF0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgYGFjY2VudCxhY2NlbnR1bmRlcixhY3Rpb250eXBlLGFsaWduLGFsaWdubWVudHNjb3BlLGFsdGltZyxhbHRpbWctaGVpZ2h0LGFsdGltZy12YWxpZ24sYWx0aW1nLXdpZHRoLGFsdHRleHQsYmV2ZWxsZWQsY2xvc2UsY29sdW1uc2FsaWduLGNvbHVtbmxpbmVzLGNvbHVtbnNwYW4sZGVub21hbGlnbixkZXB0aCxkaXIsZGlzcGxheSxkaXNwbGF5c3R5bGUsZW5jb2RpbmcsZXF1YWxjb2x1bW5zLGVxdWFscm93cyxmZW5jZSxmb250c3R5bGUsZm9udHdlaWdodCxmb3JtLGZyYW1lLGZyYW1lc3BhY2luZyxncm91cGFsaWduLGhlaWdodCxocmVmLGlkLGluZGVudGFsaWduLGluZGVudGFsaWduZmlyc3QsaW5kZW50YWxpZ25sYXN0LGluZGVudHNoaWZ0LGluZGVudHNoaWZ0Zmlyc3QsaW5kZW50c2hpZnRsYXN0LGluZGV4dHlwZSxqdXN0aWZ5LGxhcmdldG9wLGxhcmdlb3AsbHF1b3RlLGxzcGFjZSxtYXRoYmFja2dyb3VuZCxtYXRoY29sb3IsbWF0aHNpemUsbWF0aHZhcmlhbnQsbWF4c2l6ZSxtaW5sYWJlbHNwYWNpbmcsbW9kZSxvdGhlcixvdmVyZmxvdyxwb3NpdGlvbixyb3dhbGlnbixyb3dsaW5lcyxyb3dzcGFuLHJxdW90ZSxyc3BhY2Usc2NyaXB0bGV2ZWwsc2NyaXB0bWluc2l6ZSxzY3JpcHRzaXplbXVsdGlwbGllcixzZWxlY3Rpb24sc2VwYXJhdG9yLHNlcGFyYXRvcnMsc2hpZnQsc2lkZSxzcmMsc3RhY2thbGlnbixzdHJldGNoeSxzdWJzY3JpcHRzaGlmdCxzdXBlcnNjcmlwdHNoaWZ0LHN5bW1ldHJpYyx2b2Zmc2V0LHdpZHRoLHdpZHRocyx4bGluazpocmVmLHhsaW5rOnNob3cseGxpbms6dHlwZSx4bWxuc2Bcbik7XG5mdW5jdGlvbiBpc1JlbmRlcmFibGVBdHRyVmFsdWUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHR5cGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIjtcbn1cblxuY29uc3QgZXNjYXBlUkUgPSAvW1wiJyY8Pl0vO1xuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHJpbmcpIHtcbiAgY29uc3Qgc3RyID0gXCJcIiArIHN0cmluZztcbiAgY29uc3QgbWF0Y2ggPSBlc2NhcGVSRS5leGVjKHN0cik7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGxldCBodG1sID0gXCJcIjtcbiAgbGV0IGVzY2FwZWQ7XG4gIGxldCBpbmRleDtcbiAgbGV0IGxhc3RJbmRleCA9IDA7XG4gIGZvciAoaW5kZXggPSBtYXRjaC5pbmRleDsgaW5kZXggPCBzdHIubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgc3dpdGNoIChzdHIuY2hhckNvZGVBdChpbmRleCkpIHtcbiAgICAgIGNhc2UgMzQ6XG4gICAgICAgIGVzY2FwZWQgPSBcIiZxdW90O1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzg6XG4gICAgICAgIGVzY2FwZWQgPSBcIiZhbXA7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOTpcbiAgICAgICAgZXNjYXBlZCA9IFwiJiMzOTtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDYwOlxuICAgICAgICBlc2NhcGVkID0gXCImbHQ7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MjpcbiAgICAgICAgZXNjYXBlZCA9IFwiJmd0O1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobGFzdEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgaHRtbCArPSBzdHIuc2xpY2UobGFzdEluZGV4LCBpbmRleCk7XG4gICAgfVxuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcbiAgICBodG1sICs9IGVzY2FwZWQ7XG4gIH1cbiAgcmV0dXJuIGxhc3RJbmRleCAhPT0gaW5kZXggPyBodG1sICsgc3RyLnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbn1cbmNvbnN0IGNvbW1lbnRTdHJpcFJFID0gL14tPz58PCEtLXwtLT58LS0hPnw8IS0kL2c7XG5mdW5jdGlvbiBlc2NhcGVIdG1sQ29tbWVudChzcmMpIHtcbiAgcmV0dXJuIHNyYy5yZXBsYWNlKGNvbW1lbnRTdHJpcFJFLCBcIlwiKTtcbn1cbmNvbnN0IGNzc1Zhck5hbWVFc2NhcGVTeW1ib2xzUkUgPSAvWyAhXCIjJCUmJygpKissLi86Ozw9Pj9AW1xcXFxcXF1eYHt8fX5dL2c7XG5mdW5jdGlvbiBnZXRFc2NhcGVkQ3NzVmFyTmFtZShrZXksIGRvdWJsZUVzY2FwZSkge1xuICByZXR1cm4ga2V5LnJlcGxhY2UoXG4gICAgY3NzVmFyTmFtZUVzY2FwZVN5bWJvbHNSRSxcbiAgICAocykgPT4gZG91YmxlRXNjYXBlID8gcyA9PT0gJ1wiJyA/ICdcXFxcXFxcXFxcXFxcIicgOiBgXFxcXFxcXFwke3N9YCA6IGBcXFxcJHtzfWBcbiAgKTtcbn1cblxuZnVuY3Rpb24gbG9vc2VDb21wYXJlQXJyYXlzKGEsIGIpIHtcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICBsZXQgZXF1YWwgPSB0cnVlO1xuICBmb3IgKGxldCBpID0gMDsgZXF1YWwgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBlcXVhbCA9IGxvb3NlRXF1YWwoYVtpXSwgYltpXSk7XG4gIH1cbiAgcmV0dXJuIGVxdWFsO1xufVxuZnVuY3Rpb24gbG9vc2VFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgbGV0IGFWYWxpZFR5cGUgPSBpc0RhdGUoYSk7XG4gIGxldCBiVmFsaWRUeXBlID0gaXNEYXRlKGIpO1xuICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKSA6IGZhbHNlO1xuICB9XG4gIGFWYWxpZFR5cGUgPSBpc1N5bWJvbChhKTtcbiAgYlZhbGlkVHlwZSA9IGlzU3ltYm9sKGIpO1xuICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIH1cbiAgYVZhbGlkVHlwZSA9IGlzQXJyYXkoYSk7XG4gIGJWYWxpZFR5cGUgPSBpc0FycmF5KGIpO1xuICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSA6IGZhbHNlO1xuICB9XG4gIGFWYWxpZFR5cGUgPSBpc09iamVjdChhKTtcbiAgYlZhbGlkVHlwZSA9IGlzT2JqZWN0KGIpO1xuICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgaWYgKCFhVmFsaWRUeXBlIHx8ICFiVmFsaWRUeXBlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhhKS5sZW5ndGg7XG4gICAgY29uc3QgYktleXNDb3VudCA9IE9iamVjdC5rZXlzKGIpLmxlbmd0aDtcbiAgICBpZiAoYUtleXNDb3VudCAhPT0gYktleXNDb3VudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhKSB7XG4gICAgICBjb25zdCBhSGFzS2V5ID0gYS5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgICAgY29uc3QgYkhhc0tleSA9IGIuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICAgIGlmIChhSGFzS2V5ICYmICFiSGFzS2V5IHx8ICFhSGFzS2V5ICYmIGJIYXNLZXkgfHwgIWxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpO1xufVxuZnVuY3Rpb24gbG9vc2VJbmRleE9mKGFyciwgdmFsKSB7XG4gIHJldHVybiBhcnIuZmluZEluZGV4KChpdGVtKSA9PiBsb29zZUVxdWFsKGl0ZW0sIHZhbCkpO1xufVxuXG5jb25zdCBpc1JlZiA9ICh2YWwpID0+IHtcbiAgcmV0dXJuICEhKHZhbCAmJiB2YWxbXCJfX3ZfaXNSZWZcIl0gPT09IHRydWUpO1xufTtcbmNvbnN0IHRvRGlzcGxheVN0cmluZyA9ICh2YWwpID0+IHtcbiAgcmV0dXJuIGlzU3RyaW5nKHZhbCkgPyB2YWwgOiB2YWwgPT0gbnVsbCA/IFwiXCIgOiBpc0FycmF5KHZhbCkgfHwgaXNPYmplY3QodmFsKSAmJiAodmFsLnRvU3RyaW5nID09PSBvYmplY3RUb1N0cmluZyB8fCAhaXNGdW5jdGlvbih2YWwudG9TdHJpbmcpKSA/IGlzUmVmKHZhbCkgPyB0b0Rpc3BsYXlTdHJpbmcodmFsLnZhbHVlKSA6IEpTT04uc3RyaW5naWZ5KHZhbCwgcmVwbGFjZXIsIDIpIDogU3RyaW5nKHZhbCk7XG59O1xuY29uc3QgcmVwbGFjZXIgPSAoX2tleSwgdmFsKSA9PiB7XG4gIGlmIChpc1JlZih2YWwpKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VyKF9rZXksIHZhbC52YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNNYXAodmFsKSkge1xuICAgIHJldHVybiB7XG4gICAgICBbYE1hcCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC5lbnRyaWVzKCldLnJlZHVjZShcbiAgICAgICAgKGVudHJpZXMsIFtrZXksIHZhbDJdLCBpKSA9PiB7XG4gICAgICAgICAgZW50cmllc1tzdHJpbmdpZnlTeW1ib2woa2V5LCBpKSArIFwiID0+XCJdID0gdmFsMjtcbiAgICAgICAgICByZXR1cm4gZW50cmllcztcbiAgICAgICAgfSxcbiAgICAgICAge31cbiAgICAgIClcbiAgICB9O1xuICB9IGVsc2UgaWYgKGlzU2V0KHZhbCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgW2BTZXQoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwudmFsdWVzKCldLm1hcCgodikgPT4gc3RyaW5naWZ5U3ltYm9sKHYpKVxuICAgIH07XG4gIH0gZWxzZSBpZiAoaXNTeW1ib2wodmFsKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlTeW1ib2wodmFsKTtcbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpICYmICFpc0FycmF5KHZhbCkgJiYgIWlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgIHJldHVybiBTdHJpbmcodmFsKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcbmNvbnN0IHN0cmluZ2lmeVN5bWJvbCA9ICh2LCBpID0gXCJcIikgPT4ge1xuICB2YXIgX2E7XG4gIHJldHVybiAoXG4gICAgLy8gU3ltYm9sLmRlc2NyaXB0aW9uIGluIGVzMjAxOSsgc28gd2UgbmVlZCB0byBjYXN0IGhlcmUgdG8gcGFzc1xuICAgIC8vIHRoZSBsaWI6IGVzMjAxNiBjaGVja1xuICAgIGlzU3ltYm9sKHYpID8gYFN5bWJvbCgkeyhfYSA9IHYuZGVzY3JpcHRpb24pICE9IG51bGwgPyBfYSA6IGl9KWAgOiB2XG4gICk7XG59O1xuXG5leHBvcnQgeyBFTVBUWV9BUlIsIEVNUFRZX09CSiwgTk8sIE5PT1AsIFBhdGNoRmxhZ05hbWVzLCBQYXRjaEZsYWdzLCBTaGFwZUZsYWdzLCBTbG90RmxhZ3MsIGNhbWVsaXplLCBjYXBpdGFsaXplLCBjc3NWYXJOYW1lRXNjYXBlU3ltYm9sc1JFLCBkZWYsIGVzY2FwZUh0bWwsIGVzY2FwZUh0bWxDb21tZW50LCBleHRlbmQsIGdlbkNhY2hlS2V5LCBnZW5Qcm9wc0FjY2Vzc0V4cCwgZ2VuZXJhdGVDb2RlRnJhbWUsIGdldEVzY2FwZWRDc3NWYXJOYW1lLCBnZXRHbG9iYWxUaGlzLCBoYXNDaGFuZ2VkLCBoYXNPd24sIGh5cGhlbmF0ZSwgaW5jbHVkZUJvb2xlYW5BdHRyLCBpbnZva2VBcnJheUZucywgaXNBcnJheSwgaXNCb29sZWFuQXR0ciwgaXNCdWlsdEluRGlyZWN0aXZlLCBpc0RhdGUsIGlzRnVuY3Rpb24sIGlzR2xvYmFsbHlBbGxvd2VkLCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQsIGlzSFRNTFRhZywgaXNJbnRlZ2VyS2V5LCBpc0tub3duSHRtbEF0dHIsIGlzS25vd25NYXRoTUxBdHRyLCBpc0tub3duU3ZnQXR0ciwgaXNNYXAsIGlzTWF0aE1MVGFnLCBpc01vZGVsTGlzdGVuZXIsIGlzT2JqZWN0LCBpc09uLCBpc1BsYWluT2JqZWN0LCBpc1Byb21pc2UsIGlzUmVnRXhwLCBpc1JlbmRlcmFibGVBdHRyVmFsdWUsIGlzUmVzZXJ2ZWRQcm9wLCBpc1NTUlNhZmVBdHRyTmFtZSwgaXNTVkdUYWcsIGlzU2V0LCBpc1NwZWNpYWxCb29sZWFuQXR0ciwgaXNTdHJpbmcsIGlzU3ltYm9sLCBpc1ZvaWRUYWcsIGxvb3NlRXF1YWwsIGxvb3NlSW5kZXhPZiwgbG9vc2VUb051bWJlciwgbWFrZU1hcCwgbm9ybWFsaXplQ2xhc3MsIG5vcm1hbGl6ZVByb3BzLCBub3JtYWxpemVTdHlsZSwgb2JqZWN0VG9TdHJpbmcsIHBhcnNlU3RyaW5nU3R5bGUsIHByb3BzVG9BdHRyTWFwLCByZW1vdmUsIHNsb3RGbGFnc1RleHQsIHN0cmluZ2lmeVN0eWxlLCB0b0Rpc3BsYXlTdHJpbmcsIHRvSGFuZGxlcktleSwgdG9OdW1iZXIsIHRvUmF3VHlwZSwgdG9UeXBlU3RyaW5nIH07XG4iLCIvKipcbiogQHZ1ZS9yZWFjdGl2aXR5IHYzLjUuMTNcbiogKGMpIDIwMTgtcHJlc2VudCBZdXhpIChFdmFuKSBZb3UgYW5kIFZ1ZSBjb250cmlidXRvcnNcbiogQGxpY2Vuc2UgTUlUXG4qKi9cbmltcG9ydCB7IGhhc0NoYW5nZWQsIGV4dGVuZCwgaXNBcnJheSwgaXNJbnRlZ2VyS2V5LCBpc1N5bWJvbCwgaXNNYXAsIGhhc093biwgaXNPYmplY3QsIG1ha2VNYXAsIHRvUmF3VHlwZSwgY2FwaXRhbGl6ZSwgZGVmLCBpc0Z1bmN0aW9uLCBFTVBUWV9PQkosIGlzU2V0LCBpc1BsYWluT2JqZWN0LCBOT09QLCByZW1vdmUgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmZ1bmN0aW9uIHdhcm4obXNnLCAuLi5hcmdzKSB7XG4gIGNvbnNvbGUud2FybihgW1Z1ZSB3YXJuXSAke21zZ31gLCAuLi5hcmdzKTtcbn1cblxubGV0IGFjdGl2ZUVmZmVjdFNjb3BlO1xuY2xhc3MgRWZmZWN0U2NvcGUge1xuICBjb25zdHJ1Y3RvcihkZXRhY2hlZCA9IGZhbHNlKSB7XG4gICAgdGhpcy5kZXRhY2hlZCA9IGRldGFjaGVkO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5lZmZlY3RzID0gW107XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5jbGVhbnVwcyA9IFtdO1xuICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5wYXJlbnQgPSBhY3RpdmVFZmZlY3RTY29wZTtcbiAgICBpZiAoIWRldGFjaGVkICYmIGFjdGl2ZUVmZmVjdFNjb3BlKSB7XG4gICAgICB0aGlzLmluZGV4ID0gKGFjdGl2ZUVmZmVjdFNjb3BlLnNjb3BlcyB8fCAoYWN0aXZlRWZmZWN0U2NvcGUuc2NvcGVzID0gW10pKS5wdXNoKFxuICAgICAgICB0aGlzXG4gICAgICApIC0gMTtcbiAgICB9XG4gIH1cbiAgZ2V0IGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICB9XG4gIHBhdXNlKCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX2lzUGF1c2VkID0gdHJ1ZTtcbiAgICAgIGxldCBpLCBsO1xuICAgICAgaWYgKHRoaXMuc2NvcGVzKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLnNjb3Blcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB0aGlzLnNjb3Blc1tpXS5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5lZmZlY3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmVmZmVjdHNbaV0ucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlc3VtZXMgdGhlIGVmZmVjdCBzY29wZSwgaW5jbHVkaW5nIGFsbCBjaGlsZCBzY29wZXMgYW5kIGVmZmVjdHMuXG4gICAqL1xuICByZXN1bWUoKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgaWYgKHRoaXMuX2lzUGF1c2VkKSB7XG4gICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XG4gICAgICAgIGxldCBpLCBsO1xuICAgICAgICBpZiAodGhpcy5zY29wZXMpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5zY29wZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnNjb3Blc1tpXS5yZXN1bWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuZWZmZWN0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmVmZmVjdHNbaV0ucmVzdW1lKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcnVuKGZuKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgY29uc3QgY3VycmVudEVmZmVjdFNjb3BlID0gYWN0aXZlRWZmZWN0U2NvcGU7XG4gICAgICB0cnkge1xuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSBjdXJyZW50RWZmZWN0U2NvcGU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuKGBjYW5ub3QgcnVuIGFuIGluYWN0aXZlIGVmZmVjdCBzY29wZS5gKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIG5vbi1kZXRhY2hlZCBzY29wZXNcbiAgICogQGludGVybmFsXG4gICAqL1xuICBvbigpIHtcbiAgICBhY3RpdmVFZmZlY3RTY29wZSA9IHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIG5vbi1kZXRhY2hlZCBzY29wZXNcbiAgICogQGludGVybmFsXG4gICAqL1xuICBvZmYoKSB7XG4gICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzLnBhcmVudDtcbiAgfVxuICBzdG9wKGZyb21QYXJlbnQpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgIGxldCBpLCBsO1xuICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuZWZmZWN0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5lZmZlY3RzW2ldLnN0b3AoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZWZmZWN0cy5sZW5ndGggPSAwO1xuICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuY2xlYW51cHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuY2xlYW51cHNbaV0oKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xlYW51cHMubGVuZ3RoID0gMDtcbiAgICAgIGlmICh0aGlzLnNjb3Blcykge1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5zY29wZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5zY29wZXNbaV0uc3RvcCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjb3Blcy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmRldGFjaGVkICYmIHRoaXMucGFyZW50ICYmICFmcm9tUGFyZW50KSB7XG4gICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzLnBhcmVudC5zY29wZXMucG9wKCk7XG4gICAgICAgIGlmIChsYXN0ICYmIGxhc3QgIT09IHRoaXMpIHtcbiAgICAgICAgICB0aGlzLnBhcmVudC5zY29wZXNbdGhpcy5pbmRleF0gPSBsYXN0O1xuICAgICAgICAgIGxhc3QuaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnBhcmVudCA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGVmZmVjdFNjb3BlKGRldGFjaGVkKSB7XG4gIHJldHVybiBuZXcgRWZmZWN0U2NvcGUoZGV0YWNoZWQpO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFNjb3BlKCkge1xuICByZXR1cm4gYWN0aXZlRWZmZWN0U2NvcGU7XG59XG5mdW5jdGlvbiBvblNjb3BlRGlzcG9zZShmbiwgZmFpbFNpbGVudGx5ID0gZmFsc2UpIHtcbiAgaWYgKGFjdGl2ZUVmZmVjdFNjb3BlKSB7XG4gICAgYWN0aXZlRWZmZWN0U2NvcGUuY2xlYW51cHMucHVzaChmbik7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhZmFpbFNpbGVudGx5KSB7XG4gICAgd2FybihcbiAgICAgIGBvblNjb3BlRGlzcG9zZSgpIGlzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFjdGl2ZSBlZmZlY3Qgc2NvcGUgdG8gYmUgYXNzb2NpYXRlZCB3aXRoLmBcbiAgICApO1xuICB9XG59XG5cbmxldCBhY3RpdmVTdWI7XG5jb25zdCBFZmZlY3RGbGFncyA9IHtcbiAgXCJBQ1RJVkVcIjogMSxcbiAgXCIxXCI6IFwiQUNUSVZFXCIsXG4gIFwiUlVOTklOR1wiOiAyLFxuICBcIjJcIjogXCJSVU5OSU5HXCIsXG4gIFwiVFJBQ0tJTkdcIjogNCxcbiAgXCI0XCI6IFwiVFJBQ0tJTkdcIixcbiAgXCJOT1RJRklFRFwiOiA4LFxuICBcIjhcIjogXCJOT1RJRklFRFwiLFxuICBcIkRJUlRZXCI6IDE2LFxuICBcIjE2XCI6IFwiRElSVFlcIixcbiAgXCJBTExPV19SRUNVUlNFXCI6IDMyLFxuICBcIjMyXCI6IFwiQUxMT1dfUkVDVVJTRVwiLFxuICBcIlBBVVNFRFwiOiA2NCxcbiAgXCI2NFwiOiBcIlBBVVNFRFwiXG59O1xuY29uc3QgcGF1c2VkUXVldWVFZmZlY3RzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG5jbGFzcyBSZWFjdGl2ZUVmZmVjdCB7XG4gIGNvbnN0cnVjdG9yKGZuKSB7XG4gICAgdGhpcy5mbiA9IGZuO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZGVwcyA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmRlcHNUYWlsID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZmxhZ3MgPSAxIHwgNDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLm5leHQgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5jbGVhbnVwID0gdm9pZCAwO1xuICAgIHRoaXMuc2NoZWR1bGVyID0gdm9pZCAwO1xuICAgIGlmIChhY3RpdmVFZmZlY3RTY29wZSAmJiBhY3RpdmVFZmZlY3RTY29wZS5hY3RpdmUpIHtcbiAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlLmVmZmVjdHMucHVzaCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgcGF1c2UoKSB7XG4gICAgdGhpcy5mbGFncyB8PSA2NDtcbiAgfVxuICByZXN1bWUoKSB7XG4gICAgaWYgKHRoaXMuZmxhZ3MgJiA2NCkge1xuICAgICAgdGhpcy5mbGFncyAmPSB+NjQ7XG4gICAgICBpZiAocGF1c2VkUXVldWVFZmZlY3RzLmhhcyh0aGlzKSkge1xuICAgICAgICBwYXVzZWRRdWV1ZUVmZmVjdHMuZGVsZXRlKHRoaXMpO1xuICAgICAgICB0aGlzLnRyaWdnZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbm90aWZ5KCkge1xuICAgIGlmICh0aGlzLmZsYWdzICYgMiAmJiAhKHRoaXMuZmxhZ3MgJiAzMikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEodGhpcy5mbGFncyAmIDgpKSB7XG4gICAgICBiYXRjaCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgcnVuKCkge1xuICAgIGlmICghKHRoaXMuZmxhZ3MgJiAxKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZm4oKTtcbiAgICB9XG4gICAgdGhpcy5mbGFncyB8PSAyO1xuICAgIGNsZWFudXBFZmZlY3QodGhpcyk7XG4gICAgcHJlcGFyZURlcHModGhpcyk7XG4gICAgY29uc3QgcHJldkVmZmVjdCA9IGFjdGl2ZVN1YjtcbiAgICBjb25zdCBwcmV2U2hvdWxkVHJhY2sgPSBzaG91bGRUcmFjaztcbiAgICBhY3RpdmVTdWIgPSB0aGlzO1xuICAgIHNob3VsZFRyYWNrID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuZm4oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgYWN0aXZlU3ViICE9PSB0aGlzKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJBY3RpdmUgZWZmZWN0IHdhcyBub3QgcmVzdG9yZWQgY29ycmVjdGx5IC0gdGhpcyBpcyBsaWtlbHkgYSBWdWUgaW50ZXJuYWwgYnVnLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjbGVhbnVwRGVwcyh0aGlzKTtcbiAgICAgIGFjdGl2ZVN1YiA9IHByZXZFZmZlY3Q7XG4gICAgICBzaG91bGRUcmFjayA9IHByZXZTaG91bGRUcmFjaztcbiAgICAgIHRoaXMuZmxhZ3MgJj0gfjI7XG4gICAgfVxuICB9XG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuZmxhZ3MgJiAxKSB7XG4gICAgICBmb3IgKGxldCBsaW5rID0gdGhpcy5kZXBzOyBsaW5rOyBsaW5rID0gbGluay5uZXh0RGVwKSB7XG4gICAgICAgIHJlbW92ZVN1YihsaW5rKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVwcyA9IHRoaXMuZGVwc1RhaWwgPSB2b2lkIDA7XG4gICAgICBjbGVhbnVwRWZmZWN0KHRoaXMpO1xuICAgICAgdGhpcy5vblN0b3AgJiYgdGhpcy5vblN0b3AoKTtcbiAgICAgIHRoaXMuZmxhZ3MgJj0gfjE7XG4gICAgfVxuICB9XG4gIHRyaWdnZXIoKSB7XG4gICAgaWYgKHRoaXMuZmxhZ3MgJiA2NCkge1xuICAgICAgcGF1c2VkUXVldWVFZmZlY3RzLmFkZCh0aGlzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2NoZWR1bGVyKSB7XG4gICAgICB0aGlzLnNjaGVkdWxlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJ1bklmRGlydHkoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcnVuSWZEaXJ0eSgpIHtcbiAgICBpZiAoaXNEaXJ0eSh0aGlzKSkge1xuICAgICAgdGhpcy5ydW4oKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGRpcnR5KCkge1xuICAgIHJldHVybiBpc0RpcnR5KHRoaXMpO1xuICB9XG59XG5sZXQgYmF0Y2hEZXB0aCA9IDA7XG5sZXQgYmF0Y2hlZFN1YjtcbmxldCBiYXRjaGVkQ29tcHV0ZWQ7XG5mdW5jdGlvbiBiYXRjaChzdWIsIGlzQ29tcHV0ZWQgPSBmYWxzZSkge1xuICBzdWIuZmxhZ3MgfD0gODtcbiAgaWYgKGlzQ29tcHV0ZWQpIHtcbiAgICBzdWIubmV4dCA9IGJhdGNoZWRDb21wdXRlZDtcbiAgICBiYXRjaGVkQ29tcHV0ZWQgPSBzdWI7XG4gICAgcmV0dXJuO1xuICB9XG4gIHN1Yi5uZXh0ID0gYmF0Y2hlZFN1YjtcbiAgYmF0Y2hlZFN1YiA9IHN1Yjtcbn1cbmZ1bmN0aW9uIHN0YXJ0QmF0Y2goKSB7XG4gIGJhdGNoRGVwdGgrKztcbn1cbmZ1bmN0aW9uIGVuZEJhdGNoKCkge1xuICBpZiAoLS1iYXRjaERlcHRoID4gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoYmF0Y2hlZENvbXB1dGVkKSB7XG4gICAgbGV0IGUgPSBiYXRjaGVkQ29tcHV0ZWQ7XG4gICAgYmF0Y2hlZENvbXB1dGVkID0gdm9pZCAwO1xuICAgIHdoaWxlIChlKSB7XG4gICAgICBjb25zdCBuZXh0ID0gZS5uZXh0O1xuICAgICAgZS5uZXh0ID0gdm9pZCAwO1xuICAgICAgZS5mbGFncyAmPSB+ODtcbiAgICAgIGUgPSBuZXh0O1xuICAgIH1cbiAgfVxuICBsZXQgZXJyb3I7XG4gIHdoaWxlIChiYXRjaGVkU3ViKSB7XG4gICAgbGV0IGUgPSBiYXRjaGVkU3ViO1xuICAgIGJhdGNoZWRTdWIgPSB2b2lkIDA7XG4gICAgd2hpbGUgKGUpIHtcbiAgICAgIGNvbnN0IG5leHQgPSBlLm5leHQ7XG4gICAgICBlLm5leHQgPSB2b2lkIDA7XG4gICAgICBlLmZsYWdzICY9IH44O1xuICAgICAgaWYgKGUuZmxhZ3MgJiAxKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgO1xuICAgICAgICAgIGUudHJpZ2dlcigpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSBlcnJvciA9IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZSA9IG5leHQ7XG4gICAgfVxuICB9XG4gIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG59XG5mdW5jdGlvbiBwcmVwYXJlRGVwcyhzdWIpIHtcbiAgZm9yIChsZXQgbGluayA9IHN1Yi5kZXBzOyBsaW5rOyBsaW5rID0gbGluay5uZXh0RGVwKSB7XG4gICAgbGluay52ZXJzaW9uID0gLTE7XG4gICAgbGluay5wcmV2QWN0aXZlTGluayA9IGxpbmsuZGVwLmFjdGl2ZUxpbms7XG4gICAgbGluay5kZXAuYWN0aXZlTGluayA9IGxpbms7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsZWFudXBEZXBzKHN1Yikge1xuICBsZXQgaGVhZDtcbiAgbGV0IHRhaWwgPSBzdWIuZGVwc1RhaWw7XG4gIGxldCBsaW5rID0gdGFpbDtcbiAgd2hpbGUgKGxpbmspIHtcbiAgICBjb25zdCBwcmV2ID0gbGluay5wcmV2RGVwO1xuICAgIGlmIChsaW5rLnZlcnNpb24gPT09IC0xKSB7XG4gICAgICBpZiAobGluayA9PT0gdGFpbCkgdGFpbCA9IHByZXY7XG4gICAgICByZW1vdmVTdWIobGluayk7XG4gICAgICByZW1vdmVEZXAobGluayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWQgPSBsaW5rO1xuICAgIH1cbiAgICBsaW5rLmRlcC5hY3RpdmVMaW5rID0gbGluay5wcmV2QWN0aXZlTGluaztcbiAgICBsaW5rLnByZXZBY3RpdmVMaW5rID0gdm9pZCAwO1xuICAgIGxpbmsgPSBwcmV2O1xuICB9XG4gIHN1Yi5kZXBzID0gaGVhZDtcbiAgc3ViLmRlcHNUYWlsID0gdGFpbDtcbn1cbmZ1bmN0aW9uIGlzRGlydHkoc3ViKSB7XG4gIGZvciAobGV0IGxpbmsgPSBzdWIuZGVwczsgbGluazsgbGluayA9IGxpbmsubmV4dERlcCkge1xuICAgIGlmIChsaW5rLmRlcC52ZXJzaW9uICE9PSBsaW5rLnZlcnNpb24gfHwgbGluay5kZXAuY29tcHV0ZWQgJiYgKHJlZnJlc2hDb21wdXRlZChsaW5rLmRlcC5jb21wdXRlZCkgfHwgbGluay5kZXAudmVyc2lvbiAhPT0gbGluay52ZXJzaW9uKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChzdWIuX2RpcnR5KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcmVmcmVzaENvbXB1dGVkKGNvbXB1dGVkKSB7XG4gIGlmIChjb21wdXRlZC5mbGFncyAmIDQgJiYgIShjb21wdXRlZC5mbGFncyAmIDE2KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb21wdXRlZC5mbGFncyAmPSB+MTY7XG4gIGlmIChjb21wdXRlZC5nbG9iYWxWZXJzaW9uID09PSBnbG9iYWxWZXJzaW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbXB1dGVkLmdsb2JhbFZlcnNpb24gPSBnbG9iYWxWZXJzaW9uO1xuICBjb25zdCBkZXAgPSBjb21wdXRlZC5kZXA7XG4gIGNvbXB1dGVkLmZsYWdzIHw9IDI7XG4gIGlmIChkZXAudmVyc2lvbiA+IDAgJiYgIWNvbXB1dGVkLmlzU1NSICYmIGNvbXB1dGVkLmRlcHMgJiYgIWlzRGlydHkoY29tcHV0ZWQpKSB7XG4gICAgY29tcHV0ZWQuZmxhZ3MgJj0gfjI7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHByZXZTdWIgPSBhY3RpdmVTdWI7XG4gIGNvbnN0IHByZXZTaG91bGRUcmFjayA9IHNob3VsZFRyYWNrO1xuICBhY3RpdmVTdWIgPSBjb21wdXRlZDtcbiAgc2hvdWxkVHJhY2sgPSB0cnVlO1xuICB0cnkge1xuICAgIHByZXBhcmVEZXBzKGNvbXB1dGVkKTtcbiAgICBjb25zdCB2YWx1ZSA9IGNvbXB1dGVkLmZuKGNvbXB1dGVkLl92YWx1ZSk7XG4gICAgaWYgKGRlcC52ZXJzaW9uID09PSAwIHx8IGhhc0NoYW5nZWQodmFsdWUsIGNvbXB1dGVkLl92YWx1ZSkpIHtcbiAgICAgIGNvbXB1dGVkLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgZGVwLnZlcnNpb24rKztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRlcC52ZXJzaW9uKys7XG4gICAgdGhyb3cgZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIGFjdGl2ZVN1YiA9IHByZXZTdWI7XG4gICAgc2hvdWxkVHJhY2sgPSBwcmV2U2hvdWxkVHJhY2s7XG4gICAgY2xlYW51cERlcHMoY29tcHV0ZWQpO1xuICAgIGNvbXB1dGVkLmZsYWdzICY9IH4yO1xuICB9XG59XG5mdW5jdGlvbiByZW1vdmVTdWIobGluaywgc29mdCA9IGZhbHNlKSB7XG4gIGNvbnN0IHsgZGVwLCBwcmV2U3ViLCBuZXh0U3ViIH0gPSBsaW5rO1xuICBpZiAocHJldlN1Yikge1xuICAgIHByZXZTdWIubmV4dFN1YiA9IG5leHRTdWI7XG4gICAgbGluay5wcmV2U3ViID0gdm9pZCAwO1xuICB9XG4gIGlmIChuZXh0U3ViKSB7XG4gICAgbmV4dFN1Yi5wcmV2U3ViID0gcHJldlN1YjtcbiAgICBsaW5rLm5leHRTdWIgPSB2b2lkIDA7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgZGVwLnN1YnNIZWFkID09PSBsaW5rKSB7XG4gICAgZGVwLnN1YnNIZWFkID0gbmV4dFN1YjtcbiAgfVxuICBpZiAoZGVwLnN1YnMgPT09IGxpbmspIHtcbiAgICBkZXAuc3VicyA9IHByZXZTdWI7XG4gICAgaWYgKCFwcmV2U3ViICYmIGRlcC5jb21wdXRlZCkge1xuICAgICAgZGVwLmNvbXB1dGVkLmZsYWdzICY9IH40O1xuICAgICAgZm9yIChsZXQgbCA9IGRlcC5jb21wdXRlZC5kZXBzOyBsOyBsID0gbC5uZXh0RGVwKSB7XG4gICAgICAgIHJlbW92ZVN1YihsLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFzb2Z0ICYmICEtLWRlcC5zYyAmJiBkZXAubWFwKSB7XG4gICAgZGVwLm1hcC5kZWxldGUoZGVwLmtleSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZURlcChsaW5rKSB7XG4gIGNvbnN0IHsgcHJldkRlcCwgbmV4dERlcCB9ID0gbGluaztcbiAgaWYgKHByZXZEZXApIHtcbiAgICBwcmV2RGVwLm5leHREZXAgPSBuZXh0RGVwO1xuICAgIGxpbmsucHJldkRlcCA9IHZvaWQgMDtcbiAgfVxuICBpZiAobmV4dERlcCkge1xuICAgIG5leHREZXAucHJldkRlcCA9IHByZXZEZXA7XG4gICAgbGluay5uZXh0RGVwID0gdm9pZCAwO1xuICB9XG59XG5mdW5jdGlvbiBlZmZlY3QoZm4sIG9wdGlvbnMpIHtcbiAgaWYgKGZuLmVmZmVjdCBpbnN0YW5jZW9mIFJlYWN0aXZlRWZmZWN0KSB7XG4gICAgZm4gPSBmbi5lZmZlY3QuZm47XG4gIH1cbiAgY29uc3QgZSA9IG5ldyBSZWFjdGl2ZUVmZmVjdChmbik7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgZXh0ZW5kKGUsIG9wdGlvbnMpO1xuICB9XG4gIHRyeSB7XG4gICAgZS5ydW4oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZS5zdG9wKCk7XG4gICAgdGhyb3cgZXJyO1xuICB9XG4gIGNvbnN0IHJ1bm5lciA9IGUucnVuLmJpbmQoZSk7XG4gIHJ1bm5lci5lZmZlY3QgPSBlO1xuICByZXR1cm4gcnVubmVyO1xufVxuZnVuY3Rpb24gc3RvcChydW5uZXIpIHtcbiAgcnVubmVyLmVmZmVjdC5zdG9wKCk7XG59XG5sZXQgc2hvdWxkVHJhY2sgPSB0cnVlO1xuY29uc3QgdHJhY2tTdGFjayA9IFtdO1xuZnVuY3Rpb24gcGF1c2VUcmFja2luZygpIHtcbiAgdHJhY2tTdGFjay5wdXNoKHNob3VsZFRyYWNrKTtcbiAgc2hvdWxkVHJhY2sgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIGVuYWJsZVRyYWNraW5nKCkge1xuICB0cmFja1N0YWNrLnB1c2goc2hvdWxkVHJhY2spO1xuICBzaG91bGRUcmFjayA9IHRydWU7XG59XG5mdW5jdGlvbiByZXNldFRyYWNraW5nKCkge1xuICBjb25zdCBsYXN0ID0gdHJhY2tTdGFjay5wb3AoKTtcbiAgc2hvdWxkVHJhY2sgPSBsYXN0ID09PSB2b2lkIDAgPyB0cnVlIDogbGFzdDtcbn1cbmZ1bmN0aW9uIG9uRWZmZWN0Q2xlYW51cChmbiwgZmFpbFNpbGVudGx5ID0gZmFsc2UpIHtcbiAgaWYgKGFjdGl2ZVN1YiBpbnN0YW5jZW9mIFJlYWN0aXZlRWZmZWN0KSB7XG4gICAgYWN0aXZlU3ViLmNsZWFudXAgPSBmbjtcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFmYWlsU2lsZW50bHkpIHtcbiAgICB3YXJuKFxuICAgICAgYG9uRWZmZWN0Q2xlYW51cCgpIHdhcyBjYWxsZWQgd2hlbiB0aGVyZSB3YXMgbm8gYWN0aXZlIGVmZmVjdCB0byBhc3NvY2lhdGUgd2l0aC5gXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gY2xlYW51cEVmZmVjdChlKSB7XG4gIGNvbnN0IHsgY2xlYW51cCB9ID0gZTtcbiAgZS5jbGVhbnVwID0gdm9pZCAwO1xuICBpZiAoY2xlYW51cCkge1xuICAgIGNvbnN0IHByZXZTdWIgPSBhY3RpdmVTdWI7XG4gICAgYWN0aXZlU3ViID0gdm9pZCAwO1xuICAgIHRyeSB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGFjdGl2ZVN1YiA9IHByZXZTdWI7XG4gICAgfVxuICB9XG59XG5cbmxldCBnbG9iYWxWZXJzaW9uID0gMDtcbmNsYXNzIExpbmsge1xuICBjb25zdHJ1Y3RvcihzdWIsIGRlcCkge1xuICAgIHRoaXMuc3ViID0gc3ViO1xuICAgIHRoaXMuZGVwID0gZGVwO1xuICAgIHRoaXMudmVyc2lvbiA9IGRlcC52ZXJzaW9uO1xuICAgIHRoaXMubmV4dERlcCA9IHRoaXMucHJldkRlcCA9IHRoaXMubmV4dFN1YiA9IHRoaXMucHJldlN1YiA9IHRoaXMucHJldkFjdGl2ZUxpbmsgPSB2b2lkIDA7XG4gIH1cbn1cbmNsYXNzIERlcCB7XG4gIGNvbnN0cnVjdG9yKGNvbXB1dGVkKSB7XG4gICAgdGhpcy5jb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgIHRoaXMudmVyc2lvbiA9IDA7XG4gICAgLyoqXG4gICAgICogTGluayBiZXR3ZWVuIHRoaXMgZGVwIGFuZCB0aGUgY3VycmVudCBhY3RpdmUgZWZmZWN0XG4gICAgICovXG4gICAgdGhpcy5hY3RpdmVMaW5rID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIERvdWJseSBsaW5rZWQgbGlzdCByZXByZXNlbnRpbmcgdGhlIHN1YnNjcmliaW5nIGVmZmVjdHMgKHRhaWwpXG4gICAgICovXG4gICAgdGhpcy5zdWJzID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIEZvciBvYmplY3QgcHJvcGVydHkgZGVwcyBjbGVhbnVwXG4gICAgICovXG4gICAgdGhpcy5tYXAgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlciBjb3VudGVyXG4gICAgICovXG4gICAgdGhpcy5zYyA9IDA7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHRoaXMuc3Vic0hlYWQgPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIHRyYWNrKGRlYnVnSW5mbykge1xuICAgIGlmICghYWN0aXZlU3ViIHx8ICFzaG91bGRUcmFjayB8fCBhY3RpdmVTdWIgPT09IHRoaXMuY29tcHV0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGxpbmsgPSB0aGlzLmFjdGl2ZUxpbms7XG4gICAgaWYgKGxpbmsgPT09IHZvaWQgMCB8fCBsaW5rLnN1YiAhPT0gYWN0aXZlU3ViKSB7XG4gICAgICBsaW5rID0gdGhpcy5hY3RpdmVMaW5rID0gbmV3IExpbmsoYWN0aXZlU3ViLCB0aGlzKTtcbiAgICAgIGlmICghYWN0aXZlU3ViLmRlcHMpIHtcbiAgICAgICAgYWN0aXZlU3ViLmRlcHMgPSBhY3RpdmVTdWIuZGVwc1RhaWwgPSBsaW5rO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluay5wcmV2RGVwID0gYWN0aXZlU3ViLmRlcHNUYWlsO1xuICAgICAgICBhY3RpdmVTdWIuZGVwc1RhaWwubmV4dERlcCA9IGxpbms7XG4gICAgICAgIGFjdGl2ZVN1Yi5kZXBzVGFpbCA9IGxpbms7XG4gICAgICB9XG4gICAgICBhZGRTdWIobGluayk7XG4gICAgfSBlbHNlIGlmIChsaW5rLnZlcnNpb24gPT09IC0xKSB7XG4gICAgICBsaW5rLnZlcnNpb24gPSB0aGlzLnZlcnNpb247XG4gICAgICBpZiAobGluay5uZXh0RGVwKSB7XG4gICAgICAgIGNvbnN0IG5leHQgPSBsaW5rLm5leHREZXA7XG4gICAgICAgIG5leHQucHJldkRlcCA9IGxpbmsucHJldkRlcDtcbiAgICAgICAgaWYgKGxpbmsucHJldkRlcCkge1xuICAgICAgICAgIGxpbmsucHJldkRlcC5uZXh0RGVwID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBsaW5rLnByZXZEZXAgPSBhY3RpdmVTdWIuZGVwc1RhaWw7XG4gICAgICAgIGxpbmsubmV4dERlcCA9IHZvaWQgMDtcbiAgICAgICAgYWN0aXZlU3ViLmRlcHNUYWlsLm5leHREZXAgPSBsaW5rO1xuICAgICAgICBhY3RpdmVTdWIuZGVwc1RhaWwgPSBsaW5rO1xuICAgICAgICBpZiAoYWN0aXZlU3ViLmRlcHMgPT09IGxpbmspIHtcbiAgICAgICAgICBhY3RpdmVTdWIuZGVwcyA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgYWN0aXZlU3ViLm9uVHJhY2spIHtcbiAgICAgIGFjdGl2ZVN1Yi5vblRyYWNrKFxuICAgICAgICBleHRlbmQoXG4gICAgICAgICAge1xuICAgICAgICAgICAgZWZmZWN0OiBhY3RpdmVTdWJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlYnVnSW5mb1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbGluaztcbiAgfVxuICB0cmlnZ2VyKGRlYnVnSW5mbykge1xuICAgIHRoaXMudmVyc2lvbisrO1xuICAgIGdsb2JhbFZlcnNpb24rKztcbiAgICB0aGlzLm5vdGlmeShkZWJ1Z0luZm8pO1xuICB9XG4gIG5vdGlmeShkZWJ1Z0luZm8pIHtcbiAgICBzdGFydEJhdGNoKCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIGZvciAobGV0IGhlYWQgPSB0aGlzLnN1YnNIZWFkOyBoZWFkOyBoZWFkID0gaGVhZC5uZXh0U3ViKSB7XG4gICAgICAgICAgaWYgKGhlYWQuc3ViLm9uVHJpZ2dlciAmJiAhKGhlYWQuc3ViLmZsYWdzICYgOCkpIHtcbiAgICAgICAgICAgIGhlYWQuc3ViLm9uVHJpZ2dlcihcbiAgICAgICAgICAgICAgZXh0ZW5kKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGVmZmVjdDogaGVhZC5zdWJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRlYnVnSW5mb1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgbGluayA9IHRoaXMuc3ViczsgbGluazsgbGluayA9IGxpbmsucHJldlN1Yikge1xuICAgICAgICBpZiAobGluay5zdWIubm90aWZ5KCkpIHtcbiAgICAgICAgICA7XG4gICAgICAgICAgbGluay5zdWIuZGVwLm5vdGlmeSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVuZEJhdGNoKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhZGRTdWIobGluaykge1xuICBsaW5rLmRlcC5zYysrO1xuICBpZiAobGluay5zdWIuZmxhZ3MgJiA0KSB7XG4gICAgY29uc3QgY29tcHV0ZWQgPSBsaW5rLmRlcC5jb21wdXRlZDtcbiAgICBpZiAoY29tcHV0ZWQgJiYgIWxpbmsuZGVwLnN1YnMpIHtcbiAgICAgIGNvbXB1dGVkLmZsYWdzIHw9IDQgfCAxNjtcbiAgICAgIGZvciAobGV0IGwgPSBjb21wdXRlZC5kZXBzOyBsOyBsID0gbC5uZXh0RGVwKSB7XG4gICAgICAgIGFkZFN1YihsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY3VycmVudFRhaWwgPSBsaW5rLmRlcC5zdWJzO1xuICAgIGlmIChjdXJyZW50VGFpbCAhPT0gbGluaykge1xuICAgICAgbGluay5wcmV2U3ViID0gY3VycmVudFRhaWw7XG4gICAgICBpZiAoY3VycmVudFRhaWwpIGN1cnJlbnRUYWlsLm5leHRTdWIgPSBsaW5rO1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBsaW5rLmRlcC5zdWJzSGVhZCA9PT0gdm9pZCAwKSB7XG4gICAgICBsaW5rLmRlcC5zdWJzSGVhZCA9IGxpbms7XG4gICAgfVxuICAgIGxpbmsuZGVwLnN1YnMgPSBsaW5rO1xuICB9XG59XG5jb25zdCB0YXJnZXRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IElURVJBVEVfS0VZID0gU3ltYm9sKFxuICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gXCJPYmplY3QgaXRlcmF0ZVwiIDogXCJcIlxuKTtcbmNvbnN0IE1BUF9LRVlfSVRFUkFURV9LRVkgPSBTeW1ib2woXG4gICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBcIk1hcCBrZXlzIGl0ZXJhdGVcIiA6IFwiXCJcbik7XG5jb25zdCBBUlJBWV9JVEVSQVRFX0tFWSA9IFN5bWJvbChcbiAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IFwiQXJyYXkgaXRlcmF0ZVwiIDogXCJcIlxuKTtcbmZ1bmN0aW9uIHRyYWNrKHRhcmdldCwgdHlwZSwga2V5KSB7XG4gIGlmIChzaG91bGRUcmFjayAmJiBhY3RpdmVTdWIpIHtcbiAgICBsZXQgZGVwc01hcCA9IHRhcmdldE1hcC5nZXQodGFyZ2V0KTtcbiAgICBpZiAoIWRlcHNNYXApIHtcbiAgICAgIHRhcmdldE1hcC5zZXQodGFyZ2V0LCBkZXBzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgfVxuICAgIGxldCBkZXAgPSBkZXBzTWFwLmdldChrZXkpO1xuICAgIGlmICghZGVwKSB7XG4gICAgICBkZXBzTWFwLnNldChrZXksIGRlcCA9IG5ldyBEZXAoKSk7XG4gICAgICBkZXAubWFwID0gZGVwc01hcDtcbiAgICAgIGRlcC5rZXkgPSBrZXk7XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBkZXAudHJhY2soe1xuICAgICAgICB0YXJnZXQsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGtleVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlcC50cmFjaygpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdHJpZ2dlcih0YXJnZXQsIHR5cGUsIGtleSwgbmV3VmFsdWUsIG9sZFZhbHVlLCBvbGRUYXJnZXQpIHtcbiAgY29uc3QgZGVwc01hcCA9IHRhcmdldE1hcC5nZXQodGFyZ2V0KTtcbiAgaWYgKCFkZXBzTWFwKSB7XG4gICAgZ2xvYmFsVmVyc2lvbisrO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBydW4gPSAoZGVwKSA9PiB7XG4gICAgaWYgKGRlcCkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgZGVwLnRyaWdnZXIoe1xuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgICBvbGRWYWx1ZSxcbiAgICAgICAgICBvbGRUYXJnZXRcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXAudHJpZ2dlcigpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc3RhcnRCYXRjaCgpO1xuICBpZiAodHlwZSA9PT0gXCJjbGVhclwiKSB7XG4gICAgZGVwc01hcC5mb3JFYWNoKHJ1bik7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdGFyZ2V0SXNBcnJheSA9IGlzQXJyYXkodGFyZ2V0KTtcbiAgICBjb25zdCBpc0FycmF5SW5kZXggPSB0YXJnZXRJc0FycmF5ICYmIGlzSW50ZWdlcktleShrZXkpO1xuICAgIGlmICh0YXJnZXRJc0FycmF5ICYmIGtleSA9PT0gXCJsZW5ndGhcIikge1xuICAgICAgY29uc3QgbmV3TGVuZ3RoID0gTnVtYmVyKG5ld1ZhbHVlKTtcbiAgICAgIGRlcHNNYXAuZm9yRWFjaCgoZGVwLCBrZXkyKSA9PiB7XG4gICAgICAgIGlmIChrZXkyID09PSBcImxlbmd0aFwiIHx8IGtleTIgPT09IEFSUkFZX0lURVJBVEVfS0VZIHx8ICFpc1N5bWJvbChrZXkyKSAmJiBrZXkyID49IG5ld0xlbmd0aCkge1xuICAgICAgICAgIHJ1bihkZXApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGtleSAhPT0gdm9pZCAwIHx8IGRlcHNNYXAuaGFzKHZvaWQgMCkpIHtcbiAgICAgICAgcnVuKGRlcHNNYXAuZ2V0KGtleSkpO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlJbmRleCkge1xuICAgICAgICBydW4oZGVwc01hcC5nZXQoQVJSQVlfSVRFUkFURV9LRVkpKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiYWRkXCI6XG4gICAgICAgICAgaWYgKCF0YXJnZXRJc0FycmF5KSB7XG4gICAgICAgICAgICBydW4oZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgIHJ1bihkZXBzTWFwLmdldChNQVBfS0VZX0lURVJBVEVfS0VZKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5SW5kZXgpIHtcbiAgICAgICAgICAgIHJ1bihkZXBzTWFwLmdldChcImxlbmd0aFwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGVsZXRlXCI6XG4gICAgICAgICAgaWYgKCF0YXJnZXRJc0FycmF5KSB7XG4gICAgICAgICAgICBydW4oZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgIHJ1bihkZXBzTWFwLmdldChNQVBfS0VZX0lURVJBVEVfS0VZKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2V0XCI6XG4gICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJ1bihkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZW5kQmF0Y2goKTtcbn1cbmZ1bmN0aW9uIGdldERlcEZyb21SZWFjdGl2ZShvYmplY3QsIGtleSkge1xuICBjb25zdCBkZXBNYXAgPSB0YXJnZXRNYXAuZ2V0KG9iamVjdCk7XG4gIHJldHVybiBkZXBNYXAgJiYgZGVwTWFwLmdldChrZXkpO1xufVxuXG5mdW5jdGlvbiByZWFjdGl2ZVJlYWRBcnJheShhcnJheSkge1xuICBjb25zdCByYXcgPSB0b1JhdyhhcnJheSk7XG4gIGlmIChyYXcgPT09IGFycmF5KSByZXR1cm4gcmF3O1xuICB0cmFjayhyYXcsIFwiaXRlcmF0ZVwiLCBBUlJBWV9JVEVSQVRFX0tFWSk7XG4gIHJldHVybiBpc1NoYWxsb3coYXJyYXkpID8gcmF3IDogcmF3Lm1hcCh0b1JlYWN0aXZlKTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dSZWFkQXJyYXkoYXJyKSB7XG4gIHRyYWNrKGFyciA9IHRvUmF3KGFyciksIFwiaXRlcmF0ZVwiLCBBUlJBWV9JVEVSQVRFX0tFWSk7XG4gIHJldHVybiBhcnI7XG59XG5jb25zdCBhcnJheUluc3RydW1lbnRhdGlvbnMgPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yKHRoaXMsIFN5bWJvbC5pdGVyYXRvciwgdG9SZWFjdGl2ZSk7XG4gIH0sXG4gIGNvbmNhdCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHJlYWN0aXZlUmVhZEFycmF5KHRoaXMpLmNvbmNhdChcbiAgICAgIC4uLmFyZ3MubWFwKCh4KSA9PiBpc0FycmF5KHgpID8gcmVhY3RpdmVSZWFkQXJyYXkoeCkgOiB4KVxuICAgICk7XG4gIH0sXG4gIGVudHJpZXMoKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yKHRoaXMsIFwiZW50cmllc1wiLCAodmFsdWUpID0+IHtcbiAgICAgIHZhbHVlWzFdID0gdG9SZWFjdGl2ZSh2YWx1ZVsxXSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG4gIH0sXG4gIGV2ZXJ5KGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwiZXZlcnlcIiwgZm4sIHRoaXNBcmcsIHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfSxcbiAgZmlsdGVyKGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwiZmlsdGVyXCIsIGZuLCB0aGlzQXJnLCAodikgPT4gdi5tYXAodG9SZWFjdGl2ZSksIGFyZ3VtZW50cyk7XG4gIH0sXG4gIGZpbmQoZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJmaW5kXCIsIGZuLCB0aGlzQXJnLCB0b1JlYWN0aXZlLCBhcmd1bWVudHMpO1xuICB9LFxuICBmaW5kSW5kZXgoZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJmaW5kSW5kZXhcIiwgZm4sIHRoaXNBcmcsIHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfSxcbiAgZmluZExhc3QoZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYXBwbHkodGhpcywgXCJmaW5kTGFzdFwiLCBmbiwgdGhpc0FyZywgdG9SZWFjdGl2ZSwgYXJndW1lbnRzKTtcbiAgfSxcbiAgZmluZExhc3RJbmRleChmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcImZpbmRMYXN0SW5kZXhcIiwgZm4sIHRoaXNBcmcsIHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfSxcbiAgLy8gZmxhdCwgZmxhdE1hcCBjb3VsZCBiZW5lZml0IGZyb20gQVJSQVlfSVRFUkFURSBidXQgYXJlIG5vdCBzdHJhaWdodC1mb3J3YXJkIHRvIGltcGxlbWVudFxuICBmb3JFYWNoKGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwiZm9yRWFjaFwiLCBmbiwgdGhpc0FyZywgdm9pZCAwLCBhcmd1bWVudHMpO1xuICB9LFxuICBpbmNsdWRlcyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHNlYXJjaFByb3h5KHRoaXMsIFwiaW5jbHVkZXNcIiwgYXJncyk7XG4gIH0sXG4gIGluZGV4T2YoLi4uYXJncykge1xuICAgIHJldHVybiBzZWFyY2hQcm94eSh0aGlzLCBcImluZGV4T2ZcIiwgYXJncyk7XG4gIH0sXG4gIGpvaW4oc2VwYXJhdG9yKSB7XG4gICAgcmV0dXJuIHJlYWN0aXZlUmVhZEFycmF5KHRoaXMpLmpvaW4oc2VwYXJhdG9yKTtcbiAgfSxcbiAgLy8ga2V5cygpIGl0ZXJhdG9yIG9ubHkgcmVhZHMgYGxlbmd0aGAsIG5vIG9wdGltaXNhdGlvbiByZXF1aXJlZFxuICBsYXN0SW5kZXhPZiguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHNlYXJjaFByb3h5KHRoaXMsIFwibGFzdEluZGV4T2ZcIiwgYXJncyk7XG4gIH0sXG4gIG1hcChmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcIm1hcFwiLCBmbiwgdGhpc0FyZywgdm9pZCAwLCBhcmd1bWVudHMpO1xuICB9LFxuICBwb3AoKSB7XG4gICAgcmV0dXJuIG5vVHJhY2tpbmcodGhpcywgXCJwb3BcIik7XG4gIH0sXG4gIHB1c2goLi4uYXJncykge1xuICAgIHJldHVybiBub1RyYWNraW5nKHRoaXMsIFwicHVzaFwiLCBhcmdzKTtcbiAgfSxcbiAgcmVkdWNlKGZuLCAuLi5hcmdzKSB7XG4gICAgcmV0dXJuIHJlZHVjZSh0aGlzLCBcInJlZHVjZVwiLCBmbiwgYXJncyk7XG4gIH0sXG4gIHJlZHVjZVJpZ2h0KGZuLCAuLi5hcmdzKSB7XG4gICAgcmV0dXJuIHJlZHVjZSh0aGlzLCBcInJlZHVjZVJpZ2h0XCIsIGZuLCBhcmdzKTtcbiAgfSxcbiAgc2hpZnQoKSB7XG4gICAgcmV0dXJuIG5vVHJhY2tpbmcodGhpcywgXCJzaGlmdFwiKTtcbiAgfSxcbiAgLy8gc2xpY2UgY291bGQgdXNlIEFSUkFZX0lURVJBVEUgYnV0IGFsc28gc2VlbXMgdG8gYmVnIGZvciByYW5nZSB0cmFja2luZ1xuICBzb21lKGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwic29tZVwiLCBmbiwgdGhpc0FyZywgdm9pZCAwLCBhcmd1bWVudHMpO1xuICB9LFxuICBzcGxpY2UoLi4uYXJncykge1xuICAgIHJldHVybiBub1RyYWNraW5nKHRoaXMsIFwic3BsaWNlXCIsIGFyZ3MpO1xuICB9LFxuICB0b1JldmVyc2VkKCkge1xuICAgIHJldHVybiByZWFjdGl2ZVJlYWRBcnJheSh0aGlzKS50b1JldmVyc2VkKCk7XG4gIH0sXG4gIHRvU29ydGVkKGNvbXBhcmVyKSB7XG4gICAgcmV0dXJuIHJlYWN0aXZlUmVhZEFycmF5KHRoaXMpLnRvU29ydGVkKGNvbXBhcmVyKTtcbiAgfSxcbiAgdG9TcGxpY2VkKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gcmVhY3RpdmVSZWFkQXJyYXkodGhpcykudG9TcGxpY2VkKC4uLmFyZ3MpO1xuICB9LFxuICB1bnNoaWZ0KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbm9UcmFja2luZyh0aGlzLCBcInVuc2hpZnRcIiwgYXJncyk7XG4gIH0sXG4gIHZhbHVlcygpIHtcbiAgICByZXR1cm4gaXRlcmF0b3IodGhpcywgXCJ2YWx1ZXNcIiwgdG9SZWFjdGl2ZSk7XG4gIH1cbn07XG5mdW5jdGlvbiBpdGVyYXRvcihzZWxmLCBtZXRob2QsIHdyYXBWYWx1ZSkge1xuICBjb25zdCBhcnIgPSBzaGFsbG93UmVhZEFycmF5KHNlbGYpO1xuICBjb25zdCBpdGVyID0gYXJyW21ldGhvZF0oKTtcbiAgaWYgKGFyciAhPT0gc2VsZiAmJiAhaXNTaGFsbG93KHNlbGYpKSB7XG4gICAgaXRlci5fbmV4dCA9IGl0ZXIubmV4dDtcbiAgICBpdGVyLm5leHQgPSAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBpdGVyLl9uZXh0KCk7XG4gICAgICBpZiAocmVzdWx0LnZhbHVlKSB7XG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IHdyYXBWYWx1ZShyZXN1bHQudmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG4gIHJldHVybiBpdGVyO1xufVxuY29uc3QgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbmZ1bmN0aW9uIGFwcGx5KHNlbGYsIG1ldGhvZCwgZm4sIHRoaXNBcmcsIHdyYXBwZWRSZXRGbiwgYXJncykge1xuICBjb25zdCBhcnIgPSBzaGFsbG93UmVhZEFycmF5KHNlbGYpO1xuICBjb25zdCBuZWVkc1dyYXAgPSBhcnIgIT09IHNlbGYgJiYgIWlzU2hhbGxvdyhzZWxmKTtcbiAgY29uc3QgbWV0aG9kRm4gPSBhcnJbbWV0aG9kXTtcbiAgaWYgKG1ldGhvZEZuICE9PSBhcnJheVByb3RvW21ldGhvZF0pIHtcbiAgICBjb25zdCByZXN1bHQyID0gbWV0aG9kRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgcmV0dXJuIG5lZWRzV3JhcCA/IHRvUmVhY3RpdmUocmVzdWx0MikgOiByZXN1bHQyO1xuICB9XG4gIGxldCB3cmFwcGVkRm4gPSBmbjtcbiAgaWYgKGFyciAhPT0gc2VsZikge1xuICAgIGlmIChuZWVkc1dyYXApIHtcbiAgICAgIHdyYXBwZWRGbiA9IGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIHRvUmVhY3RpdmUoaXRlbSksIGluZGV4LCBzZWxmKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChmbi5sZW5ndGggPiAyKSB7XG4gICAgICB3cmFwcGVkRm4gPSBmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBpdGVtLCBpbmRleCwgc2VsZik7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBjb25zdCByZXN1bHQgPSBtZXRob2RGbi5jYWxsKGFyciwgd3JhcHBlZEZuLCB0aGlzQXJnKTtcbiAgcmV0dXJuIG5lZWRzV3JhcCAmJiB3cmFwcGVkUmV0Rm4gPyB3cmFwcGVkUmV0Rm4ocmVzdWx0KSA6IHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHJlZHVjZShzZWxmLCBtZXRob2QsIGZuLCBhcmdzKSB7XG4gIGNvbnN0IGFyciA9IHNoYWxsb3dSZWFkQXJyYXkoc2VsZik7XG4gIGxldCB3cmFwcGVkRm4gPSBmbjtcbiAgaWYgKGFyciAhPT0gc2VsZikge1xuICAgIGlmICghaXNTaGFsbG93KHNlbGYpKSB7XG4gICAgICB3cmFwcGVkRm4gPSBmdW5jdGlvbihhY2MsIGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGFjYywgdG9SZWFjdGl2ZShpdGVtKSwgaW5kZXgsIHNlbGYpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGZuLmxlbmd0aCA+IDMpIHtcbiAgICAgIHdyYXBwZWRGbiA9IGZ1bmN0aW9uKGFjYywgaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgYWNjLCBpdGVtLCBpbmRleCwgc2VsZik7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyW21ldGhvZF0od3JhcHBlZEZuLCAuLi5hcmdzKTtcbn1cbmZ1bmN0aW9uIHNlYXJjaFByb3h5KHNlbGYsIG1ldGhvZCwgYXJncykge1xuICBjb25zdCBhcnIgPSB0b1JhdyhzZWxmKTtcbiAgdHJhY2soYXJyLCBcIml0ZXJhdGVcIiwgQVJSQVlfSVRFUkFURV9LRVkpO1xuICBjb25zdCByZXMgPSBhcnJbbWV0aG9kXSguLi5hcmdzKTtcbiAgaWYgKChyZXMgPT09IC0xIHx8IHJlcyA9PT0gZmFsc2UpICYmIGlzUHJveHkoYXJnc1swXSkpIHtcbiAgICBhcmdzWzBdID0gdG9SYXcoYXJnc1swXSk7XG4gICAgcmV0dXJuIGFyclttZXRob2RdKC4uLmFyZ3MpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBub1RyYWNraW5nKHNlbGYsIG1ldGhvZCwgYXJncyA9IFtdKSB7XG4gIHBhdXNlVHJhY2tpbmcoKTtcbiAgc3RhcnRCYXRjaCgpO1xuICBjb25zdCByZXMgPSB0b1JhdyhzZWxmKVttZXRob2RdLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICBlbmRCYXRjaCgpO1xuICByZXNldFRyYWNraW5nKCk7XG4gIHJldHVybiByZXM7XG59XG5cbmNvbnN0IGlzTm9uVHJhY2thYmxlS2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKGBfX3Byb3RvX18sX192X2lzUmVmLF9faXNWdWVgKTtcbmNvbnN0IGJ1aWx0SW5TeW1ib2xzID0gbmV3IFNldChcbiAgLyogQF9fUFVSRV9fICovIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFN5bWJvbCkuZmlsdGVyKChrZXkpID0+IGtleSAhPT0gXCJhcmd1bWVudHNcIiAmJiBrZXkgIT09IFwiY2FsbGVyXCIpLm1hcCgoa2V5KSA9PiBTeW1ib2xba2V5XSkuZmlsdGVyKGlzU3ltYm9sKVxuKTtcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KGtleSkge1xuICBpZiAoIWlzU3ltYm9sKGtleSkpIGtleSA9IFN0cmluZyhrZXkpO1xuICBjb25zdCBvYmogPSB0b1Jhdyh0aGlzKTtcbiAgdHJhY2sob2JqLCBcImhhc1wiLCBrZXkpO1xuICByZXR1cm4gb2JqLmhhc093blByb3BlcnR5KGtleSk7XG59XG5jbGFzcyBCYXNlUmVhY3RpdmVIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IoX2lzUmVhZG9ubHkgPSBmYWxzZSwgX2lzU2hhbGxvdyA9IGZhbHNlKSB7XG4gICAgdGhpcy5faXNSZWFkb25seSA9IF9pc1JlYWRvbmx5O1xuICAgIHRoaXMuX2lzU2hhbGxvdyA9IF9pc1NoYWxsb3c7XG4gIH1cbiAgZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcikge1xuICAgIGlmIChrZXkgPT09IFwiX192X3NraXBcIikgcmV0dXJuIHRhcmdldFtcIl9fdl9za2lwXCJdO1xuICAgIGNvbnN0IGlzUmVhZG9ubHkyID0gdGhpcy5faXNSZWFkb25seSwgaXNTaGFsbG93MiA9IHRoaXMuX2lzU2hhbGxvdztcbiAgICBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWN0aXZlXCIpIHtcbiAgICAgIHJldHVybiAhaXNSZWFkb25seTI7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzUmVhZG9ubHlcIikge1xuICAgICAgcmV0dXJuIGlzUmVhZG9ubHkyO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9pc1NoYWxsb3dcIikge1xuICAgICAgcmV0dXJuIGlzU2hhbGxvdzI7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiKSB7XG4gICAgICBpZiAocmVjZWl2ZXIgPT09IChpc1JlYWRvbmx5MiA/IGlzU2hhbGxvdzIgPyBzaGFsbG93UmVhZG9ubHlNYXAgOiByZWFkb25seU1hcCA6IGlzU2hhbGxvdzIgPyBzaGFsbG93UmVhY3RpdmVNYXAgOiByZWFjdGl2ZU1hcCkuZ2V0KHRhcmdldCkgfHwgLy8gcmVjZWl2ZXIgaXMgbm90IHRoZSByZWFjdGl2ZSBwcm94eSwgYnV0IGhhcyB0aGUgc2FtZSBwcm90b3R5cGVcbiAgICAgIC8vIHRoaXMgbWVhbnMgdGhlIHJlY2VpdmVyIGlzIGEgdXNlciBwcm94eSBvZiB0aGUgcmVhY3RpdmUgcHJveHlcbiAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocmVjZWl2ZXIpKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldElzQXJyYXkgPSBpc0FycmF5KHRhcmdldCk7XG4gICAgaWYgKCFpc1JlYWRvbmx5Mikge1xuICAgICAgbGV0IGZuO1xuICAgICAgaWYgKHRhcmdldElzQXJyYXkgJiYgKGZuID0gYXJyYXlJbnN0cnVtZW50YXRpb25zW2tleV0pKSB7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09IFwiaGFzT3duUHJvcGVydHlcIikge1xuICAgICAgICByZXR1cm4gaGFzT3duUHJvcGVydHk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IFJlZmxlY3QuZ2V0KFxuICAgICAgdGFyZ2V0LFxuICAgICAga2V5LFxuICAgICAgLy8gaWYgdGhpcyBpcyBhIHByb3h5IHdyYXBwaW5nIGEgcmVmLCByZXR1cm4gbWV0aG9kcyB1c2luZyB0aGUgcmF3IHJlZlxuICAgICAgLy8gYXMgcmVjZWl2ZXIgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGNhbGwgYHRvUmF3YCBvbiB0aGUgcmVmIGluIGFsbFxuICAgICAgLy8gaXRzIGNsYXNzIG1ldGhvZHNcbiAgICAgIGlzUmVmKHRhcmdldCkgPyB0YXJnZXQgOiByZWNlaXZlclxuICAgICk7XG4gICAgaWYgKGlzU3ltYm9sKGtleSkgPyBidWlsdEluU3ltYm9scy5oYXMoa2V5KSA6IGlzTm9uVHJhY2thYmxlS2V5cyhrZXkpKSB7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBpZiAoIWlzUmVhZG9ubHkyKSB7XG4gICAgICB0cmFjayh0YXJnZXQsIFwiZ2V0XCIsIGtleSk7XG4gICAgfVxuICAgIGlmIChpc1NoYWxsb3cyKSB7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBpZiAoaXNSZWYocmVzKSkge1xuICAgICAgcmV0dXJuIHRhcmdldElzQXJyYXkgJiYgaXNJbnRlZ2VyS2V5KGtleSkgPyByZXMgOiByZXMudmFsdWU7XG4gICAgfVxuICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICByZXR1cm4gaXNSZWFkb25seTIgPyByZWFkb25seShyZXMpIDogcmVhY3RpdmUocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxufVxuY2xhc3MgTXV0YWJsZVJlYWN0aXZlSGFuZGxlciBleHRlbmRzIEJhc2VSZWFjdGl2ZUhhbmRsZXIge1xuICBjb25zdHJ1Y3Rvcihpc1NoYWxsb3cyID0gZmFsc2UpIHtcbiAgICBzdXBlcihmYWxzZSwgaXNTaGFsbG93Mik7XG4gIH1cbiAgc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICBsZXQgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcbiAgICBpZiAoIXRoaXMuX2lzU2hhbGxvdykge1xuICAgICAgY29uc3QgaXNPbGRWYWx1ZVJlYWRvbmx5ID0gaXNSZWFkb25seShvbGRWYWx1ZSk7XG4gICAgICBpZiAoIWlzU2hhbGxvdyh2YWx1ZSkgJiYgIWlzUmVhZG9ubHkodmFsdWUpKSB7XG4gICAgICAgIG9sZFZhbHVlID0gdG9SYXcob2xkVmFsdWUpO1xuICAgICAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNBcnJheSh0YXJnZXQpICYmIGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XG4gICAgICAgIGlmIChpc09sZFZhbHVlUmVhZG9ubHkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2xkVmFsdWUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBoYWRLZXkgPSBpc0FycmF5KHRhcmdldCkgJiYgaXNJbnRlZ2VyS2V5KGtleSkgPyBOdW1iZXIoa2V5KSA8IHRhcmdldC5sZW5ndGggOiBoYXNPd24odGFyZ2V0LCBrZXkpO1xuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3Quc2V0KFxuICAgICAgdGFyZ2V0LFxuICAgICAga2V5LFxuICAgICAgdmFsdWUsXG4gICAgICBpc1JlZih0YXJnZXQpID8gdGFyZ2V0IDogcmVjZWl2ZXJcbiAgICApO1xuICAgIGlmICh0YXJnZXQgPT09IHRvUmF3KHJlY2VpdmVyKSkge1xuICAgICAgaWYgKCFoYWRLZXkpIHtcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIsIGtleSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChoYXNDaGFuZ2VkKHZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwic2V0XCIsIGtleSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xuICAgIGNvbnN0IGhhZEtleSA9IGhhc093bih0YXJnZXQsIGtleSk7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KTtcbiAgICBpZiAocmVzdWx0ICYmIGhhZEtleSkge1xuICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiZGVsZXRlXCIsIGtleSwgdm9pZCAwLCBvbGRWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaGFzKHRhcmdldCwga2V5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5oYXModGFyZ2V0LCBrZXkpO1xuICAgIGlmICghaXNTeW1ib2woa2V5KSB8fCAhYnVpbHRJblN5bWJvbHMuaGFzKGtleSkpIHtcbiAgICAgIHRyYWNrKHRhcmdldCwgXCJoYXNcIiwga2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBvd25LZXlzKHRhcmdldCkge1xuICAgIHRyYWNrKFxuICAgICAgdGFyZ2V0LFxuICAgICAgXCJpdGVyYXRlXCIsXG4gICAgICBpc0FycmF5KHRhcmdldCkgPyBcImxlbmd0aFwiIDogSVRFUkFURV9LRVlcbiAgICApO1xuICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcbiAgfVxufVxuY2xhc3MgUmVhZG9ubHlSZWFjdGl2ZUhhbmRsZXIgZXh0ZW5kcyBCYXNlUmVhY3RpdmVIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IoaXNTaGFsbG93MiA9IGZhbHNlKSB7XG4gICAgc3VwZXIodHJ1ZSwgaXNTaGFsbG93Mik7XG4gIH1cbiAgc2V0KHRhcmdldCwga2V5KSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBTZXQgb3BlcmF0aW9uIG9uIGtleSBcIiR7U3RyaW5nKGtleSl9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCxcbiAgICAgICAgdGFyZ2V0XG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgRGVsZXRlIG9wZXJhdGlvbiBvbiBrZXkgXCIke1N0cmluZyhrZXkpfVwiIGZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsXG4gICAgICAgIHRhcmdldFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmNvbnN0IG11dGFibGVIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTXV0YWJsZVJlYWN0aXZlSGFuZGxlcigpO1xuY29uc3QgcmVhZG9ubHlIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUmVhZG9ubHlSZWFjdGl2ZUhhbmRsZXIoKTtcbmNvbnN0IHNoYWxsb3dSZWFjdGl2ZUhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNdXRhYmxlUmVhY3RpdmVIYW5kbGVyKHRydWUpO1xuY29uc3Qgc2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlYWRvbmx5UmVhY3RpdmVIYW5kbGVyKHRydWUpO1xuXG5jb25zdCB0b1NoYWxsb3cgPSAodmFsdWUpID0+IHZhbHVlO1xuY29uc3QgZ2V0UHJvdG8gPSAodikgPT4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZih2KTtcbmZ1bmN0aW9uIGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgaXNSZWFkb25seTIsIGlzU2hhbGxvdzIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiXTtcbiAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICAgIGNvbnN0IHRhcmdldElzTWFwID0gaXNNYXAocmF3VGFyZ2V0KTtcbiAgICBjb25zdCBpc1BhaXIgPSBtZXRob2QgPT09IFwiZW50cmllc1wiIHx8IG1ldGhvZCA9PT0gU3ltYm9sLml0ZXJhdG9yICYmIHRhcmdldElzTWFwO1xuICAgIGNvbnN0IGlzS2V5T25seSA9IG1ldGhvZCA9PT0gXCJrZXlzXCIgJiYgdGFyZ2V0SXNNYXA7XG4gICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRhcmdldFttZXRob2RdKC4uLmFyZ3MpO1xuICAgIGNvbnN0IHdyYXAgPSBpc1NoYWxsb3cyID8gdG9TaGFsbG93IDogaXNSZWFkb25seTIgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcbiAgICAhaXNSZWFkb25seTIgJiYgdHJhY2soXG4gICAgICByYXdUYXJnZXQsXG4gICAgICBcIml0ZXJhdGVcIixcbiAgICAgIGlzS2V5T25seSA/IE1BUF9LRVlfSVRFUkFURV9LRVkgOiBJVEVSQVRFX0tFWVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIGl0ZXJhdG9yIHByb3RvY29sXG4gICAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBpbm5lckl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIGRvbmUgPyB7IHZhbHVlLCBkb25lIH0gOiB7XG4gICAgICAgICAgdmFsdWU6IGlzUGFpciA/IFt3cmFwKHZhbHVlWzBdKSwgd3JhcCh2YWx1ZVsxXSldIDogd3JhcCh2YWx1ZSksXG4gICAgICAgICAgZG9uZVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIC8vIGl0ZXJhYmxlIHByb3RvY29sXG4gICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlYWRvbmx5TWV0aG9kKHR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgY29uc3Qga2V5ID0gYXJnc1swXSA/IGBvbiBrZXkgXCIke2FyZ3NbMF19XCIgYCA6IGBgO1xuICAgICAgd2FybihcbiAgICAgICAgYCR7Y2FwaXRhbGl6ZSh0eXBlKX0gb3BlcmF0aW9uICR7a2V5fWZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsXG4gICAgICAgIHRvUmF3KHRoaXMpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZSA9PT0gXCJkZWxldGVcIiA/IGZhbHNlIDogdHlwZSA9PT0gXCJjbGVhclwiID8gdm9pZCAwIDogdGhpcztcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluc3RydW1lbnRhdGlvbnMocmVhZG9ubHksIHNoYWxsb3cpIHtcbiAgY29uc3QgaW5zdHJ1bWVudGF0aW9ucyA9IHtcbiAgICBnZXQoa2V5KSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiXTtcbiAgICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XG4gICAgICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xuICAgICAgaWYgKCFyZWFkb25seSkge1xuICAgICAgICBpZiAoaGFzQ2hhbmdlZChrZXksIHJhd0tleSkpIHtcbiAgICAgICAgICB0cmFjayhyYXdUYXJnZXQsIFwiZ2V0XCIsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2socmF3VGFyZ2V0LCBcImdldFwiLCByYXdLZXkpO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBoYXMgfSA9IGdldFByb3RvKHJhd1RhcmdldCk7XG4gICAgICBjb25zdCB3cmFwID0gc2hhbGxvdyA/IHRvU2hhbGxvdyA6IHJlYWRvbmx5ID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XG4gICAgICBpZiAoaGFzLmNhbGwocmF3VGFyZ2V0LCBrZXkpKSB7XG4gICAgICAgIHJldHVybiB3cmFwKHRhcmdldC5nZXQoa2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKGhhcy5jYWxsKHJhd1RhcmdldCwgcmF3S2V5KSkge1xuICAgICAgICByZXR1cm4gd3JhcCh0YXJnZXQuZ2V0KHJhd0tleSkpO1xuICAgICAgfSBlbHNlIGlmICh0YXJnZXQgIT09IHJhd1RhcmdldCkge1xuICAgICAgICB0YXJnZXQuZ2V0KGtleSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXNbXCJfX3ZfcmF3XCJdO1xuICAgICAgIXJlYWRvbmx5ICYmIHRyYWNrKHRvUmF3KHRhcmdldCksIFwiaXRlcmF0ZVwiLCBJVEVSQVRFX0tFWSk7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBcInNpemVcIiwgdGFyZ2V0KTtcbiAgICB9LFxuICAgIGhhcyhrZXkpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXNbXCJfX3ZfcmF3XCJdO1xuICAgICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcbiAgICAgIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XG4gICAgICBpZiAoIXJlYWRvbmx5KSB7XG4gICAgICAgIGlmIChoYXNDaGFuZ2VkKGtleSwgcmF3S2V5KSkge1xuICAgICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJoYXNcIiwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0cmFjayhyYXdUYXJnZXQsIFwiaGFzXCIsIHJhd0tleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5ID09PSByYXdLZXkgPyB0YXJnZXQuaGFzKGtleSkgOiB0YXJnZXQuaGFzKGtleSkgfHwgdGFyZ2V0LmhhcyhyYXdLZXkpO1xuICAgIH0sXG4gICAgZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgY29uc3Qgb2JzZXJ2ZWQgPSB0aGlzO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gb2JzZXJ2ZWRbXCJfX3ZfcmF3XCJdO1xuICAgICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcbiAgICAgIGNvbnN0IHdyYXAgPSBzaGFsbG93ID8gdG9TaGFsbG93IDogcmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcbiAgICAgICFyZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiaXRlcmF0ZVwiLCBJVEVSQVRFX0tFWSk7XG4gICAgICByZXR1cm4gdGFyZ2V0LmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgd3JhcCh2YWx1ZSksIHdyYXAoa2V5KSwgb2JzZXJ2ZWQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBleHRlbmQoXG4gICAgaW5zdHJ1bWVudGF0aW9ucyxcbiAgICByZWFkb25seSA/IHtcbiAgICAgIGFkZDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJhZGRcIiksXG4gICAgICBzZXQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwic2V0XCIpLFxuICAgICAgZGVsZXRlOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImRlbGV0ZVwiKSxcbiAgICAgIGNsZWFyOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImNsZWFyXCIpXG4gICAgfSA6IHtcbiAgICAgIGFkZCh2YWx1ZSkge1xuICAgICAgICBpZiAoIXNoYWxsb3cgJiYgIWlzU2hhbGxvdyh2YWx1ZSkgJiYgIWlzUmVhZG9ubHkodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XG4gICAgICAgIGNvbnN0IHByb3RvID0gZ2V0UHJvdG8odGFyZ2V0KTtcbiAgICAgICAgY29uc3QgaGFkS2V5ID0gcHJvdG8uaGFzLmNhbGwodGFyZ2V0LCB2YWx1ZSk7XG4gICAgICAgIGlmICghaGFkS2V5KSB7XG4gICAgICAgICAgdGFyZ2V0LmFkZCh2YWx1ZSk7XG4gICAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIsIHZhbHVlLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCFzaGFsbG93ICYmICFpc1NoYWxsb3codmFsdWUpICYmICFpc1JlYWRvbmx5KHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xuICAgICAgICBjb25zdCB7IGhhcywgZ2V0IH0gPSBnZXRQcm90byh0YXJnZXQpO1xuICAgICAgICBsZXQgaGFkS2V5ID0gaGFzLmNhbGwodGFyZ2V0LCBrZXkpO1xuICAgICAgICBpZiAoIWhhZEtleSkge1xuICAgICAgICAgIGtleSA9IHRvUmF3KGtleSk7XG4gICAgICAgICAgaGFkS2V5ID0gaGFzLmNhbGwodGFyZ2V0LCBrZXkpO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhcywga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IGdldC5jYWxsKHRhcmdldCwga2V5KTtcbiAgICAgICAgdGFyZ2V0LnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgaWYgKCFoYWRLZXkpIHtcbiAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFzQ2hhbmdlZCh2YWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwic2V0XCIsIGtleSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xuICAgICAgICBjb25zdCB7IGhhcywgZ2V0IH0gPSBnZXRQcm90byh0YXJnZXQpO1xuICAgICAgICBsZXQgaGFkS2V5ID0gaGFzLmNhbGwodGFyZ2V0LCBrZXkpO1xuICAgICAgICBpZiAoIWhhZEtleSkge1xuICAgICAgICAgIGtleSA9IHRvUmF3KGtleSk7XG4gICAgICAgICAgaGFkS2V5ID0gaGFzLmNhbGwodGFyZ2V0LCBrZXkpO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhcywga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IGdldCA/IGdldC5jYWxsKHRhcmdldCwga2V5KSA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGFyZ2V0LmRlbGV0ZShrZXkpO1xuICAgICAgICBpZiAoaGFkS2V5KSB7XG4gICAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiZGVsZXRlXCIsIGtleSwgdm9pZCAwLCBvbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICBjbGVhcigpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XG4gICAgICAgIGNvbnN0IGhhZEl0ZW1zID0gdGFyZ2V0LnNpemUgIT09IDA7XG4gICAgICAgIGNvbnN0IG9sZFRhcmdldCA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBpc01hcCh0YXJnZXQpID8gbmV3IE1hcCh0YXJnZXQpIDogbmV3IFNldCh0YXJnZXQpIDogdm9pZCAwO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0YXJnZXQuY2xlYXIoKTtcbiAgICAgICAgaWYgKGhhZEl0ZW1zKSB7XG4gICAgICAgICAgdHJpZ2dlcihcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIFwiY2xlYXJcIixcbiAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgIG9sZFRhcmdldFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIGNvbnN0IGl0ZXJhdG9yTWV0aG9kcyA9IFtcbiAgICBcImtleXNcIixcbiAgICBcInZhbHVlc1wiLFxuICAgIFwiZW50cmllc1wiLFxuICAgIFN5bWJvbC5pdGVyYXRvclxuICBdO1xuICBpdGVyYXRvck1ldGhvZHMuZm9yRWFjaCgobWV0aG9kKSA9PiB7XG4gICAgaW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCByZWFkb25seSwgc2hhbGxvdyk7XG4gIH0pO1xuICByZXR1cm4gaW5zdHJ1bWVudGF0aW9ucztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihpc1JlYWRvbmx5Miwgc2hhbGxvdykge1xuICBjb25zdCBpbnN0cnVtZW50YXRpb25zID0gY3JlYXRlSW5zdHJ1bWVudGF0aW9ucyhpc1JlYWRvbmx5Miwgc2hhbGxvdyk7XG4gIHJldHVybiAodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSA9PiB7XG4gICAgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFjdGl2ZVwiKSB7XG4gICAgICByZXR1cm4gIWlzUmVhZG9ubHkyO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWRvbmx5XCIpIHtcbiAgICAgIHJldHVybiBpc1JlYWRvbmx5MjtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfcmF3XCIpIHtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIHJldHVybiBSZWZsZWN0LmdldChcbiAgICAgIGhhc093bihpbnN0cnVtZW50YXRpb25zLCBrZXkpICYmIGtleSBpbiB0YXJnZXQgPyBpbnN0cnVtZW50YXRpb25zIDogdGFyZ2V0LFxuICAgICAga2V5LFxuICAgICAgcmVjZWl2ZXJcbiAgICApO1xuICB9O1xufVxuY29uc3QgbXV0YWJsZUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgZ2V0OiAvKiBAX19QVVJFX18gKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGZhbHNlLCBmYWxzZSlcbn07XG5jb25zdCBzaGFsbG93Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICBnZXQ6IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoZmFsc2UsIHRydWUpXG59O1xuY29uc3QgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gIGdldDogLyogQF9fUFVSRV9fICovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcih0cnVlLCBmYWxzZSlcbn07XG5jb25zdCBzaGFsbG93UmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gIGdldDogLyogQF9fUFVSRV9fICovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcih0cnVlLCB0cnVlKVxufTtcbmZ1bmN0aW9uIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzLCBrZXkpIHtcbiAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcbiAgaWYgKHJhd0tleSAhPT0ga2V5ICYmIGhhcy5jYWxsKHRhcmdldCwgcmF3S2V5KSkge1xuICAgIGNvbnN0IHR5cGUgPSB0b1Jhd1R5cGUodGFyZ2V0KTtcbiAgICB3YXJuKFxuICAgICAgYFJlYWN0aXZlICR7dHlwZX0gY29udGFpbnMgYm90aCB0aGUgcmF3IGFuZCByZWFjdGl2ZSB2ZXJzaW9ucyBvZiB0aGUgc2FtZSBvYmplY3Qke3R5cGUgPT09IGBNYXBgID8gYCBhcyBrZXlzYCA6IGBgfSwgd2hpY2ggY2FuIGxlYWQgdG8gaW5jb25zaXN0ZW5jaWVzLiBBdm9pZCBkaWZmZXJlbnRpYXRpbmcgYmV0d2VlbiB0aGUgcmF3IGFuZCByZWFjdGl2ZSB2ZXJzaW9ucyBvZiBhbiBvYmplY3QgYW5kIG9ubHkgdXNlIHRoZSByZWFjdGl2ZSB2ZXJzaW9uIGlmIHBvc3NpYmxlLmBcbiAgICApO1xuICB9XG59XG5cbmNvbnN0IHJlYWN0aXZlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBzaGFsbG93UmVhY3RpdmVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHJlYWRvbmx5TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBzaGFsbG93UmVhZG9ubHlNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHRhcmdldFR5cGVNYXAocmF3VHlwZSkge1xuICBzd2l0Y2ggKHJhd1R5cGUpIHtcbiAgICBjYXNlIFwiT2JqZWN0XCI6XG4gICAgY2FzZSBcIkFycmF5XCI6XG4gICAgICByZXR1cm4gMSAvKiBDT01NT04gKi87XG4gICAgY2FzZSBcIk1hcFwiOlxuICAgIGNhc2UgXCJTZXRcIjpcbiAgICBjYXNlIFwiV2Vha01hcFwiOlxuICAgIGNhc2UgXCJXZWFrU2V0XCI6XG4gICAgICByZXR1cm4gMiAvKiBDT0xMRUNUSU9OICovO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gMCAvKiBJTlZBTElEICovO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUYXJnZXRUeXBlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZVtcIl9fdl9za2lwXCJdIHx8ICFPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSA/IDAgLyogSU5WQUxJRCAqLyA6IHRhcmdldFR5cGVNYXAodG9SYXdUeXBlKHZhbHVlKSk7XG59XG5mdW5jdGlvbiByZWFjdGl2ZSh0YXJnZXQpIHtcbiAgaWYgKGlzUmVhZG9ubHkodGFyZ2V0KSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KFxuICAgIHRhcmdldCxcbiAgICBmYWxzZSxcbiAgICBtdXRhYmxlSGFuZGxlcnMsXG4gICAgbXV0YWJsZUNvbGxlY3Rpb25IYW5kbGVycyxcbiAgICByZWFjdGl2ZU1hcFxuICApO1xufVxuZnVuY3Rpb24gc2hhbGxvd1JlYWN0aXZlKHRhcmdldCkge1xuICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QoXG4gICAgdGFyZ2V0LFxuICAgIGZhbHNlLFxuICAgIHNoYWxsb3dSZWFjdGl2ZUhhbmRsZXJzLFxuICAgIHNoYWxsb3dDb2xsZWN0aW9uSGFuZGxlcnMsXG4gICAgc2hhbGxvd1JlYWN0aXZlTWFwXG4gICk7XG59XG5mdW5jdGlvbiByZWFkb25seSh0YXJnZXQpIHtcbiAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KFxuICAgIHRhcmdldCxcbiAgICB0cnVlLFxuICAgIHJlYWRvbmx5SGFuZGxlcnMsXG4gICAgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMsXG4gICAgcmVhZG9ubHlNYXBcbiAgKTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dSZWFkb25seSh0YXJnZXQpIHtcbiAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KFxuICAgIHRhcmdldCxcbiAgICB0cnVlLFxuICAgIHNoYWxsb3dSZWFkb25seUhhbmRsZXJzLFxuICAgIHNoYWxsb3dSZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyxcbiAgICBzaGFsbG93UmVhZG9ubHlNYXBcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgaXNSZWFkb25seTIsIGJhc2VIYW5kbGVycywgY29sbGVjdGlvbkhhbmRsZXJzLCBwcm94eU1hcCkge1xuICBpZiAoIWlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybihcbiAgICAgICAgYHZhbHVlIGNhbm5vdCBiZSBtYWRlICR7aXNSZWFkb25seTIgPyBcInJlYWRvbmx5XCIgOiBcInJlYWN0aXZlXCJ9OiAke1N0cmluZyhcbiAgICAgICAgICB0YXJnZXRcbiAgICAgICAgKX1gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGlmICh0YXJnZXRbXCJfX3ZfcmF3XCJdICYmICEoaXNSZWFkb25seTIgJiYgdGFyZ2V0W1wiX192X2lzUmVhY3RpdmVcIl0pKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBjb25zdCBleGlzdGluZ1Byb3h5ID0gcHJveHlNYXAuZ2V0KHRhcmdldCk7XG4gIGlmIChleGlzdGluZ1Byb3h5KSB7XG4gICAgcmV0dXJuIGV4aXN0aW5nUHJveHk7XG4gIH1cbiAgY29uc3QgdGFyZ2V0VHlwZSA9IGdldFRhcmdldFR5cGUodGFyZ2V0KTtcbiAgaWYgKHRhcmdldFR5cGUgPT09IDAgLyogSU5WQUxJRCAqLykge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoXG4gICAgdGFyZ2V0LFxuICAgIHRhcmdldFR5cGUgPT09IDIgLyogQ09MTEVDVElPTiAqLyA/IGNvbGxlY3Rpb25IYW5kbGVycyA6IGJhc2VIYW5kbGVyc1xuICApO1xuICBwcm94eU1hcC5zZXQodGFyZ2V0LCBwcm94eSk7XG4gIHJldHVybiBwcm94eTtcbn1cbmZ1bmN0aW9uIGlzUmVhY3RpdmUodmFsdWUpIHtcbiAgaWYgKGlzUmVhZG9ubHkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGlzUmVhY3RpdmUodmFsdWVbXCJfX3ZfcmF3XCJdKTtcbiAgfVxuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNSZWFjdGl2ZVwiXSk7XG59XG5mdW5jdGlvbiBpc1JlYWRvbmx5KHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1JlYWRvbmx5XCJdKTtcbn1cbmZ1bmN0aW9uIGlzU2hhbGxvdyh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNTaGFsbG93XCJdKTtcbn1cbmZ1bmN0aW9uIGlzUHJveHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID8gISF2YWx1ZVtcIl9fdl9yYXdcIl0gOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHRvUmF3KG9ic2VydmVkKSB7XG4gIGNvbnN0IHJhdyA9IG9ic2VydmVkICYmIG9ic2VydmVkW1wiX192X3Jhd1wiXTtcbiAgcmV0dXJuIHJhdyA/IHRvUmF3KHJhdykgOiBvYnNlcnZlZDtcbn1cbmZ1bmN0aW9uIG1hcmtSYXcodmFsdWUpIHtcbiAgaWYgKCFoYXNPd24odmFsdWUsIFwiX192X3NraXBcIikgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkpIHtcbiAgICBkZWYodmFsdWUsIFwiX192X3NraXBcIiwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3QgdG9SZWFjdGl2ZSA9ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpID8gcmVhY3RpdmUodmFsdWUpIDogdmFsdWU7XG5jb25zdCB0b1JlYWRvbmx5ID0gKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgPyByZWFkb25seSh2YWx1ZSkgOiB2YWx1ZTtcblxuZnVuY3Rpb24gaXNSZWYocikge1xuICByZXR1cm4gciA/IHJbXCJfX3ZfaXNSZWZcIl0gPT09IHRydWUgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJlZih2YWx1ZSkge1xuICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlLCBmYWxzZSk7XG59XG5mdW5jdGlvbiBzaGFsbG93UmVmKHZhbHVlKSB7XG4gIHJldHVybiBjcmVhdGVSZWYodmFsdWUsIHRydWUpO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVmKHJhd1ZhbHVlLCBzaGFsbG93KSB7XG4gIGlmIChpc1JlZihyYXdWYWx1ZSkpIHtcbiAgICByZXR1cm4gcmF3VmFsdWU7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZWZJbXBsKHJhd1ZhbHVlLCBzaGFsbG93KTtcbn1cbmNsYXNzIFJlZkltcGwge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgaXNTaGFsbG93Mikge1xuICAgIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICAgIHRoaXNbXCJfX3ZfaXNSZWZcIl0gPSB0cnVlO1xuICAgIHRoaXNbXCJfX3ZfaXNTaGFsbG93XCJdID0gZmFsc2U7XG4gICAgdGhpcy5fcmF3VmFsdWUgPSBpc1NoYWxsb3cyID8gdmFsdWUgOiB0b1Jhdyh2YWx1ZSk7XG4gICAgdGhpcy5fdmFsdWUgPSBpc1NoYWxsb3cyID8gdmFsdWUgOiB0b1JlYWN0aXZlKHZhbHVlKTtcbiAgICB0aGlzW1wiX192X2lzU2hhbGxvd1wiXSA9IGlzU2hhbGxvdzI7XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB0aGlzLmRlcC50cmFjayh7XG4gICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgICAgdHlwZTogXCJnZXRcIixcbiAgICAgICAga2V5OiBcInZhbHVlXCJcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlcC50cmFjaygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cbiAgc2V0IHZhbHVlKG5ld1ZhbHVlKSB7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLl9yYXdWYWx1ZTtcbiAgICBjb25zdCB1c2VEaXJlY3RWYWx1ZSA9IHRoaXNbXCJfX3ZfaXNTaGFsbG93XCJdIHx8IGlzU2hhbGxvdyhuZXdWYWx1ZSkgfHwgaXNSZWFkb25seShuZXdWYWx1ZSk7XG4gICAgbmV3VmFsdWUgPSB1c2VEaXJlY3RWYWx1ZSA/IG5ld1ZhbHVlIDogdG9SYXcobmV3VmFsdWUpO1xuICAgIGlmIChoYXNDaGFuZ2VkKG5ld1ZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICAgIHRoaXMuX3Jhd1ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICB0aGlzLl92YWx1ZSA9IHVzZURpcmVjdFZhbHVlID8gbmV3VmFsdWUgOiB0b1JlYWN0aXZlKG5ld1ZhbHVlKTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIHRoaXMuZGVwLnRyaWdnZXIoe1xuICAgICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgICAgICAgIG5ld1ZhbHVlLFxuICAgICAgICAgIG9sZFZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZXAudHJpZ2dlcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdHJpZ2dlclJlZihyZWYyKSB7XG4gIGlmIChyZWYyLmRlcCkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICByZWYyLmRlcC50cmlnZ2VyKHtcbiAgICAgICAgdGFyZ2V0OiByZWYyLFxuICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICBrZXk6IFwidmFsdWVcIixcbiAgICAgICAgbmV3VmFsdWU6IHJlZjIuX3ZhbHVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVmMi5kZXAudHJpZ2dlcigpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdW5yZWYocmVmMikge1xuICByZXR1cm4gaXNSZWYocmVmMikgPyByZWYyLnZhbHVlIDogcmVmMjtcbn1cbmZ1bmN0aW9uIHRvVmFsdWUoc291cmNlKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKHNvdXJjZSkgPyBzb3VyY2UoKSA6IHVucmVmKHNvdXJjZSk7XG59XG5jb25zdCBzaGFsbG93VW53cmFwSGFuZGxlcnMgPSB7XG4gIGdldDogKHRhcmdldCwga2V5LCByZWNlaXZlcikgPT4ga2V5ID09PSBcIl9fdl9yYXdcIiA/IHRhcmdldCA6IHVucmVmKFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcikpLFxuICBzZXQ6ICh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSA9PiB7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcbiAgICBpZiAoaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcbiAgICAgIG9sZFZhbHVlLnZhbHVlID0gdmFsdWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFJlZmxlY3Quc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIHByb3h5UmVmcyhvYmplY3RXaXRoUmVmcykge1xuICByZXR1cm4gaXNSZWFjdGl2ZShvYmplY3RXaXRoUmVmcykgPyBvYmplY3RXaXRoUmVmcyA6IG5ldyBQcm94eShvYmplY3RXaXRoUmVmcywgc2hhbGxvd1Vud3JhcEhhbmRsZXJzKTtcbn1cbmNsYXNzIEN1c3RvbVJlZkltcGwge1xuICBjb25zdHJ1Y3RvcihmYWN0b3J5KSB7XG4gICAgdGhpc1tcIl9fdl9pc1JlZlwiXSA9IHRydWU7XG4gICAgdGhpcy5fdmFsdWUgPSB2b2lkIDA7XG4gICAgY29uc3QgZGVwID0gdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gICAgY29uc3QgeyBnZXQsIHNldCB9ID0gZmFjdG9yeShkZXAudHJhY2suYmluZChkZXApLCBkZXAudHJpZ2dlci5iaW5kKGRlcCkpO1xuICAgIHRoaXMuX2dldCA9IGdldDtcbiAgICB0aGlzLl9zZXQgPSBzZXQ7XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZSA9IHRoaXMuX2dldCgpO1xuICB9XG4gIHNldCB2YWx1ZShuZXdWYWwpIHtcbiAgICB0aGlzLl9zZXQobmV3VmFsKTtcbiAgfVxufVxuZnVuY3Rpb24gY3VzdG9tUmVmKGZhY3RvcnkpIHtcbiAgcmV0dXJuIG5ldyBDdXN0b21SZWZJbXBsKGZhY3RvcnkpO1xufVxuZnVuY3Rpb24gdG9SZWZzKG9iamVjdCkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNQcm94eShvYmplY3QpKSB7XG4gICAgd2FybihgdG9SZWZzKCkgZXhwZWN0cyBhIHJlYWN0aXZlIG9iamVjdCBidXQgcmVjZWl2ZWQgYSBwbGFpbiBvbmUuYCk7XG4gIH1cbiAgY29uc3QgcmV0ID0gaXNBcnJheShvYmplY3QpID8gbmV3IEFycmF5KG9iamVjdC5sZW5ndGgpIDoge307XG4gIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgIHJldFtrZXldID0gcHJvcGVydHlUb1JlZihvYmplY3QsIGtleSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmNsYXNzIE9iamVjdFJlZkltcGwge1xuICBjb25zdHJ1Y3Rvcihfb2JqZWN0LCBfa2V5LCBfZGVmYXVsdFZhbHVlKSB7XG4gICAgdGhpcy5fb2JqZWN0ID0gX29iamVjdDtcbiAgICB0aGlzLl9rZXkgPSBfa2V5O1xuICAgIHRoaXMuX2RlZmF1bHRWYWx1ZSA9IF9kZWZhdWx0VmFsdWU7XG4gICAgdGhpc1tcIl9fdl9pc1JlZlwiXSA9IHRydWU7XG4gICAgdGhpcy5fdmFsdWUgPSB2b2lkIDA7XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIGNvbnN0IHZhbCA9IHRoaXMuX29iamVjdFt0aGlzLl9rZXldO1xuICAgIHJldHVybiB0aGlzLl92YWx1ZSA9IHZhbCA9PT0gdm9pZCAwID8gdGhpcy5fZGVmYXVsdFZhbHVlIDogdmFsO1xuICB9XG4gIHNldCB2YWx1ZShuZXdWYWwpIHtcbiAgICB0aGlzLl9vYmplY3RbdGhpcy5fa2V5XSA9IG5ld1ZhbDtcbiAgfVxuICBnZXQgZGVwKCkge1xuICAgIHJldHVybiBnZXREZXBGcm9tUmVhY3RpdmUodG9SYXcodGhpcy5fb2JqZWN0KSwgdGhpcy5fa2V5KTtcbiAgfVxufVxuY2xhc3MgR2V0dGVyUmVmSW1wbCB7XG4gIGNvbnN0cnVjdG9yKF9nZXR0ZXIpIHtcbiAgICB0aGlzLl9nZXR0ZXIgPSBfZ2V0dGVyO1xuICAgIHRoaXNbXCJfX3ZfaXNSZWZcIl0gPSB0cnVlO1xuICAgIHRoaXNbXCJfX3ZfaXNSZWFkb25seVwiXSA9IHRydWU7XG4gICAgdGhpcy5fdmFsdWUgPSB2b2lkIDA7XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZSA9IHRoaXMuX2dldHRlcigpO1xuICB9XG59XG5mdW5jdGlvbiB0b1JlZihzb3VyY2UsIGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmIChpc1JlZihzb3VyY2UpKSB7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHNvdXJjZSkpIHtcbiAgICByZXR1cm4gbmV3IEdldHRlclJlZkltcGwoc291cmNlKTtcbiAgfSBlbHNlIGlmIChpc09iamVjdChzb3VyY2UpICYmIGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5VG9SZWYoc291cmNlLCBrZXksIGRlZmF1bHRWYWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlZihzb3VyY2UpO1xuICB9XG59XG5mdW5jdGlvbiBwcm9wZXJ0eVRvUmVmKHNvdXJjZSwga2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgY29uc3QgdmFsID0gc291cmNlW2tleV07XG4gIHJldHVybiBpc1JlZih2YWwpID8gdmFsIDogbmV3IE9iamVjdFJlZkltcGwoc291cmNlLCBrZXksIGRlZmF1bHRWYWx1ZSk7XG59XG5cbmNsYXNzIENvbXB1dGVkUmVmSW1wbCB7XG4gIGNvbnN0cnVjdG9yKGZuLCBzZXR0ZXIsIGlzU1NSKSB7XG4gICAgdGhpcy5mbiA9IGZuO1xuICAgIHRoaXMuc2V0dGVyID0gc2V0dGVyO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX3ZhbHVlID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZGVwID0gbmV3IERlcCh0aGlzKTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XG4gICAgLy8gVE9ETyBpc29sYXRlZERlY2xhcmF0aW9ucyBcIl9fdl9pc1JlYWRvbmx5XCJcbiAgICAvLyBBIGNvbXB1dGVkIGlzIGFsc28gYSBzdWJzY3JpYmVyIHRoYXQgdHJhY2tzIG90aGVyIGRlcHNcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmRlcHMgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5kZXBzVGFpbCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmZsYWdzID0gMTY7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5nbG9iYWxWZXJzaW9uID0gZ2xvYmFsVmVyc2lvbiAtIDE7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5uZXh0ID0gdm9pZCAwO1xuICAgIC8vIGZvciBiYWNrd2FyZHMgY29tcGF0XG4gICAgdGhpcy5lZmZlY3QgPSB0aGlzO1xuICAgIHRoaXNbXCJfX3ZfaXNSZWFkb25seVwiXSA9ICFzZXR0ZXI7XG4gICAgdGhpcy5pc1NTUiA9IGlzU1NSO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG5vdGlmeSgpIHtcbiAgICB0aGlzLmZsYWdzIHw9IDE2O1xuICAgIGlmICghKHRoaXMuZmxhZ3MgJiA4KSAmJiAvLyBhdm9pZCBpbmZpbml0ZSBzZWxmIHJlY3Vyc2lvblxuICAgIGFjdGl2ZVN1YiAhPT0gdGhpcykge1xuICAgICAgYmF0Y2godGhpcywgdHJ1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIDtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgY29uc3QgbGluayA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyB0aGlzLmRlcC50cmFjayh7XG4gICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICB0eXBlOiBcImdldFwiLFxuICAgICAga2V5OiBcInZhbHVlXCJcbiAgICB9KSA6IHRoaXMuZGVwLnRyYWNrKCk7XG4gICAgcmVmcmVzaENvbXB1dGVkKHRoaXMpO1xuICAgIGlmIChsaW5rKSB7XG4gICAgICBsaW5rLnZlcnNpb24gPSB0aGlzLmRlcC52ZXJzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cbiAgc2V0IHZhbHVlKG5ld1ZhbHVlKSB7XG4gICAgaWYgKHRoaXMuc2V0dGVyKSB7XG4gICAgICB0aGlzLnNldHRlcihuZXdWYWx1ZSk7XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuKFwiV3JpdGUgb3BlcmF0aW9uIGZhaWxlZDogY29tcHV0ZWQgdmFsdWUgaXMgcmVhZG9ubHlcIik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjb21wdXRlZChnZXR0ZXJPck9wdGlvbnMsIGRlYnVnT3B0aW9ucywgaXNTU1IgPSBmYWxzZSkge1xuICBsZXQgZ2V0dGVyO1xuICBsZXQgc2V0dGVyO1xuICBpZiAoaXNGdW5jdGlvbihnZXR0ZXJPck9wdGlvbnMpKSB7XG4gICAgZ2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zO1xuICB9IGVsc2Uge1xuICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucy5nZXQ7XG4gICAgc2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLnNldDtcbiAgfVxuICBjb25zdCBjUmVmID0gbmV3IENvbXB1dGVkUmVmSW1wbChnZXR0ZXIsIHNldHRlciwgaXNTU1IpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBkZWJ1Z09wdGlvbnMgJiYgIWlzU1NSKSB7XG4gICAgY1JlZi5vblRyYWNrID0gZGVidWdPcHRpb25zLm9uVHJhY2s7XG4gICAgY1JlZi5vblRyaWdnZXIgPSBkZWJ1Z09wdGlvbnMub25UcmlnZ2VyO1xuICB9XG4gIHJldHVybiBjUmVmO1xufVxuXG5jb25zdCBUcmFja09wVHlwZXMgPSB7XG4gIFwiR0VUXCI6IFwiZ2V0XCIsXG4gIFwiSEFTXCI6IFwiaGFzXCIsXG4gIFwiSVRFUkFURVwiOiBcIml0ZXJhdGVcIlxufTtcbmNvbnN0IFRyaWdnZXJPcFR5cGVzID0ge1xuICBcIlNFVFwiOiBcInNldFwiLFxuICBcIkFERFwiOiBcImFkZFwiLFxuICBcIkRFTEVURVwiOiBcImRlbGV0ZVwiLFxuICBcIkNMRUFSXCI6IFwiY2xlYXJcIlxufTtcbmNvbnN0IFJlYWN0aXZlRmxhZ3MgPSB7XG4gIFwiU0tJUFwiOiBcIl9fdl9za2lwXCIsXG4gIFwiSVNfUkVBQ1RJVkVcIjogXCJfX3ZfaXNSZWFjdGl2ZVwiLFxuICBcIklTX1JFQURPTkxZXCI6IFwiX192X2lzUmVhZG9ubHlcIixcbiAgXCJJU19TSEFMTE9XXCI6IFwiX192X2lzU2hhbGxvd1wiLFxuICBcIlJBV1wiOiBcIl9fdl9yYXdcIixcbiAgXCJJU19SRUZcIjogXCJfX3ZfaXNSZWZcIlxufTtcblxuY29uc3QgV2F0Y2hFcnJvckNvZGVzID0ge1xuICBcIldBVENIX0dFVFRFUlwiOiAyLFxuICBcIjJcIjogXCJXQVRDSF9HRVRURVJcIixcbiAgXCJXQVRDSF9DQUxMQkFDS1wiOiAzLFxuICBcIjNcIjogXCJXQVRDSF9DQUxMQkFDS1wiLFxuICBcIldBVENIX0NMRUFOVVBcIjogNCxcbiAgXCI0XCI6IFwiV0FUQ0hfQ0xFQU5VUFwiXG59O1xuY29uc3QgSU5JVElBTF9XQVRDSEVSX1ZBTFVFID0ge307XG5jb25zdCBjbGVhbnVwTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5sZXQgYWN0aXZlV2F0Y2hlciA9IHZvaWQgMDtcbmZ1bmN0aW9uIGdldEN1cnJlbnRXYXRjaGVyKCkge1xuICByZXR1cm4gYWN0aXZlV2F0Y2hlcjtcbn1cbmZ1bmN0aW9uIG9uV2F0Y2hlckNsZWFudXAoY2xlYW51cEZuLCBmYWlsU2lsZW50bHkgPSBmYWxzZSwgb3duZXIgPSBhY3RpdmVXYXRjaGVyKSB7XG4gIGlmIChvd25lcikge1xuICAgIGxldCBjbGVhbnVwcyA9IGNsZWFudXBNYXAuZ2V0KG93bmVyKTtcbiAgICBpZiAoIWNsZWFudXBzKSBjbGVhbnVwTWFwLnNldChvd25lciwgY2xlYW51cHMgPSBbXSk7XG4gICAgY2xlYW51cHMucHVzaChjbGVhbnVwRm4pO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWZhaWxTaWxlbnRseSkge1xuICAgIHdhcm4oXG4gICAgICBgb25XYXRjaGVyQ2xlYW51cCgpIHdhcyBjYWxsZWQgd2hlbiB0aGVyZSB3YXMgbm8gYWN0aXZlIHdhdGNoZXIgdG8gYXNzb2NpYXRlIHdpdGguYFxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMgPSBFTVBUWV9PQkopIHtcbiAgY29uc3QgeyBpbW1lZGlhdGUsIGRlZXAsIG9uY2UsIHNjaGVkdWxlciwgYXVnbWVudEpvYiwgY2FsbCB9ID0gb3B0aW9ucztcbiAgY29uc3Qgd2FybkludmFsaWRTb3VyY2UgPSAocykgPT4ge1xuICAgIChvcHRpb25zLm9uV2FybiB8fCB3YXJuKShcbiAgICAgIGBJbnZhbGlkIHdhdGNoIHNvdXJjZTogYCxcbiAgICAgIHMsXG4gICAgICBgQSB3YXRjaCBzb3VyY2UgY2FuIG9ubHkgYmUgYSBnZXR0ZXIvZWZmZWN0IGZ1bmN0aW9uLCBhIHJlZiwgYSByZWFjdGl2ZSBvYmplY3QsIG9yIGFuIGFycmF5IG9mIHRoZXNlIHR5cGVzLmBcbiAgICApO1xuICB9O1xuICBjb25zdCByZWFjdGl2ZUdldHRlciA9IChzb3VyY2UyKSA9PiB7XG4gICAgaWYgKGRlZXApIHJldHVybiBzb3VyY2UyO1xuICAgIGlmIChpc1NoYWxsb3coc291cmNlMikgfHwgZGVlcCA9PT0gZmFsc2UgfHwgZGVlcCA9PT0gMClcbiAgICAgIHJldHVybiB0cmF2ZXJzZShzb3VyY2UyLCAxKTtcbiAgICByZXR1cm4gdHJhdmVyc2Uoc291cmNlMik7XG4gIH07XG4gIGxldCBlZmZlY3Q7XG4gIGxldCBnZXR0ZXI7XG4gIGxldCBjbGVhbnVwO1xuICBsZXQgYm91bmRDbGVhbnVwO1xuICBsZXQgZm9yY2VUcmlnZ2VyID0gZmFsc2U7XG4gIGxldCBpc011bHRpU291cmNlID0gZmFsc2U7XG4gIGlmIChpc1JlZihzb3VyY2UpKSB7XG4gICAgZ2V0dGVyID0gKCkgPT4gc291cmNlLnZhbHVlO1xuICAgIGZvcmNlVHJpZ2dlciA9IGlzU2hhbGxvdyhzb3VyY2UpO1xuICB9IGVsc2UgaWYgKGlzUmVhY3RpdmUoc291cmNlKSkge1xuICAgIGdldHRlciA9ICgpID0+IHJlYWN0aXZlR2V0dGVyKHNvdXJjZSk7XG4gICAgZm9yY2VUcmlnZ2VyID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc0FycmF5KHNvdXJjZSkpIHtcbiAgICBpc011bHRpU291cmNlID0gdHJ1ZTtcbiAgICBmb3JjZVRyaWdnZXIgPSBzb3VyY2Uuc29tZSgocykgPT4gaXNSZWFjdGl2ZShzKSB8fCBpc1NoYWxsb3cocykpO1xuICAgIGdldHRlciA9ICgpID0+IHNvdXJjZS5tYXAoKHMpID0+IHtcbiAgICAgIGlmIChpc1JlZihzKSkge1xuICAgICAgICByZXR1cm4gcy52YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNSZWFjdGl2ZShzKSkge1xuICAgICAgICByZXR1cm4gcmVhY3RpdmVHZXR0ZXIocyk7XG4gICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24ocykpIHtcbiAgICAgICAgcmV0dXJuIGNhbGwgPyBjYWxsKHMsIDIpIDogcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuSW52YWxpZFNvdXJjZShzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHNvdXJjZSkpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGdldHRlciA9IGNhbGwgPyAoKSA9PiBjYWxsKHNvdXJjZSwgMikgOiBzb3VyY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdldHRlciA9ICgpID0+IHtcbiAgICAgICAgaWYgKGNsZWFudXApIHtcbiAgICAgICAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgcmVzZXRUcmFja2luZygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50RWZmZWN0ID0gYWN0aXZlV2F0Y2hlcjtcbiAgICAgICAgYWN0aXZlV2F0Y2hlciA9IGVmZmVjdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gY2FsbCA/IGNhbGwoc291cmNlLCAzLCBbYm91bmRDbGVhbnVwXSkgOiBzb3VyY2UoYm91bmRDbGVhbnVwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBhY3RpdmVXYXRjaGVyID0gY3VycmVudEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZ2V0dGVyID0gTk9PUDtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm5JbnZhbGlkU291cmNlKHNvdXJjZSk7XG4gIH1cbiAgaWYgKGNiICYmIGRlZXApIHtcbiAgICBjb25zdCBiYXNlR2V0dGVyID0gZ2V0dGVyO1xuICAgIGNvbnN0IGRlcHRoID0gZGVlcCA9PT0gdHJ1ZSA/IEluZmluaXR5IDogZGVlcDtcbiAgICBnZXR0ZXIgPSAoKSA9PiB0cmF2ZXJzZShiYXNlR2V0dGVyKCksIGRlcHRoKTtcbiAgfVxuICBjb25zdCBzY29wZSA9IGdldEN1cnJlbnRTY29wZSgpO1xuICBjb25zdCB3YXRjaEhhbmRsZSA9ICgpID0+IHtcbiAgICBlZmZlY3Quc3RvcCgpO1xuICAgIGlmIChzY29wZSAmJiBzY29wZS5hY3RpdmUpIHtcbiAgICAgIHJlbW92ZShzY29wZS5lZmZlY3RzLCBlZmZlY3QpO1xuICAgIH1cbiAgfTtcbiAgaWYgKG9uY2UgJiYgY2IpIHtcbiAgICBjb25zdCBfY2IgPSBjYjtcbiAgICBjYiA9ICguLi5hcmdzKSA9PiB7XG4gICAgICBfY2IoLi4uYXJncyk7XG4gICAgICB3YXRjaEhhbmRsZSgpO1xuICAgIH07XG4gIH1cbiAgbGV0IG9sZFZhbHVlID0gaXNNdWx0aVNvdXJjZSA/IG5ldyBBcnJheShzb3VyY2UubGVuZ3RoKS5maWxsKElOSVRJQUxfV0FUQ0hFUl9WQUxVRSkgOiBJTklUSUFMX1dBVENIRVJfVkFMVUU7XG4gIGNvbnN0IGpvYiA9IChpbW1lZGlhdGVGaXJzdFJ1bikgPT4ge1xuICAgIGlmICghKGVmZmVjdC5mbGFncyAmIDEpIHx8ICFlZmZlY3QuZGlydHkgJiYgIWltbWVkaWF0ZUZpcnN0UnVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjYikge1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSBlZmZlY3QucnVuKCk7XG4gICAgICBpZiAoZGVlcCB8fCBmb3JjZVRyaWdnZXIgfHwgKGlzTXVsdGlTb3VyY2UgPyBuZXdWYWx1ZS5zb21lKCh2LCBpKSA9PiBoYXNDaGFuZ2VkKHYsIG9sZFZhbHVlW2ldKSkgOiBoYXNDaGFuZ2VkKG5ld1ZhbHVlLCBvbGRWYWx1ZSkpKSB7XG4gICAgICAgIGlmIChjbGVhbnVwKSB7XG4gICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRXYXRjaGVyID0gYWN0aXZlV2F0Y2hlcjtcbiAgICAgICAgYWN0aXZlV2F0Y2hlciA9IGVmZmVjdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBhcmdzID0gW1xuICAgICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgICAvLyBwYXNzIHVuZGVmaW5lZCBhcyB0aGUgb2xkIHZhbHVlIHdoZW4gaXQncyBjaGFuZ2VkIGZvciB0aGUgZmlyc3QgdGltZVxuICAgICAgICAgICAgb2xkVmFsdWUgPT09IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA/IHZvaWQgMCA6IGlzTXVsdGlTb3VyY2UgJiYgb2xkVmFsdWVbMF0gPT09IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA/IFtdIDogb2xkVmFsdWUsXG4gICAgICAgICAgICBib3VuZENsZWFudXBcbiAgICAgICAgICBdO1xuICAgICAgICAgIGNhbGwgPyBjYWxsKGNiLCAzLCBhcmdzKSA6IChcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIGNiKC4uLmFyZ3MpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBvbGRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGFjdGl2ZVdhdGNoZXIgPSBjdXJyZW50V2F0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlZmZlY3QucnVuKCk7XG4gICAgfVxuICB9O1xuICBpZiAoYXVnbWVudEpvYikge1xuICAgIGF1Z21lbnRKb2Ioam9iKTtcbiAgfVxuICBlZmZlY3QgPSBuZXcgUmVhY3RpdmVFZmZlY3QoZ2V0dGVyKTtcbiAgZWZmZWN0LnNjaGVkdWxlciA9IHNjaGVkdWxlciA/ICgpID0+IHNjaGVkdWxlcihqb2IsIGZhbHNlKSA6IGpvYjtcbiAgYm91bmRDbGVhbnVwID0gKGZuKSA9PiBvbldhdGNoZXJDbGVhbnVwKGZuLCBmYWxzZSwgZWZmZWN0KTtcbiAgY2xlYW51cCA9IGVmZmVjdC5vblN0b3AgPSAoKSA9PiB7XG4gICAgY29uc3QgY2xlYW51cHMgPSBjbGVhbnVwTWFwLmdldChlZmZlY3QpO1xuICAgIGlmIChjbGVhbnVwcykge1xuICAgICAgaWYgKGNhbGwpIHtcbiAgICAgICAgY2FsbChjbGVhbnVwcywgNCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGNsZWFudXAyIG9mIGNsZWFudXBzKSBjbGVhbnVwMigpO1xuICAgICAgfVxuICAgICAgY2xlYW51cE1hcC5kZWxldGUoZWZmZWN0KTtcbiAgICB9XG4gIH07XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgZWZmZWN0Lm9uVHJhY2sgPSBvcHRpb25zLm9uVHJhY2s7XG4gICAgZWZmZWN0Lm9uVHJpZ2dlciA9IG9wdGlvbnMub25UcmlnZ2VyO1xuICB9XG4gIGlmIChjYikge1xuICAgIGlmIChpbW1lZGlhdGUpIHtcbiAgICAgIGpvYih0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2xkVmFsdWUgPSBlZmZlY3QucnVuKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHNjaGVkdWxlcikge1xuICAgIHNjaGVkdWxlcihqb2IuYmluZChudWxsLCB0cnVlKSwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZWZmZWN0LnJ1bigpO1xuICB9XG4gIHdhdGNoSGFuZGxlLnBhdXNlID0gZWZmZWN0LnBhdXNlLmJpbmQoZWZmZWN0KTtcbiAgd2F0Y2hIYW5kbGUucmVzdW1lID0gZWZmZWN0LnJlc3VtZS5iaW5kKGVmZmVjdCk7XG4gIHdhdGNoSGFuZGxlLnN0b3AgPSB3YXRjaEhhbmRsZTtcbiAgcmV0dXJuIHdhdGNoSGFuZGxlO1xufVxuZnVuY3Rpb24gdHJhdmVyc2UodmFsdWUsIGRlcHRoID0gSW5maW5pdHksIHNlZW4pIHtcbiAgaWYgKGRlcHRoIDw9IDAgfHwgIWlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZVtcIl9fdl9za2lwXCJdKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHNlZW4gPSBzZWVuIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGlmIChzZWVuLmhhcyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgc2Vlbi5hZGQodmFsdWUpO1xuICBkZXB0aC0tO1xuICBpZiAoaXNSZWYodmFsdWUpKSB7XG4gICAgdHJhdmVyc2UodmFsdWUudmFsdWUsIGRlcHRoLCBzZWVuKTtcbiAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRyYXZlcnNlKHZhbHVlW2ldLCBkZXB0aCwgc2Vlbik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzU2V0KHZhbHVlKSB8fCBpc01hcCh2YWx1ZSkpIHtcbiAgICB2YWx1ZS5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICB0cmF2ZXJzZSh2LCBkZXB0aCwgc2Vlbik7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgdHJhdmVyc2UodmFsdWVba2V5XSwgZGVwdGgsIHNlZW4pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbHVlKSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwga2V5KSkge1xuICAgICAgICB0cmF2ZXJzZSh2YWx1ZVtrZXldLCBkZXB0aCwgc2Vlbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0IHsgQVJSQVlfSVRFUkFURV9LRVksIEVmZmVjdEZsYWdzLCBFZmZlY3RTY29wZSwgSVRFUkFURV9LRVksIE1BUF9LRVlfSVRFUkFURV9LRVksIFJlYWN0aXZlRWZmZWN0LCBSZWFjdGl2ZUZsYWdzLCBUcmFja09wVHlwZXMsIFRyaWdnZXJPcFR5cGVzLCBXYXRjaEVycm9yQ29kZXMsIGNvbXB1dGVkLCBjdXN0b21SZWYsIGVmZmVjdCwgZWZmZWN0U2NvcGUsIGVuYWJsZVRyYWNraW5nLCBnZXRDdXJyZW50U2NvcGUsIGdldEN1cnJlbnRXYXRjaGVyLCBpc1Byb3h5LCBpc1JlYWN0aXZlLCBpc1JlYWRvbmx5LCBpc1JlZiwgaXNTaGFsbG93LCBtYXJrUmF3LCBvbkVmZmVjdENsZWFudXAsIG9uU2NvcGVEaXNwb3NlLCBvbldhdGNoZXJDbGVhbnVwLCBwYXVzZVRyYWNraW5nLCBwcm94eVJlZnMsIHJlYWN0aXZlLCByZWFjdGl2ZVJlYWRBcnJheSwgcmVhZG9ubHksIHJlZiwgcmVzZXRUcmFja2luZywgc2hhbGxvd1JlYWN0aXZlLCBzaGFsbG93UmVhZEFycmF5LCBzaGFsbG93UmVhZG9ubHksIHNoYWxsb3dSZWYsIHN0b3AsIHRvUmF3LCB0b1JlYWN0aXZlLCB0b1JlYWRvbmx5LCB0b1JlZiwgdG9SZWZzLCB0b1ZhbHVlLCB0cmFjaywgdHJhdmVyc2UsIHRyaWdnZXIsIHRyaWdnZXJSZWYsIHVucmVmLCB3YXRjaCB9O1xuIiwiLyoqXG4qIEB2dWUvcnVudGltZS1jb3JlIHYzLjUuMTNcbiogKGMpIDIwMTgtcHJlc2VudCBZdXhpIChFdmFuKSBZb3UgYW5kIFZ1ZSBjb250cmlidXRvcnNcbiogQGxpY2Vuc2UgTUlUXG4qKi9cbmltcG9ydCB7IHBhdXNlVHJhY2tpbmcsIHJlc2V0VHJhY2tpbmcsIGlzUmVmLCB0b1JhdywgdHJhdmVyc2UsIHNoYWxsb3dSZWYsIHJlYWRvbmx5LCBpc1JlYWN0aXZlLCByZWYsIGlzU2hhbGxvdywgc2hhbGxvd1JlYWRBcnJheSwgdG9SZWFjdGl2ZSwgc2hhbGxvd1JlYWRvbmx5LCB0cmFjaywgcmVhY3RpdmUsIHNoYWxsb3dSZWFjdGl2ZSwgdHJpZ2dlciwgUmVhY3RpdmVFZmZlY3QsIHdhdGNoIGFzIHdhdGNoJDEsIGN1c3RvbVJlZiwgaXNQcm94eSwgcHJveHlSZWZzLCBtYXJrUmF3LCBFZmZlY3RTY29wZSwgY29tcHV0ZWQgYXMgY29tcHV0ZWQkMSwgaXNSZWFkb25seSB9IGZyb20gJ0B2dWUvcmVhY3Rpdml0eSc7XG5leHBvcnQgeyBFZmZlY3RTY29wZSwgUmVhY3RpdmVFZmZlY3QsIFRyYWNrT3BUeXBlcywgVHJpZ2dlck9wVHlwZXMsIGN1c3RvbVJlZiwgZWZmZWN0LCBlZmZlY3RTY29wZSwgZ2V0Q3VycmVudFNjb3BlLCBnZXRDdXJyZW50V2F0Y2hlciwgaXNQcm94eSwgaXNSZWFjdGl2ZSwgaXNSZWFkb25seSwgaXNSZWYsIGlzU2hhbGxvdywgbWFya1Jhdywgb25TY29wZURpc3Bvc2UsIG9uV2F0Y2hlckNsZWFudXAsIHByb3h5UmVmcywgcmVhY3RpdmUsIHJlYWRvbmx5LCByZWYsIHNoYWxsb3dSZWFjdGl2ZSwgc2hhbGxvd1JlYWRvbmx5LCBzaGFsbG93UmVmLCBzdG9wLCB0b1JhdywgdG9SZWYsIHRvUmVmcywgdG9WYWx1ZSwgdHJpZ2dlclJlZiwgdW5yZWYgfSBmcm9tICdAdnVlL3JlYWN0aXZpdHknO1xuaW1wb3J0IHsgaXNTdHJpbmcsIGlzRnVuY3Rpb24sIGlzUHJvbWlzZSwgaXNBcnJheSwgRU1QVFlfT0JKLCBOT09QLCBnZXRHbG9iYWxUaGlzLCBleHRlbmQsIGlzQnVpbHRJbkRpcmVjdGl2ZSwgaGFzT3duLCByZW1vdmUsIGRlZiwgaXNPbiwgaXNSZXNlcnZlZFByb3AsIG5vcm1hbGl6ZUNsYXNzLCBzdHJpbmdpZnlTdHlsZSwgbm9ybWFsaXplU3R5bGUsIGlzS25vd25TdmdBdHRyLCBpc0Jvb2xlYW5BdHRyLCBpc0tub3duSHRtbEF0dHIsIGluY2x1ZGVCb29sZWFuQXR0ciwgaXNSZW5kZXJhYmxlQXR0clZhbHVlLCBnZXRFc2NhcGVkQ3NzVmFyTmFtZSwgaXNPYmplY3QsIGlzUmVnRXhwLCBpbnZva2VBcnJheUZucywgdG9IYW5kbGVyS2V5LCBjYXBpdGFsaXplLCBjYW1lbGl6ZSwgaXNTeW1ib2wsIGlzR2xvYmFsbHlBbGxvd2VkLCBOTywgaHlwaGVuYXRlLCBFTVBUWV9BUlIsIHRvUmF3VHlwZSwgbWFrZU1hcCwgaGFzQ2hhbmdlZCwgbG9vc2VUb051bWJlciwgaXNNb2RlbExpc3RlbmVyLCB0b051bWJlciB9IGZyb20gJ0B2dWUvc2hhcmVkJztcbmV4cG9ydCB7IGNhbWVsaXplLCBjYXBpdGFsaXplLCBub3JtYWxpemVDbGFzcywgbm9ybWFsaXplUHJvcHMsIG5vcm1hbGl6ZVN0eWxlLCB0b0Rpc3BsYXlTdHJpbmcsIHRvSGFuZGxlcktleSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuY29uc3Qgc3RhY2sgPSBbXTtcbmZ1bmN0aW9uIHB1c2hXYXJuaW5nQ29udGV4dCh2bm9kZSkge1xuICBzdGFjay5wdXNoKHZub2RlKTtcbn1cbmZ1bmN0aW9uIHBvcFdhcm5pbmdDb250ZXh0KCkge1xuICBzdGFjay5wb3AoKTtcbn1cbmxldCBpc1dhcm5pbmcgPSBmYWxzZTtcbmZ1bmN0aW9uIHdhcm4kMShtc2csIC4uLmFyZ3MpIHtcbiAgaWYgKGlzV2FybmluZykgcmV0dXJuO1xuICBpc1dhcm5pbmcgPSB0cnVlO1xuICBwYXVzZVRyYWNraW5nKCk7XG4gIGNvbnN0IGluc3RhbmNlID0gc3RhY2subGVuZ3RoID8gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0uY29tcG9uZW50IDogbnVsbDtcbiAgY29uc3QgYXBwV2FybkhhbmRsZXIgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy53YXJuSGFuZGxlcjtcbiAgY29uc3QgdHJhY2UgPSBnZXRDb21wb25lbnRUcmFjZSgpO1xuICBpZiAoYXBwV2FybkhhbmRsZXIpIHtcbiAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoXG4gICAgICBhcHBXYXJuSGFuZGxlcixcbiAgICAgIGluc3RhbmNlLFxuICAgICAgMTEsXG4gICAgICBbXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICBtc2cgKyBhcmdzLm1hcCgoYSkgPT4ge1xuICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IGEudG9TdHJpbmcpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKGEpKSAhPSBudWxsID8gX2IgOiBKU09OLnN0cmluZ2lmeShhKTtcbiAgICAgICAgfSkuam9pbihcIlwiKSxcbiAgICAgICAgaW5zdGFuY2UgJiYgaW5zdGFuY2UucHJveHksXG4gICAgICAgIHRyYWNlLm1hcChcbiAgICAgICAgICAoeyB2bm9kZSB9KSA9PiBgYXQgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgdm5vZGUudHlwZSl9PmBcbiAgICAgICAgKS5qb2luKFwiXFxuXCIpLFxuICAgICAgICB0cmFjZVxuICAgICAgXVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgd2FybkFyZ3MgPSBbYFtWdWUgd2Fybl06ICR7bXNnfWAsIC4uLmFyZ3NdO1xuICAgIGlmICh0cmFjZS5sZW5ndGggJiYgLy8gYXZvaWQgc3BhbW1pbmcgY29uc29sZSBkdXJpbmcgdGVzdHNcbiAgICB0cnVlKSB7XG4gICAgICB3YXJuQXJncy5wdXNoKGBcbmAsIC4uLmZvcm1hdFRyYWNlKHRyYWNlKSk7XG4gICAgfVxuICAgIGNvbnNvbGUud2FybiguLi53YXJuQXJncyk7XG4gIH1cbiAgcmVzZXRUcmFja2luZygpO1xuICBpc1dhcm5pbmcgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldENvbXBvbmVudFRyYWNlKCkge1xuICBsZXQgY3VycmVudFZOb2RlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gIGlmICghY3VycmVudFZOb2RlKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IG5vcm1hbGl6ZWRTdGFjayA9IFtdO1xuICB3aGlsZSAoY3VycmVudFZOb2RlKSB7XG4gICAgY29uc3QgbGFzdCA9IG5vcm1hbGl6ZWRTdGFja1swXTtcbiAgICBpZiAobGFzdCAmJiBsYXN0LnZub2RlID09PSBjdXJyZW50Vk5vZGUpIHtcbiAgICAgIGxhc3QucmVjdXJzZUNvdW50Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vcm1hbGl6ZWRTdGFjay5wdXNoKHtcbiAgICAgICAgdm5vZGU6IGN1cnJlbnRWTm9kZSxcbiAgICAgICAgcmVjdXJzZUNvdW50OiAwXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50SW5zdGFuY2UgPSBjdXJyZW50Vk5vZGUuY29tcG9uZW50ICYmIGN1cnJlbnRWTm9kZS5jb21wb25lbnQucGFyZW50O1xuICAgIGN1cnJlbnRWTm9kZSA9IHBhcmVudEluc3RhbmNlICYmIHBhcmVudEluc3RhbmNlLnZub2RlO1xuICB9XG4gIHJldHVybiBub3JtYWxpemVkU3RhY2s7XG59XG5mdW5jdGlvbiBmb3JtYXRUcmFjZSh0cmFjZSkge1xuICBjb25zdCBsb2dzID0gW107XG4gIHRyYWNlLmZvckVhY2goKGVudHJ5LCBpKSA9PiB7XG4gICAgbG9ncy5wdXNoKC4uLmkgPT09IDAgPyBbXSA6IFtgXG5gXSwgLi4uZm9ybWF0VHJhY2VFbnRyeShlbnRyeSkpO1xuICB9KTtcbiAgcmV0dXJuIGxvZ3M7XG59XG5mdW5jdGlvbiBmb3JtYXRUcmFjZUVudHJ5KHsgdm5vZGUsIHJlY3Vyc2VDb3VudCB9KSB7XG4gIGNvbnN0IHBvc3RmaXggPSByZWN1cnNlQ291bnQgPiAwID8gYC4uLiAoJHtyZWN1cnNlQ291bnR9IHJlY3Vyc2l2ZSBjYWxscylgIDogYGA7XG4gIGNvbnN0IGlzUm9vdCA9IHZub2RlLmNvbXBvbmVudCA/IHZub2RlLmNvbXBvbmVudC5wYXJlbnQgPT0gbnVsbCA6IGZhbHNlO1xuICBjb25zdCBvcGVuID0gYCBhdCA8JHtmb3JtYXRDb21wb25lbnROYW1lKFxuICAgIHZub2RlLmNvbXBvbmVudCxcbiAgICB2bm9kZS50eXBlLFxuICAgIGlzUm9vdFxuICApfWA7XG4gIGNvbnN0IGNsb3NlID0gYD5gICsgcG9zdGZpeDtcbiAgcmV0dXJuIHZub2RlLnByb3BzID8gW29wZW4sIC4uLmZvcm1hdFByb3BzKHZub2RlLnByb3BzKSwgY2xvc2VdIDogW29wZW4gKyBjbG9zZV07XG59XG5mdW5jdGlvbiBmb3JtYXRQcm9wcyhwcm9wcykge1xuICBjb25zdCByZXMgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKTtcbiAga2V5cy5zbGljZSgwLCAzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICByZXMucHVzaCguLi5mb3JtYXRQcm9wKGtleSwgcHJvcHNba2V5XSkpO1xuICB9KTtcbiAgaWYgKGtleXMubGVuZ3RoID4gMykge1xuICAgIHJlcy5wdXNoKGAgLi4uYCk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGZvcm1hdFByb3Aoa2V5LCB2YWx1ZSwgcmF3KSB7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT0ke3ZhbHVlfWBdO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT0ke3ZhbHVlfWBdO1xuICB9IGVsc2UgaWYgKGlzUmVmKHZhbHVlKSkge1xuICAgIHZhbHVlID0gZm9ybWF0UHJvcChrZXksIHRvUmF3KHZhbHVlLnZhbHVlKSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09UmVmPGAsIHZhbHVlLCBgPmBdO1xuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgcmV0dXJuIFtgJHtrZXl9PWZuJHt2YWx1ZS5uYW1lID8gYDwke3ZhbHVlLm5hbWV9PmAgOiBgYH1gXTtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcbiAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT1gLCB2YWx1ZV07XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydE51bWJlcih2YWwsIHR5cGUpIHtcbiAgaWYgKCEhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSByZXR1cm47XG4gIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsICE9PSBcIm51bWJlclwiKSB7XG4gICAgd2FybiQxKGAke3R5cGV9IGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbCl9LmApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuJDEoYCR7dHlwZX0gaXMgTmFOIC0gdGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LmApO1xuICB9XG59XG5cbmNvbnN0IEVycm9yQ29kZXMgPSB7XG4gIFwiU0VUVVBfRlVOQ1RJT05cIjogMCxcbiAgXCIwXCI6IFwiU0VUVVBfRlVOQ1RJT05cIixcbiAgXCJSRU5ERVJfRlVOQ1RJT05cIjogMSxcbiAgXCIxXCI6IFwiUkVOREVSX0ZVTkNUSU9OXCIsXG4gIFwiTkFUSVZFX0VWRU5UX0hBTkRMRVJcIjogNSxcbiAgXCI1XCI6IFwiTkFUSVZFX0VWRU5UX0hBTkRMRVJcIixcbiAgXCJDT01QT05FTlRfRVZFTlRfSEFORExFUlwiOiA2LFxuICBcIjZcIjogXCJDT01QT05FTlRfRVZFTlRfSEFORExFUlwiLFxuICBcIlZOT0RFX0hPT0tcIjogNyxcbiAgXCI3XCI6IFwiVk5PREVfSE9PS1wiLFxuICBcIkRJUkVDVElWRV9IT09LXCI6IDgsXG4gIFwiOFwiOiBcIkRJUkVDVElWRV9IT09LXCIsXG4gIFwiVFJBTlNJVElPTl9IT09LXCI6IDksXG4gIFwiOVwiOiBcIlRSQU5TSVRJT05fSE9PS1wiLFxuICBcIkFQUF9FUlJPUl9IQU5ETEVSXCI6IDEwLFxuICBcIjEwXCI6IFwiQVBQX0VSUk9SX0hBTkRMRVJcIixcbiAgXCJBUFBfV0FSTl9IQU5ETEVSXCI6IDExLFxuICBcIjExXCI6IFwiQVBQX1dBUk5fSEFORExFUlwiLFxuICBcIkZVTkNUSU9OX1JFRlwiOiAxMixcbiAgXCIxMlwiOiBcIkZVTkNUSU9OX1JFRlwiLFxuICBcIkFTWU5DX0NPTVBPTkVOVF9MT0FERVJcIjogMTMsXG4gIFwiMTNcIjogXCJBU1lOQ19DT01QT05FTlRfTE9BREVSXCIsXG4gIFwiU0NIRURVTEVSXCI6IDE0LFxuICBcIjE0XCI6IFwiU0NIRURVTEVSXCIsXG4gIFwiQ09NUE9ORU5UX1VQREFURVwiOiAxNSxcbiAgXCIxNVwiOiBcIkNPTVBPTkVOVF9VUERBVEVcIixcbiAgXCJBUFBfVU5NT1VOVF9DTEVBTlVQXCI6IDE2LFxuICBcIjE2XCI6IFwiQVBQX1VOTU9VTlRfQ0xFQU5VUFwiXG59O1xuY29uc3QgRXJyb3JUeXBlU3RyaW5ncyQxID0ge1xuICBbXCJzcFwiXTogXCJzZXJ2ZXJQcmVmZXRjaCBob29rXCIsXG4gIFtcImJjXCJdOiBcImJlZm9yZUNyZWF0ZSBob29rXCIsXG4gIFtcImNcIl06IFwiY3JlYXRlZCBob29rXCIsXG4gIFtcImJtXCJdOiBcImJlZm9yZU1vdW50IGhvb2tcIixcbiAgW1wibVwiXTogXCJtb3VudGVkIGhvb2tcIixcbiAgW1wiYnVcIl06IFwiYmVmb3JlVXBkYXRlIGhvb2tcIixcbiAgW1widVwiXTogXCJ1cGRhdGVkXCIsXG4gIFtcImJ1bVwiXTogXCJiZWZvcmVVbm1vdW50IGhvb2tcIixcbiAgW1widW1cIl06IFwidW5tb3VudGVkIGhvb2tcIixcbiAgW1wiYVwiXTogXCJhY3RpdmF0ZWQgaG9va1wiLFxuICBbXCJkYVwiXTogXCJkZWFjdGl2YXRlZCBob29rXCIsXG4gIFtcImVjXCJdOiBcImVycm9yQ2FwdHVyZWQgaG9va1wiLFxuICBbXCJydGNcIl06IFwicmVuZGVyVHJhY2tlZCBob29rXCIsXG4gIFtcInJ0Z1wiXTogXCJyZW5kZXJUcmlnZ2VyZWQgaG9va1wiLFxuICBbMF06IFwic2V0dXAgZnVuY3Rpb25cIixcbiAgWzFdOiBcInJlbmRlciBmdW5jdGlvblwiLFxuICBbMl06IFwid2F0Y2hlciBnZXR0ZXJcIixcbiAgWzNdOiBcIndhdGNoZXIgY2FsbGJhY2tcIixcbiAgWzRdOiBcIndhdGNoZXIgY2xlYW51cCBmdW5jdGlvblwiLFxuICBbNV06IFwibmF0aXZlIGV2ZW50IGhhbmRsZXJcIixcbiAgWzZdOiBcImNvbXBvbmVudCBldmVudCBoYW5kbGVyXCIsXG4gIFs3XTogXCJ2bm9kZSBob29rXCIsXG4gIFs4XTogXCJkaXJlY3RpdmUgaG9va1wiLFxuICBbOV06IFwidHJhbnNpdGlvbiBob29rXCIsXG4gIFsxMF06IFwiYXBwIGVycm9ySGFuZGxlclwiLFxuICBbMTFdOiBcImFwcCB3YXJuSGFuZGxlclwiLFxuICBbMTJdOiBcInJlZiBmdW5jdGlvblwiLFxuICBbMTNdOiBcImFzeW5jIGNvbXBvbmVudCBsb2FkZXJcIixcbiAgWzE0XTogXCJzY2hlZHVsZXIgZmx1c2hcIixcbiAgWzE1XTogXCJjb21wb25lbnQgdXBkYXRlXCIsXG4gIFsxNl06IFwiYXBwIHVubW91bnQgY2xlYW51cCBmdW5jdGlvblwiXG59O1xuZnVuY3Rpb24gY2FsbFdpdGhFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncykge1xuICB0cnkge1xuICAgIHJldHVybiBhcmdzID8gZm4oLi4uYXJncykgOiBmbigpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCB0eXBlKTtcbiAgfVxufVxuZnVuY3Rpb24gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSB7XG4gIGlmIChpc0Z1bmN0aW9uKGZuKSkge1xuICAgIGNvbnN0IHJlcyA9IGNhbGxXaXRoRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpO1xuICAgIGlmIChyZXMgJiYgaXNQcm9taXNlKHJlcykpIHtcbiAgICAgIHJlcy5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgaWYgKGlzQXJyYXkoZm4pKSB7XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzLnB1c2goY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoZm5baV0sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4kMShcbiAgICAgIGBJbnZhbGlkIHZhbHVlIHR5cGUgcGFzc2VkIHRvIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKCk6ICR7dHlwZW9mIGZufWBcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCB0eXBlLCB0aHJvd0luRGV2ID0gdHJ1ZSkge1xuICBjb25zdCBjb250ZXh0Vk5vZGUgPSBpbnN0YW5jZSA/IGluc3RhbmNlLnZub2RlIDogbnVsbDtcbiAgY29uc3QgeyBlcnJvckhhbmRsZXIsIHRocm93VW5oYW5kbGVkRXJyb3JJblByb2R1Y3Rpb24gfSA9IGluc3RhbmNlICYmIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnIHx8IEVNUFRZX09CSjtcbiAgaWYgKGluc3RhbmNlKSB7XG4gICAgbGV0IGN1ciA9IGluc3RhbmNlLnBhcmVudDtcbiAgICBjb25zdCBleHBvc2VkSW5zdGFuY2UgPSBpbnN0YW5jZS5wcm94eTtcbiAgICBjb25zdCBlcnJvckluZm8gPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gRXJyb3JUeXBlU3RyaW5ncyQxW3R5cGVdIDogYGh0dHBzOi8vdnVlanMub3JnL2Vycm9yLXJlZmVyZW5jZS8jcnVudGltZS0ke3R5cGV9YDtcbiAgICB3aGlsZSAoY3VyKSB7XG4gICAgICBjb25zdCBlcnJvckNhcHR1cmVkSG9va3MgPSBjdXIuZWM7XG4gICAgICBpZiAoZXJyb3JDYXB0dXJlZEhvb2tzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXJyb3JDYXB0dXJlZEhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGVycm9yQ2FwdHVyZWRIb29rc1tpXShlcnIsIGV4cG9zZWRJbnN0YW5jZSwgZXJyb3JJbmZvKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN1ciA9IGN1ci5wYXJlbnQ7XG4gICAgfVxuICAgIGlmIChlcnJvckhhbmRsZXIpIHtcbiAgICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhlcnJvckhhbmRsZXIsIG51bGwsIDEwLCBbXG4gICAgICAgIGVycixcbiAgICAgICAgZXhwb3NlZEluc3RhbmNlLFxuICAgICAgICBlcnJvckluZm9cbiAgICAgIF0pO1xuICAgICAgcmVzZXRUcmFja2luZygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBsb2dFcnJvcihlcnIsIHR5cGUsIGNvbnRleHRWTm9kZSwgdGhyb3dJbkRldiwgdGhyb3dVbmhhbmRsZWRFcnJvckluUHJvZHVjdGlvbik7XG59XG5mdW5jdGlvbiBsb2dFcnJvcihlcnIsIHR5cGUsIGNvbnRleHRWTm9kZSwgdGhyb3dJbkRldiA9IHRydWUsIHRocm93SW5Qcm9kID0gZmFsc2UpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBjb25zdCBpbmZvID0gRXJyb3JUeXBlU3RyaW5ncyQxW3R5cGVdO1xuICAgIGlmIChjb250ZXh0Vk5vZGUpIHtcbiAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChjb250ZXh0Vk5vZGUpO1xuICAgIH1cbiAgICB3YXJuJDEoYFVuaGFuZGxlZCBlcnJvciR7aW5mbyA/IGAgZHVyaW5nIGV4ZWN1dGlvbiBvZiAke2luZm99YCA6IGBgfWApO1xuICAgIGlmIChjb250ZXh0Vk5vZGUpIHtcbiAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XG4gICAgfVxuICAgIGlmICh0aHJvd0luRGV2KSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhyb3dJblByb2QpIHtcbiAgICB0aHJvdyBlcnI7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9XG59XG5cbmNvbnN0IHF1ZXVlID0gW107XG5sZXQgZmx1c2hJbmRleCA9IC0xO1xuY29uc3QgcGVuZGluZ1Bvc3RGbHVzaENicyA9IFtdO1xubGV0IGFjdGl2ZVBvc3RGbHVzaENicyA9IG51bGw7XG5sZXQgcG9zdEZsdXNoSW5kZXggPSAwO1xuY29uc3QgcmVzb2x2ZWRQcm9taXNlID0gLyogQF9fUFVSRV9fICovIFByb21pc2UucmVzb2x2ZSgpO1xubGV0IGN1cnJlbnRGbHVzaFByb21pc2UgPSBudWxsO1xuY29uc3QgUkVDVVJTSU9OX0xJTUlUID0gMTAwO1xuZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgY29uc3QgcCA9IGN1cnJlbnRGbHVzaFByb21pc2UgfHwgcmVzb2x2ZWRQcm9taXNlO1xuICByZXR1cm4gZm4gPyBwLnRoZW4odGhpcyA/IGZuLmJpbmQodGhpcykgOiBmbikgOiBwO1xufVxuZnVuY3Rpb24gZmluZEluc2VydGlvbkluZGV4KGlkKSB7XG4gIGxldCBzdGFydCA9IGZsdXNoSW5kZXggKyAxO1xuICBsZXQgZW5kID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcbiAgICBjb25zdCBtaWRkbGUgPSBzdGFydCArIGVuZCA+Pj4gMTtcbiAgICBjb25zdCBtaWRkbGVKb2IgPSBxdWV1ZVttaWRkbGVdO1xuICAgIGNvbnN0IG1pZGRsZUpvYklkID0gZ2V0SWQobWlkZGxlSm9iKTtcbiAgICBpZiAobWlkZGxlSm9iSWQgPCBpZCB8fCBtaWRkbGVKb2JJZCA9PT0gaWQgJiYgbWlkZGxlSm9iLmZsYWdzICYgMikge1xuICAgICAgc3RhcnQgPSBtaWRkbGUgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmQgPSBtaWRkbGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGFydDtcbn1cbmZ1bmN0aW9uIHF1ZXVlSm9iKGpvYikge1xuICBpZiAoIShqb2IuZmxhZ3MgJiAxKSkge1xuICAgIGNvbnN0IGpvYklkID0gZ2V0SWQoam9iKTtcbiAgICBjb25zdCBsYXN0Sm9iID0gcXVldWVbcXVldWUubGVuZ3RoIC0gMV07XG4gICAgaWYgKCFsYXN0Sm9iIHx8IC8vIGZhc3QgcGF0aCB3aGVuIHRoZSBqb2IgaWQgaXMgbGFyZ2VyIHRoYW4gdGhlIHRhaWxcbiAgICAhKGpvYi5mbGFncyAmIDIpICYmIGpvYklkID49IGdldElkKGxhc3RKb2IpKSB7XG4gICAgICBxdWV1ZS5wdXNoKGpvYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXVlLnNwbGljZShmaW5kSW5zZXJ0aW9uSW5kZXgoam9iSWQpLCAwLCBqb2IpO1xuICAgIH1cbiAgICBqb2IuZmxhZ3MgfD0gMTtcbiAgICBxdWV1ZUZsdXNoKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHF1ZXVlRmx1c2goKSB7XG4gIGlmICghY3VycmVudEZsdXNoUHJvbWlzZSkge1xuICAgIGN1cnJlbnRGbHVzaFByb21pc2UgPSByZXNvbHZlZFByb21pc2UudGhlbihmbHVzaEpvYnMpO1xuICB9XG59XG5mdW5jdGlvbiBxdWV1ZVBvc3RGbHVzaENiKGNiKSB7XG4gIGlmICghaXNBcnJheShjYikpIHtcbiAgICBpZiAoYWN0aXZlUG9zdEZsdXNoQ2JzICYmIGNiLmlkID09PSAtMSkge1xuICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzLnNwbGljZShwb3N0Rmx1c2hJbmRleCArIDEsIDAsIGNiKTtcbiAgICB9IGVsc2UgaWYgKCEoY2IuZmxhZ3MgJiAxKSkge1xuICAgICAgcGVuZGluZ1Bvc3RGbHVzaENicy5wdXNoKGNiKTtcbiAgICAgIGNiLmZsYWdzIHw9IDE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBlbmRpbmdQb3N0Rmx1c2hDYnMucHVzaCguLi5jYik7XG4gIH1cbiAgcXVldWVGbHVzaCgpO1xufVxuZnVuY3Rpb24gZmx1c2hQcmVGbHVzaENicyhpbnN0YW5jZSwgc2VlbiwgaSA9IGZsdXNoSW5kZXggKyAxKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgc2VlbiA9IHNlZW4gfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBmb3IgKDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2IgPSBxdWV1ZVtpXTtcbiAgICBpZiAoY2IgJiYgY2IuZmxhZ3MgJiAyKSB7XG4gICAgICBpZiAoaW5zdGFuY2UgJiYgY2IuaWQgIT09IGluc3RhbmNlLnVpZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBjYikpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSwgMSk7XG4gICAgICBpLS07XG4gICAgICBpZiAoY2IuZmxhZ3MgJiA0KSB7XG4gICAgICAgIGNiLmZsYWdzICY9IH4xO1xuICAgICAgfVxuICAgICAgY2IoKTtcbiAgICAgIGlmICghKGNiLmZsYWdzICYgNCkpIHtcbiAgICAgICAgY2IuZmxhZ3MgJj0gfjE7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmbHVzaFBvc3RGbHVzaENicyhzZWVuKSB7XG4gIGlmIChwZW5kaW5nUG9zdEZsdXNoQ2JzLmxlbmd0aCkge1xuICAgIGNvbnN0IGRlZHVwZWQgPSBbLi4ubmV3IFNldChwZW5kaW5nUG9zdEZsdXNoQ2JzKV0uc29ydChcbiAgICAgIChhLCBiKSA9PiBnZXRJZChhKSAtIGdldElkKGIpXG4gICAgKTtcbiAgICBwZW5kaW5nUG9zdEZsdXNoQ2JzLmxlbmd0aCA9IDA7XG4gICAgaWYgKGFjdGl2ZVBvc3RGbHVzaENicykge1xuICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzLnB1c2goLi4uZGVkdXBlZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFjdGl2ZVBvc3RGbHVzaENicyA9IGRlZHVwZWQ7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHNlZW4gPSBzZWVuIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGZvciAocG9zdEZsdXNoSW5kZXggPSAwOyBwb3N0Rmx1c2hJbmRleCA8IGFjdGl2ZVBvc3RGbHVzaENicy5sZW5ndGg7IHBvc3RGbHVzaEluZGV4KyspIHtcbiAgICAgIGNvbnN0IGNiID0gYWN0aXZlUG9zdEZsdXNoQ2JzW3Bvc3RGbHVzaEluZGV4XTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBjYikpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoY2IuZmxhZ3MgJiA0KSB7XG4gICAgICAgIGNiLmZsYWdzICY9IH4xO1xuICAgICAgfVxuICAgICAgaWYgKCEoY2IuZmxhZ3MgJiA4KSkgY2IoKTtcbiAgICAgIGNiLmZsYWdzICY9IH4xO1xuICAgIH1cbiAgICBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBudWxsO1xuICAgIHBvc3RGbHVzaEluZGV4ID0gMDtcbiAgfVxufVxuY29uc3QgZ2V0SWQgPSAoam9iKSA9PiBqb2IuaWQgPT0gbnVsbCA/IGpvYi5mbGFncyAmIDIgPyAtMSA6IEluZmluaXR5IDogam9iLmlkO1xuZnVuY3Rpb24gZmx1c2hKb2JzKHNlZW4pIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBzZWVuID0gc2VlbiB8fCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGNvbnN0IGNoZWNrID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IChqb2IpID0+IGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBqb2IpIDogTk9PUDtcbiAgdHJ5IHtcbiAgICBmb3IgKGZsdXNoSW5kZXggPSAwOyBmbHVzaEluZGV4IDwgcXVldWUubGVuZ3RoOyBmbHVzaEluZGV4KyspIHtcbiAgICAgIGNvbnN0IGpvYiA9IHF1ZXVlW2ZsdXNoSW5kZXhdO1xuICAgICAgaWYgKGpvYiAmJiAhKGpvYi5mbGFncyAmIDgpKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNoZWNrKGpvYikpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoam9iLmZsYWdzICYgNCkge1xuICAgICAgICAgIGpvYi5mbGFncyAmPSB+MTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoXG4gICAgICAgICAgam9iLFxuICAgICAgICAgIGpvYi5pLFxuICAgICAgICAgIGpvYi5pID8gMTUgOiAxNFxuICAgICAgICApO1xuICAgICAgICBpZiAoIShqb2IuZmxhZ3MgJiA0KSkge1xuICAgICAgICAgIGpvYi5mbGFncyAmPSB+MTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBmb3IgKDsgZmx1c2hJbmRleCA8IHF1ZXVlLmxlbmd0aDsgZmx1c2hJbmRleCsrKSB7XG4gICAgICBjb25zdCBqb2IgPSBxdWV1ZVtmbHVzaEluZGV4XTtcbiAgICAgIGlmIChqb2IpIHtcbiAgICAgICAgam9iLmZsYWdzICY9IH4xO1xuICAgICAgfVxuICAgIH1cbiAgICBmbHVzaEluZGV4ID0gLTE7XG4gICAgcXVldWUubGVuZ3RoID0gMDtcbiAgICBmbHVzaFBvc3RGbHVzaENicyhzZWVuKTtcbiAgICBjdXJyZW50Rmx1c2hQcm9taXNlID0gbnVsbDtcbiAgICBpZiAocXVldWUubGVuZ3RoIHx8IHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoKSB7XG4gICAgICBmbHVzaEpvYnMoc2Vlbik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgZm4pIHtcbiAgY29uc3QgY291bnQgPSBzZWVuLmdldChmbikgfHwgMDtcbiAgaWYgKGNvdW50ID4gUkVDVVJTSU9OX0xJTUlUKSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBmbi5pO1xuICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBpbnN0YW5jZSAmJiBnZXRDb21wb25lbnROYW1lKGluc3RhbmNlLnR5cGUpO1xuICAgIGhhbmRsZUVycm9yKFxuICAgICAgYE1heGltdW0gcmVjdXJzaXZlIHVwZGF0ZXMgZXhjZWVkZWQke2NvbXBvbmVudE5hbWUgPyBgIGluIGNvbXBvbmVudCA8JHtjb21wb25lbnROYW1lfT5gIDogYGB9LiBUaGlzIG1lYW5zIHlvdSBoYXZlIGEgcmVhY3RpdmUgZWZmZWN0IHRoYXQgaXMgbXV0YXRpbmcgaXRzIG93biBkZXBlbmRlbmNpZXMgYW5kIHRodXMgcmVjdXJzaXZlbHkgdHJpZ2dlcmluZyBpdHNlbGYuIFBvc3NpYmxlIHNvdXJjZXMgaW5jbHVkZSBjb21wb25lbnQgdGVtcGxhdGUsIHJlbmRlciBmdW5jdGlvbiwgdXBkYXRlZCBob29rIG9yIHdhdGNoZXIgc291cmNlIGZ1bmN0aW9uLmAsXG4gICAgICBudWxsLFxuICAgICAgMTBcbiAgICApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHNlZW4uc2V0KGZuLCBjb3VudCArIDEpO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmxldCBpc0htclVwZGF0aW5nID0gZmFsc2U7XG5jb25zdCBobXJEaXJ0eUNvbXBvbmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX0hNUl9SVU5USU1FX18gPSB7XG4gICAgY3JlYXRlUmVjb3JkOiB0cnlXcmFwKGNyZWF0ZVJlY29yZCksXG4gICAgcmVyZW5kZXI6IHRyeVdyYXAocmVyZW5kZXIpLFxuICAgIHJlbG9hZDogdHJ5V3JhcChyZWxvYWQpXG4gIH07XG59XG5jb25zdCBtYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gcmVnaXN0ZXJITVIoaW5zdGFuY2UpIHtcbiAgY29uc3QgaWQgPSBpbnN0YW5jZS50eXBlLl9faG1ySWQ7XG4gIGxldCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcbiAgaWYgKCFyZWNvcmQpIHtcbiAgICBjcmVhdGVSZWNvcmQoaWQsIGluc3RhbmNlLnR5cGUpO1xuICAgIHJlY29yZCA9IG1hcC5nZXQoaWQpO1xuICB9XG4gIHJlY29yZC5pbnN0YW5jZXMuYWRkKGluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIHVucmVnaXN0ZXJITVIoaW5zdGFuY2UpIHtcbiAgbWFwLmdldChpbnN0YW5jZS50eXBlLl9faG1ySWQpLmluc3RhbmNlcy5kZWxldGUoaW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVjb3JkKGlkLCBpbml0aWFsRGVmKSB7XG4gIGlmIChtYXAuaGFzKGlkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBtYXAuc2V0KGlkLCB7XG4gICAgaW5pdGlhbERlZjogbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5pdGlhbERlZiksXG4gICAgaW5zdGFuY2VzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXG4gIH0pO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICByZXR1cm4gaXNDbGFzc0NvbXBvbmVudChjb21wb25lbnQpID8gY29tcG9uZW50Ll9fdmNjT3B0cyA6IGNvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIHJlcmVuZGVyKGlkLCBuZXdSZW5kZXIpIHtcbiAgY29uc3QgcmVjb3JkID0gbWFwLmdldChpZCk7XG4gIGlmICghcmVjb3JkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlY29yZC5pbml0aWFsRGVmLnJlbmRlciA9IG5ld1JlbmRlcjtcbiAgWy4uLnJlY29yZC5pbnN0YW5jZXNdLmZvckVhY2goKGluc3RhbmNlKSA9PiB7XG4gICAgaWYgKG5ld1JlbmRlcikge1xuICAgICAgaW5zdGFuY2UucmVuZGVyID0gbmV3UmVuZGVyO1xuICAgICAgbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5zdGFuY2UudHlwZSkucmVuZGVyID0gbmV3UmVuZGVyO1xuICAgIH1cbiAgICBpbnN0YW5jZS5yZW5kZXJDYWNoZSA9IFtdO1xuICAgIGlzSG1yVXBkYXRpbmcgPSB0cnVlO1xuICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgIGlzSG1yVXBkYXRpbmcgPSBmYWxzZTtcbiAgfSk7XG59XG5mdW5jdGlvbiByZWxvYWQoaWQsIG5ld0NvbXApIHtcbiAgY29uc3QgcmVjb3JkID0gbWFwLmdldChpZCk7XG4gIGlmICghcmVjb3JkKSByZXR1cm47XG4gIG5ld0NvbXAgPSBub3JtYWxpemVDbGFzc0NvbXBvbmVudChuZXdDb21wKTtcbiAgdXBkYXRlQ29tcG9uZW50RGVmKHJlY29yZC5pbml0aWFsRGVmLCBuZXdDb21wKTtcbiAgY29uc3QgaW5zdGFuY2VzID0gWy4uLnJlY29yZC5pbnN0YW5jZXNdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VzW2ldO1xuICAgIGNvbnN0IG9sZENvbXAgPSBub3JtYWxpemVDbGFzc0NvbXBvbmVudChpbnN0YW5jZS50eXBlKTtcbiAgICBsZXQgZGlydHlJbnN0YW5jZXMgPSBobXJEaXJ0eUNvbXBvbmVudHMuZ2V0KG9sZENvbXApO1xuICAgIGlmICghZGlydHlJbnN0YW5jZXMpIHtcbiAgICAgIGlmIChvbGRDb21wICE9PSByZWNvcmQuaW5pdGlhbERlZikge1xuICAgICAgICB1cGRhdGVDb21wb25lbnREZWYob2xkQ29tcCwgbmV3Q29tcCk7XG4gICAgICB9XG4gICAgICBobXJEaXJ0eUNvbXBvbmVudHMuc2V0KG9sZENvbXAsIGRpcnR5SW5zdGFuY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgfVxuICAgIGRpcnR5SW5zdGFuY2VzLmFkZChpbnN0YW5jZSk7XG4gICAgaW5zdGFuY2UuYXBwQ29udGV4dC5wcm9wc0NhY2hlLmRlbGV0ZShpbnN0YW5jZS50eXBlKTtcbiAgICBpbnN0YW5jZS5hcHBDb250ZXh0LmVtaXRzQ2FjaGUuZGVsZXRlKGluc3RhbmNlLnR5cGUpO1xuICAgIGluc3RhbmNlLmFwcENvbnRleHQub3B0aW9uc0NhY2hlLmRlbGV0ZShpbnN0YW5jZS50eXBlKTtcbiAgICBpZiAoaW5zdGFuY2UuY2VSZWxvYWQpIHtcbiAgICAgIGRpcnR5SW5zdGFuY2VzLmFkZChpbnN0YW5jZSk7XG4gICAgICBpbnN0YW5jZS5jZVJlbG9hZChuZXdDb21wLnN0eWxlcyk7XG4gICAgICBkaXJ0eUluc3RhbmNlcy5kZWxldGUoaW5zdGFuY2UpO1xuICAgIH0gZWxzZSBpZiAoaW5zdGFuY2UucGFyZW50KSB7XG4gICAgICBxdWV1ZUpvYigoKSA9PiB7XG4gICAgICAgIGlzSG1yVXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICBpbnN0YW5jZS5wYXJlbnQudXBkYXRlKCk7XG4gICAgICAgIGlzSG1yVXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgZGlydHlJbnN0YW5jZXMuZGVsZXRlKGluc3RhbmNlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5yZWxvYWQpIHtcbiAgICAgIGluc3RhbmNlLmFwcENvbnRleHQucmVsb2FkKCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJbSE1SXSBSb290IG9yIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UgbW9kaWZpZWQuIEZ1bGwgcmVsb2FkIHJlcXVpcmVkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoaW5zdGFuY2Uucm9vdC5jZSAmJiBpbnN0YW5jZSAhPT0gaW5zdGFuY2Uucm9vdCkge1xuICAgICAgaW5zdGFuY2Uucm9vdC5jZS5fcmVtb3ZlQ2hpbGRTdHlsZShvbGRDb21wKTtcbiAgICB9XG4gIH1cbiAgcXVldWVQb3N0Rmx1c2hDYigoKSA9PiB7XG4gICAgaG1yRGlydHlDb21wb25lbnRzLmNsZWFyKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50RGVmKG9sZENvbXAsIG5ld0NvbXApIHtcbiAgZXh0ZW5kKG9sZENvbXAsIG5ld0NvbXApO1xuICBmb3IgKGNvbnN0IGtleSBpbiBvbGRDb21wKSB7XG4gICAgaWYgKGtleSAhPT0gXCJfX2ZpbGVcIiAmJiAhKGtleSBpbiBuZXdDb21wKSkge1xuICAgICAgZGVsZXRlIG9sZENvbXBba2V5XTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRyeVdyYXAoZm4pIHtcbiAgcmV0dXJuIChpZCwgYXJnKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbihpZCwgYXJnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW0hNUl0gU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIFZ1ZSBjb21wb25lbnQgaG90LXJlbG9hZC4gRnVsbCByZWxvYWQgcmVxdWlyZWQuYFxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5cbmxldCBkZXZ0b29scyQxO1xubGV0IGJ1ZmZlciA9IFtdO1xubGV0IGRldnRvb2xzTm90SW5zdGFsbGVkID0gZmFsc2U7XG5mdW5jdGlvbiBlbWl0JDEoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgaWYgKGRldnRvb2xzJDEpIHtcbiAgICBkZXZ0b29scyQxLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICB9IGVsc2UgaWYgKCFkZXZ0b29sc05vdEluc3RhbGxlZCkge1xuICAgIGJ1ZmZlci5wdXNoKHsgZXZlbnQsIGFyZ3MgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldERldnRvb2xzSG9vayQxKGhvb2ssIHRhcmdldCkge1xuICB2YXIgX2EsIF9iO1xuICBkZXZ0b29scyQxID0gaG9vaztcbiAgaWYgKGRldnRvb2xzJDEpIHtcbiAgICBkZXZ0b29scyQxLmVuYWJsZWQgPSB0cnVlO1xuICAgIGJ1ZmZlci5mb3JFYWNoKCh7IGV2ZW50LCBhcmdzIH0pID0+IGRldnRvb2xzJDEuZW1pdChldmVudCwgLi4uYXJncykpO1xuICAgIGJ1ZmZlciA9IFtdO1xuICB9IGVsc2UgaWYgKFxuICAgIC8vIGhhbmRsZSBsYXRlIGRldnRvb2xzIGluamVjdGlvbiAtIG9ubHkgZG8gdGhpcyBpZiB3ZSBhcmUgaW4gYW4gYWN0dWFsXG4gICAgLy8gYnJvd3NlciBlbnZpcm9ubWVudCB0byBhdm9pZCB0aGUgdGltZXIgaGFuZGxlIHN0YWxsaW5nIHRlc3QgcnVubmVyIGV4aXRcbiAgICAvLyAoIzQ4MTUpXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAvLyBzb21lIGVudnMgbW9jayB3aW5kb3cgYnV0IG5vdCBmdWxseVxuICAgIHdpbmRvdy5IVE1MRWxlbWVudCAmJiAvLyBhbHNvIGV4Y2x1ZGUganNkb21cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAhKChfYiA9IChfYSA9IHdpbmRvdy5uYXZpZ2F0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfYS51c2VyQWdlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5pbmNsdWRlcyhcImpzZG9tXCIpKVxuICApIHtcbiAgICBjb25zdCByZXBsYXkgPSB0YXJnZXQuX19WVUVfREVWVE9PTFNfSE9PS19SRVBMQVlfXyA9IHRhcmdldC5fX1ZVRV9ERVZUT09MU19IT09LX1JFUExBWV9fIHx8IFtdO1xuICAgIHJlcGxheS5wdXNoKChuZXdIb29rKSA9PiB7XG4gICAgICBzZXREZXZ0b29sc0hvb2skMShuZXdIb29rLCB0YXJnZXQpO1xuICAgIH0pO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKCFkZXZ0b29scyQxKSB7XG4gICAgICAgIHRhcmdldC5fX1ZVRV9ERVZUT09MU19IT09LX1JFUExBWV9fID0gbnVsbDtcbiAgICAgICAgZGV2dG9vbHNOb3RJbnN0YWxsZWQgPSB0cnVlO1xuICAgICAgICBidWZmZXIgPSBbXTtcbiAgICAgIH1cbiAgICB9LCAzZTMpO1xuICB9IGVsc2Uge1xuICAgIGRldnRvb2xzTm90SW5zdGFsbGVkID0gdHJ1ZTtcbiAgICBidWZmZXIgPSBbXTtcbiAgfVxufVxuZnVuY3Rpb24gZGV2dG9vbHNJbml0QXBwKGFwcCwgdmVyc2lvbikge1xuICBlbWl0JDEoXCJhcHA6aW5pdFwiIC8qIEFQUF9JTklUICovLCBhcHAsIHZlcnNpb24sIHtcbiAgICBGcmFnbWVudCxcbiAgICBUZXh0LFxuICAgIENvbW1lbnQsXG4gICAgU3RhdGljXG4gIH0pO1xufVxuZnVuY3Rpb24gZGV2dG9vbHNVbm1vdW50QXBwKGFwcCkge1xuICBlbWl0JDEoXCJhcHA6dW5tb3VudFwiIC8qIEFQUF9VTk1PVU5UICovLCBhcHApO1xufVxuY29uc3QgZGV2dG9vbHNDb21wb25lbnRBZGRlZCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soXCJjb21wb25lbnQ6YWRkZWRcIiAvKiBDT01QT05FTlRfQURERUQgKi8pO1xuY29uc3QgZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcImNvbXBvbmVudDp1cGRhdGVkXCIgLyogQ09NUE9ORU5UX1VQREFURUQgKi8pO1xuY29uc3QgX2RldnRvb2xzQ29tcG9uZW50UmVtb3ZlZCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soXG4gIFwiY29tcG9uZW50OnJlbW92ZWRcIiAvKiBDT01QT05FTlRfUkVNT1ZFRCAqL1xuKTtcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZCA9IChjb21wb25lbnQpID0+IHtcbiAgaWYgKGRldnRvb2xzJDEgJiYgdHlwZW9mIGRldnRvb2xzJDEuY2xlYW51cEJ1ZmZlciA9PT0gXCJmdW5jdGlvblwiICYmIC8vIHJlbW92ZSB0aGUgY29tcG9uZW50IGlmIGl0IHdhc24ndCBidWZmZXJlZFxuICAhZGV2dG9vbHMkMS5jbGVhbnVwQnVmZmVyKGNvbXBvbmVudCkpIHtcbiAgICBfZGV2dG9vbHNDb21wb25lbnRSZW1vdmVkKGNvbXBvbmVudCk7XG4gIH1cbn07XG4vKiEgI19fTk9fU0lERV9FRkZFQ1RTX18gKi9cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soaG9vaykge1xuICByZXR1cm4gKGNvbXBvbmVudCkgPT4ge1xuICAgIGVtaXQkMShcbiAgICAgIGhvb2ssXG4gICAgICBjb21wb25lbnQuYXBwQ29udGV4dC5hcHAsXG4gICAgICBjb21wb25lbnQudWlkLFxuICAgICAgY29tcG9uZW50LnBhcmVudCA/IGNvbXBvbmVudC5wYXJlbnQudWlkIDogdm9pZCAwLFxuICAgICAgY29tcG9uZW50XG4gICAgKTtcbiAgfTtcbn1cbmNvbnN0IGRldnRvb2xzUGVyZlN0YXJ0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURldnRvb2xzUGVyZm9ybWFuY2VIb29rKFwicGVyZjpzdGFydFwiIC8qIFBFUkZPUk1BTkNFX1NUQVJUICovKTtcbmNvbnN0IGRldnRvb2xzUGVyZkVuZCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayhcInBlcmY6ZW5kXCIgLyogUEVSRk9STUFOQ0VfRU5EICovKTtcbmZ1bmN0aW9uIGNyZWF0ZURldnRvb2xzUGVyZm9ybWFuY2VIb29rKGhvb2spIHtcbiAgcmV0dXJuIChjb21wb25lbnQsIHR5cGUsIHRpbWUpID0+IHtcbiAgICBlbWl0JDEoaG9vaywgY29tcG9uZW50LmFwcENvbnRleHQuYXBwLCBjb21wb25lbnQudWlkLCBjb21wb25lbnQsIHR5cGUsIHRpbWUpO1xuICB9O1xufVxuZnVuY3Rpb24gZGV2dG9vbHNDb21wb25lbnRFbWl0KGNvbXBvbmVudCwgZXZlbnQsIHBhcmFtcykge1xuICBlbWl0JDEoXG4gICAgXCJjb21wb25lbnQ6ZW1pdFwiIC8qIENPTVBPTkVOVF9FTUlUICovLFxuICAgIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCxcbiAgICBjb21wb25lbnQsXG4gICAgZXZlbnQsXG4gICAgcGFyYW1zXG4gICk7XG59XG5cbmxldCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xubGV0IGN1cnJlbnRTY29wZUlkID0gbnVsbDtcbmZ1bmN0aW9uIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShpbnN0YW5jZSkge1xuICBjb25zdCBwcmV2ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgY3VycmVudFNjb3BlSWQgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS50eXBlLl9fc2NvcGVJZCB8fCBudWxsO1xuICByZXR1cm4gcHJldjtcbn1cbmZ1bmN0aW9uIHB1c2hTY29wZUlkKGlkKSB7XG4gIGN1cnJlbnRTY29wZUlkID0gaWQ7XG59XG5mdW5jdGlvbiBwb3BTY29wZUlkKCkge1xuICBjdXJyZW50U2NvcGVJZCA9IG51bGw7XG59XG5jb25zdCB3aXRoU2NvcGVJZCA9IChfaWQpID0+IHdpdGhDdHg7XG5mdW5jdGlvbiB3aXRoQ3R4KGZuLCBjdHggPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsIGlzTm9uU2NvcGVkU2xvdCkge1xuICBpZiAoIWN0eCkgcmV0dXJuIGZuO1xuICBpZiAoZm4uX24pIHtcbiAgICByZXR1cm4gZm47XG4gIH1cbiAgY29uc3QgcmVuZGVyRm5XaXRoQ29udGV4dCA9ICguLi5hcmdzKSA9PiB7XG4gICAgaWYgKHJlbmRlckZuV2l0aENvbnRleHQuX2QpIHtcbiAgICAgIHNldEJsb2NrVHJhY2tpbmcoLTEpO1xuICAgIH1cbiAgICBjb25zdCBwcmV2SW5zdGFuY2UgPSBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoY3R4KTtcbiAgICBsZXQgcmVzO1xuICAgIHRyeSB7XG4gICAgICByZXMgPSBmbiguLi5hcmdzKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKHByZXZJbnN0YW5jZSk7XG4gICAgICBpZiAocmVuZGVyRm5XaXRoQ29udGV4dC5fZCkge1xuICAgICAgICBzZXRCbG9ja1RyYWNraW5nKDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZChjdHgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuICByZW5kZXJGbldpdGhDb250ZXh0Ll9uID0gdHJ1ZTtcbiAgcmVuZGVyRm5XaXRoQ29udGV4dC5fYyA9IHRydWU7XG4gIHJlbmRlckZuV2l0aENvbnRleHQuX2QgPSB0cnVlO1xuICByZXR1cm4gcmVuZGVyRm5XaXRoQ29udGV4dDtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVEaXJlY3RpdmVOYW1lKG5hbWUpIHtcbiAgaWYgKGlzQnVpbHRJbkRpcmVjdGl2ZShuYW1lKSkge1xuICAgIHdhcm4kMShcIkRvIG5vdCB1c2UgYnVpbHQtaW4gZGlyZWN0aXZlIGlkcyBhcyBjdXN0b20gZGlyZWN0aXZlIGlkOiBcIiArIG5hbWUpO1xuICB9XG59XG5mdW5jdGlvbiB3aXRoRGlyZWN0aXZlcyh2bm9kZSwgZGlyZWN0aXZlcykge1xuICBpZiAoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID09PSBudWxsKSB7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuJDEoYHdpdGhEaXJlY3RpdmVzIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHJlbmRlciBmdW5jdGlvbnMuYCk7XG4gICAgcmV0dXJuIHZub2RlO1xuICB9XG4gIGNvbnN0IGluc3RhbmNlID0gZ2V0Q29tcG9uZW50UHVibGljSW5zdGFuY2UoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKTtcbiAgY29uc3QgYmluZGluZ3MgPSB2bm9kZS5kaXJzIHx8ICh2bm9kZS5kaXJzID0gW10pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpcmVjdGl2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgW2RpciwgdmFsdWUsIGFyZywgbW9kaWZpZXJzID0gRU1QVFlfT0JKXSA9IGRpcmVjdGl2ZXNbaV07XG4gICAgaWYgKGRpcikge1xuICAgICAgaWYgKGlzRnVuY3Rpb24oZGlyKSkge1xuICAgICAgICBkaXIgPSB7XG4gICAgICAgICAgbW91bnRlZDogZGlyLFxuICAgICAgICAgIHVwZGF0ZWQ6IGRpclxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGRpci5kZWVwKSB7XG4gICAgICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGJpbmRpbmdzLnB1c2goe1xuICAgICAgICBkaXIsXG4gICAgICAgIGluc3RhbmNlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgb2xkVmFsdWU6IHZvaWQgMCxcbiAgICAgICAgYXJnLFxuICAgICAgICBtb2RpZmllcnNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm5vZGU7XG59XG5mdW5jdGlvbiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBwcmV2Vk5vZGUsIGluc3RhbmNlLCBuYW1lKSB7XG4gIGNvbnN0IGJpbmRpbmdzID0gdm5vZGUuZGlycztcbiAgY29uc3Qgb2xkQmluZGluZ3MgPSBwcmV2Vk5vZGUgJiYgcHJldlZOb2RlLmRpcnM7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBiaW5kaW5nID0gYmluZGluZ3NbaV07XG4gICAgaWYgKG9sZEJpbmRpbmdzKSB7XG4gICAgICBiaW5kaW5nLm9sZFZhbHVlID0gb2xkQmluZGluZ3NbaV0udmFsdWU7XG4gICAgfVxuICAgIGxldCBob29rID0gYmluZGluZy5kaXJbbmFtZV07XG4gICAgaWYgKGhvb2spIHtcbiAgICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIGluc3RhbmNlLCA4LCBbXG4gICAgICAgIHZub2RlLmVsLFxuICAgICAgICBiaW5kaW5nLFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgcHJldlZOb2RlXG4gICAgICBdKTtcbiAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgVGVsZXBvcnRFbmRLZXkgPSBTeW1ib2woXCJfdnRlXCIpO1xuY29uc3QgaXNUZWxlcG9ydCA9ICh0eXBlKSA9PiB0eXBlLl9faXNUZWxlcG9ydDtcbmNvbnN0IGlzVGVsZXBvcnREaXNhYmxlZCA9IChwcm9wcykgPT4gcHJvcHMgJiYgKHByb3BzLmRpc2FibGVkIHx8IHByb3BzLmRpc2FibGVkID09PSBcIlwiKTtcbmNvbnN0IGlzVGVsZXBvcnREZWZlcnJlZCA9IChwcm9wcykgPT4gcHJvcHMgJiYgKHByb3BzLmRlZmVyIHx8IHByb3BzLmRlZmVyID09PSBcIlwiKTtcbmNvbnN0IGlzVGFyZ2V0U1ZHID0gKHRhcmdldCkgPT4gdHlwZW9mIFNWR0VsZW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudDtcbmNvbnN0IGlzVGFyZ2V0TWF0aE1MID0gKHRhcmdldCkgPT4gdHlwZW9mIE1hdGhNTEVsZW1lbnQgPT09IFwiZnVuY3Rpb25cIiAmJiB0YXJnZXQgaW5zdGFuY2VvZiBNYXRoTUxFbGVtZW50O1xuY29uc3QgcmVzb2x2ZVRhcmdldCA9IChwcm9wcywgc2VsZWN0KSA9PiB7XG4gIGNvbnN0IHRhcmdldFNlbGVjdG9yID0gcHJvcHMgJiYgcHJvcHMudG87XG4gIGlmIChpc1N0cmluZyh0YXJnZXRTZWxlY3RvcikpIHtcbiAgICBpZiAoIXNlbGVjdCkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuJDEoXG4gICAgICAgIGBDdXJyZW50IHJlbmRlcmVyIGRvZXMgbm90IHN1cHBvcnQgc3RyaW5nIHRhcmdldCBmb3IgVGVsZXBvcnRzLiAobWlzc2luZyBxdWVyeVNlbGVjdG9yIHJlbmRlcmVyIG9wdGlvbilgXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHNlbGVjdCh0YXJnZXRTZWxlY3Rvcik7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhdGFyZ2V0ICYmICFpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBgRmFpbGVkIHRvIGxvY2F0ZSBUZWxlcG9ydCB0YXJnZXQgd2l0aCBzZWxlY3RvciBcIiR7dGFyZ2V0U2VsZWN0b3J9XCIuIE5vdGUgdGhlIHRhcmdldCBlbGVtZW50IG11c3QgZXhpc3QgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZCAtIGkuZS4gdGhlIHRhcmdldCBjYW5ub3QgYmUgcmVuZGVyZWQgYnkgdGhlIGNvbXBvbmVudCBpdHNlbGYsIGFuZCBpZGVhbGx5IHNob3VsZCBiZSBvdXRzaWRlIG9mIHRoZSBlbnRpcmUgVnVlIGNvbXBvbmVudCB0cmVlLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICF0YXJnZXRTZWxlY3RvciAmJiAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xuICAgICAgd2FybiQxKGBJbnZhbGlkIFRlbGVwb3J0IHRhcmdldDogJHt0YXJnZXRTZWxlY3Rvcn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldFNlbGVjdG9yO1xuICB9XG59O1xuY29uc3QgVGVsZXBvcnRJbXBsID0ge1xuICBuYW1lOiBcIlRlbGVwb3J0XCIsXG4gIF9faXNUZWxlcG9ydDogdHJ1ZSxcbiAgcHJvY2VzcyhuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBpbnRlcm5hbHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBtYzogbW91bnRDaGlsZHJlbixcbiAgICAgIHBjOiBwYXRjaENoaWxkcmVuLFxuICAgICAgcGJjOiBwYXRjaEJsb2NrQ2hpbGRyZW4sXG4gICAgICBvOiB7IGluc2VydCwgcXVlcnlTZWxlY3RvciwgY3JlYXRlVGV4dCwgY3JlYXRlQ29tbWVudCB9XG4gICAgfSA9IGludGVybmFscztcbiAgICBjb25zdCBkaXNhYmxlZCA9IGlzVGVsZXBvcnREaXNhYmxlZChuMi5wcm9wcyk7XG4gICAgbGV0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuIH0gPSBuMjtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0htclVwZGF0aW5nKSB7XG4gICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgIGR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgfVxuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBjb25zdCBwbGFjZWhvbGRlciA9IG4yLmVsID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGNyZWF0ZUNvbW1lbnQoXCJ0ZWxlcG9ydCBzdGFydFwiKSA6IGNyZWF0ZVRleHQoXCJcIik7XG4gICAgICBjb25zdCBtYWluQW5jaG9yID0gbjIuYW5jaG9yID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGNyZWF0ZUNvbW1lbnQoXCJ0ZWxlcG9ydCBlbmRcIikgOiBjcmVhdGVUZXh0KFwiXCIpO1xuICAgICAgaW5zZXJ0KHBsYWNlaG9sZGVyLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICBpbnNlcnQobWFpbkFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgY29uc3QgbW91bnQgPSAoY29udGFpbmVyMiwgYW5jaG9yMikgPT4ge1xuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgICAgICBpZiAocGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC5pc0NFKSB7XG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQuY2UuX3RlbGVwb3J0VGFyZ2V0ID0gY29udGFpbmVyMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbW91bnRDaGlsZHJlbihcbiAgICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgICAgY29udGFpbmVyMixcbiAgICAgICAgICAgIGFuY2hvcjIsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBtb3VudFRvVGFyZ2V0ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBuMi50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KG4yLnByb3BzLCBxdWVyeVNlbGVjdG9yKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0QW5jaG9yID0gcHJlcGFyZUFuY2hvcih0YXJnZXQsIG4yLCBjcmVhdGVUZXh0LCBpbnNlcnQpO1xuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgaWYgKG5hbWVzcGFjZSAhPT0gXCJzdmdcIiAmJiBpc1RhcmdldFNWRyh0YXJnZXQpKSB7XG4gICAgICAgICAgICBuYW1lc3BhY2UgPSBcInN2Z1wiO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmFtZXNwYWNlICE9PSBcIm1hdGhtbFwiICYmIGlzVGFyZ2V0TWF0aE1MKHRhcmdldCkpIHtcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IFwibWF0aG1sXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIG1vdW50KHRhcmdldCwgdGFyZ2V0QW5jaG9yKTtcbiAgICAgICAgICAgIHVwZGF0ZUNzc1ZhcnMobjIsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhZGlzYWJsZWQpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBcIkludmFsaWQgVGVsZXBvcnQgdGFyZ2V0IG9uIG1vdW50OlwiLFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgYCgke3R5cGVvZiB0YXJnZXR9KWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgIG1vdW50KGNvbnRhaW5lciwgbWFpbkFuY2hvcik7XG4gICAgICAgIHVwZGF0ZUNzc1ZhcnMobjIsIHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKGlzVGVsZXBvcnREZWZlcnJlZChuMi5wcm9wcykpIHtcbiAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICBtb3VudFRvVGFyZ2V0KCk7XG4gICAgICAgICAgbjIuZWwuX19pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb3VudFRvVGFyZ2V0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1RlbGVwb3J0RGVmZXJyZWQobjIucHJvcHMpICYmICFuMS5lbC5fX2lzTW91bnRlZCkge1xuICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgIFRlbGVwb3J0SW1wbC5wcm9jZXNzKFxuICAgICAgICAgICAgbjEsXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICAgICAgaW50ZXJuYWxzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkZWxldGUgbjEuZWwuX19pc01vdW50ZWQ7XG4gICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbjIuZWwgPSBuMS5lbDtcbiAgICAgIG4yLnRhcmdldFN0YXJ0ID0gbjEudGFyZ2V0U3RhcnQ7XG4gICAgICBjb25zdCBtYWluQW5jaG9yID0gbjIuYW5jaG9yID0gbjEuYW5jaG9yO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gbjIudGFyZ2V0ID0gbjEudGFyZ2V0O1xuICAgICAgY29uc3QgdGFyZ2V0QW5jaG9yID0gbjIudGFyZ2V0QW5jaG9yID0gbjEudGFyZ2V0QW5jaG9yO1xuICAgICAgY29uc3Qgd2FzRGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQobjEucHJvcHMpO1xuICAgICAgY29uc3QgY3VycmVudENvbnRhaW5lciA9IHdhc0Rpc2FibGVkID8gY29udGFpbmVyIDogdGFyZ2V0O1xuICAgICAgY29uc3QgY3VycmVudEFuY2hvciA9IHdhc0Rpc2FibGVkID8gbWFpbkFuY2hvciA6IHRhcmdldEFuY2hvcjtcbiAgICAgIGlmIChuYW1lc3BhY2UgPT09IFwic3ZnXCIgfHwgaXNUYXJnZXRTVkcodGFyZ2V0KSkge1xuICAgICAgICBuYW1lc3BhY2UgPSBcInN2Z1wiO1xuICAgICAgfSBlbHNlIGlmIChuYW1lc3BhY2UgPT09IFwibWF0aG1sXCIgfHwgaXNUYXJnZXRNYXRoTUwodGFyZ2V0KSkge1xuICAgICAgICBuYW1lc3BhY2UgPSBcIm1hdGhtbFwiO1xuICAgICAgfVxuICAgICAgaWYgKGR5bmFtaWNDaGlsZHJlbikge1xuICAgICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4oXG4gICAgICAgICAgbjEuZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgICBjdXJyZW50Q29udGFpbmVyLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzXG4gICAgICAgICk7XG4gICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoIW9wdGltaXplZCkge1xuICAgICAgICBwYXRjaENoaWxkcmVuKFxuICAgICAgICAgIG4xLFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGN1cnJlbnRDb250YWluZXIsXG4gICAgICAgICAgY3VycmVudEFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgIGlmICghd2FzRGlzYWJsZWQpIHtcbiAgICAgICAgICBtb3ZlVGVsZXBvcnQoXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIG1haW5BbmNob3IsXG4gICAgICAgICAgICBpbnRlcm5hbHMsXG4gICAgICAgICAgICAxXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobjIucHJvcHMgJiYgbjEucHJvcHMgJiYgbjIucHJvcHMudG8gIT09IG4xLnByb3BzLnRvKSB7XG4gICAgICAgICAgICBuMi5wcm9wcy50byA9IG4xLnByb3BzLnRvO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKChuMi5wcm9wcyAmJiBuMi5wcm9wcy50bykgIT09IChuMS5wcm9wcyAmJiBuMS5wcm9wcy50bykpIHtcbiAgICAgICAgICBjb25zdCBuZXh0VGFyZ2V0ID0gbjIudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChcbiAgICAgICAgICAgIG4yLnByb3BzLFxuICAgICAgICAgICAgcXVlcnlTZWxlY3RvclxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG5leHRUYXJnZXQpIHtcbiAgICAgICAgICAgIG1vdmVUZWxlcG9ydChcbiAgICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICAgIG5leHRUYXJnZXQsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIGludGVybmFscyxcbiAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIFRlbGVwb3J0IHRhcmdldCBvbiB1cGRhdGU6XCIsXG4gICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgYCgke3R5cGVvZiB0YXJnZXR9KWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHdhc0Rpc2FibGVkKSB7XG4gICAgICAgICAgbW92ZVRlbGVwb3J0KFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICB0YXJnZXRBbmNob3IsXG4gICAgICAgICAgICBpbnRlcm5hbHMsXG4gICAgICAgICAgICAxXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdXBkYXRlQ3NzVmFycyhuMiwgZGlzYWJsZWQpO1xuICAgIH1cbiAgfSxcbiAgcmVtb3ZlKHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB7IHVtOiB1bm1vdW50LCBvOiB7IHJlbW92ZTogaG9zdFJlbW92ZSB9IH0sIGRvUmVtb3ZlKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2hhcGVGbGFnLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBhbmNob3IsXG4gICAgICB0YXJnZXRTdGFydCxcbiAgICAgIHRhcmdldEFuY2hvcixcbiAgICAgIHRhcmdldCxcbiAgICAgIHByb3BzXG4gICAgfSA9IHZub2RlO1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIGhvc3RSZW1vdmUodGFyZ2V0U3RhcnQpO1xuICAgICAgaG9zdFJlbW92ZSh0YXJnZXRBbmNob3IpO1xuICAgIH1cbiAgICBkb1JlbW92ZSAmJiBob3N0UmVtb3ZlKGFuY2hvcik7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICBjb25zdCBzaG91bGRSZW1vdmUgPSBkb1JlbW92ZSB8fCAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgdW5tb3VudChcbiAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgc2hvdWxkUmVtb3ZlLFxuICAgICAgICAgICEhY2hpbGQuZHluYW1pY0NoaWxkcmVuXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3ZlOiBtb3ZlVGVsZXBvcnQsXG4gIGh5ZHJhdGU6IGh5ZHJhdGVUZWxlcG9ydFxufTtcbmZ1bmN0aW9uIG1vdmVUZWxlcG9ydCh2bm9kZSwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IsIHsgbzogeyBpbnNlcnQgfSwgbTogbW92ZSB9LCBtb3ZlVHlwZSA9IDIpIHtcbiAgaWYgKG1vdmVUeXBlID09PSAwKSB7XG4gICAgaW5zZXJ0KHZub2RlLnRhcmdldEFuY2hvciwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xuICB9XG4gIGNvbnN0IHsgZWwsIGFuY2hvciwgc2hhcGVGbGFnLCBjaGlsZHJlbiwgcHJvcHMgfSA9IHZub2RlO1xuICBjb25zdCBpc1Jlb3JkZXIgPSBtb3ZlVHlwZSA9PT0gMjtcbiAgaWYgKGlzUmVvcmRlcikge1xuICAgIGluc2VydChlbCwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xuICB9XG4gIGlmICghaXNSZW9yZGVyIHx8IGlzVGVsZXBvcnREaXNhYmxlZChwcm9wcykpIHtcbiAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbW92ZShcbiAgICAgICAgICBjaGlsZHJlbltpXSxcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgcGFyZW50QW5jaG9yLFxuICAgICAgICAgIDJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGlzUmVvcmRlcikge1xuICAgIGluc2VydChhbmNob3IsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcbiAgfVxufVxuZnVuY3Rpb24gaHlkcmF0ZVRlbGVwb3J0KG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwge1xuICBvOiB7IG5leHRTaWJsaW5nLCBwYXJlbnROb2RlLCBxdWVyeVNlbGVjdG9yLCBpbnNlcnQsIGNyZWF0ZVRleHQgfVxufSwgaHlkcmF0ZUNoaWxkcmVuKSB7XG4gIGNvbnN0IHRhcmdldCA9IHZub2RlLnRhcmdldCA9IHJlc29sdmVUYXJnZXQoXG4gICAgdm5vZGUucHJvcHMsXG4gICAgcXVlcnlTZWxlY3RvclxuICApO1xuICBpZiAodGFyZ2V0KSB7XG4gICAgY29uc3QgZGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQodm5vZGUucHJvcHMpO1xuICAgIGNvbnN0IHRhcmdldE5vZGUgPSB0YXJnZXQuX2xwYSB8fCB0YXJnZXQuZmlyc3RDaGlsZDtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICB2bm9kZS5hbmNob3IgPSBoeWRyYXRlQ2hpbGRyZW4oXG4gICAgICAgICAgbmV4dFNpYmxpbmcobm9kZSksXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgcGFyZW50Tm9kZShub2RlKSxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICB2bm9kZS50YXJnZXRTdGFydCA9IHRhcmdldE5vZGU7XG4gICAgICAgIHZub2RlLnRhcmdldEFuY2hvciA9IHRhcmdldE5vZGUgJiYgbmV4dFNpYmxpbmcodGFyZ2V0Tm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZS5hbmNob3IgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgbGV0IHRhcmdldEFuY2hvciA9IHRhcmdldE5vZGU7XG4gICAgICAgIHdoaWxlICh0YXJnZXRBbmNob3IpIHtcbiAgICAgICAgICBpZiAodGFyZ2V0QW5jaG9yICYmIHRhcmdldEFuY2hvci5ub2RlVHlwZSA9PT0gOCkge1xuICAgICAgICAgICAgaWYgKHRhcmdldEFuY2hvci5kYXRhID09PSBcInRlbGVwb3J0IHN0YXJ0IGFuY2hvclwiKSB7XG4gICAgICAgICAgICAgIHZub2RlLnRhcmdldFN0YXJ0ID0gdGFyZ2V0QW5jaG9yO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRBbmNob3IuZGF0YSA9PT0gXCJ0ZWxlcG9ydCBhbmNob3JcIikge1xuICAgICAgICAgICAgICB2bm9kZS50YXJnZXRBbmNob3IgPSB0YXJnZXRBbmNob3I7XG4gICAgICAgICAgICAgIHRhcmdldC5fbHBhID0gdm5vZGUudGFyZ2V0QW5jaG9yICYmIG5leHRTaWJsaW5nKHZub2RlLnRhcmdldEFuY2hvcik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXRBbmNob3IgPSBuZXh0U2libGluZyh0YXJnZXRBbmNob3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdm5vZGUudGFyZ2V0QW5jaG9yKSB7XG4gICAgICAgICAgcHJlcGFyZUFuY2hvcih0YXJnZXQsIHZub2RlLCBjcmVhdGVUZXh0LCBpbnNlcnQpO1xuICAgICAgICB9XG4gICAgICAgIGh5ZHJhdGVDaGlsZHJlbihcbiAgICAgICAgICB0YXJnZXROb2RlICYmIG5leHRTaWJsaW5nKHRhcmdldE5vZGUpLFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVDc3NWYXJzKHZub2RlLCBkaXNhYmxlZCk7XG4gIH1cbiAgcmV0dXJuIHZub2RlLmFuY2hvciAmJiBuZXh0U2libGluZyh2bm9kZS5hbmNob3IpO1xufVxuY29uc3QgVGVsZXBvcnQgPSBUZWxlcG9ydEltcGw7XG5mdW5jdGlvbiB1cGRhdGVDc3NWYXJzKHZub2RlLCBpc0Rpc2FibGVkKSB7XG4gIGNvbnN0IGN0eCA9IHZub2RlLmN0eDtcbiAgaWYgKGN0eCAmJiBjdHgudXQpIHtcbiAgICBsZXQgbm9kZSwgYW5jaG9yO1xuICAgIGlmIChpc0Rpc2FibGVkKSB7XG4gICAgICBub2RlID0gdm5vZGUuZWw7XG4gICAgICBhbmNob3IgPSB2bm9kZS5hbmNob3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSB2bm9kZS50YXJnZXRTdGFydDtcbiAgICAgIGFuY2hvciA9IHZub2RlLnRhcmdldEFuY2hvcjtcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUgJiYgbm9kZSAhPT0gYW5jaG9yKSB7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSkgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXYtb3duZXJcIiwgY3R4LnVpZCk7XG4gICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICB9XG4gICAgY3R4LnV0KCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHByZXBhcmVBbmNob3IodGFyZ2V0LCB2bm9kZSwgY3JlYXRlVGV4dCwgaW5zZXJ0KSB7XG4gIGNvbnN0IHRhcmdldFN0YXJ0ID0gdm5vZGUudGFyZ2V0U3RhcnQgPSBjcmVhdGVUZXh0KFwiXCIpO1xuICBjb25zdCB0YXJnZXRBbmNob3IgPSB2bm9kZS50YXJnZXRBbmNob3IgPSBjcmVhdGVUZXh0KFwiXCIpO1xuICB0YXJnZXRTdGFydFtUZWxlcG9ydEVuZEtleV0gPSB0YXJnZXRBbmNob3I7XG4gIGlmICh0YXJnZXQpIHtcbiAgICBpbnNlcnQodGFyZ2V0U3RhcnQsIHRhcmdldCk7XG4gICAgaW5zZXJ0KHRhcmdldEFuY2hvciwgdGFyZ2V0KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0QW5jaG9yO1xufVxuXG5jb25zdCBsZWF2ZUNiS2V5ID0gU3ltYm9sKFwiX2xlYXZlQ2JcIik7XG5jb25zdCBlbnRlckNiS2V5ID0gU3ltYm9sKFwiX2VudGVyQ2JcIik7XG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uU3RhdGUoKSB7XG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIGlzTW91bnRlZDogZmFsc2UsXG4gICAgaXNMZWF2aW5nOiBmYWxzZSxcbiAgICBpc1VubW91bnRpbmc6IGZhbHNlLFxuICAgIGxlYXZpbmdWTm9kZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKClcbiAgfTtcbiAgb25Nb3VudGVkKCgpID0+IHtcbiAgICBzdGF0ZS5pc01vdW50ZWQgPSB0cnVlO1xuICB9KTtcbiAgb25CZWZvcmVVbm1vdW50KCgpID0+IHtcbiAgICBzdGF0ZS5pc1VubW91bnRpbmcgPSB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuY29uc3QgVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IgPSBbRnVuY3Rpb24sIEFycmF5XTtcbmNvbnN0IEJhc2VUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzID0ge1xuICBtb2RlOiBTdHJpbmcsXG4gIGFwcGVhcjogQm9vbGVhbixcbiAgcGVyc2lzdGVkOiBCb29sZWFuLFxuICAvLyBlbnRlclxuICBvbkJlZm9yZUVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25FbnRlcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uQWZ0ZXJFbnRlcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uRW50ZXJDYW5jZWxsZWQ6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICAvLyBsZWF2ZVxuICBvbkJlZm9yZUxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25MZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uQWZ0ZXJMZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uTGVhdmVDYW5jZWxsZWQ6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICAvLyBhcHBlYXJcbiAgb25CZWZvcmVBcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uQWZ0ZXJBcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkFwcGVhckNhbmNlbGxlZDogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3Jcbn07XG5jb25zdCByZWN1cnNpdmVHZXRTdWJ0cmVlID0gKGluc3RhbmNlKSA9PiB7XG4gIGNvbnN0IHN1YlRyZWUgPSBpbnN0YW5jZS5zdWJUcmVlO1xuICByZXR1cm4gc3ViVHJlZS5jb21wb25lbnQgPyByZWN1cnNpdmVHZXRTdWJ0cmVlKHN1YlRyZWUuY29tcG9uZW50KSA6IHN1YlRyZWU7XG59O1xuY29uc3QgQmFzZVRyYW5zaXRpb25JbXBsID0ge1xuICBuYW1lOiBgQmFzZVRyYW5zaXRpb25gLFxuICBwcm9wczogQmFzZVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMsXG4gIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGNvbnN0IHN0YXRlID0gdXNlVHJhbnNpdGlvblN0YXRlKCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCAmJiBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oc2xvdHMuZGVmYXVsdCgpLCB0cnVlKTtcbiAgICAgIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZCA9IGZpbmROb25Db21tZW50Q2hpbGQoY2hpbGRyZW4pO1xuICAgICAgY29uc3QgcmF3UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XG4gICAgICBjb25zdCB7IG1vZGUgfSA9IHJhd1Byb3BzO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbW9kZSAmJiBtb2RlICE9PSBcImluLW91dFwiICYmIG1vZGUgIT09IFwib3V0LWluXCIgJiYgbW9kZSAhPT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgd2FybiQxKGBpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAke21vZGV9YCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuaXNMZWF2aW5nKSB7XG4gICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlubmVyQ2hpbGQgPSBnZXRJbm5lckNoaWxkJDEoY2hpbGQpO1xuICAgICAgaWYgKCFpbm5lckNoaWxkKSB7XG4gICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGxldCBlbnRlckhvb2tzID0gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhcbiAgICAgICAgaW5uZXJDaGlsZCxcbiAgICAgICAgcmF3UHJvcHMsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgLy8gIzExMDYxLCBlbnN1cmUgZW50ZXJIb29rcyBpcyBmcmVzaCBhZnRlciBjbG9uZVxuICAgICAgICAoaG9va3MpID0+IGVudGVySG9va3MgPSBob29rc1xuICAgICAgKTtcbiAgICAgIGlmIChpbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKGlubmVyQ2hpbGQsIGVudGVySG9va3MpO1xuICAgICAgfVxuICAgICAgbGV0IG9sZElubmVyQ2hpbGQgPSBpbnN0YW5jZS5zdWJUcmVlICYmIGdldElubmVyQ2hpbGQkMShpbnN0YW5jZS5zdWJUcmVlKTtcbiAgICAgIGlmIChvbGRJbm5lckNoaWxkICYmIG9sZElubmVyQ2hpbGQudHlwZSAhPT0gQ29tbWVudCAmJiAhaXNTYW1lVk5vZGVUeXBlKGlubmVyQ2hpbGQsIG9sZElubmVyQ2hpbGQpICYmIHJlY3Vyc2l2ZUdldFN1YnRyZWUoaW5zdGFuY2UpLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgICAgbGV0IGxlYXZpbmdIb29rcyA9IHJlc29sdmVUcmFuc2l0aW9uSG9va3MoXG4gICAgICAgICAgb2xkSW5uZXJDaGlsZCxcbiAgICAgICAgICByYXdQcm9wcyxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICApO1xuICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3Mob2xkSW5uZXJDaGlsZCwgbGVhdmluZ0hvb2tzKTtcbiAgICAgICAgaWYgKG1vZGUgPT09IFwib3V0LWluXCIgJiYgaW5uZXJDaGlsZC50eXBlICE9PSBDb21tZW50KSB7XG4gICAgICAgICAgc3RhdGUuaXNMZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgICBsZWF2aW5nSG9va3MuYWZ0ZXJMZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHN0YXRlLmlzTGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCEoaW5zdGFuY2Uuam9iLmZsYWdzICYgOCkpIHtcbiAgICAgICAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgbGVhdmluZ0hvb2tzLmFmdGVyTGVhdmU7XG4gICAgICAgICAgICBvbGRJbm5lckNoaWxkID0gdm9pZCAwO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGVtcHR5UGxhY2Vob2xkZXIoY2hpbGQpO1xuICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09IFwiaW4tb3V0XCIgJiYgaW5uZXJDaGlsZC50eXBlICE9PSBDb21tZW50KSB7XG4gICAgICAgICAgbGVhdmluZ0hvb2tzLmRlbGF5TGVhdmUgPSAoZWwsIGVhcmx5UmVtb3ZlLCBkZWxheWVkTGVhdmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxlYXZpbmdWTm9kZXNDYWNoZSA9IGdldExlYXZpbmdOb2Rlc0ZvclR5cGUoXG4gICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICBvbGRJbm5lckNoaWxkXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGVhdmluZ1ZOb2Rlc0NhY2hlW1N0cmluZyhvbGRJbm5lckNoaWxkLmtleSldID0gb2xkSW5uZXJDaGlsZDtcbiAgICAgICAgICAgIGVsW2xlYXZlQ2JLZXldID0gKCkgPT4ge1xuICAgICAgICAgICAgICBlYXJseVJlbW92ZSgpO1xuICAgICAgICAgICAgICBlbFtsZWF2ZUNiS2V5XSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgZGVsZXRlIGVudGVySG9va3MuZGVsYXllZExlYXZlO1xuICAgICAgICAgICAgICBvbGRJbm5lckNoaWxkID0gdm9pZCAwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGVudGVySG9va3MuZGVsYXllZExlYXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgICBkZWxheWVkTGVhdmUoKTtcbiAgICAgICAgICAgICAgZGVsZXRlIGVudGVySG9va3MuZGVsYXllZExlYXZlO1xuICAgICAgICAgICAgICBvbGRJbm5lckNoaWxkID0gdm9pZCAwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9sZElubmVyQ2hpbGQgPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob2xkSW5uZXJDaGlsZCkge1xuICAgICAgICBvbGRJbm5lckNoaWxkID0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBmaW5kTm9uQ29tbWVudENoaWxkKGNoaWxkcmVuKSB7XG4gIGxldCBjaGlsZCA9IGNoaWxkcmVuWzBdO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgIGxldCBoYXNGb3VuZCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgYyBvZiBjaGlsZHJlbikge1xuICAgICAgaWYgKGMudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBoYXNGb3VuZCkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIFwiPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudCBvciBjb21wb25lbnQuIFVzZSA8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjaGlsZCA9IGM7XG4gICAgICAgIGhhc0ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgaWYgKCEhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoaWxkO1xufVxuY29uc3QgQmFzZVRyYW5zaXRpb24gPSBCYXNlVHJhbnNpdGlvbkltcGw7XG5mdW5jdGlvbiBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCB2bm9kZSkge1xuICBjb25zdCB7IGxlYXZpbmdWTm9kZXMgfSA9IHN0YXRlO1xuICBsZXQgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gbGVhdmluZ1ZOb2Rlcy5nZXQodm5vZGUudHlwZSk7XG4gIGlmICghbGVhdmluZ1ZOb2Rlc0NhY2hlKSB7XG4gICAgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGVhdmluZ1ZOb2Rlcy5zZXQodm5vZGUudHlwZSwgbGVhdmluZ1ZOb2Rlc0NhY2hlKTtcbiAgfVxuICByZXR1cm4gbGVhdmluZ1ZOb2Rlc0NhY2hlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyh2bm9kZSwgcHJvcHMsIHN0YXRlLCBpbnN0YW5jZSwgcG9zdENsb25lKSB7XG4gIGNvbnN0IHtcbiAgICBhcHBlYXIsXG4gICAgbW9kZSxcbiAgICBwZXJzaXN0ZWQgPSBmYWxzZSxcbiAgICBvbkJlZm9yZUVudGVyLFxuICAgIG9uRW50ZXIsXG4gICAgb25BZnRlckVudGVyLFxuICAgIG9uRW50ZXJDYW5jZWxsZWQsXG4gICAgb25CZWZvcmVMZWF2ZSxcbiAgICBvbkxlYXZlLFxuICAgIG9uQWZ0ZXJMZWF2ZSxcbiAgICBvbkxlYXZlQ2FuY2VsbGVkLFxuICAgIG9uQmVmb3JlQXBwZWFyLFxuICAgIG9uQXBwZWFyLFxuICAgIG9uQWZ0ZXJBcHBlYXIsXG4gICAgb25BcHBlYXJDYW5jZWxsZWRcbiAgfSA9IHByb3BzO1xuICBjb25zdCBrZXkgPSBTdHJpbmcodm5vZGUua2V5KTtcbiAgY29uc3QgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShzdGF0ZSwgdm5vZGUpO1xuICBjb25zdCBjYWxsSG9vayA9IChob29rLCBhcmdzKSA9PiB7XG4gICAgaG9vayAmJiBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICAgIGhvb2ssXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDksXG4gICAgICBhcmdzXG4gICAgKTtcbiAgfTtcbiAgY29uc3QgY2FsbEFzeW5jSG9vayA9IChob29rLCBhcmdzKSA9PiB7XG4gICAgY29uc3QgZG9uZSA9IGFyZ3NbMV07XG4gICAgY2FsbEhvb2soaG9vaywgYXJncyk7XG4gICAgaWYgKGlzQXJyYXkoaG9vaykpIHtcbiAgICAgIGlmIChob29rLmV2ZXJ5KChob29rMikgPT4gaG9vazIubGVuZ3RoIDw9IDEpKSBkb25lKCk7XG4gICAgfSBlbHNlIGlmIChob29rLmxlbmd0aCA8PSAxKSB7XG4gICAgICBkb25lKCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBob29rcyA9IHtcbiAgICBtb2RlLFxuICAgIHBlcnNpc3RlZCxcbiAgICBiZWZvcmVFbnRlcihlbCkge1xuICAgICAgbGV0IGhvb2sgPSBvbkJlZm9yZUVudGVyO1xuICAgICAgaWYgKCFzdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgICAgaWYgKGFwcGVhcikge1xuICAgICAgICAgIGhvb2sgPSBvbkJlZm9yZUFwcGVhciB8fCBvbkJlZm9yZUVudGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVsW2xlYXZlQ2JLZXldKSB7XG4gICAgICAgIGVsW2xlYXZlQ2JLZXldKFxuICAgICAgICAgIHRydWVcbiAgICAgICAgICAvKiBjYW5jZWxsZWQgKi9cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxlYXZpbmdWTm9kZSA9IGxlYXZpbmdWTm9kZXNDYWNoZVtrZXldO1xuICAgICAgaWYgKGxlYXZpbmdWTm9kZSAmJiBpc1NhbWVWTm9kZVR5cGUodm5vZGUsIGxlYXZpbmdWTm9kZSkgJiYgbGVhdmluZ1ZOb2RlLmVsW2xlYXZlQ2JLZXldKSB7XG4gICAgICAgIGxlYXZpbmdWTm9kZS5lbFtsZWF2ZUNiS2V5XSgpO1xuICAgICAgfVxuICAgICAgY2FsbEhvb2soaG9vaywgW2VsXSk7XG4gICAgfSxcbiAgICBlbnRlcihlbCkge1xuICAgICAgbGV0IGhvb2sgPSBvbkVudGVyO1xuICAgICAgbGV0IGFmdGVySG9vayA9IG9uQWZ0ZXJFbnRlcjtcbiAgICAgIGxldCBjYW5jZWxIb29rID0gb25FbnRlckNhbmNlbGxlZDtcbiAgICAgIGlmICghc3RhdGUuaXNNb3VudGVkKSB7XG4gICAgICAgIGlmIChhcHBlYXIpIHtcbiAgICAgICAgICBob29rID0gb25BcHBlYXIgfHwgb25FbnRlcjtcbiAgICAgICAgICBhZnRlckhvb2sgPSBvbkFmdGVyQXBwZWFyIHx8IG9uQWZ0ZXJFbnRlcjtcbiAgICAgICAgICBjYW5jZWxIb29rID0gb25BcHBlYXJDYW5jZWxsZWQgfHwgb25FbnRlckNhbmNlbGxlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGRvbmUgPSBlbFtlbnRlckNiS2V5XSA9IChjYW5jZWxsZWQpID0+IHtcbiAgICAgICAgaWYgKGNhbGxlZCkgcmV0dXJuO1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgY2FsbEhvb2soY2FuY2VsSG9vaywgW2VsXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbEhvb2soYWZ0ZXJIb29rLCBbZWxdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va3MuZGVsYXllZExlYXZlKSB7XG4gICAgICAgICAgaG9va3MuZGVsYXllZExlYXZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxbZW50ZXJDYktleV0gPSB2b2lkIDA7XG4gICAgICB9O1xuICAgICAgaWYgKGhvb2spIHtcbiAgICAgICAgY2FsbEFzeW5jSG9vayhob29rLCBbZWwsIGRvbmVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGxlYXZlKGVsLCByZW1vdmUpIHtcbiAgICAgIGNvbnN0IGtleTIgPSBTdHJpbmcodm5vZGUua2V5KTtcbiAgICAgIGlmIChlbFtlbnRlckNiS2V5XSkge1xuICAgICAgICBlbFtlbnRlckNiS2V5XShcbiAgICAgICAgICB0cnVlXG4gICAgICAgICAgLyogY2FuY2VsbGVkICovXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuaXNVbm1vdW50aW5nKSB7XG4gICAgICAgIHJldHVybiByZW1vdmUoKTtcbiAgICAgIH1cbiAgICAgIGNhbGxIb29rKG9uQmVmb3JlTGVhdmUsIFtlbF0pO1xuICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICAgICAgY29uc3QgZG9uZSA9IGVsW2xlYXZlQ2JLZXldID0gKGNhbmNlbGxlZCkgPT4ge1xuICAgICAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIHJlbW92ZSgpO1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgY2FsbEhvb2sob25MZWF2ZUNhbmNlbGxlZCwgW2VsXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbEhvb2sob25BZnRlckxlYXZlLCBbZWxdKTtcbiAgICAgICAgfVxuICAgICAgICBlbFtsZWF2ZUNiS2V5XSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGxlYXZpbmdWTm9kZXNDYWNoZVtrZXkyXSA9PT0gdm5vZGUpIHtcbiAgICAgICAgICBkZWxldGUgbGVhdmluZ1ZOb2Rlc0NhY2hlW2tleTJdO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgbGVhdmluZ1ZOb2Rlc0NhY2hlW2tleTJdID0gdm5vZGU7XG4gICAgICBpZiAob25MZWF2ZSkge1xuICAgICAgICBjYWxsQXN5bmNIb29rKG9uTGVhdmUsIFtlbCwgZG9uZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2xvbmUodm5vZGUyKSB7XG4gICAgICBjb25zdCBob29rczIgPSByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKFxuICAgICAgICB2bm9kZTIsXG4gICAgICAgIHByb3BzLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgIHBvc3RDbG9uZVxuICAgICAgKTtcbiAgICAgIGlmIChwb3N0Q2xvbmUpIHBvc3RDbG9uZShob29rczIpO1xuICAgICAgcmV0dXJuIGhvb2tzMjtcbiAgICB9XG4gIH07XG4gIHJldHVybiBob29rcztcbn1cbmZ1bmN0aW9uIGVtcHR5UGxhY2Vob2xkZXIodm5vZGUpIHtcbiAgaWYgKGlzS2VlcEFsaXZlKHZub2RlKSkge1xuICAgIHZub2RlID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgdm5vZGUuY2hpbGRyZW4gPSBudWxsO1xuICAgIHJldHVybiB2bm9kZTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0SW5uZXJDaGlsZCQxKHZub2RlKSB7XG4gIGlmICghaXNLZWVwQWxpdmUodm5vZGUpKSB7XG4gICAgaWYgKGlzVGVsZXBvcnQodm5vZGUudHlwZSkgJiYgdm5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBmaW5kTm9uQ29tbWVudENoaWxkKHZub2RlLmNoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHZub2RlLmNvbXBvbmVudCkge1xuICAgIHJldHVybiB2bm9kZS5jb21wb25lbnQuc3ViVHJlZTtcbiAgfVxuICBjb25zdCB7IHNoYXBlRmxhZywgY2hpbGRyZW4gfSA9IHZub2RlO1xuICBpZiAoY2hpbGRyZW4pIHtcbiAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlblswXTtcbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDMyICYmIGlzRnVuY3Rpb24oY2hpbGRyZW4uZGVmYXVsdCkpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbi5kZWZhdWx0KCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRUcmFuc2l0aW9uSG9va3Modm5vZGUsIGhvb2tzKSB7XG4gIGlmICh2bm9kZS5zaGFwZUZsYWcgJiA2ICYmIHZub2RlLmNvbXBvbmVudCkge1xuICAgIHZub2RlLnRyYW5zaXRpb24gPSBob29rcztcbiAgICBzZXRUcmFuc2l0aW9uSG9va3Modm5vZGUuY29tcG9uZW50LnN1YlRyZWUsIGhvb2tzKTtcbiAgfSBlbHNlIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxMjgpIHtcbiAgICB2bm9kZS5zc0NvbnRlbnQudHJhbnNpdGlvbiA9IGhvb2tzLmNsb25lKHZub2RlLnNzQ29udGVudCk7XG4gICAgdm5vZGUuc3NGYWxsYmFjay50cmFuc2l0aW9uID0gaG9va3MuY2xvbmUodm5vZGUuc3NGYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgdm5vZGUudHJhbnNpdGlvbiA9IGhvb2tzO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oY2hpbGRyZW4sIGtlZXBDb21tZW50ID0gZmFsc2UsIHBhcmVudEtleSkge1xuICBsZXQgcmV0ID0gW107XG4gIGxldCBrZXllZEZyYWdtZW50Q291bnQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgY29uc3Qga2V5ID0gcGFyZW50S2V5ID09IG51bGwgPyBjaGlsZC5rZXkgOiBTdHJpbmcocGFyZW50S2V5KSArIFN0cmluZyhjaGlsZC5rZXkgIT0gbnVsbCA/IGNoaWxkLmtleSA6IGkpO1xuICAgIGlmIChjaGlsZC50eXBlID09PSBGcmFnbWVudCkge1xuICAgICAgaWYgKGNoaWxkLnBhdGNoRmxhZyAmIDEyOCkga2V5ZWRGcmFnbWVudENvdW50Kys7XG4gICAgICByZXQgPSByZXQuY29uY2F0KFxuICAgICAgICBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oY2hpbGQuY2hpbGRyZW4sIGtlZXBDb21tZW50LCBrZXkpXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoa2VlcENvbW1lbnQgfHwgY2hpbGQudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgcmV0LnB1c2goa2V5ICE9IG51bGwgPyBjbG9uZVZOb2RlKGNoaWxkLCB7IGtleSB9KSA6IGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgaWYgKGtleWVkRnJhZ21lbnRDb3VudCA+IDEpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJldC5sZW5ndGg7IGkrKykge1xuICAgICAgcmV0W2ldLnBhdGNoRmxhZyA9IC0yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKiEgI19fTk9fU0lERV9FRkZFQ1RTX18gKi9cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBkZWZpbmVDb21wb25lbnQob3B0aW9ucywgZXh0cmFPcHRpb25zKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKG9wdGlvbnMpID8gKFxuICAgIC8vICM4MjM2OiBleHRlbmQgY2FsbCBhbmQgb3B0aW9ucy5uYW1lIGFjY2VzcyBhcmUgY29uc2lkZXJlZCBzaWRlLWVmZmVjdHNcbiAgICAvLyBieSBSb2xsdXAsIHNvIHdlIGhhdmUgdG8gd3JhcCBpdCBpbiBhIHB1cmUtYW5ub3RhdGVkIElJRkUuXG4gICAgLyogQF9fUFVSRV9fICovICgoKSA9PiBleHRlbmQoeyBuYW1lOiBvcHRpb25zLm5hbWUgfSwgZXh0cmFPcHRpb25zLCB7IHNldHVwOiBvcHRpb25zIH0pKSgpXG4gICkgOiBvcHRpb25zO1xufVxuXG5mdW5jdGlvbiB1c2VJZCgpIHtcbiAgY29uc3QgaSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBpZiAoaSkge1xuICAgIHJldHVybiAoaS5hcHBDb250ZXh0LmNvbmZpZy5pZFByZWZpeCB8fCBcInZcIikgKyBcIi1cIiArIGkuaWRzWzBdICsgaS5pZHNbMV0rKztcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FybiQxKFxuICAgICAgYHVzZUlkKCkgaXMgY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZSB0byBiZSBhc3NvY2lhdGVkIHdpdGguYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIFwiXCI7XG59XG5mdW5jdGlvbiBtYXJrQXN5bmNCb3VuZGFyeShpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5pZHMgPSBbaW5zdGFuY2UuaWRzWzBdICsgaW5zdGFuY2UuaWRzWzJdKysgKyBcIi1cIiwgMCwgMF07XG59XG5cbmNvbnN0IGtub3duVGVtcGxhdGVSZWZzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG5mdW5jdGlvbiB1c2VUZW1wbGF0ZVJlZihrZXkpIHtcbiAgY29uc3QgaSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBjb25zdCByID0gc2hhbGxvd1JlZihudWxsKTtcbiAgaWYgKGkpIHtcbiAgICBjb25zdCByZWZzID0gaS5yZWZzID09PSBFTVBUWV9PQkogPyBpLnJlZnMgPSB7fSA6IGkucmVmcztcbiAgICBsZXQgZGVzYztcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAoZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocmVmcywga2V5KSkgJiYgIWRlc2MuY29uZmlndXJhYmxlKSB7XG4gICAgICB3YXJuJDEoYHVzZVRlbXBsYXRlUmVmKCcke2tleX0nKSBhbHJlYWR5IGV4aXN0cy5gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlZnMsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IHIudmFsdWUsXG4gICAgICAgIHNldDogKHZhbCkgPT4gci52YWx1ZSA9IHZhbFxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgdXNlVGVtcGxhdGVSZWYoKSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlIHRvIGJlIGFzc29jaWF0ZWQgd2l0aC5gXG4gICAgKTtcbiAgfVxuICBjb25zdCByZXQgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gcmVhZG9ubHkocikgOiByO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGtub3duVGVtcGxhdGVSZWZzLmFkZChyZXQpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHNldFJlZihyYXdSZWYsIG9sZFJhd1JlZiwgcGFyZW50U3VzcGVuc2UsIHZub2RlLCBpc1VubW91bnQgPSBmYWxzZSkge1xuICBpZiAoaXNBcnJheShyYXdSZWYpKSB7XG4gICAgcmF3UmVmLmZvckVhY2goXG4gICAgICAociwgaSkgPT4gc2V0UmVmKFxuICAgICAgICByLFxuICAgICAgICBvbGRSYXdSZWYgJiYgKGlzQXJyYXkob2xkUmF3UmVmKSA/IG9sZFJhd1JlZltpXSA6IG9sZFJhd1JlZiksXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgaXNVbm1vdW50XG4gICAgICApXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGlzQXN5bmNXcmFwcGVyKHZub2RlKSAmJiAhaXNVbm1vdW50KSB7XG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDUxMiAmJiB2bm9kZS50eXBlLl9fYXN5bmNSZXNvbHZlZCAmJiB2bm9kZS5jb21wb25lbnQuc3ViVHJlZS5jb21wb25lbnQpIHtcbiAgICAgIHNldFJlZihyYXdSZWYsIG9sZFJhd1JlZiwgcGFyZW50U3VzcGVuc2UsIHZub2RlLmNvbXBvbmVudC5zdWJUcmVlKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJlZlZhbHVlID0gdm5vZGUuc2hhcGVGbGFnICYgNCA/IGdldENvbXBvbmVudFB1YmxpY0luc3RhbmNlKHZub2RlLmNvbXBvbmVudCkgOiB2bm9kZS5lbDtcbiAgY29uc3QgdmFsdWUgPSBpc1VubW91bnQgPyBudWxsIDogcmVmVmFsdWU7XG4gIGNvbnN0IHsgaTogb3duZXIsIHI6IHJlZiB9ID0gcmF3UmVmO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhb3duZXIpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgTWlzc2luZyByZWYgb3duZXIgY29udGV4dC4gcmVmIGNhbm5vdCBiZSB1c2VkIG9uIGhvaXN0ZWQgdm5vZGVzLiBBIHZub2RlIHdpdGggcmVmIG11c3QgYmUgY3JlYXRlZCBpbnNpZGUgdGhlIHJlbmRlciBmdW5jdGlvbi5gXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb2xkUmVmID0gb2xkUmF3UmVmICYmIG9sZFJhd1JlZi5yO1xuICBjb25zdCByZWZzID0gb3duZXIucmVmcyA9PT0gRU1QVFlfT0JKID8gb3duZXIucmVmcyA9IHt9IDogb3duZXIucmVmcztcbiAgY29uc3Qgc2V0dXBTdGF0ZSA9IG93bmVyLnNldHVwU3RhdGU7XG4gIGNvbnN0IHJhd1NldHVwU3RhdGUgPSB0b1JhdyhzZXR1cFN0YXRlKTtcbiAgY29uc3QgY2FuU2V0U2V0dXBSZWYgPSBzZXR1cFN0YXRlID09PSBFTVBUWV9PQkogPyAoKSA9PiBmYWxzZSA6IChrZXkpID0+IHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgaWYgKGhhc093bihyYXdTZXR1cFN0YXRlLCBrZXkpICYmICFpc1JlZihyYXdTZXR1cFN0YXRlW2tleV0pKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBgVGVtcGxhdGUgcmVmIFwiJHtrZXl9XCIgdXNlZCBvbiBhIG5vbi1yZWYgdmFsdWUuIEl0IHdpbGwgbm90IHdvcmsgaW4gdGhlIHByb2R1Y3Rpb24gYnVpbGQuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGtub3duVGVtcGxhdGVSZWZzLmhhcyhyYXdTZXR1cFN0YXRlW2tleV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhhc093bihyYXdTZXR1cFN0YXRlLCBrZXkpO1xuICB9O1xuICBpZiAob2xkUmVmICE9IG51bGwgJiYgb2xkUmVmICE9PSByZWYpIHtcbiAgICBpZiAoaXNTdHJpbmcob2xkUmVmKSkge1xuICAgICAgcmVmc1tvbGRSZWZdID0gbnVsbDtcbiAgICAgIGlmIChjYW5TZXRTZXR1cFJlZihvbGRSZWYpKSB7XG4gICAgICAgIHNldHVwU3RhdGVbb2xkUmVmXSA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1JlZihvbGRSZWYpKSB7XG4gICAgICBvbGRSZWYudmFsdWUgPSBudWxsO1xuICAgIH1cbiAgfVxuICBpZiAoaXNGdW5jdGlvbihyZWYpKSB7XG4gICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKHJlZiwgb3duZXIsIDEyLCBbdmFsdWUsIHJlZnNdKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBfaXNTdHJpbmcgPSBpc1N0cmluZyhyZWYpO1xuICAgIGNvbnN0IF9pc1JlZiA9IGlzUmVmKHJlZik7XG4gICAgaWYgKF9pc1N0cmluZyB8fCBfaXNSZWYpIHtcbiAgICAgIGNvbnN0IGRvU2V0ID0gKCkgPT4ge1xuICAgICAgICBpZiAocmF3UmVmLmYpIHtcbiAgICAgICAgICBjb25zdCBleGlzdGluZyA9IF9pc1N0cmluZyA/IGNhblNldFNldHVwUmVmKHJlZikgPyBzZXR1cFN0YXRlW3JlZl0gOiByZWZzW3JlZl0gOiByZWYudmFsdWU7XG4gICAgICAgICAgaWYgKGlzVW5tb3VudCkge1xuICAgICAgICAgICAgaXNBcnJheShleGlzdGluZykgJiYgcmVtb3ZlKGV4aXN0aW5nLCByZWZWYWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaXNBcnJheShleGlzdGluZykpIHtcbiAgICAgICAgICAgICAgaWYgKF9pc1N0cmluZykge1xuICAgICAgICAgICAgICAgIHJlZnNbcmVmXSA9IFtyZWZWYWx1ZV07XG4gICAgICAgICAgICAgICAgaWYgKGNhblNldFNldHVwUmVmKHJlZikpIHtcbiAgICAgICAgICAgICAgICAgIHNldHVwU3RhdGVbcmVmXSA9IHJlZnNbcmVmXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVmLnZhbHVlID0gW3JlZlZhbHVlXTtcbiAgICAgICAgICAgICAgICBpZiAocmF3UmVmLmspIHJlZnNbcmF3UmVmLmtdID0gcmVmLnZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFleGlzdGluZy5pbmNsdWRlcyhyZWZWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgZXhpc3RpbmcucHVzaChyZWZWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKF9pc1N0cmluZykge1xuICAgICAgICAgIHJlZnNbcmVmXSA9IHZhbHVlO1xuICAgICAgICAgIGlmIChjYW5TZXRTZXR1cFJlZihyZWYpKSB7XG4gICAgICAgICAgICBzZXR1cFN0YXRlW3JlZl0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoX2lzUmVmKSB7XG4gICAgICAgICAgcmVmLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgaWYgKHJhd1JlZi5rKSByZWZzW3Jhd1JlZi5rXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB3YXJuJDEoXCJJbnZhbGlkIHRlbXBsYXRlIHJlZiB0eXBlOlwiLCByZWYsIGAoJHt0eXBlb2YgcmVmfSlgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBkb1NldC5pZCA9IC0xO1xuICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoZG9TZXQsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvU2V0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuJDEoXCJJbnZhbGlkIHRlbXBsYXRlIHJlZiB0eXBlOlwiLCByZWYsIGAoJHt0eXBlb2YgcmVmfSlgKTtcbiAgICB9XG4gIH1cbn1cblxubGV0IGhhc0xvZ2dlZE1pc21hdGNoRXJyb3IgPSBmYWxzZTtcbmNvbnN0IGxvZ01pc21hdGNoRXJyb3IgPSAoKSA9PiB7XG4gIGlmIChoYXNMb2dnZWRNaXNtYXRjaEVycm9yKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUuZXJyb3IoXCJIeWRyYXRpb24gY29tcGxldGVkIGJ1dCBjb250YWlucyBtaXNtYXRjaGVzLlwiKTtcbiAgaGFzTG9nZ2VkTWlzbWF0Y2hFcnJvciA9IHRydWU7XG59O1xuY29uc3QgaXNTVkdDb250YWluZXIgPSAoY29udGFpbmVyKSA9PiBjb250YWluZXIubmFtZXNwYWNlVVJJLmluY2x1ZGVzKFwic3ZnXCIpICYmIGNvbnRhaW5lci50YWdOYW1lICE9PSBcImZvcmVpZ25PYmplY3RcIjtcbmNvbnN0IGlzTWF0aE1MQ29udGFpbmVyID0gKGNvbnRhaW5lcikgPT4gY29udGFpbmVyLm5hbWVzcGFjZVVSSS5pbmNsdWRlcyhcIk1hdGhNTFwiKTtcbmNvbnN0IGdldENvbnRhaW5lclR5cGUgPSAoY29udGFpbmVyKSA9PiB7XG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgIT09IDEpIHJldHVybiB2b2lkIDA7XG4gIGlmIChpc1NWR0NvbnRhaW5lcihjb250YWluZXIpKSByZXR1cm4gXCJzdmdcIjtcbiAgaWYgKGlzTWF0aE1MQ29udGFpbmVyKGNvbnRhaW5lcikpIHJldHVybiBcIm1hdGhtbFwiO1xuICByZXR1cm4gdm9pZCAwO1xufTtcbmNvbnN0IGlzQ29tbWVudCA9IChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSA4O1xuZnVuY3Rpb24gY3JlYXRlSHlkcmF0aW9uRnVuY3Rpb25zKHJlbmRlcmVySW50ZXJuYWxzKSB7XG4gIGNvbnN0IHtcbiAgICBtdDogbW91bnRDb21wb25lbnQsXG4gICAgcDogcGF0Y2gsXG4gICAgbzoge1xuICAgICAgcGF0Y2hQcm9wLFxuICAgICAgY3JlYXRlVGV4dCxcbiAgICAgIG5leHRTaWJsaW5nLFxuICAgICAgcGFyZW50Tm9kZSxcbiAgICAgIHJlbW92ZSxcbiAgICAgIGluc2VydCxcbiAgICAgIGNyZWF0ZUNvbW1lbnRcbiAgICB9XG4gIH0gPSByZW5kZXJlckludGVybmFscztcbiAgY29uc3QgaHlkcmF0ZSA9ICh2bm9kZSwgY29udGFpbmVyKSA9PiB7XG4gICAgaWYgKCFjb250YWluZXIuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pICYmIHdhcm4kMShcbiAgICAgICAgYEF0dGVtcHRpbmcgdG8gaHlkcmF0ZSBleGlzdGluZyBtYXJrdXAgYnV0IGNvbnRhaW5lciBpcyBlbXB0eS4gUGVyZm9ybWluZyBmdWxsIG1vdW50IGluc3RlYWQuYFxuICAgICAgKTtcbiAgICAgIHBhdGNoKG51bGwsIHZub2RlLCBjb250YWluZXIpO1xuICAgICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcbiAgICAgIGNvbnRhaW5lci5fdm5vZGUgPSB2bm9kZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaHlkcmF0ZU5vZGUoY29udGFpbmVyLmZpcnN0Q2hpbGQsIHZub2RlLCBudWxsLCBudWxsLCBudWxsKTtcbiAgICBmbHVzaFBvc3RGbHVzaENicygpO1xuICAgIGNvbnRhaW5lci5fdm5vZGUgPSB2bm9kZTtcbiAgfTtcbiAgY29uc3QgaHlkcmF0ZU5vZGUgPSAobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcbiAgICBvcHRpbWl6ZWQgPSBvcHRpbWl6ZWQgfHwgISF2bm9kZS5keW5hbWljQ2hpbGRyZW47XG4gICAgY29uc3QgaXNGcmFnbWVudFN0YXJ0ID0gaXNDb21tZW50KG5vZGUpICYmIG5vZGUuZGF0YSA9PT0gXCJbXCI7XG4gICAgY29uc3Qgb25NaXNtYXRjaCA9ICgpID0+IGhhbmRsZU1pc21hdGNoKFxuICAgICAgbm9kZSxcbiAgICAgIHZub2RlLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICBzbG90U2NvcGVJZHMsXG4gICAgICBpc0ZyYWdtZW50U3RhcnRcbiAgICApO1xuICAgIGNvbnN0IHsgdHlwZSwgcmVmLCBzaGFwZUZsYWcsIHBhdGNoRmxhZyB9ID0gdm5vZGU7XG4gICAgbGV0IGRvbVR5cGUgPSBub2RlLm5vZGVUeXBlO1xuICAgIHZub2RlLmVsID0gbm9kZTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGRlZihub2RlLCBcIl9fdm5vZGVcIiwgdm5vZGUsIHRydWUpO1xuICAgICAgZGVmKG5vZGUsIFwiX192dWVQYXJlbnRDb21wb25lbnRcIiwgcGFyZW50Q29tcG9uZW50LCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKHBhdGNoRmxhZyA9PT0gLTIpIHtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICB9XG4gICAgbGV0IG5leHROb2RlID0gbnVsbDtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgVGV4dDpcbiAgICAgICAgaWYgKGRvbVR5cGUgIT09IDMpIHtcbiAgICAgICAgICBpZiAodm5vZGUuY2hpbGRyZW4gPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGluc2VydCh2bm9kZS5lbCA9IGNyZWF0ZVRleHQoXCJcIiksIHBhcmVudE5vZGUobm9kZSksIG5vZGUpO1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBub2RlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG5vZGUuZGF0YSAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgd2FybiQxKFxuICAgICAgICAgICAgICBgSHlkcmF0aW9uIHRleHQgbWlzbWF0Y2ggaW5gLFxuICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgIGBcbiAgLSByZW5kZXJlZCBvbiBzZXJ2ZXI6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhXG4gICAgICAgICAgICAgICl9XG4gIC0gZXhwZWN0ZWQgb24gY2xpZW50OiAke0pTT04uc3RyaW5naWZ5KHZub2RlLmNoaWxkcmVuKX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbG9nTWlzbWF0Y2hFcnJvcigpO1xuICAgICAgICAgICAgbm9kZS5kYXRhID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENvbW1lbnQ6XG4gICAgICAgIGlmIChpc1RlbXBsYXRlTm9kZShub2RlKSkge1xuICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgcmVwbGFjZU5vZGUoXG4gICAgICAgICAgICB2bm9kZS5lbCA9IG5vZGUuY29udGVudC5maXJzdENoaWxkLFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoZG9tVHlwZSAhPT0gOCB8fCBpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdGF0aWM6XG4gICAgICAgIGlmIChpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICBub2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgZG9tVHlwZSA9IG5vZGUubm9kZVR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvbVR5cGUgPT09IDEgfHwgZG9tVHlwZSA9PT0gMykge1xuICAgICAgICAgIG5leHROb2RlID0gbm9kZTtcbiAgICAgICAgICBjb25zdCBuZWVkVG9BZG9wdENvbnRlbnQgPSAhdm5vZGUuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdm5vZGUuc3RhdGljQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKG5lZWRUb0Fkb3B0Q29udGVudClcbiAgICAgICAgICAgICAgdm5vZGUuY2hpbGRyZW4gKz0gbmV4dE5vZGUubm9kZVR5cGUgPT09IDEgPyBuZXh0Tm9kZS5vdXRlckhUTUwgOiBuZXh0Tm9kZS5kYXRhO1xuICAgICAgICAgICAgaWYgKGkgPT09IHZub2RlLnN0YXRpY0NvdW50IC0gMSkge1xuICAgICAgICAgICAgICB2bm9kZS5hbmNob3IgPSBuZXh0Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobmV4dE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaXNGcmFnbWVudFN0YXJ0ID8gbmV4dFNpYmxpbmcobmV4dE5vZGUpIDogbmV4dE5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25NaXNtYXRjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGcmFnbWVudDpcbiAgICAgICAgaWYgKCFpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IGh5ZHJhdGVGcmFnbWVudChcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxKSB7XG4gICAgICAgICAgaWYgKChkb21UeXBlICE9PSAxIHx8IHZub2RlLnR5cGUudG9Mb3dlckNhc2UoKSAhPT0gbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpICYmICFpc1RlbXBsYXRlTm9kZShub2RlKSkge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gaHlkcmF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgIHZub2RlLFxuICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgNikge1xuICAgICAgICAgIHZub2RlLnNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkcztcbiAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xuICAgICAgICAgIGlmIChpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gbG9jYXRlQ2xvc2luZ0FuY2hvcihub2RlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzQ29tbWVudChub2RlKSAmJiBub2RlLmRhdGEgPT09IFwidGVsZXBvcnQgc3RhcnRcIikge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBsb2NhdGVDbG9zaW5nQW5jaG9yKG5vZGUsIG5vZGUuZGF0YSwgXCJ0ZWxlcG9ydCBlbmRcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1vdW50Q29tcG9uZW50KFxuICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBnZXRDb250YWluZXJUeXBlKGNvbnRhaW5lciksXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChpc0FzeW5jV3JhcHBlcih2bm9kZSkgJiYgIXZub2RlLnR5cGUuX19hc3luY1Jlc29sdmVkKSB7XG4gICAgICAgICAgICBsZXQgc3ViVHJlZTtcbiAgICAgICAgICAgIGlmIChpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICAgICAgc3ViVHJlZSA9IGNyZWF0ZVZOb2RlKEZyYWdtZW50KTtcbiAgICAgICAgICAgICAgc3ViVHJlZS5hbmNob3IgPSBuZXh0Tm9kZSA/IG5leHROb2RlLnByZXZpb3VzU2libGluZyA6IGNvbnRhaW5lci5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdWJUcmVlID0gbm9kZS5ub2RlVHlwZSA9PT0gMyA/IGNyZWF0ZVRleHRWTm9kZShcIlwiKSA6IGNyZWF0ZVZOb2RlKFwiZGl2XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3ViVHJlZS5lbCA9IG5vZGU7XG4gICAgICAgICAgICB2bm9kZS5jb21wb25lbnQuc3ViVHJlZSA9IHN1YlRyZWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDY0KSB7XG4gICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDgpIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IHZub2RlLnR5cGUuaHlkcmF0ZShcbiAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICAgICAgICByZW5kZXJlckludGVybmFscyxcbiAgICAgICAgICAgICAgaHlkcmF0ZUNoaWxkcmVuXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IHZub2RlLnR5cGUuaHlkcmF0ZShcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgZ2V0Q29udGFpbmVyVHlwZShwYXJlbnROb2RlKG5vZGUpKSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgICAgIHJlbmRlcmVySW50ZXJuYWxzLFxuICAgICAgICAgICAgaHlkcmF0ZU5vZGVcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fKSB7XG4gICAgICAgICAgd2FybiQxKFwiSW52YWxpZCBIb3N0Vk5vZGUgdHlwZTpcIiwgdHlwZSwgYCgke3R5cGVvZiB0eXBlfSlgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVmICE9IG51bGwpIHtcbiAgICAgIHNldFJlZihyZWYsIG51bGwsIHBhcmVudFN1c3BlbnNlLCB2bm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0Tm9kZTtcbiAgfTtcbiAgY29uc3QgaHlkcmF0ZUVsZW1lbnQgPSAoZWwsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIG9wdGltaXplZCA9IG9wdGltaXplZCB8fCAhIXZub2RlLmR5bmFtaWNDaGlsZHJlbjtcbiAgICBjb25zdCB7IHR5cGUsIHByb3BzLCBwYXRjaEZsYWcsIHNoYXBlRmxhZywgZGlycywgdHJhbnNpdGlvbiB9ID0gdm5vZGU7XG4gICAgY29uc3QgZm9yY2VQYXRjaCA9IHR5cGUgPT09IFwiaW5wdXRcIiB8fCB0eXBlID09PSBcIm9wdGlvblwiO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IGZvcmNlUGF0Y2ggfHwgcGF0Y2hGbGFnICE9PSAtMSkge1xuICAgICAgaWYgKGRpcnMpIHtcbiAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcImNyZWF0ZWRcIik7XG4gICAgICB9XG4gICAgICBsZXQgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgPSBmYWxzZTtcbiAgICAgIGlmIChpc1RlbXBsYXRlTm9kZShlbCkpIHtcbiAgICAgICAgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgPSBuZWVkVHJhbnNpdGlvbihcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIC8vIG5vIG5lZWQgY2hlY2sgcGFyZW50U3VzcGVuc2UgaW4gaHlkcmF0aW9uXG4gICAgICAgICAgdHJhbnNpdGlvblxuICAgICAgICApICYmIHBhcmVudENvbXBvbmVudCAmJiBwYXJlbnRDb21wb25lbnQudm5vZGUucHJvcHMgJiYgcGFyZW50Q29tcG9uZW50LnZub2RlLnByb3BzLmFwcGVhcjtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGVsLmNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzKSB7XG4gICAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXBsYWNlTm9kZShjb250ZW50LCBlbCwgcGFyZW50Q29tcG9uZW50KTtcbiAgICAgICAgdm5vZGUuZWwgPSBlbCA9IGNvbnRlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoc2hhcGVGbGFnICYgMTYgJiYgLy8gc2tpcCBpZiBlbGVtZW50IGhhcyBpbm5lckhUTUwgLyB0ZXh0Q29udGVudFxuICAgICAgIShwcm9wcyAmJiAocHJvcHMuaW5uZXJIVE1MIHx8IHByb3BzLnRleHRDb250ZW50KSkpIHtcbiAgICAgICAgbGV0IG5leHQgPSBoeWRyYXRlQ2hpbGRyZW4oXG4gICAgICAgICAgZWwuZmlyc3RDaGlsZCxcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBlbCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBsZXQgaGFzV2FybmVkID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChuZXh0KSB7XG4gICAgICAgICAgaWYgKCFpc01pc21hdGNoQWxsb3dlZChlbCwgMSAvKiBDSElMRFJFTiAqLykpIHtcbiAgICAgICAgICAgIGlmICgoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pICYmICFoYXNXYXJuZWQpIHtcbiAgICAgICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgICAgIGBIeWRyYXRpb24gY2hpbGRyZW4gbWlzbWF0Y2ggb25gLFxuICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgIGBcblNlcnZlciByZW5kZXJlZCBlbGVtZW50IGNvbnRhaW5zIG1vcmUgY2hpbGQgbm9kZXMgdGhhbiBjbGllbnQgdmRvbS5gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dNaXNtYXRjaEVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGN1ciA9IG5leHQ7XG4gICAgICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgcmVtb3ZlKGN1cik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgOCkge1xuICAgICAgICBsZXQgY2xpZW50VGV4dCA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgICBpZiAoY2xpZW50VGV4dFswXSA9PT0gXCJcXG5cIiAmJiAoZWwudGFnTmFtZSA9PT0gXCJQUkVcIiB8fCBlbC50YWdOYW1lID09PSBcIlRFWFRBUkVBXCIpKSB7XG4gICAgICAgICAgY2xpZW50VGV4dCA9IGNsaWVudFRleHQuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsLnRleHRDb250ZW50ICE9PSBjbGllbnRUZXh0KSB7XG4gICAgICAgICAgaWYgKCFpc01pc21hdGNoQWxsb3dlZChlbCwgMCAvKiBURVhUICovKSkge1xuICAgICAgICAgICAgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fKSAmJiB3YXJuJDEoXG4gICAgICAgICAgICAgIGBIeWRyYXRpb24gdGV4dCBjb250ZW50IG1pc21hdGNoIG9uYCxcbiAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgIGBcbiAgLSByZW5kZXJlZCBvbiBzZXJ2ZXI6ICR7ZWwudGV4dENvbnRlbnR9XG4gIC0gZXhwZWN0ZWQgb24gY2xpZW50OiAke3Zub2RlLmNoaWxkcmVufWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsb2dNaXNtYXRjaEVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsLnRleHRDb250ZW50ID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcykge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18gfHwgZm9yY2VQYXRjaCB8fCAhb3B0aW1pemVkIHx8IHBhdGNoRmxhZyAmICgxNiB8IDMyKSkge1xuICAgICAgICAgIGNvbnN0IGlzQ3VzdG9tRWxlbWVudCA9IGVsLnRhZ05hbWUuaW5jbHVkZXMoXCItXCIpO1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgICAgICBpZiAoKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fKSAmJiAvLyAjMTExODkgc2tpcCBpZiB0aGlzIG5vZGUgaGFzIGRpcmVjdGl2ZXMgdGhhdCBoYXZlIGNyZWF0ZWQgaG9va3NcbiAgICAgICAgICAgIC8vIGFzIGl0IGNvdWxkIGhhdmUgbXV0YXRlZCB0aGUgRE9NIGluIGFueSBwb3NzaWJsZSB3YXlcbiAgICAgICAgICAgICEoZGlycyAmJiBkaXJzLnNvbWUoKGQpID0+IGQuZGlyLmNyZWF0ZWQpKSAmJiBwcm9wSGFzTWlzbWF0Y2goZWwsIGtleSwgcHJvcHNba2V5XSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgbG9nTWlzbWF0Y2hFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcmNlUGF0Y2ggJiYgKGtleS5lbmRzV2l0aChcInZhbHVlXCIpIHx8IGtleSA9PT0gXCJpbmRldGVybWluYXRlXCIpIHx8IGlzT24oa2V5KSAmJiAhaXNSZXNlcnZlZFByb3Aoa2V5KSB8fCAvLyBmb3JjZSBoeWRyYXRlIHYtYmluZCB3aXRoIC5wcm9wIG1vZGlmaWVyc1xuICAgICAgICAgICAga2V5WzBdID09PSBcIi5cIiB8fCBpc0N1c3RvbUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgcGF0Y2hQcm9wKGVsLCBrZXksIG51bGwsIHByb3BzW2tleV0sIHZvaWQgMCwgcGFyZW50Q29tcG9uZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcHMub25DbGljaykge1xuICAgICAgICAgIHBhdGNoUHJvcChcbiAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgXCJvbkNsaWNrXCIsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcHJvcHMub25DbGljayxcbiAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAocGF0Y2hGbGFnICYgNCAmJiBpc1JlYWN0aXZlKHByb3BzLnN0eWxlKSkge1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzLnN0eWxlKSBwcm9wcy5zdHlsZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgdm5vZGVIb29rcztcbiAgICAgIGlmICh2bm9kZUhvb2tzID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSB7XG4gICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2tzLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICAgIH1cbiAgICAgIGlmIChkaXJzKSB7XG4gICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJiZWZvcmVNb3VudFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICgodm5vZGVIb29rcyA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSB8fCBkaXJzIHx8IG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzKSB7XG4gICAgICAgIHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlKCgpID0+IHtcbiAgICAgICAgICB2bm9kZUhvb2tzICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2tzLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICAgICAgICBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyAmJiB0cmFuc2l0aW9uLmVudGVyKGVsKTtcbiAgICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJtb3VudGVkXCIpO1xuICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbC5uZXh0U2libGluZztcbiAgfTtcbiAgY29uc3QgaHlkcmF0ZUNoaWxkcmVuID0gKG5vZGUsIHBhcmVudFZOb2RlLCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgb3B0aW1pemVkID0gb3B0aW1pemVkIHx8ICEhcGFyZW50Vk5vZGUuZHluYW1pY0NoaWxkcmVuO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50Vk5vZGUuY2hpbGRyZW47XG4gICAgY29uc3QgbCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBsZXQgaGFzV2FybmVkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IHZub2RlID0gb3B0aW1pemVkID8gY2hpbGRyZW5baV0gOiBjaGlsZHJlbltpXSA9IG5vcm1hbGl6ZVZOb2RlKGNoaWxkcmVuW2ldKTtcbiAgICAgIGNvbnN0IGlzVGV4dCA9IHZub2RlLnR5cGUgPT09IFRleHQ7XG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICBpZiAoaXNUZXh0ICYmICFvcHRpbWl6ZWQpIHtcbiAgICAgICAgICBpZiAoaSArIDEgPCBsICYmIG5vcm1hbGl6ZVZOb2RlKGNoaWxkcmVuW2kgKyAxXSkudHlwZSA9PT0gVGV4dCkge1xuICAgICAgICAgICAgaW5zZXJ0KFxuICAgICAgICAgICAgICBjcmVhdGVUZXh0KFxuICAgICAgICAgICAgICAgIG5vZGUuZGF0YS5zbGljZSh2bm9kZS5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgICAgbmV4dFNpYmxpbmcobm9kZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBub2RlLmRhdGEgPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IGh5ZHJhdGVOb2RlKFxuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNUZXh0ICYmICF2bm9kZS5jaGlsZHJlbikge1xuICAgICAgICBpbnNlcnQodm5vZGUuZWwgPSBjcmVhdGVUZXh0KFwiXCIpLCBjb250YWluZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFpc01pc21hdGNoQWxsb3dlZChjb250YWluZXIsIDEgLyogQ0hJTERSRU4gKi8pKSB7XG4gICAgICAgICAgaWYgKCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgIWhhc1dhcm5lZCkge1xuICAgICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgICBgSHlkcmF0aW9uIGNoaWxkcmVuIG1pc21hdGNoIG9uYCxcbiAgICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgICBgXG5TZXJ2ZXIgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBmZXdlciBjaGlsZCBub2RlcyB0aGFuIGNsaWVudCB2ZG9tLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2dNaXNtYXRjaEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgZ2V0Q29udGFpbmVyVHlwZShjb250YWluZXIpLFxuICAgICAgICAgIHNsb3RTY29wZUlkc1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcbiAgY29uc3QgaHlkcmF0ZUZyYWdtZW50ID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IHsgc2xvdFNjb3BlSWRzOiBmcmFnbWVudFNsb3RTY29wZUlkcyB9ID0gdm5vZGU7XG4gICAgaWYgKGZyYWdtZW50U2xvdFNjb3BlSWRzKSB7XG4gICAgICBzbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHMgPyBzbG90U2NvcGVJZHMuY29uY2F0KGZyYWdtZW50U2xvdFNjb3BlSWRzKSA6IGZyYWdtZW50U2xvdFNjb3BlSWRzO1xuICAgIH1cbiAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xuICAgIGNvbnN0IG5leHQgPSBoeWRyYXRlQ2hpbGRyZW4oXG4gICAgICBuZXh0U2libGluZyhub2RlKSxcbiAgICAgIHZub2RlLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICBzbG90U2NvcGVJZHMsXG4gICAgICBvcHRpbWl6ZWRcbiAgICApO1xuICAgIGlmIChuZXh0ICYmIGlzQ29tbWVudChuZXh0KSAmJiBuZXh0LmRhdGEgPT09IFwiXVwiKSB7XG4gICAgICByZXR1cm4gbmV4dFNpYmxpbmcodm5vZGUuYW5jaG9yID0gbmV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ01pc21hdGNoRXJyb3IoKTtcbiAgICAgIGluc2VydCh2bm9kZS5hbmNob3IgPSBjcmVhdGVDb21tZW50KGBdYCksIGNvbnRhaW5lciwgbmV4dCk7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGhhbmRsZU1pc21hdGNoID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIGlzRnJhZ21lbnQpID0+IHtcbiAgICBpZiAoIWlzTWlzbWF0Y2hBbGxvd2VkKG5vZGUucGFyZW50RWxlbWVudCwgMSAvKiBDSElMRFJFTiAqLykpIHtcbiAgICAgICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgd2FybiQxKFxuICAgICAgICBgSHlkcmF0aW9uIG5vZGUgbWlzbWF0Y2g6XG4tIHJlbmRlcmVkIG9uIHNlcnZlcjpgLFxuICAgICAgICBub2RlLFxuICAgICAgICBub2RlLm5vZGVUeXBlID09PSAzID8gYCh0ZXh0KWAgOiBpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSBcIltcIiA/IGAoc3RhcnQgb2YgZnJhZ21lbnQpYCA6IGBgLFxuICAgICAgICBgXG4tIGV4cGVjdGVkIG9uIGNsaWVudDpgLFxuICAgICAgICB2bm9kZS50eXBlXG4gICAgICApO1xuICAgICAgbG9nTWlzbWF0Y2hFcnJvcigpO1xuICAgIH1cbiAgICB2bm9kZS5lbCA9IG51bGw7XG4gICAgaWYgKGlzRnJhZ21lbnQpIHtcbiAgICAgIGNvbnN0IGVuZCA9IGxvY2F0ZUNsb3NpbmdBbmNob3Iobm9kZSk7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCBuZXh0MiA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICBpZiAobmV4dDIgJiYgbmV4dDIgIT09IGVuZCkge1xuICAgICAgICAgIHJlbW92ZShuZXh0Mik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbmV4dCA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudE5vZGUobm9kZSk7XG4gICAgcmVtb3ZlKG5vZGUpO1xuICAgIHBhdGNoKFxuICAgICAgbnVsbCxcbiAgICAgIHZub2RlLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgbmV4dCxcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgZ2V0Q29udGFpbmVyVHlwZShjb250YWluZXIpLFxuICAgICAgc2xvdFNjb3BlSWRzXG4gICAgKTtcbiAgICBpZiAocGFyZW50Q29tcG9uZW50KSB7XG4gICAgICBwYXJlbnRDb21wb25lbnQudm5vZGUuZWwgPSB2bm9kZS5lbDtcbiAgICAgIHVwZGF0ZUhPQ0hvc3RFbChwYXJlbnRDb21wb25lbnQsIHZub2RlLmVsKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQ7XG4gIH07XG4gIGNvbnN0IGxvY2F0ZUNsb3NpbmdBbmNob3IgPSAobm9kZSwgb3BlbiA9IFwiW1wiLCBjbG9zZSA9IFwiXVwiKSA9PiB7XG4gICAgbGV0IG1hdGNoID0gMDtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgbm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgaWYgKG5vZGUgJiYgaXNDb21tZW50KG5vZGUpKSB7XG4gICAgICAgIGlmIChub2RlLmRhdGEgPT09IG9wZW4pIG1hdGNoKys7XG4gICAgICAgIGlmIChub2RlLmRhdGEgPT09IGNsb3NlKSB7XG4gICAgICAgICAgaWYgKG1hdGNoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9O1xuICBjb25zdCByZXBsYWNlTm9kZSA9IChuZXdOb2RlLCBvbGROb2RlLCBwYXJlbnRDb21wb25lbnQpID0+IHtcbiAgICBjb25zdCBwYXJlbnROb2RlMiA9IG9sZE5vZGUucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50Tm9kZTIpIHtcbiAgICAgIHBhcmVudE5vZGUyLnJlcGxhY2VDaGlsZChuZXdOb2RlLCBvbGROb2RlKTtcbiAgICB9XG4gICAgbGV0IHBhcmVudCA9IHBhcmVudENvbXBvbmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LnZub2RlLmVsID09PSBvbGROb2RlKSB7XG4gICAgICAgIHBhcmVudC52bm9kZS5lbCA9IHBhcmVudC5zdWJUcmVlLmVsID0gbmV3Tm9kZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICB9O1xuICBjb25zdCBpc1RlbXBsYXRlTm9kZSA9IChub2RlKSA9PiB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgbm9kZS50YWdOYW1lID09PSBcIlRFTVBMQVRFXCI7XG4gIH07XG4gIHJldHVybiBbaHlkcmF0ZSwgaHlkcmF0ZU5vZGVdO1xufVxuZnVuY3Rpb24gcHJvcEhhc01pc21hdGNoKGVsLCBrZXksIGNsaWVudFZhbHVlLCB2bm9kZSwgaW5zdGFuY2UpIHtcbiAgbGV0IG1pc21hdGNoVHlwZTtcbiAgbGV0IG1pc21hdGNoS2V5O1xuICBsZXQgYWN0dWFsO1xuICBsZXQgZXhwZWN0ZWQ7XG4gIGlmIChrZXkgPT09IFwiY2xhc3NcIikge1xuICAgIGFjdHVhbCA9IGVsLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpO1xuICAgIGV4cGVjdGVkID0gbm9ybWFsaXplQ2xhc3MoY2xpZW50VmFsdWUpO1xuICAgIGlmICghaXNTZXRFcXVhbCh0b0NsYXNzU2V0KGFjdHVhbCB8fCBcIlwiKSwgdG9DbGFzc1NldChleHBlY3RlZCkpKSB7XG4gICAgICBtaXNtYXRjaFR5cGUgPSAyIC8qIENMQVNTICovO1xuICAgICAgbWlzbWF0Y2hLZXkgPSBgY2xhc3NgO1xuICAgIH1cbiAgfSBlbHNlIGlmIChrZXkgPT09IFwic3R5bGVcIikge1xuICAgIGFjdHVhbCA9IGVsLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpIHx8IFwiXCI7XG4gICAgZXhwZWN0ZWQgPSBpc1N0cmluZyhjbGllbnRWYWx1ZSkgPyBjbGllbnRWYWx1ZSA6IHN0cmluZ2lmeVN0eWxlKG5vcm1hbGl6ZVN0eWxlKGNsaWVudFZhbHVlKSk7XG4gICAgY29uc3QgYWN0dWFsTWFwID0gdG9TdHlsZU1hcChhY3R1YWwpO1xuICAgIGNvbnN0IGV4cGVjdGVkTWFwID0gdG9TdHlsZU1hcChleHBlY3RlZCk7XG4gICAgaWYgKHZub2RlLmRpcnMpIHtcbiAgICAgIGZvciAoY29uc3QgeyBkaXIsIHZhbHVlIH0gb2Ygdm5vZGUuZGlycykge1xuICAgICAgICBpZiAoZGlyLm5hbWUgPT09IFwic2hvd1wiICYmICF2YWx1ZSkge1xuICAgICAgICAgIGV4cGVjdGVkTWFwLnNldChcImRpc3BsYXlcIiwgXCJub25lXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgcmVzb2x2ZUNzc1ZhcnMoaW5zdGFuY2UsIHZub2RlLCBleHBlY3RlZE1hcCk7XG4gICAgfVxuICAgIGlmICghaXNNYXBFcXVhbChhY3R1YWxNYXAsIGV4cGVjdGVkTWFwKSkge1xuICAgICAgbWlzbWF0Y2hUeXBlID0gMyAvKiBTVFlMRSAqLztcbiAgICAgIG1pc21hdGNoS2V5ID0gXCJzdHlsZVwiO1xuICAgIH1cbiAgfSBlbHNlIGlmIChlbCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQgJiYgaXNLbm93blN2Z0F0dHIoa2V5KSB8fCBlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIChpc0Jvb2xlYW5BdHRyKGtleSkgfHwgaXNLbm93bkh0bWxBdHRyKGtleSkpKSB7XG4gICAgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuICAgICAgYWN0dWFsID0gZWwuaGFzQXR0cmlidXRlKGtleSk7XG4gICAgICBleHBlY3RlZCA9IGluY2x1ZGVCb29sZWFuQXR0cihjbGllbnRWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChjbGllbnRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBhY3R1YWwgPSBlbC5oYXNBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIGV4cGVjdGVkID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoa2V5KSkge1xuICAgICAgICBhY3R1YWwgPSBlbC5nZXRBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInZhbHVlXCIgJiYgZWwudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiKSB7XG4gICAgICAgIGFjdHVhbCA9IGVsLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0dWFsID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBleHBlY3RlZCA9IGlzUmVuZGVyYWJsZUF0dHJWYWx1ZShjbGllbnRWYWx1ZSkgPyBTdHJpbmcoY2xpZW50VmFsdWUpIDogZmFsc2U7XG4gICAgfVxuICAgIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgICBtaXNtYXRjaFR5cGUgPSA0IC8qIEFUVFJJQlVURSAqLztcbiAgICAgIG1pc21hdGNoS2V5ID0ga2V5O1xuICAgIH1cbiAgfVxuICBpZiAobWlzbWF0Y2hUeXBlICE9IG51bGwgJiYgIWlzTWlzbWF0Y2hBbGxvd2VkKGVsLCBtaXNtYXRjaFR5cGUpKSB7XG4gICAgY29uc3QgZm9ybWF0ID0gKHYpID0+IHYgPT09IGZhbHNlID8gYChub3QgcmVuZGVyZWQpYCA6IGAke21pc21hdGNoS2V5fT1cIiR7dn1cImA7XG4gICAgY29uc3QgcHJlU2VnbWVudCA9IGBIeWRyYXRpb24gJHtNaXNtYXRjaFR5cGVTdHJpbmdbbWlzbWF0Y2hUeXBlXX0gbWlzbWF0Y2ggb25gO1xuICAgIGNvbnN0IHBvc3RTZWdtZW50ID0gYFxuICAtIHJlbmRlcmVkIG9uIHNlcnZlcjogJHtmb3JtYXQoYWN0dWFsKX1cbiAgLSBleHBlY3RlZCBvbiBjbGllbnQ6ICR7Zm9ybWF0KGV4cGVjdGVkKX1cbiAgTm90ZTogdGhpcyBtaXNtYXRjaCBpcyBjaGVjay1vbmx5LiBUaGUgRE9NIHdpbGwgbm90IGJlIHJlY3RpZmllZCBpbiBwcm9kdWN0aW9uIGR1ZSB0byBwZXJmb3JtYW5jZSBvdmVyaGVhZC5cbiAgWW91IHNob3VsZCBmaXggdGhlIHNvdXJjZSBvZiB0aGUgbWlzbWF0Y2guYDtcbiAgICB7XG4gICAgICB3YXJuJDEocHJlU2VnbWVudCwgZWwsIHBvc3RTZWdtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdG9DbGFzc1NldChzdHIpIHtcbiAgcmV0dXJuIG5ldyBTZXQoc3RyLnRyaW0oKS5zcGxpdCgvXFxzKy8pKTtcbn1cbmZ1bmN0aW9uIGlzU2V0RXF1YWwoYSwgYikge1xuICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBzIG9mIGEpIHtcbiAgICBpZiAoIWIuaGFzKHMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gdG9TdHlsZU1hcChzdHIpIHtcbiAgY29uc3Qgc3R5bGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmb3IgKGNvbnN0IGl0ZW0gb2Ygc3RyLnNwbGl0KFwiO1wiKSkge1xuICAgIGxldCBba2V5LCB2YWx1ZV0gPSBpdGVtLnNwbGl0KFwiOlwiKTtcbiAgICBrZXkgPSBrZXkudHJpbSgpO1xuICAgIHZhbHVlID0gdmFsdWUgJiYgdmFsdWUudHJpbSgpO1xuICAgIGlmIChrZXkgJiYgdmFsdWUpIHtcbiAgICAgIHN0eWxlTWFwLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlTWFwO1xufVxuZnVuY3Rpb24gaXNNYXBFcXVhbChhLCBiKSB7XG4gIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBhKSB7XG4gICAgaWYgKHZhbHVlICE9PSBiLmdldChrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUNzc1ZhcnMoaW5zdGFuY2UsIHZub2RlLCBleHBlY3RlZE1hcCkge1xuICBjb25zdCByb290ID0gaW5zdGFuY2Uuc3ViVHJlZTtcbiAgaWYgKGluc3RhbmNlLmdldENzc1ZhcnMgJiYgKHZub2RlID09PSByb290IHx8IHJvb3QgJiYgcm9vdC50eXBlID09PSBGcmFnbWVudCAmJiByb290LmNoaWxkcmVuLmluY2x1ZGVzKHZub2RlKSkpIHtcbiAgICBjb25zdCBjc3NWYXJzID0gaW5zdGFuY2UuZ2V0Q3NzVmFycygpO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNzc1ZhcnMpIHtcbiAgICAgIGV4cGVjdGVkTWFwLnNldChcbiAgICAgICAgYC0tJHtnZXRFc2NhcGVkQ3NzVmFyTmFtZShrZXksIGZhbHNlKX1gLFxuICAgICAgICBTdHJpbmcoY3NzVmFyc1trZXldKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHZub2RlID09PSByb290ICYmIGluc3RhbmNlLnBhcmVudCkge1xuICAgIHJlc29sdmVDc3NWYXJzKGluc3RhbmNlLnBhcmVudCwgaW5zdGFuY2Uudm5vZGUsIGV4cGVjdGVkTWFwKTtcbiAgfVxufVxuY29uc3QgYWxsb3dNaXNtYXRjaEF0dHIgPSBcImRhdGEtYWxsb3ctbWlzbWF0Y2hcIjtcbmNvbnN0IE1pc21hdGNoVHlwZVN0cmluZyA9IHtcbiAgWzAgLyogVEVYVCAqL106IFwidGV4dFwiLFxuICBbMSAvKiBDSElMRFJFTiAqL106IFwiY2hpbGRyZW5cIixcbiAgWzIgLyogQ0xBU1MgKi9dOiBcImNsYXNzXCIsXG4gIFszIC8qIFNUWUxFICovXTogXCJzdHlsZVwiLFxuICBbNCAvKiBBVFRSSUJVVEUgKi9dOiBcImF0dHJpYnV0ZVwiXG59O1xuZnVuY3Rpb24gaXNNaXNtYXRjaEFsbG93ZWQoZWwsIGFsbG93ZWRUeXBlKSB7XG4gIGlmIChhbGxvd2VkVHlwZSA9PT0gMCAvKiBURVhUICovIHx8IGFsbG93ZWRUeXBlID09PSAxIC8qIENISUxEUkVOICovKSB7XG4gICAgd2hpbGUgKGVsICYmICFlbC5oYXNBdHRyaWJ1dGUoYWxsb3dNaXNtYXRjaEF0dHIpKSB7XG4gICAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICB9XG4gIGNvbnN0IGFsbG93ZWRBdHRyID0gZWwgJiYgZWwuZ2V0QXR0cmlidXRlKGFsbG93TWlzbWF0Y2hBdHRyKTtcbiAgaWYgKGFsbG93ZWRBdHRyID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoYWxsb3dlZEF0dHIgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBsaXN0ID0gYWxsb3dlZEF0dHIuc3BsaXQoXCIsXCIpO1xuICAgIGlmIChhbGxvd2VkVHlwZSA9PT0gMCAvKiBURVhUICovICYmIGxpc3QuaW5jbHVkZXMoXCJjaGlsZHJlblwiKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBhbGxvd2VkQXR0ci5zcGxpdChcIixcIikuaW5jbHVkZXMoTWlzbWF0Y2hUeXBlU3RyaW5nW2FsbG93ZWRUeXBlXSk7XG4gIH1cbn1cblxuY29uc3QgcmVxdWVzdElkbGVDYWxsYmFjayA9IGdldEdsb2JhbFRoaXMoKS5yZXF1ZXN0SWRsZUNhbGxiYWNrIHx8ICgoY2IpID0+IHNldFRpbWVvdXQoY2IsIDEpKTtcbmNvbnN0IGNhbmNlbElkbGVDYWxsYmFjayA9IGdldEdsb2JhbFRoaXMoKS5jYW5jZWxJZGxlQ2FsbGJhY2sgfHwgKChpZCkgPT4gY2xlYXJUaW1lb3V0KGlkKSk7XG5jb25zdCBoeWRyYXRlT25JZGxlID0gKHRpbWVvdXQgPSAxZTQpID0+IChoeWRyYXRlKSA9PiB7XG4gIGNvbnN0IGlkID0gcmVxdWVzdElkbGVDYWxsYmFjayhoeWRyYXRlLCB7IHRpbWVvdXQgfSk7XG4gIHJldHVybiAoKSA9PiBjYW5jZWxJZGxlQ2FsbGJhY2soaWQpO1xufTtcbmZ1bmN0aW9uIGVsZW1lbnRJc1Zpc2libGVJblZpZXdwb3J0KGVsKSB7XG4gIGNvbnN0IHsgdG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0IH0gPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgeyBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCB9ID0gd2luZG93O1xuICByZXR1cm4gKHRvcCA+IDAgJiYgdG9wIDwgaW5uZXJIZWlnaHQgfHwgYm90dG9tID4gMCAmJiBib3R0b20gPCBpbm5lckhlaWdodCkgJiYgKGxlZnQgPiAwICYmIGxlZnQgPCBpbm5lcldpZHRoIHx8IHJpZ2h0ID4gMCAmJiByaWdodCA8IGlubmVyV2lkdGgpO1xufVxuY29uc3QgaHlkcmF0ZU9uVmlzaWJsZSA9IChvcHRzKSA9PiAoaHlkcmF0ZSwgZm9yRWFjaCkgPT4ge1xuICBjb25zdCBvYiA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgIGZvciAoY29uc3QgZSBvZiBlbnRyaWVzKSB7XG4gICAgICBpZiAoIWUuaXNJbnRlcnNlY3RpbmcpIGNvbnRpbnVlO1xuICAgICAgb2IuZGlzY29ubmVjdCgpO1xuICAgICAgaHlkcmF0ZSgpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9LCBvcHRzKTtcbiAgZm9yRWFjaCgoZWwpID0+IHtcbiAgICBpZiAoIShlbCBpbnN0YW5jZW9mIEVsZW1lbnQpKSByZXR1cm47XG4gICAgaWYgKGVsZW1lbnRJc1Zpc2libGVJblZpZXdwb3J0KGVsKSkge1xuICAgICAgaHlkcmF0ZSgpO1xuICAgICAgb2IuZGlzY29ubmVjdCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYi5vYnNlcnZlKGVsKTtcbiAgfSk7XG4gIHJldHVybiAoKSA9PiBvYi5kaXNjb25uZWN0KCk7XG59O1xuY29uc3QgaHlkcmF0ZU9uTWVkaWFRdWVyeSA9IChxdWVyeSkgPT4gKGh5ZHJhdGUpID0+IHtcbiAgaWYgKHF1ZXJ5KSB7XG4gICAgY29uc3QgbXFsID0gbWF0Y2hNZWRpYShxdWVyeSk7XG4gICAgaWYgKG1xbC5tYXRjaGVzKSB7XG4gICAgICBoeWRyYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1xbC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGh5ZHJhdGUsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgIHJldHVybiAoKSA9PiBtcWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoeWRyYXRlKTtcbiAgICB9XG4gIH1cbn07XG5jb25zdCBoeWRyYXRlT25JbnRlcmFjdGlvbiA9IChpbnRlcmFjdGlvbnMgPSBbXSkgPT4gKGh5ZHJhdGUsIGZvckVhY2gpID0+IHtcbiAgaWYgKGlzU3RyaW5nKGludGVyYWN0aW9ucykpIGludGVyYWN0aW9ucyA9IFtpbnRlcmFjdGlvbnNdO1xuICBsZXQgaGFzSHlkcmF0ZWQgPSBmYWxzZTtcbiAgY29uc3QgZG9IeWRyYXRlID0gKGUpID0+IHtcbiAgICBpZiAoIWhhc0h5ZHJhdGVkKSB7XG4gICAgICBoYXNIeWRyYXRlZCA9IHRydWU7XG4gICAgICB0ZWFyZG93bigpO1xuICAgICAgaHlkcmF0ZSgpO1xuICAgICAgZS50YXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgZS5jb25zdHJ1Y3RvcihlLnR5cGUsIGUpKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHRlYXJkb3duID0gKCkgPT4ge1xuICAgIGZvckVhY2goKGVsKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGkgb2YgaW50ZXJhY3Rpb25zKSB7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoaSwgZG9IeWRyYXRlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgZm9yRWFjaCgoZWwpID0+IHtcbiAgICBmb3IgKGNvbnN0IGkgb2YgaW50ZXJhY3Rpb25zKSB7XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGksIGRvSHlkcmF0ZSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0ZWFyZG93bjtcbn07XG5mdW5jdGlvbiBmb3JFYWNoRWxlbWVudChub2RlLCBjYikge1xuICBpZiAoaXNDb21tZW50KG5vZGUpICYmIG5vZGUuZGF0YSA9PT0gXCJbXCIpIHtcbiAgICBsZXQgZGVwdGggPSAxO1xuICAgIGxldCBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICB3aGlsZSAobmV4dCkge1xuICAgICAgaWYgKG5leHQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY2IobmV4dCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDb21tZW50KG5leHQpKSB7XG4gICAgICAgIGlmIChuZXh0LmRhdGEgPT09IFwiXVwiKSB7XG4gICAgICAgICAgaWYgKC0tZGVwdGggPT09IDApIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKG5leHQuZGF0YSA9PT0gXCJbXCIpIHtcbiAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY2Iobm9kZSk7XG4gIH1cbn1cblxuY29uc3QgaXNBc3luY1dyYXBwZXIgPSAoaSkgPT4gISFpLnR5cGUuX19hc3luY0xvYWRlcjtcbi8qISAjX19OT19TSURFX0VGRkVDVFNfXyAqL1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGRlZmluZUFzeW5jQ29tcG9uZW50KHNvdXJjZSkge1xuICBpZiAoaXNGdW5jdGlvbihzb3VyY2UpKSB7XG4gICAgc291cmNlID0geyBsb2FkZXI6IHNvdXJjZSB9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBsb2FkZXIsXG4gICAgbG9hZGluZ0NvbXBvbmVudCxcbiAgICBlcnJvckNvbXBvbmVudCxcbiAgICBkZWxheSA9IDIwMCxcbiAgICBoeWRyYXRlOiBoeWRyYXRlU3RyYXRlZ3ksXG4gICAgdGltZW91dCxcbiAgICAvLyB1bmRlZmluZWQgPSBuZXZlciB0aW1lcyBvdXRcbiAgICBzdXNwZW5zaWJsZSA9IHRydWUsXG4gICAgb25FcnJvcjogdXNlck9uRXJyb3JcbiAgfSA9IHNvdXJjZTtcbiAgbGV0IHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcbiAgbGV0IHJlc29sdmVkQ29tcDtcbiAgbGV0IHJldHJpZXMgPSAwO1xuICBjb25zdCByZXRyeSA9ICgpID0+IHtcbiAgICByZXRyaWVzKys7XG4gICAgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xuICAgIHJldHVybiBsb2FkKCk7XG4gIH07XG4gIGNvbnN0IGxvYWQgPSAoKSA9PiB7XG4gICAgbGV0IHRoaXNSZXF1ZXN0O1xuICAgIHJldHVybiBwZW5kaW5nUmVxdWVzdCB8fCAodGhpc1JlcXVlc3QgPSBwZW5kaW5nUmVxdWVzdCA9IGxvYWRlcigpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGVyciA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyIDogbmV3IEVycm9yKFN0cmluZyhlcnIpKTtcbiAgICAgIGlmICh1c2VyT25FcnJvcikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHVzZXJSZXRyeSA9ICgpID0+IHJlc29sdmUocmV0cnkoKSk7XG4gICAgICAgICAgY29uc3QgdXNlckZhaWwgPSAoKSA9PiByZWplY3QoZXJyKTtcbiAgICAgICAgICB1c2VyT25FcnJvcihlcnIsIHVzZXJSZXRyeSwgdXNlckZhaWwsIHJldHJpZXMgKyAxKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfSkudGhlbigoY29tcCkgPT4ge1xuICAgICAgaWYgKHRoaXNSZXF1ZXN0ICE9PSBwZW5kaW5nUmVxdWVzdCAmJiBwZW5kaW5nUmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gcGVuZGluZ1JlcXVlc3Q7XG4gICAgICB9XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhY29tcCkge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYEFzeW5jIGNvbXBvbmVudCBsb2FkZXIgcmVzb2x2ZWQgdG8gdW5kZWZpbmVkLiBJZiB5b3UgYXJlIHVzaW5nIHJldHJ5KCksIG1ha2Ugc3VyZSB0byByZXR1cm4gaXRzIHJldHVybiB2YWx1ZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoY29tcCAmJiAoY29tcC5fX2VzTW9kdWxlIHx8IGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gXCJNb2R1bGVcIikpIHtcbiAgICAgICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgICAgIH1cbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNvbXAgJiYgIWlzT2JqZWN0KGNvbXApICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhc3luYyBjb21wb25lbnQgbG9hZCByZXN1bHQ6ICR7Y29tcH1gKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmVkQ29tcCA9IGNvbXA7XG4gICAgICByZXR1cm4gY29tcDtcbiAgICB9KSk7XG4gIH07XG4gIHJldHVybiBkZWZpbmVDb21wb25lbnQoe1xuICAgIG5hbWU6IFwiQXN5bmNDb21wb25lbnRXcmFwcGVyXCIsXG4gICAgX19hc3luY0xvYWRlcjogbG9hZCxcbiAgICBfX2FzeW5jSHlkcmF0ZShlbCwgaW5zdGFuY2UsIGh5ZHJhdGUpIHtcbiAgICAgIGNvbnN0IGRvSHlkcmF0ZSA9IGh5ZHJhdGVTdHJhdGVneSA/ICgpID0+IHtcbiAgICAgICAgY29uc3QgdGVhcmRvd24gPSBoeWRyYXRlU3RyYXRlZ3koXG4gICAgICAgICAgaHlkcmF0ZSxcbiAgICAgICAgICAoY2IpID0+IGZvckVhY2hFbGVtZW50KGVsLCBjYilcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHRlYXJkb3duKSB7XG4gICAgICAgICAgKGluc3RhbmNlLmJ1bSB8fCAoaW5zdGFuY2UuYnVtID0gW10pKS5wdXNoKHRlYXJkb3duKTtcbiAgICAgICAgfVxuICAgICAgfSA6IGh5ZHJhdGU7XG4gICAgICBpZiAocmVzb2x2ZWRDb21wKSB7XG4gICAgICAgIGRvSHlkcmF0ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9hZCgpLnRoZW4oKCkgPT4gIWluc3RhbmNlLmlzVW5tb3VudGVkICYmIGRvSHlkcmF0ZSgpKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldCBfX2FzeW5jUmVzb2x2ZWQoKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZWRDb21wO1xuICAgIH0sXG4gICAgc2V0dXAoKSB7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICAgIG1hcmtBc3luY0JvdW5kYXJ5KGluc3RhbmNlKTtcbiAgICAgIGlmIChyZXNvbHZlZENvbXApIHtcbiAgICAgICAgcmV0dXJuICgpID0+IGNyZWF0ZUlubmVyQ29tcChyZXNvbHZlZENvbXAsIGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgaGFuZGxlRXJyb3IoXG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIDEzLFxuICAgICAgICAgICFlcnJvckNvbXBvbmVudFxuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIGlmIChzdXNwZW5zaWJsZSAmJiBpbnN0YW5jZS5zdXNwZW5zZSB8fCBpc0luU1NSQ29tcG9uZW50U2V0dXApIHtcbiAgICAgICAgcmV0dXJuIGxvYWQoKS50aGVuKChjb21wKSA9PiB7XG4gICAgICAgICAgcmV0dXJuICgpID0+IGNyZWF0ZUlubmVyQ29tcChjb21wLCBpbnN0YW5jZSk7XG4gICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgcmV0dXJuICgpID0+IGVycm9yQ29tcG9uZW50ID8gY3JlYXRlVk5vZGUoZXJyb3JDb21wb25lbnQsIHtcbiAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICB9KSA6IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgbG9hZGVkID0gcmVmKGZhbHNlKTtcbiAgICAgIGNvbnN0IGVycm9yID0gcmVmKCk7XG4gICAgICBjb25zdCBkZWxheWVkID0gcmVmKCEhZGVsYXkpO1xuICAgICAgaWYgKGRlbGF5KSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGRlbGF5ZWQudmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAoIWxvYWRlZC52YWx1ZSAmJiAhZXJyb3IudmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYEFzeW5jIGNvbXBvbmVudCB0aW1lZCBvdXQgYWZ0ZXIgJHt0aW1lb3V0fW1zLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgICBlcnJvci52YWx1ZSA9IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgbG9hZCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBsb2FkZWQudmFsdWUgPSB0cnVlO1xuICAgICAgICBpZiAoaW5zdGFuY2UucGFyZW50ICYmIGlzS2VlcEFsaXZlKGluc3RhbmNlLnBhcmVudC52bm9kZSkpIHtcbiAgICAgICAgICBpbnN0YW5jZS5wYXJlbnQudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICBlcnJvci52YWx1ZSA9IGVycjtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKGxvYWRlZC52YWx1ZSAmJiByZXNvbHZlZENvbXApIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlSW5uZXJDb21wKHJlc29sdmVkQ29tcCwgaW5zdGFuY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yLnZhbHVlICYmIGVycm9yQ29tcG9uZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKGVycm9yQ29tcG9uZW50LCB7XG4gICAgICAgICAgICBlcnJvcjogZXJyb3IudmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2FkaW5nQ29tcG9uZW50ICYmICFkZWxheWVkLnZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKGxvYWRpbmdDb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVJbm5lckNvbXAoY29tcCwgcGFyZW50KSB7XG4gIGNvbnN0IHsgcmVmOiByZWYyLCBwcm9wcywgY2hpbGRyZW4sIGNlIH0gPSBwYXJlbnQudm5vZGU7XG4gIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUoY29tcCwgcHJvcHMsIGNoaWxkcmVuKTtcbiAgdm5vZGUucmVmID0gcmVmMjtcbiAgdm5vZGUuY2UgPSBjZTtcbiAgZGVsZXRlIHBhcmVudC52bm9kZS5jZTtcbiAgcmV0dXJuIHZub2RlO1xufVxuXG5jb25zdCBpc0tlZXBBbGl2ZSA9ICh2bm9kZSkgPT4gdm5vZGUudHlwZS5fX2lzS2VlcEFsaXZlO1xuY29uc3QgS2VlcEFsaXZlSW1wbCA9IHtcbiAgbmFtZTogYEtlZXBBbGl2ZWAsXG4gIC8vIE1hcmtlciBmb3Igc3BlY2lhbCBoYW5kbGluZyBpbnNpZGUgdGhlIHJlbmRlcmVyLiBXZSBhcmUgbm90IHVzaW5nIGEgPT09XG4gIC8vIGNoZWNrIGRpcmVjdGx5IG9uIEtlZXBBbGl2ZSBpbiB0aGUgcmVuZGVyZXIsIGJlY2F1c2UgaW1wb3J0aW5nIGl0IGRpcmVjdGx5XG4gIC8vIHdvdWxkIHByZXZlbnQgaXQgZnJvbSBiZWluZyB0cmVlLXNoYWtlbi5cbiAgX19pc0tlZXBBbGl2ZTogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XSxcbiAgICBleGNsdWRlOiBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XSxcbiAgICBtYXg6IFtTdHJpbmcsIE51bWJlcl1cbiAgfSxcbiAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgY29uc3Qgc2hhcmVkQ29udGV4dCA9IGluc3RhbmNlLmN0eDtcbiAgICBpZiAoIXNoYXJlZENvbnRleHQucmVuZGVyZXIpIHtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCAmJiBzbG90cy5kZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgPyBjaGlsZHJlblswXSA6IGNoaWxkcmVuO1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGxldCBjdXJyZW50ID0gbnVsbDtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGluc3RhbmNlLl9fdl9jYWNoZSA9IGNhY2hlO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnRTdXNwZW5zZSA9IGluc3RhbmNlLnN1c3BlbnNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlbmRlcmVyOiB7XG4gICAgICAgIHA6IHBhdGNoLFxuICAgICAgICBtOiBtb3ZlLFxuICAgICAgICB1bTogX3VubW91bnQsXG4gICAgICAgIG86IHsgY3JlYXRlRWxlbWVudCB9XG4gICAgICB9XG4gICAgfSA9IHNoYXJlZENvbnRleHQ7XG4gICAgY29uc3Qgc3RvcmFnZUNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgc2hhcmVkQ29udGV4dC5hY3RpdmF0ZSA9ICh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIG5hbWVzcGFjZSwgb3B0aW1pemVkKSA9PiB7XG4gICAgICBjb25zdCBpbnN0YW5jZTIgPSB2bm9kZS5jb21wb25lbnQ7XG4gICAgICBtb3ZlKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgMCwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgcGF0Y2goXG4gICAgICAgIGluc3RhbmNlMi52bm9kZSxcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBpbnN0YW5jZTIsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHZub2RlLnNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaW5zdGFuY2UyLmlzRGVhY3RpdmF0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGluc3RhbmNlMi5hKSB7XG4gICAgICAgICAgaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UyLmEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZub2RlSG9vayA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLm9uVm5vZGVNb3VudGVkO1xuICAgICAgICBpZiAodm5vZGVIb29rKSB7XG4gICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgaW5zdGFuY2UyLnBhcmVudCwgdm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgZGV2dG9vbHNDb21wb25lbnRBZGRlZChpbnN0YW5jZTIpO1xuICAgICAgfVxuICAgIH07XG4gICAgc2hhcmVkQ29udGV4dC5kZWFjdGl2YXRlID0gKHZub2RlKSA9PiB7XG4gICAgICBjb25zdCBpbnN0YW5jZTIgPSB2bm9kZS5jb21wb25lbnQ7XG4gICAgICBpbnZhbGlkYXRlTW91bnQoaW5zdGFuY2UyLm0pO1xuICAgICAgaW52YWxpZGF0ZU1vdW50KGluc3RhbmNlMi5hKTtcbiAgICAgIG1vdmUodm5vZGUsIHN0b3JhZ2VDb250YWluZXIsIG51bGwsIDEsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChpbnN0YW5jZTIuZGEpIHtcbiAgICAgICAgICBpbnZva2VBcnJheUZucyhpbnN0YW5jZTIuZGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZub2RlSG9vayA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLm9uVm5vZGVVbm1vdW50ZWQ7XG4gICAgICAgIGlmICh2bm9kZUhvb2spIHtcbiAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBpbnN0YW5jZTIucGFyZW50LCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UyLmlzRGVhY3RpdmF0ZWQgPSB0cnVlO1xuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgIGRldnRvb2xzQ29tcG9uZW50QWRkZWQoaW5zdGFuY2UyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHVubW91bnQodm5vZGUpIHtcbiAgICAgIHJlc2V0U2hhcGVGbGFnKHZub2RlKTtcbiAgICAgIF91bm1vdW50KHZub2RlLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcnVuZUNhY2hlKGZpbHRlcikge1xuICAgICAgY2FjaGUuZm9yRWFjaCgodm5vZGUsIGtleSkgPT4ge1xuICAgICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh2bm9kZS50eXBlKTtcbiAgICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShrZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5KGtleSkge1xuICAgICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICBpZiAoY2FjaGVkICYmICghY3VycmVudCB8fCAhaXNTYW1lVk5vZGVUeXBlKGNhY2hlZCwgY3VycmVudCkpKSB7XG4gICAgICAgIHVubW91bnQoY2FjaGVkKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudCkge1xuICAgICAgICByZXNldFNoYXBlRmxhZyhjdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGNhY2hlLmRlbGV0ZShrZXkpO1xuICAgICAga2V5cy5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgd2F0Y2goXG4gICAgICAoKSA9PiBbcHJvcHMuaW5jbHVkZSwgcHJvcHMuZXhjbHVkZV0sXG4gICAgICAoW2luY2x1ZGUsIGV4Y2x1ZGVdKSA9PiB7XG4gICAgICAgIGluY2x1ZGUgJiYgcHJ1bmVDYWNoZSgobmFtZSkgPT4gbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSk7XG4gICAgICAgIGV4Y2x1ZGUgJiYgcHJ1bmVDYWNoZSgobmFtZSkgPT4gIW1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpO1xuICAgICAgfSxcbiAgICAgIC8vIHBydW5lIHBvc3QtcmVuZGVyIGFmdGVyIGBjdXJyZW50YCBoYXMgYmVlbiB1cGRhdGVkXG4gICAgICB7IGZsdXNoOiBcInBvc3RcIiwgZGVlcDogdHJ1ZSB9XG4gICAgKTtcbiAgICBsZXQgcGVuZGluZ0NhY2hlS2V5ID0gbnVsbDtcbiAgICBjb25zdCBjYWNoZVN1YnRyZWUgPSAoKSA9PiB7XG4gICAgICBpZiAocGVuZGluZ0NhY2hlS2V5ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGlzU3VzcGVuc2UoaW5zdGFuY2Uuc3ViVHJlZS50eXBlKSkge1xuICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBjYWNoZS5zZXQocGVuZGluZ0NhY2hlS2V5LCBnZXRJbm5lckNoaWxkKGluc3RhbmNlLnN1YlRyZWUpKTtcbiAgICAgICAgICB9LCBpbnN0YW5jZS5zdWJUcmVlLnN1c3BlbnNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWNoZS5zZXQocGVuZGluZ0NhY2hlS2V5LCBnZXRJbm5lckNoaWxkKGluc3RhbmNlLnN1YlRyZWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgb25Nb3VudGVkKGNhY2hlU3VidHJlZSk7XG4gICAgb25VcGRhdGVkKGNhY2hlU3VidHJlZSk7XG4gICAgb25CZWZvcmVVbm1vdW50KCgpID0+IHtcbiAgICAgIGNhY2hlLmZvckVhY2goKGNhY2hlZCkgPT4ge1xuICAgICAgICBjb25zdCB7IHN1YlRyZWUsIHN1c3BlbnNlIH0gPSBpbnN0YW5jZTtcbiAgICAgICAgY29uc3Qgdm5vZGUgPSBnZXRJbm5lckNoaWxkKHN1YlRyZWUpO1xuICAgICAgICBpZiAoY2FjaGVkLnR5cGUgPT09IHZub2RlLnR5cGUgJiYgY2FjaGVkLmtleSA9PT0gdm5vZGUua2V5KSB7XG4gICAgICAgICAgcmVzZXRTaGFwZUZsYWcodm5vZGUpO1xuICAgICAgICAgIGNvbnN0IGRhID0gdm5vZGUuY29tcG9uZW50LmRhO1xuICAgICAgICAgIGRhICYmIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChkYSwgc3VzcGVuc2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB1bm1vdW50KGNhY2hlZCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcGVuZGluZ0NhY2hlS2V5ID0gbnVsbDtcbiAgICAgIGlmICghc2xvdHMuZGVmYXVsdCkge1xuICAgICAgICByZXR1cm4gY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQoKTtcbiAgICAgIGNvbnN0IHJhd1ZOb2RlID0gY2hpbGRyZW5bMF07XG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4kMShgS2VlcEFsaXZlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIGNvbXBvbmVudCBjaGlsZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgfSBlbHNlIGlmICghaXNWTm9kZShyYXdWTm9kZSkgfHwgIShyYXdWTm9kZS5zaGFwZUZsYWcgJiA0KSAmJiAhKHJhd1ZOb2RlLnNoYXBlRmxhZyAmIDEyOCkpIHtcbiAgICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiByYXdWTm9kZTtcbiAgICAgIH1cbiAgICAgIGxldCB2bm9kZSA9IGdldElubmVyQ2hpbGQocmF3Vk5vZGUpO1xuICAgICAgaWYgKHZub2RlLnR5cGUgPT09IENvbW1lbnQpIHtcbiAgICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiB2bm9kZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbXAgPSB2bm9kZS50eXBlO1xuICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoXG4gICAgICAgIGlzQXN5bmNXcmFwcGVyKHZub2RlKSA/IHZub2RlLnR5cGUuX19hc3luY1Jlc29sdmVkIHx8IHt9IDogY29tcFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHsgaW5jbHVkZSwgZXhjbHVkZSwgbWF4IH0gPSBwcm9wcztcbiAgICAgIGlmIChpbmNsdWRlICYmICghbmFtZSB8fCAhbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSkgfHwgZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpIHtcbiAgICAgICAgdm5vZGUuc2hhcGVGbGFnICY9IH4yNTY7XG4gICAgICAgIGN1cnJlbnQgPSB2bm9kZTtcbiAgICAgICAgcmV0dXJuIHJhd1ZOb2RlO1xuICAgICAgfVxuICAgICAgY29uc3Qga2V5ID0gdm5vZGUua2V5ID09IG51bGwgPyBjb21wIDogdm5vZGUua2V5O1xuICAgICAgY29uc3QgY2FjaGVkVk5vZGUgPSBjYWNoZS5nZXQoa2V5KTtcbiAgICAgIGlmICh2bm9kZS5lbCkge1xuICAgICAgICB2bm9kZSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgICAgICBpZiAocmF3Vk5vZGUuc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICAgICAgcmF3Vk5vZGUuc3NDb250ZW50ID0gdm5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBlbmRpbmdDYWNoZUtleSA9IGtleTtcbiAgICAgIGlmIChjYWNoZWRWTm9kZSkge1xuICAgICAgICB2bm9kZS5lbCA9IGNhY2hlZFZOb2RlLmVsO1xuICAgICAgICB2bm9kZS5jb21wb25lbnQgPSBjYWNoZWRWTm9kZS5jb21wb25lbnQ7XG4gICAgICAgIGlmICh2bm9kZS50cmFuc2l0aW9uKSB7XG4gICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLCB2bm9kZS50cmFuc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB2bm9kZS5zaGFwZUZsYWcgfD0gNTEyO1xuICAgICAgICBrZXlzLmRlbGV0ZShrZXkpO1xuICAgICAgICBrZXlzLmFkZChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICAgICAgaWYgKG1heCAmJiBrZXlzLnNpemUgPiBwYXJzZUludChtYXgsIDEwKSkge1xuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShrZXlzLnZhbHVlcygpLm5leHQoKS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZub2RlLnNoYXBlRmxhZyB8PSAyNTY7XG4gICAgICBjdXJyZW50ID0gdm5vZGU7XG4gICAgICByZXR1cm4gaXNTdXNwZW5zZShyYXdWTm9kZS50eXBlKSA/IHJhd1ZOb2RlIDogdm5vZGU7XG4gICAgfTtcbiAgfVxufTtcbmNvbnN0IEtlZXBBbGl2ZSA9IEtlZXBBbGl2ZUltcGw7XG5mdW5jdGlvbiBtYXRjaGVzKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKGlzQXJyYXkocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zb21lKChwKSA9PiBtYXRjaGVzKHAsIG5hbWUpKTtcbiAgfSBlbHNlIGlmIChpc1N0cmluZyhwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KFwiLFwiKS5pbmNsdWRlcyhuYW1lKTtcbiAgfSBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgIHBhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG9uQWN0aXZhdGVkKGhvb2ssIHRhcmdldCkge1xuICByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgXCJhXCIsIHRhcmdldCk7XG59XG5mdW5jdGlvbiBvbkRlYWN0aXZhdGVkKGhvb2ssIHRhcmdldCkge1xuICByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgXCJkYVwiLCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIHR5cGUsIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkge1xuICBjb25zdCB3cmFwcGVkSG9vayA9IGhvb2suX193ZGMgfHwgKGhvb2suX193ZGMgPSAoKSA9PiB7XG4gICAgbGV0IGN1cnJlbnQgPSB0YXJnZXQ7XG4gICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgIGlmIChjdXJyZW50LmlzRGVhY3RpdmF0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gaG9vaygpO1xuICB9KTtcbiAgaW5qZWN0SG9vayh0eXBlLCB3cmFwcGVkSG9vaywgdGFyZ2V0KTtcbiAgaWYgKHRhcmdldCkge1xuICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0LnBhcmVudDtcbiAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50LnBhcmVudCkge1xuICAgICAgaWYgKGlzS2VlcEFsaXZlKGN1cnJlbnQucGFyZW50LnZub2RlKSkge1xuICAgICAgICBpbmplY3RUb0tlZXBBbGl2ZVJvb3Qod3JhcHBlZEhvb2ssIHR5cGUsIHRhcmdldCwgY3VycmVudCk7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpbmplY3RUb0tlZXBBbGl2ZVJvb3QoaG9vaywgdHlwZSwgdGFyZ2V0LCBrZWVwQWxpdmVSb290KSB7XG4gIGNvbnN0IGluamVjdGVkID0gaW5qZWN0SG9vayhcbiAgICB0eXBlLFxuICAgIGhvb2ssXG4gICAga2VlcEFsaXZlUm9vdCxcbiAgICB0cnVlXG4gICAgLyogcHJlcGVuZCAqL1xuICApO1xuICBvblVubW91bnRlZCgoKSA9PiB7XG4gICAgcmVtb3ZlKGtlZXBBbGl2ZVJvb3RbdHlwZV0sIGluamVjdGVkKTtcbiAgfSwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIHJlc2V0U2hhcGVGbGFnKHZub2RlKSB7XG4gIHZub2RlLnNoYXBlRmxhZyAmPSB+MjU2O1xuICB2bm9kZS5zaGFwZUZsYWcgJj0gfjUxMjtcbn1cbmZ1bmN0aW9uIGdldElubmVyQ2hpbGQodm5vZGUpIHtcbiAgcmV0dXJuIHZub2RlLnNoYXBlRmxhZyAmIDEyOCA/IHZub2RlLnNzQ29udGVudCA6IHZub2RlO1xufVxuXG5mdW5jdGlvbiBpbmplY3RIb29rKHR5cGUsIGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSwgcHJlcGVuZCA9IGZhbHNlKSB7XG4gIGlmICh0YXJnZXQpIHtcbiAgICBjb25zdCBob29rcyA9IHRhcmdldFt0eXBlXSB8fCAodGFyZ2V0W3R5cGVdID0gW10pO1xuICAgIGNvbnN0IHdyYXBwZWRIb29rID0gaG9vay5fX3dlaCB8fCAoaG9vay5fX3dlaCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgICBjb25zdCByZXNldCA9IHNldEN1cnJlbnRJbnN0YW5jZSh0YXJnZXQpO1xuICAgICAgY29uc3QgcmVzID0gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgdGFyZ2V0LCB0eXBlLCBhcmdzKTtcbiAgICAgIHJlc2V0KCk7XG4gICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0pO1xuICAgIGlmIChwcmVwZW5kKSB7XG4gICAgICBob29rcy51bnNoaWZ0KHdyYXBwZWRIb29rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaG9va3MucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfVxuICAgIHJldHVybiB3cmFwcGVkSG9vaztcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY29uc3QgYXBpTmFtZSA9IHRvSGFuZGxlcktleShFcnJvclR5cGVTdHJpbmdzJDFbdHlwZV0ucmVwbGFjZSgvIGhvb2skLywgXCJcIikpO1xuICAgIHdhcm4kMShcbiAgICAgIGAke2FwaU5hbWV9IGlzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UgdG8gYmUgYXNzb2NpYXRlZCB3aXRoLiBMaWZlY3ljbGUgaW5qZWN0aW9uIEFQSXMgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgZXhlY3V0aW9uIG9mIHNldHVwKCkuYCArIChgIElmIHlvdSBhcmUgdXNpbmcgYXN5bmMgc2V0dXAoKSwgbWFrZSBzdXJlIHRvIHJlZ2lzdGVyIGxpZmVjeWNsZSBob29rcyBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0IHN0YXRlbWVudC5gIClcbiAgICApO1xuICB9XG59XG5jb25zdCBjcmVhdGVIb29rID0gKGxpZmVjeWNsZSkgPT4gKGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkgPT4ge1xuICBpZiAoIWlzSW5TU1JDb21wb25lbnRTZXR1cCB8fCBsaWZlY3ljbGUgPT09IFwic3BcIikge1xuICAgIGluamVjdEhvb2sobGlmZWN5Y2xlLCAoLi4uYXJncykgPT4gaG9vayguLi5hcmdzKSwgdGFyZ2V0KTtcbiAgfVxufTtcbmNvbnN0IG9uQmVmb3JlTW91bnQgPSBjcmVhdGVIb29rKFwiYm1cIik7XG5jb25zdCBvbk1vdW50ZWQgPSBjcmVhdGVIb29rKFwibVwiKTtcbmNvbnN0IG9uQmVmb3JlVXBkYXRlID0gY3JlYXRlSG9vayhcbiAgXCJidVwiXG4pO1xuY29uc3Qgb25VcGRhdGVkID0gY3JlYXRlSG9vayhcInVcIik7XG5jb25zdCBvbkJlZm9yZVVubW91bnQgPSBjcmVhdGVIb29rKFxuICBcImJ1bVwiXG4pO1xuY29uc3Qgb25Vbm1vdW50ZWQgPSBjcmVhdGVIb29rKFwidW1cIik7XG5jb25zdCBvblNlcnZlclByZWZldGNoID0gY3JlYXRlSG9vayhcbiAgXCJzcFwiXG4pO1xuY29uc3Qgb25SZW5kZXJUcmlnZ2VyZWQgPSBjcmVhdGVIb29rKFwicnRnXCIpO1xuY29uc3Qgb25SZW5kZXJUcmFja2VkID0gY3JlYXRlSG9vayhcInJ0Y1wiKTtcbmZ1bmN0aW9uIG9uRXJyb3JDYXB0dXJlZChob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpIHtcbiAgaW5qZWN0SG9vayhcImVjXCIsIGhvb2ssIHRhcmdldCk7XG59XG5cbmNvbnN0IENPTVBPTkVOVFMgPSBcImNvbXBvbmVudHNcIjtcbmNvbnN0IERJUkVDVElWRVMgPSBcImRpcmVjdGl2ZXNcIjtcbmZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnQobmFtZSwgbWF5YmVTZWxmUmVmZXJlbmNlKSB7XG4gIHJldHVybiByZXNvbHZlQXNzZXQoQ09NUE9ORU5UUywgbmFtZSwgdHJ1ZSwgbWF5YmVTZWxmUmVmZXJlbmNlKSB8fCBuYW1lO1xufVxuY29uc3QgTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCA9IFN5bWJvbC5mb3IoXCJ2LW5kY1wiKTtcbmZ1bmN0aW9uIHJlc29sdmVEeW5hbWljQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICBpZiAoaXNTdHJpbmcoY29tcG9uZW50KSkge1xuICAgIHJldHVybiByZXNvbHZlQXNzZXQoQ09NUE9ORU5UUywgY29tcG9uZW50LCBmYWxzZSkgfHwgY29tcG9uZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb21wb25lbnQgfHwgTlVMTF9EWU5BTUlDX0NPTVBPTkVOVDtcbiAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZURpcmVjdGl2ZShuYW1lKSB7XG4gIHJldHVybiByZXNvbHZlQXNzZXQoRElSRUNUSVZFUywgbmFtZSk7XG59XG5mdW5jdGlvbiByZXNvbHZlQXNzZXQodHlwZSwgbmFtZSwgd2Fybk1pc3NpbmcgPSB0cnVlLCBtYXliZVNlbGZSZWZlcmVuY2UgPSBmYWxzZSkge1xuICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSB8fCBjdXJyZW50SW5zdGFuY2U7XG4gIGlmIChpbnN0YW5jZSkge1xuICAgIGNvbnN0IENvbXBvbmVudCA9IGluc3RhbmNlLnR5cGU7XG4gICAgaWYgKHR5cGUgPT09IENPTVBPTkVOVFMpIHtcbiAgICAgIGNvbnN0IHNlbGZOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICAgIGlmIChzZWxmTmFtZSAmJiAoc2VsZk5hbWUgPT09IG5hbWUgfHwgc2VsZk5hbWUgPT09IGNhbWVsaXplKG5hbWUpIHx8IHNlbGZOYW1lID09PSBjYXBpdGFsaXplKGNhbWVsaXplKG5hbWUpKSkpIHtcbiAgICAgICAgcmV0dXJuIENvbXBvbmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzID0gKFxuICAgICAgLy8gbG9jYWwgcmVnaXN0cmF0aW9uXG4gICAgICAvLyBjaGVjayBpbnN0YW5jZVt0eXBlXSBmaXJzdCB3aGljaCBpcyByZXNvbHZlZCBmb3Igb3B0aW9ucyBBUElcbiAgICAgIHJlc29sdmUoaW5zdGFuY2VbdHlwZV0gfHwgQ29tcG9uZW50W3R5cGVdLCBuYW1lKSB8fCAvLyBnbG9iYWwgcmVnaXN0cmF0aW9uXG4gICAgICByZXNvbHZlKGluc3RhbmNlLmFwcENvbnRleHRbdHlwZV0sIG5hbWUpXG4gICAgKTtcbiAgICBpZiAoIXJlcyAmJiBtYXliZVNlbGZSZWZlcmVuY2UpIHtcbiAgICAgIHJldHVybiBDb21wb25lbnQ7XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICAgIGNvbnN0IGV4dHJhID0gdHlwZSA9PT0gQ09NUE9ORU5UUyA/IGBcbklmIHRoaXMgaXMgYSBuYXRpdmUgY3VzdG9tIGVsZW1lbnQsIG1ha2Ugc3VyZSB0byBleGNsdWRlIGl0IGZyb20gY29tcG9uZW50IHJlc29sdXRpb24gdmlhIGNvbXBpbGVyT3B0aW9ucy5pc0N1c3RvbUVsZW1lbnQuYCA6IGBgO1xuICAgICAgd2FybiQxKGBGYWlsZWQgdG8gcmVzb2x2ZSAke3R5cGUuc2xpY2UoMCwgLTEpfTogJHtuYW1lfSR7ZXh0cmF9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4kMShcbiAgICAgIGByZXNvbHZlJHtjYXBpdGFsaXplKHR5cGUuc2xpY2UoMCwgLTEpKX0gY2FuIG9ubHkgYmUgdXNlZCBpbiByZW5kZXIoKSBvciBzZXR1cCgpLmBcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiByZXNvbHZlKHJlZ2lzdHJ5LCBuYW1lKSB7XG4gIHJldHVybiByZWdpc3RyeSAmJiAocmVnaXN0cnlbbmFtZV0gfHwgcmVnaXN0cnlbY2FtZWxpemUobmFtZSldIHx8IHJlZ2lzdHJ5W2NhcGl0YWxpemUoY2FtZWxpemUobmFtZSkpXSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckxpc3Qoc291cmNlLCByZW5kZXJJdGVtLCBjYWNoZSwgaW5kZXgpIHtcbiAgbGV0IHJldDtcbiAgY29uc3QgY2FjaGVkID0gY2FjaGUgJiYgY2FjaGVbaW5kZXhdO1xuICBjb25zdCBzb3VyY2VJc0FycmF5ID0gaXNBcnJheShzb3VyY2UpO1xuICBpZiAoc291cmNlSXNBcnJheSB8fCBpc1N0cmluZyhzb3VyY2UpKSB7XG4gICAgY29uc3Qgc291cmNlSXNSZWFjdGl2ZUFycmF5ID0gc291cmNlSXNBcnJheSAmJiBpc1JlYWN0aXZlKHNvdXJjZSk7XG4gICAgbGV0IG5lZWRzV3JhcCA9IGZhbHNlO1xuICAgIGlmIChzb3VyY2VJc1JlYWN0aXZlQXJyYXkpIHtcbiAgICAgIG5lZWRzV3JhcCA9ICFpc1NoYWxsb3coc291cmNlKTtcbiAgICAgIHNvdXJjZSA9IHNoYWxsb3dSZWFkQXJyYXkoc291cmNlKTtcbiAgICB9XG4gICAgcmV0ID0gbmV3IEFycmF5KHNvdXJjZS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gc291cmNlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVySXRlbShcbiAgICAgICAgbmVlZHNXcmFwID8gdG9SZWFjdGl2ZShzb3VyY2VbaV0pIDogc291cmNlW2ldLFxuICAgICAgICBpLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIGNhY2hlZCAmJiBjYWNoZWRbaV1cbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBzb3VyY2UgPT09IFwibnVtYmVyXCIpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhTnVtYmVyLmlzSW50ZWdlcihzb3VyY2UpKSB7XG4gICAgICB3YXJuJDEoYFRoZSB2LWZvciByYW5nZSBleHBlY3QgYW4gaW50ZWdlciB2YWx1ZSBidXQgZ290ICR7c291cmNlfS5gKTtcbiAgICB9XG4gICAgcmV0ID0gbmV3IEFycmF5KHNvdXJjZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2U7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVySXRlbShpICsgMSwgaSwgdm9pZCAwLCBjYWNoZWQgJiYgY2FjaGVkW2ldKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xuICAgIGlmIChzb3VyY2VbU3ltYm9sLml0ZXJhdG9yXSkge1xuICAgICAgcmV0ID0gQXJyYXkuZnJvbShcbiAgICAgICAgc291cmNlLFxuICAgICAgICAoaXRlbSwgaSkgPT4gcmVuZGVySXRlbShpdGVtLCBpLCB2b2lkIDAsIGNhY2hlZCAmJiBjYWNoZWRbaV0pXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oc291cmNlW2tleV0sIGtleSwgaSwgY2FjaGVkICYmIGNhY2hlZFtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldCA9IFtdO1xuICB9XG4gIGlmIChjYWNoZSkge1xuICAgIGNhY2hlW2luZGV4XSA9IHJldDtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTbG90cyhzbG90cywgZHluYW1pY1Nsb3RzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZHluYW1pY1Nsb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2xvdCA9IGR5bmFtaWNTbG90c1tpXTtcbiAgICBpZiAoaXNBcnJheShzbG90KSkge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzbG90Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHNsb3RzW3Nsb3Rbal0ubmFtZV0gPSBzbG90W2pdLmZuO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2xvdCkge1xuICAgICAgc2xvdHNbc2xvdC5uYW1lXSA9IHNsb3Qua2V5ID8gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgcmVzID0gc2xvdC5mbiguLi5hcmdzKTtcbiAgICAgICAgaWYgKHJlcykgcmVzLmtleSA9IHNsb3Qua2V5O1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSA6IHNsb3QuZm47XG4gICAgfVxuICB9XG4gIHJldHVybiBzbG90cztcbn1cblxuZnVuY3Rpb24gcmVuZGVyU2xvdChzbG90cywgbmFtZSwgcHJvcHMgPSB7fSwgZmFsbGJhY2ssIG5vU2xvdHRlZCkge1xuICBpZiAoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLmNlIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5wYXJlbnQgJiYgaXNBc3luY1dyYXBwZXIoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnBhcmVudCkgJiYgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnBhcmVudC5jZSkge1xuICAgIGlmIChuYW1lICE9PSBcImRlZmF1bHRcIikgcHJvcHMubmFtZSA9IG5hbWU7XG4gICAgcmV0dXJuIG9wZW5CbG9jaygpLCBjcmVhdGVCbG9jayhcbiAgICAgIEZyYWdtZW50LFxuICAgICAgbnVsbCxcbiAgICAgIFtjcmVhdGVWTm9kZShcInNsb3RcIiwgcHJvcHMsIGZhbGxiYWNrICYmIGZhbGxiYWNrKCkpXSxcbiAgICAgIDY0XG4gICAgKTtcbiAgfVxuICBsZXQgc2xvdCA9IHNsb3RzW25hbWVdO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzbG90ICYmIHNsb3QubGVuZ3RoID4gMSkge1xuICAgIHdhcm4kMShcbiAgICAgIGBTU1Itb3B0aW1pemVkIHNsb3QgZnVuY3Rpb24gZGV0ZWN0ZWQgaW4gYSBub24tU1NSLW9wdGltaXplZCByZW5kZXIgZnVuY3Rpb24uIFlvdSBuZWVkIHRvIG1hcmsgdGhpcyBjb21wb25lbnQgd2l0aCAkZHluYW1pYy1zbG90cyBpbiB0aGUgcGFyZW50IHRlbXBsYXRlLmBcbiAgICApO1xuICAgIHNsb3QgPSAoKSA9PiBbXTtcbiAgfVxuICBpZiAoc2xvdCAmJiBzbG90Ll9jKSB7XG4gICAgc2xvdC5fZCA9IGZhbHNlO1xuICB9XG4gIG9wZW5CbG9jaygpO1xuICBjb25zdCB2YWxpZFNsb3RDb250ZW50ID0gc2xvdCAmJiBlbnN1cmVWYWxpZFZOb2RlKHNsb3QocHJvcHMpKTtcbiAgY29uc3Qgc2xvdEtleSA9IHByb3BzLmtleSB8fCAvLyBzbG90IGNvbnRlbnQgYXJyYXkgb2YgYSBkeW5hbWljIGNvbmRpdGlvbmFsIHNsb3QgbWF5IGhhdmUgYSBicmFuY2hcbiAgLy8ga2V5IGF0dGFjaGVkIGluIHRoZSBgY3JlYXRlU2xvdHNgIGhlbHBlciwgcmVzcGVjdCB0aGF0XG4gIHZhbGlkU2xvdENvbnRlbnQgJiYgdmFsaWRTbG90Q29udGVudC5rZXk7XG4gIGNvbnN0IHJlbmRlcmVkID0gY3JlYXRlQmxvY2soXG4gICAgRnJhZ21lbnQsXG4gICAge1xuICAgICAga2V5OiAoc2xvdEtleSAmJiAhaXNTeW1ib2woc2xvdEtleSkgPyBzbG90S2V5IDogYF8ke25hbWV9YCkgKyAvLyAjNzI1NiBmb3JjZSBkaWZmZXJlbnRpYXRlIGZhbGxiYWNrIGNvbnRlbnQgZnJvbSBhY3R1YWwgY29udGVudFxuICAgICAgKCF2YWxpZFNsb3RDb250ZW50ICYmIGZhbGxiYWNrID8gXCJfZmJcIiA6IFwiXCIpXG4gICAgfSxcbiAgICB2YWxpZFNsb3RDb250ZW50IHx8IChmYWxsYmFjayA/IGZhbGxiYWNrKCkgOiBbXSksXG4gICAgdmFsaWRTbG90Q29udGVudCAmJiBzbG90cy5fID09PSAxID8gNjQgOiAtMlxuICApO1xuICBpZiAoIW5vU2xvdHRlZCAmJiByZW5kZXJlZC5zY29wZUlkKSB7XG4gICAgcmVuZGVyZWQuc2xvdFNjb3BlSWRzID0gW3JlbmRlcmVkLnNjb3BlSWQgKyBcIi1zXCJdO1xuICB9XG4gIGlmIChzbG90ICYmIHNsb3QuX2MpIHtcbiAgICBzbG90Ll9kID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVuZGVyZWQ7XG59XG5mdW5jdGlvbiBlbnN1cmVWYWxpZFZOb2RlKHZub2Rlcykge1xuICByZXR1cm4gdm5vZGVzLnNvbWUoKGNoaWxkKSA9PiB7XG4gICAgaWYgKCFpc1ZOb2RlKGNoaWxkKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGNoaWxkLnR5cGUgPT09IENvbW1lbnQpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gRnJhZ21lbnQgJiYgIWVuc3VyZVZhbGlkVk5vZGUoY2hpbGQuY2hpbGRyZW4pKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9KSA/IHZub2RlcyA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHRvSGFuZGxlcnMob2JqLCBwcmVzZXJ2ZUNhc2VJZk5lY2Vzc2FyeSkge1xuICBjb25zdCByZXQgPSB7fTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzT2JqZWN0KG9iaikpIHtcbiAgICB3YXJuJDEoYHYtb24gd2l0aCBubyBhcmd1bWVudCBleHBlY3RzIGFuIG9iamVjdCB2YWx1ZS5gKTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIHJldFtwcmVzZXJ2ZUNhc2VJZk5lY2Vzc2FyeSAmJiAvW0EtWl0vLnRlc3Qoa2V5KSA/IGBvbjoke2tleX1gIDogdG9IYW5kbGVyS2V5KGtleSldID0gb2JqW2tleV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuY29uc3QgZ2V0UHVibGljSW5zdGFuY2UgPSAoaSkgPT4ge1xuICBpZiAoIWkpIHJldHVybiBudWxsO1xuICBpZiAoaXNTdGF0ZWZ1bENvbXBvbmVudChpKSkgcmV0dXJuIGdldENvbXBvbmVudFB1YmxpY0luc3RhbmNlKGkpO1xuICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoaS5wYXJlbnQpO1xufTtcbmNvbnN0IHB1YmxpY1Byb3BlcnRpZXNNYXAgPSAoXG4gIC8vIE1vdmUgUFVSRSBtYXJrZXIgdG8gbmV3IGxpbmUgdG8gd29ya2Fyb3VuZCBjb21waWxlciBkaXNjYXJkaW5nIGl0XG4gIC8vIGR1ZSB0byB0eXBlIGFubm90YXRpb25cbiAgLyogQF9fUFVSRV9fICovIGV4dGVuZCgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICAgICQ6IChpKSA9PiBpLFxuICAgICRlbDogKGkpID0+IGkudm5vZGUuZWwsXG4gICAgJGRhdGE6IChpKSA9PiBpLmRhdGEsXG4gICAgJHByb3BzOiAoaSkgPT4gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShpLnByb3BzKSA6IGkucHJvcHMsXG4gICAgJGF0dHJzOiAoaSkgPT4gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShpLmF0dHJzKSA6IGkuYXR0cnMsXG4gICAgJHNsb3RzOiAoaSkgPT4gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShpLnNsb3RzKSA6IGkuc2xvdHMsXG4gICAgJHJlZnM6IChpKSA9PiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGkucmVmcykgOiBpLnJlZnMsXG4gICAgJHBhcmVudDogKGkpID0+IGdldFB1YmxpY0luc3RhbmNlKGkucGFyZW50KSxcbiAgICAkcm9vdDogKGkpID0+IGdldFB1YmxpY0luc3RhbmNlKGkucm9vdCksXG4gICAgJGhvc3Q6IChpKSA9PiBpLmNlLFxuICAgICRlbWl0OiAoaSkgPT4gaS5lbWl0LFxuICAgICRvcHRpb25zOiAoaSkgPT4gX19WVUVfT1BUSU9OU19BUElfXyA/IHJlc29sdmVNZXJnZWRPcHRpb25zKGkpIDogaS50eXBlLFxuICAgICRmb3JjZVVwZGF0ZTogKGkpID0+IGkuZiB8fCAoaS5mID0gKCkgPT4ge1xuICAgICAgcXVldWVKb2IoaS51cGRhdGUpO1xuICAgIH0pLFxuICAgICRuZXh0VGljazogKGkpID0+IGkubiB8fCAoaS5uID0gbmV4dFRpY2suYmluZChpLnByb3h5KSksXG4gICAgJHdhdGNoOiAoaSkgPT4gX19WVUVfT1BUSU9OU19BUElfXyA/IGluc3RhbmNlV2F0Y2guYmluZChpKSA6IE5PT1BcbiAgfSlcbik7XG5jb25zdCBpc1Jlc2VydmVkUHJlZml4ID0gKGtleSkgPT4ga2V5ID09PSBcIl9cIiB8fCBrZXkgPT09IFwiJFwiO1xuY29uc3QgaGFzU2V0dXBCaW5kaW5nID0gKHN0YXRlLCBrZXkpID0+IHN0YXRlICE9PSBFTVBUWV9PQkogJiYgIXN0YXRlLl9faXNTY3JpcHRTZXR1cCAmJiBoYXNPd24oc3RhdGUsIGtleSk7XG5jb25zdCBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMgPSB7XG4gIGdldCh7IF86IGluc3RhbmNlIH0sIGtleSkge1xuICAgIGlmIChrZXkgPT09IFwiX192X3NraXBcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHsgY3R4LCBzZXR1cFN0YXRlLCBkYXRhLCBwcm9wcywgYWNjZXNzQ2FjaGUsIHR5cGUsIGFwcENvbnRleHQgfSA9IGluc3RhbmNlO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGtleSA9PT0gXCJfX2lzVnVlXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgbm9ybWFsaXplZFByb3BzO1xuICAgIGlmIChrZXlbMF0gIT09IFwiJFwiKSB7XG4gICAgICBjb25zdCBuID0gYWNjZXNzQ2FjaGVba2V5XTtcbiAgICAgIGlmIChuICE9PSB2b2lkIDApIHtcbiAgICAgICAgc3dpdGNoIChuKSB7XG4gICAgICAgICAgY2FzZSAxIC8qIFNFVFVQICovOlxuICAgICAgICAgICAgcmV0dXJuIHNldHVwU3RhdGVba2V5XTtcbiAgICAgICAgICBjYXNlIDIgLyogREFUQSAqLzpcbiAgICAgICAgICAgIHJldHVybiBkYXRhW2tleV07XG4gICAgICAgICAgY2FzZSA0IC8qIENPTlRFWFQgKi86XG4gICAgICAgICAgICByZXR1cm4gY3R4W2tleV07XG4gICAgICAgICAgY2FzZSAzIC8qIFBST1BTICovOlxuICAgICAgICAgICAgcmV0dXJuIHByb3BzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaGFzU2V0dXBCaW5kaW5nKHNldHVwU3RhdGUsIGtleSkpIHtcbiAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDEgLyogU0VUVVAgKi87XG4gICAgICAgIHJldHVybiBzZXR1cFN0YXRlW2tleV07XG4gICAgICB9IGVsc2UgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oZGF0YSwga2V5KSkge1xuICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMiAvKiBEQVRBICovO1xuICAgICAgICByZXR1cm4gZGF0YVtrZXldO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgLy8gb25seSBjYWNoZSBvdGhlciBwcm9wZXJ0aWVzIHdoZW4gaW5zdGFuY2UgaGFzIGRlY2xhcmVkICh0aHVzIHN0YWJsZSlcbiAgICAgICAgLy8gcHJvcHNcbiAgICAgICAgKG5vcm1hbGl6ZWRQcm9wcyA9IGluc3RhbmNlLnByb3BzT3B0aW9uc1swXSkgJiYgaGFzT3duKG5vcm1hbGl6ZWRQcm9wcywga2V5KVxuICAgICAgKSB7XG4gICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAzIC8qIFBST1BTICovO1xuICAgICAgICByZXR1cm4gcHJvcHNba2V5XTtcbiAgICAgIH0gZWxzZSBpZiAoY3R4ICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGN0eCwga2V5KSkge1xuICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gNCAvKiBDT05URVhUICovO1xuICAgICAgICByZXR1cm4gY3R4W2tleV07XG4gICAgICB9IGVsc2UgaWYgKCFfX1ZVRV9PUFRJT05TX0FQSV9fIHx8IHNob3VsZENhY2hlQWNjZXNzKSB7XG4gICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAwIC8qIE9USEVSICovO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwdWJsaWNHZXR0ZXIgPSBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV07XG4gICAgbGV0IGNzc01vZHVsZSwgZ2xvYmFsUHJvcGVydGllcztcbiAgICBpZiAocHVibGljR2V0dGVyKSB7XG4gICAgICBpZiAoa2V5ID09PSBcIiRhdHRyc1wiKSB7XG4gICAgICAgIHRyYWNrKGluc3RhbmNlLmF0dHJzLCBcImdldFwiLCBcIlwiKTtcbiAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xuICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGtleSA9PT0gXCIkc2xvdHNcIikge1xuICAgICAgICB0cmFjayhpbnN0YW5jZSwgXCJnZXRcIiwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwdWJsaWNHZXR0ZXIoaW5zdGFuY2UpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAvLyBjc3MgbW9kdWxlIChpbmplY3RlZCBieSB2dWUtbG9hZGVyKVxuICAgICAgKGNzc01vZHVsZSA9IHR5cGUuX19jc3NNb2R1bGVzKSAmJiAoY3NzTW9kdWxlID0gY3NzTW9kdWxlW2tleV0pXG4gICAgKSB7XG4gICAgICByZXR1cm4gY3NzTW9kdWxlO1xuICAgIH0gZWxzZSBpZiAoY3R4ICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGN0eCwga2V5KSkge1xuICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDQgLyogQ09OVEVYVCAqLztcbiAgICAgIHJldHVybiBjdHhba2V5XTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgLy8gZ2xvYmFsIHByb3BlcnRpZXNcbiAgICAgIGdsb2JhbFByb3BlcnRpZXMgPSBhcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzLCBoYXNPd24oZ2xvYmFsUHJvcGVydGllcywga2V5KVxuICAgICkge1xuICAgICAge1xuICAgICAgICByZXR1cm4gZ2xvYmFsUHJvcGVydGllc1trZXldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgJiYgKCFpc1N0cmluZyhrZXkpIHx8IC8vICMxMDkxIGF2b2lkIGludGVybmFsIGlzUmVmL2lzVk5vZGUgY2hlY2tzIG9uIGNvbXBvbmVudCBpbnN0YW5jZSBsZWFkaW5nXG4gICAgLy8gdG8gaW5maW5pdGUgd2FybmluZyBsb29wXG4gICAga2V5LmluZGV4T2YoXCJfX3ZcIikgIT09IDApKSB7XG4gICAgICBpZiAoZGF0YSAhPT0gRU1QVFlfT0JKICYmIGlzUmVzZXJ2ZWRQcmVmaXgoa2V5WzBdKSAmJiBoYXNPd24oZGF0YSwga2V5KSkge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYFByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICBrZXlcbiAgICAgICAgICApfSBtdXN0IGJlIGFjY2Vzc2VkIHZpYSAkZGF0YSBiZWNhdXNlIGl0IHN0YXJ0cyB3aXRoIGEgcmVzZXJ2ZWQgY2hhcmFjdGVyIChcIiRcIiBvciBcIl9cIikgYW5kIGlzIG5vdCBwcm94aWVkIG9uIHRoZSByZW5kZXIgY29udGV4dC5gXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGluc3RhbmNlID09PSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KGtleSl9IHdhcyBhY2Nlc3NlZCBkdXJpbmcgcmVuZGVyIGJ1dCBpcyBub3QgZGVmaW5lZCBvbiBpbnN0YW5jZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzZXQoeyBfOiBpbnN0YW5jZSB9LCBrZXksIHZhbHVlKSB7XG4gICAgY29uc3QgeyBkYXRhLCBzZXR1cFN0YXRlLCBjdHggfSA9IGluc3RhbmNlO1xuICAgIGlmIChoYXNTZXR1cEJpbmRpbmcoc2V0dXBTdGF0ZSwga2V5KSkge1xuICAgICAgc2V0dXBTdGF0ZVtrZXldID0gdmFsdWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2V0dXBTdGF0ZS5fX2lzU2NyaXB0U2V0dXAgJiYgaGFzT3duKHNldHVwU3RhdGUsIGtleSkpIHtcbiAgICAgIHdhcm4kMShgQ2Fubm90IG11dGF0ZSA8c2NyaXB0IHNldHVwPiBiaW5kaW5nIFwiJHtrZXl9XCIgZnJvbSBPcHRpb25zIEFQSS5gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oZGF0YSwga2V5KSkge1xuICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGhhc093bihpbnN0YW5jZS5wcm9wcywga2V5KSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuJDEoYEF0dGVtcHRpbmcgdG8gbXV0YXRlIHByb3AgXCIke2tleX1cIi4gUHJvcHMgYXJlIHJlYWRvbmx5LmApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoa2V5WzBdID09PSBcIiRcIiAmJiBrZXkuc2xpY2UoMSkgaW4gaW5zdGFuY2UpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKFxuICAgICAgICBgQXR0ZW1wdGluZyB0byBtdXRhdGUgcHVibGljIHByb3BlcnR5IFwiJHtrZXl9XCIuIFByb3BlcnRpZXMgc3RhcnRpbmcgd2l0aCAkIGFyZSByZXNlcnZlZCBhbmQgcmVhZG9ubHkuYFxuICAgICAgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYga2V5IGluIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHhba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgaGFzKHtcbiAgICBfOiB7IGRhdGEsIHNldHVwU3RhdGUsIGFjY2Vzc0NhY2hlLCBjdHgsIGFwcENvbnRleHQsIHByb3BzT3B0aW9ucyB9XG4gIH0sIGtleSkge1xuICAgIGxldCBub3JtYWxpemVkUHJvcHM7XG4gICAgcmV0dXJuICEhYWNjZXNzQ2FjaGVba2V5XSB8fCBkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkgfHwgaGFzU2V0dXBCaW5kaW5nKHNldHVwU3RhdGUsIGtleSkgfHwgKG5vcm1hbGl6ZWRQcm9wcyA9IHByb3BzT3B0aW9uc1swXSkgJiYgaGFzT3duKG5vcm1hbGl6ZWRQcm9wcywga2V5KSB8fCBoYXNPd24oY3R4LCBrZXkpIHx8IGhhc093bihwdWJsaWNQcm9wZXJ0aWVzTWFwLCBrZXkpIHx8IGhhc093bihhcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzLCBrZXkpO1xuICB9LFxuICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuICAgIGlmIChkZXNjcmlwdG9yLmdldCAhPSBudWxsKSB7XG4gICAgICB0YXJnZXQuXy5hY2Nlc3NDYWNoZVtrZXldID0gMDtcbiAgICB9IGVsc2UgaWYgKGhhc093bihkZXNjcmlwdG9yLCBcInZhbHVlXCIpKSB7XG4gICAgICB0aGlzLnNldCh0YXJnZXQsIGtleSwgZGVzY3JpcHRvci52YWx1ZSwgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufTtcbmlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHRydWUpIHtcbiAgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLm93bktleXMgPSAodGFyZ2V0KSA9PiB7XG4gICAgd2FybiQxKFxuICAgICAgYEF2b2lkIGFwcCBsb2dpYyB0aGF0IHJlbGllcyBvbiBlbnVtZXJhdGluZyBrZXlzIG9uIGEgY29tcG9uZW50IGluc3RhbmNlLiBUaGUga2V5cyB3aWxsIGJlIGVtcHR5IGluIHByb2R1Y3Rpb24gbW9kZSB0byBhdm9pZCBwZXJmb3JtYW5jZSBvdmVyaGVhZC5gXG4gICAgKTtcbiAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XG4gIH07XG59XG5jb25zdCBSdW50aW1lQ29tcGlsZWRQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKHt9LCBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMsIHtcbiAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgaWYgKGtleSA9PT0gU3ltYm9sLnVuc2NvcGFibGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMuZ2V0KHRhcmdldCwga2V5LCB0YXJnZXQpO1xuICB9LFxuICBoYXMoXywga2V5KSB7XG4gICAgY29uc3QgaGFzID0ga2V5WzBdICE9PSBcIl9cIiAmJiAhaXNHbG9iYWxseUFsbG93ZWQoa2V5KTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaGFzICYmIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5oYXMoXywga2V5KSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBrZXlcbiAgICAgICAgKX0gc2hvdWxkIG5vdCBzdGFydCB3aXRoIF8gd2hpY2ggaXMgYSByZXNlcnZlZCBwcmVmaXggZm9yIFZ1ZSBpbnRlcm5hbHMuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhcztcbiAgfVxufSk7XG5mdW5jdGlvbiBjcmVhdGVEZXZSZW5kZXJDb250ZXh0KGluc3RhbmNlKSB7XG4gIGNvbnN0IHRhcmdldCA9IHt9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBgX2AsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0OiAoKSA9PiBpbnN0YW5jZVxuICB9KTtcbiAgT2JqZWN0LmtleXMocHVibGljUHJvcGVydGllc01hcCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogKCkgPT4gcHVibGljUHJvcGVydGllc01hcFtrZXldKGluc3RhbmNlKSxcbiAgICAgIC8vIGludGVyY2VwdGVkIGJ5IHRoZSBwcm94eSBzbyBubyBuZWVkIGZvciBpbXBsZW1lbnRhdGlvbixcbiAgICAgIC8vIGJ1dCBuZWVkZWQgdG8gcHJldmVudCBzZXQgZXJyb3JzXG4gICAgICBzZXQ6IE5PT1BcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBleHBvc2VQcm9wc09uUmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xuICBjb25zdCB7XG4gICAgY3R4LFxuICAgIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc11cbiAgfSA9IGluc3RhbmNlO1xuICBpZiAocHJvcHNPcHRpb25zKSB7XG4gICAgT2JqZWN0LmtleXMocHJvcHNPcHRpb25zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gaW5zdGFuY2UucHJvcHNba2V5XSxcbiAgICAgICAgc2V0OiBOT09QXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZXhwb3NlU2V0dXBTdGF0ZU9uUmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xuICBjb25zdCB7IGN0eCwgc2V0dXBTdGF0ZSB9ID0gaW5zdGFuY2U7XG4gIE9iamVjdC5rZXlzKHRvUmF3KHNldHVwU3RhdGUpKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAoIXNldHVwU3RhdGUuX19pc1NjcmlwdFNldHVwKSB7XG4gICAgICBpZiAoaXNSZXNlcnZlZFByZWZpeChrZXlbMF0pKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBgc2V0dXAoKSByZXR1cm4gcHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIGtleVxuICAgICAgICAgICl9IHNob3VsZCBub3Qgc3RhcnQgd2l0aCBcIiRcIiBvciBcIl9cIiB3aGljaCBhcmUgcmVzZXJ2ZWQgcHJlZml4ZXMgZm9yIFZ1ZSBpbnRlcm5hbHMuYFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IHNldHVwU3RhdGVba2V5XSxcbiAgICAgICAgc2V0OiBOT09QXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5jb25zdCB3YXJuUnVudGltZVVzYWdlID0gKG1ldGhvZCkgPT4gd2FybiQxKFxuICBgJHttZXRob2R9KCkgaXMgYSBjb21waWxlci1oaW50IGhlbHBlciB0aGF0IGlzIG9ubHkgdXNhYmxlIGluc2lkZSA8c2NyaXB0IHNldHVwPiBvZiBhIHNpbmdsZSBmaWxlIGNvbXBvbmVudC4gSXRzIGFyZ3VtZW50cyBzaG91bGQgYmUgY29tcGlsZWQgYXdheSBhbmQgcGFzc2luZyBpdCBhdCBydW50aW1lIGhhcyBubyBlZmZlY3QuYFxuKTtcbmZ1bmN0aW9uIGRlZmluZVByb3BzKCkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZVByb3BzYCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBkZWZpbmVFbWl0cygpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVFbWl0c2ApO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZGVmaW5lRXhwb3NlKGV4cG9zZWQpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVFeHBvc2VgKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVmaW5lT3B0aW9ucyhvcHRpb25zKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lT3B0aW9uc2ApO1xuICB9XG59XG5mdW5jdGlvbiBkZWZpbmVTbG90cygpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVTbG90c2ApO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZGVmaW5lTW9kZWwoKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShcImRlZmluZU1vZGVsXCIpO1xuICB9XG59XG5mdW5jdGlvbiB3aXRoRGVmYXVsdHMocHJvcHMsIGRlZmF1bHRzKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShgd2l0aERlZmF1bHRzYCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB1c2VTbG90cygpIHtcbiAgcmV0dXJuIGdldENvbnRleHQoKS5zbG90cztcbn1cbmZ1bmN0aW9uIHVzZUF0dHJzKCkge1xuICByZXR1cm4gZ2V0Q29udGV4dCgpLmF0dHJzO1xufVxuZnVuY3Rpb24gZ2V0Q29udGV4dCgpIHtcbiAgY29uc3QgaSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaSkge1xuICAgIHdhcm4kMShgdXNlQ29udGV4dCgpIGNhbGxlZCB3aXRob3V0IGFjdGl2ZSBpbnN0YW5jZS5gKTtcbiAgfVxuICByZXR1cm4gaS5zZXR1cENvbnRleHQgfHwgKGkuc2V0dXBDb250ZXh0ID0gY3JlYXRlU2V0dXBDb250ZXh0KGkpKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzT3JFbWl0cyhwcm9wcykge1xuICByZXR1cm4gaXNBcnJheShwcm9wcykgPyBwcm9wcy5yZWR1Y2UoXG4gICAgKG5vcm1hbGl6ZWQsIHApID0+IChub3JtYWxpemVkW3BdID0gbnVsbCwgbm9ybWFsaXplZCksXG4gICAge31cbiAgKSA6IHByb3BzO1xufVxuZnVuY3Rpb24gbWVyZ2VEZWZhdWx0cyhyYXcsIGRlZmF1bHRzKSB7XG4gIGNvbnN0IHByb3BzID0gbm9ybWFsaXplUHJvcHNPckVtaXRzKHJhdyk7XG4gIGZvciAoY29uc3Qga2V5IGluIGRlZmF1bHRzKSB7XG4gICAgaWYgKGtleS5zdGFydHNXaXRoKFwiX19za2lwXCIpKSBjb250aW51ZTtcbiAgICBsZXQgb3B0ID0gcHJvcHNba2V5XTtcbiAgICBpZiAob3B0KSB7XG4gICAgICBpZiAoaXNBcnJheShvcHQpIHx8IGlzRnVuY3Rpb24ob3B0KSkge1xuICAgICAgICBvcHQgPSBwcm9wc1trZXldID0geyB0eXBlOiBvcHQsIGRlZmF1bHQ6IGRlZmF1bHRzW2tleV0gfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdC5kZWZhdWx0ID0gZGVmYXVsdHNba2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wdCA9PT0gbnVsbCkge1xuICAgICAgb3B0ID0gcHJvcHNba2V5XSA9IHsgZGVmYXVsdDogZGVmYXVsdHNba2V5XSB9O1xuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybiQxKGBwcm9wcyBkZWZhdWx0IGtleSBcIiR7a2V5fVwiIGhhcyBubyBjb3JyZXNwb25kaW5nIGRlY2xhcmF0aW9uLmApO1xuICAgIH1cbiAgICBpZiAob3B0ICYmIGRlZmF1bHRzW2BfX3NraXBfJHtrZXl9YF0pIHtcbiAgICAgIG9wdC5za2lwRmFjdG9yeSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wcztcbn1cbmZ1bmN0aW9uIG1lcmdlTW9kZWxzKGEsIGIpIHtcbiAgaWYgKCFhIHx8ICFiKSByZXR1cm4gYSB8fCBiO1xuICBpZiAoaXNBcnJheShhKSAmJiBpc0FycmF5KGIpKSByZXR1cm4gYS5jb25jYXQoYik7XG4gIHJldHVybiBleHRlbmQoe30sIG5vcm1hbGl6ZVByb3BzT3JFbWl0cyhhKSwgbm9ybWFsaXplUHJvcHNPckVtaXRzKGIpKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb3BzUmVzdFByb3h5KHByb3BzLCBleGNsdWRlZEtleXMpIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgaWYgKCFleGNsdWRlZEtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJldCwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gcHJvcHNba2V5XVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiB3aXRoQXN5bmNDb250ZXh0KGdldEF3YWl0YWJsZSkge1xuICBjb25zdCBjdHggPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWN0eCkge1xuICAgIHdhcm4kMShcbiAgICAgIGB3aXRoQXN5bmNDb250ZXh0IGNhbGxlZCB3aXRob3V0IGFjdGl2ZSBjdXJyZW50IGluc3RhbmNlLiBUaGlzIGlzIGxpa2VseSBhIGJ1Zy5gXG4gICAgKTtcbiAgfVxuICBsZXQgYXdhaXRhYmxlID0gZ2V0QXdhaXRhYmxlKCk7XG4gIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGlmIChpc1Byb21pc2UoYXdhaXRhYmxlKSkge1xuICAgIGF3YWl0YWJsZSA9IGF3YWl0YWJsZS5jYXRjaCgoZSkgPT4ge1xuICAgICAgc2V0Q3VycmVudEluc3RhbmNlKGN0eCk7XG4gICAgICB0aHJvdyBlO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBbYXdhaXRhYmxlLCAoKSA9PiBzZXRDdXJyZW50SW5zdGFuY2UoY3R4KV07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUR1cGxpY2F0ZUNoZWNrZXIoKSB7XG4gIGNvbnN0IGNhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAodHlwZSwga2V5KSA9PiB7XG4gICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgIHdhcm4kMShgJHt0eXBlfSBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiAke2NhY2hlW2tleV19LmApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWNoZVtrZXldID0gdHlwZTtcbiAgICB9XG4gIH07XG59XG5sZXQgc2hvdWxkQ2FjaGVBY2Nlc3MgPSB0cnVlO1xuZnVuY3Rpb24gYXBwbHlPcHRpb25zKGluc3RhbmNlKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSk7XG4gIGNvbnN0IHB1YmxpY1RoaXMgPSBpbnN0YW5jZS5wcm94eTtcbiAgY29uc3QgY3R4ID0gaW5zdGFuY2UuY3R4O1xuICBzaG91bGRDYWNoZUFjY2VzcyA9IGZhbHNlO1xuICBpZiAob3B0aW9ucy5iZWZvcmVDcmVhdGUpIHtcbiAgICBjYWxsSG9vayhvcHRpb25zLmJlZm9yZUNyZWF0ZSwgaW5zdGFuY2UsIFwiYmNcIik7XG4gIH1cbiAgY29uc3Qge1xuICAgIC8vIHN0YXRlXG4gICAgZGF0YTogZGF0YU9wdGlvbnMsXG4gICAgY29tcHV0ZWQ6IGNvbXB1dGVkT3B0aW9ucyxcbiAgICBtZXRob2RzLFxuICAgIHdhdGNoOiB3YXRjaE9wdGlvbnMsXG4gICAgcHJvdmlkZTogcHJvdmlkZU9wdGlvbnMsXG4gICAgaW5qZWN0OiBpbmplY3RPcHRpb25zLFxuICAgIC8vIGxpZmVjeWNsZVxuICAgIGNyZWF0ZWQsXG4gICAgYmVmb3JlTW91bnQsXG4gICAgbW91bnRlZCxcbiAgICBiZWZvcmVVcGRhdGUsXG4gICAgdXBkYXRlZCxcbiAgICBhY3RpdmF0ZWQsXG4gICAgZGVhY3RpdmF0ZWQsXG4gICAgYmVmb3JlRGVzdHJveSxcbiAgICBiZWZvcmVVbm1vdW50LFxuICAgIGRlc3Ryb3llZCxcbiAgICB1bm1vdW50ZWQsXG4gICAgcmVuZGVyLFxuICAgIHJlbmRlclRyYWNrZWQsXG4gICAgcmVuZGVyVHJpZ2dlcmVkLFxuICAgIGVycm9yQ2FwdHVyZWQsXG4gICAgc2VydmVyUHJlZmV0Y2gsXG4gICAgLy8gcHVibGljIEFQSVxuICAgIGV4cG9zZSxcbiAgICBpbmhlcml0QXR0cnMsXG4gICAgLy8gYXNzZXRzXG4gICAgY29tcG9uZW50cyxcbiAgICBkaXJlY3RpdmVzLFxuICAgIGZpbHRlcnNcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBjcmVhdGVEdXBsaWNhdGVDaGVja2VyKCkgOiBudWxsO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IFtwcm9wc09wdGlvbnNdID0gaW5zdGFuY2UucHJvcHNPcHRpb25zO1xuICAgIGlmIChwcm9wc09wdGlvbnMpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzT3B0aW9ucykge1xuICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJQcm9wc1wiIC8qIFBST1BTICovLCBrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoaW5qZWN0T3B0aW9ucykge1xuICAgIHJlc29sdmVJbmplY3Rpb25zKGluamVjdE9wdGlvbnMsIGN0eCwgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKTtcbiAgfVxuICBpZiAobWV0aG9kcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGNvbnN0IG1ldGhvZEhhbmRsZXIgPSBtZXRob2RzW2tleV07XG4gICAgICBpZiAoaXNGdW5jdGlvbihtZXRob2RIYW5kbGVyKSkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IG1ldGhvZEhhbmRsZXIuYmluZChwdWJsaWNUaGlzKSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eFtrZXldID0gbWV0aG9kSGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiTWV0aG9kc1wiIC8qIE1FVEhPRFMgKi8sIGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYE1ldGhvZCBcIiR7a2V5fVwiIGhhcyB0eXBlIFwiJHt0eXBlb2YgbWV0aG9kSGFuZGxlcn1cIiBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIERpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoZGF0YU9wdGlvbnMpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNGdW5jdGlvbihkYXRhT3B0aW9ucykpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYFRoZSBkYXRhIG9wdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24uIFBsYWluIG9iamVjdCB1c2FnZSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBkYXRhT3B0aW9ucy5jYWxsKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzUHJvbWlzZShkYXRhKSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgZGF0YSgpIHJldHVybmVkIGEgUHJvbWlzZSAtIG5vdGUgZGF0YSgpIGNhbm5vdCBiZSBhc3luYzsgSWYgeW91IGludGVuZCB0byBwZXJmb3JtIGRhdGEgZmV0Y2hpbmcgYmVmb3JlIGNvbXBvbmVudCByZW5kZXJzLCB1c2UgYXN5bmMgc2V0dXAoKSArIDxTdXNwZW5zZT4uYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFpc09iamVjdChkYXRhKSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuJDEoYGRhdGEoKSBzaG91bGQgcmV0dXJuIGFuIG9iamVjdC5gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2UuZGF0YSA9IHJlYWN0aXZlKGRhdGEpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkRhdGFcIiAvKiBEQVRBICovLCBrZXkpO1xuICAgICAgICAgIGlmICghaXNSZXNlcnZlZFByZWZpeChrZXlbMF0pKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICBnZXQ6ICgpID0+IGRhdGFba2V5XSxcbiAgICAgICAgICAgICAgc2V0OiBOT09QXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2hvdWxkQ2FjaGVBY2Nlc3MgPSB0cnVlO1xuICBpZiAoY29tcHV0ZWRPcHRpb25zKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY29tcHV0ZWRPcHRpb25zKSB7XG4gICAgICBjb25zdCBvcHQgPSBjb21wdXRlZE9wdGlvbnNba2V5XTtcbiAgICAgIGNvbnN0IGdldCA9IGlzRnVuY3Rpb24ob3B0KSA/IG9wdC5iaW5kKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpIDogaXNGdW5jdGlvbihvcHQuZ2V0KSA/IG9wdC5nZXQuYmluZChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKSA6IE5PT1A7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBnZXQgPT09IE5PT1ApIHtcbiAgICAgICAgd2FybiQxKGBDb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGhhcyBubyBnZXR0ZXIuYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzZXQgPSAhaXNGdW5jdGlvbihvcHQpICYmIGlzRnVuY3Rpb24ob3B0LnNldCkgPyBvcHQuc2V0LmJpbmQocHVibGljVGhpcykgOiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gKCkgPT4ge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYFdyaXRlIG9wZXJhdGlvbiBmYWlsZWQ6IGNvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgaXMgcmVhZG9ubHkuYFxuICAgICAgICApO1xuICAgICAgfSA6IE5PT1A7XG4gICAgICBjb25zdCBjID0gY29tcHV0ZWQoe1xuICAgICAgICBnZXQsXG4gICAgICAgIHNldFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IGMudmFsdWUsXG4gICAgICAgIHNldDogKHYpID0+IGMudmFsdWUgPSB2XG4gICAgICB9KTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkNvbXB1dGVkXCIgLyogQ09NUFVURUQgKi8sIGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh3YXRjaE9wdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB3YXRjaE9wdGlvbnMpIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIod2F0Y2hPcHRpb25zW2tleV0sIGN0eCwgcHVibGljVGhpcywga2V5KTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb3ZpZGVPcHRpb25zKSB7XG4gICAgY29uc3QgcHJvdmlkZXMgPSBpc0Z1bmN0aW9uKHByb3ZpZGVPcHRpb25zKSA/IHByb3ZpZGVPcHRpb25zLmNhbGwocHVibGljVGhpcykgOiBwcm92aWRlT3B0aW9ucztcbiAgICBSZWZsZWN0Lm93bktleXMocHJvdmlkZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgcHJvdmlkZShrZXksIHByb3ZpZGVzW2tleV0pO1xuICAgIH0pO1xuICB9XG4gIGlmIChjcmVhdGVkKSB7XG4gICAgY2FsbEhvb2soY3JlYXRlZCwgaW5zdGFuY2UsIFwiY1wiKTtcbiAgfVxuICBmdW5jdGlvbiByZWdpc3RlckxpZmVjeWNsZUhvb2socmVnaXN0ZXIsIGhvb2spIHtcbiAgICBpZiAoaXNBcnJheShob29rKSkge1xuICAgICAgaG9vay5mb3JFYWNoKChfaG9vaykgPT4gcmVnaXN0ZXIoX2hvb2suYmluZChwdWJsaWNUaGlzKSkpO1xuICAgIH0gZWxzZSBpZiAoaG9vaykge1xuICAgICAgcmVnaXN0ZXIoaG9vay5iaW5kKHB1YmxpY1RoaXMpKTtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQmVmb3JlTW91bnQsIGJlZm9yZU1vdW50KTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uTW91bnRlZCwgbW91bnRlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkJlZm9yZVVwZGF0ZSwgYmVmb3JlVXBkYXRlKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uVXBkYXRlZCwgdXBkYXRlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkFjdGl2YXRlZCwgYWN0aXZhdGVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uRGVhY3RpdmF0ZWQsIGRlYWN0aXZhdGVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uRXJyb3JDYXB0dXJlZCwgZXJyb3JDYXB0dXJlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblJlbmRlclRyYWNrZWQsIHJlbmRlclRyYWNrZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25SZW5kZXJUcmlnZ2VyZWQsIHJlbmRlclRyaWdnZXJlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkJlZm9yZVVubW91bnQsIGJlZm9yZVVubW91bnQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25Vbm1vdW50ZWQsIHVubW91bnRlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblNlcnZlclByZWZldGNoLCBzZXJ2ZXJQcmVmZXRjaCk7XG4gIGlmIChpc0FycmF5KGV4cG9zZSkpIHtcbiAgICBpZiAoZXhwb3NlLmxlbmd0aCkge1xuICAgICAgY29uc3QgZXhwb3NlZCA9IGluc3RhbmNlLmV4cG9zZWQgfHwgKGluc3RhbmNlLmV4cG9zZWQgPSB7fSk7XG4gICAgICBleHBvc2UuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvc2VkLCBrZXksIHtcbiAgICAgICAgICBnZXQ6ICgpID0+IHB1YmxpY1RoaXNba2V5XSxcbiAgICAgICAgICBzZXQ6ICh2YWwpID0+IHB1YmxpY1RoaXNba2V5XSA9IHZhbFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIWluc3RhbmNlLmV4cG9zZWQpIHtcbiAgICAgIGluc3RhbmNlLmV4cG9zZWQgPSB7fTtcbiAgICB9XG4gIH1cbiAgaWYgKHJlbmRlciAmJiBpbnN0YW5jZS5yZW5kZXIgPT09IE5PT1ApIHtcbiAgICBpbnN0YW5jZS5yZW5kZXIgPSByZW5kZXI7XG4gIH1cbiAgaWYgKGluaGVyaXRBdHRycyAhPSBudWxsKSB7XG4gICAgaW5zdGFuY2UuaW5oZXJpdEF0dHJzID0gaW5oZXJpdEF0dHJzO1xuICB9XG4gIGlmIChjb21wb25lbnRzKSBpbnN0YW5jZS5jb21wb25lbnRzID0gY29tcG9uZW50cztcbiAgaWYgKGRpcmVjdGl2ZXMpIGluc3RhbmNlLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xuICBpZiAoc2VydmVyUHJlZmV0Y2gpIHtcbiAgICBtYXJrQXN5bmNCb3VuZGFyeShpbnN0YW5jZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVJbmplY3Rpb25zKGluamVjdE9wdGlvbnMsIGN0eCwgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzID0gTk9PUCkge1xuICBpZiAoaXNBcnJheShpbmplY3RPcHRpb25zKSkge1xuICAgIGluamVjdE9wdGlvbnMgPSBub3JtYWxpemVJbmplY3QoaW5qZWN0T3B0aW9ucyk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gaW5qZWN0T3B0aW9ucykge1xuICAgIGNvbnN0IG9wdCA9IGluamVjdE9wdGlvbnNba2V5XTtcbiAgICBsZXQgaW5qZWN0ZWQ7XG4gICAgaWYgKGlzT2JqZWN0KG9wdCkpIHtcbiAgICAgIGlmIChcImRlZmF1bHRcIiBpbiBvcHQpIHtcbiAgICAgICAgaW5qZWN0ZWQgPSBpbmplY3QoXG4gICAgICAgICAgb3B0LmZyb20gfHwga2V5LFxuICAgICAgICAgIG9wdC5kZWZhdWx0LFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluamVjdGVkID0gaW5qZWN0KG9wdC5mcm9tIHx8IGtleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGluamVjdGVkID0gaW5qZWN0KG9wdCk7XG4gICAgfVxuICAgIGlmIChpc1JlZihpbmplY3RlZCkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gaW5qZWN0ZWQudmFsdWUsXG4gICAgICAgIHNldDogKHYpID0+IGluamVjdGVkLnZhbHVlID0gdlxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eFtrZXldID0gaW5qZWN0ZWQ7XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJJbmplY3RcIiAvKiBJTkpFQ1QgKi8sIGtleSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjYWxsSG9vayhob29rLCBpbnN0YW5jZSwgdHlwZSkge1xuICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICBpc0FycmF5KGhvb2spID8gaG9vay5tYXAoKGgpID0+IGguYmluZChpbnN0YW5jZS5wcm94eSkpIDogaG9vay5iaW5kKGluc3RhbmNlLnByb3h5KSxcbiAgICBpbnN0YW5jZSxcbiAgICB0eXBlXG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyKHJhdywgY3R4LCBwdWJsaWNUaGlzLCBrZXkpIHtcbiAgbGV0IGdldHRlciA9IGtleS5pbmNsdWRlcyhcIi5cIikgPyBjcmVhdGVQYXRoR2V0dGVyKHB1YmxpY1RoaXMsIGtleSkgOiAoKSA9PiBwdWJsaWNUaGlzW2tleV07XG4gIGlmIChpc1N0cmluZyhyYXcpKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IGN0eFtyYXddO1xuICAgIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgICB7XG4gICAgICAgIHdhdGNoKGdldHRlciwgaGFuZGxlcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuJDEoYEludmFsaWQgd2F0Y2ggaGFuZGxlciBzcGVjaWZpZWQgYnkga2V5IFwiJHtyYXd9XCJgLCBoYW5kbGVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihyYXcpKSB7XG4gICAge1xuICAgICAgd2F0Y2goZ2V0dGVyLCByYXcuYmluZChwdWJsaWNUaGlzKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHJhdykpIHtcbiAgICBpZiAoaXNBcnJheShyYXcpKSB7XG4gICAgICByYXcuZm9yRWFjaCgocikgPT4gY3JlYXRlV2F0Y2hlcihyLCBjdHgsIHB1YmxpY1RoaXMsIGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gaXNGdW5jdGlvbihyYXcuaGFuZGxlcikgPyByYXcuaGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpIDogY3R4W3Jhdy5oYW5kbGVyXTtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgICAgIHdhdGNoKGdldHRlciwgaGFuZGxlciwgcmF3KTtcbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICB3YXJuJDEoYEludmFsaWQgd2F0Y2ggaGFuZGxlciBzcGVjaWZpZWQgYnkga2V5IFwiJHtyYXcuaGFuZGxlcn1cImAsIGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FybiQxKGBJbnZhbGlkIHdhdGNoIG9wdGlvbjogXCIke2tleX1cImAsIHJhdyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVNZXJnZWRPcHRpb25zKGluc3RhbmNlKSB7XG4gIGNvbnN0IGJhc2UgPSBpbnN0YW5jZS50eXBlO1xuICBjb25zdCB7IG1peGlucywgZXh0ZW5kczogZXh0ZW5kc09wdGlvbnMgfSA9IGJhc2U7XG4gIGNvbnN0IHtcbiAgICBtaXhpbnM6IGdsb2JhbE1peGlucyxcbiAgICBvcHRpb25zQ2FjaGU6IGNhY2hlLFxuICAgIGNvbmZpZzogeyBvcHRpb25NZXJnZVN0cmF0ZWdpZXMgfVxuICB9ID0gaW5zdGFuY2UuYXBwQ29udGV4dDtcbiAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGJhc2UpO1xuICBsZXQgcmVzb2x2ZWQ7XG4gIGlmIChjYWNoZWQpIHtcbiAgICByZXNvbHZlZCA9IGNhY2hlZDtcbiAgfSBlbHNlIGlmICghZ2xvYmFsTWl4aW5zLmxlbmd0aCAmJiAhbWl4aW5zICYmICFleHRlbmRzT3B0aW9ucykge1xuICAgIHtcbiAgICAgIHJlc29sdmVkID0gYmFzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzb2x2ZWQgPSB7fTtcbiAgICBpZiAoZ2xvYmFsTWl4aW5zLmxlbmd0aCkge1xuICAgICAgZ2xvYmFsTWl4aW5zLmZvckVhY2goXG4gICAgICAgIChtKSA9PiBtZXJnZU9wdGlvbnMocmVzb2x2ZWQsIG0sIG9wdGlvbk1lcmdlU3RyYXRlZ2llcywgdHJ1ZSlcbiAgICAgICk7XG4gICAgfVxuICAgIG1lcmdlT3B0aW9ucyhyZXNvbHZlZCwgYmFzZSwgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzKTtcbiAgfVxuICBpZiAoaXNPYmplY3QoYmFzZSkpIHtcbiAgICBjYWNoZS5zZXQoYmFzZSwgcmVzb2x2ZWQpO1xuICB9XG4gIHJldHVybiByZXNvbHZlZDtcbn1cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyh0bywgZnJvbSwgc3RyYXRzLCBhc01peGluID0gZmFsc2UpIHtcbiAgY29uc3QgeyBtaXhpbnMsIGV4dGVuZHM6IGV4dGVuZHNPcHRpb25zIH0gPSBmcm9tO1xuICBpZiAoZXh0ZW5kc09wdGlvbnMpIHtcbiAgICBtZXJnZU9wdGlvbnModG8sIGV4dGVuZHNPcHRpb25zLCBzdHJhdHMsIHRydWUpO1xuICB9XG4gIGlmIChtaXhpbnMpIHtcbiAgICBtaXhpbnMuZm9yRWFjaChcbiAgICAgIChtKSA9PiBtZXJnZU9wdGlvbnModG8sIG0sIHN0cmF0cywgdHJ1ZSlcbiAgICApO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGZyb20pIHtcbiAgICBpZiAoYXNNaXhpbiAmJiBrZXkgPT09IFwiZXhwb3NlXCIpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKFxuICAgICAgICBgXCJleHBvc2VcIiBvcHRpb24gaXMgaWdub3JlZCB3aGVuIGRlY2xhcmVkIGluIG1peGlucyBvciBleHRlbmRzLiBJdCBzaG91bGQgb25seSBiZSBkZWNsYXJlZCBpbiB0aGUgYmFzZSBjb21wb25lbnQgaXRzZWxmLmBcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0cmF0ID0gaW50ZXJuYWxPcHRpb25NZXJnZVN0cmF0c1trZXldIHx8IHN0cmF0cyAmJiBzdHJhdHNba2V5XTtcbiAgICAgIHRvW2tleV0gPSBzdHJhdCA/IHN0cmF0KHRvW2tleV0sIGZyb21ba2V5XSkgOiBmcm9tW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0bztcbn1cbmNvbnN0IGludGVybmFsT3B0aW9uTWVyZ2VTdHJhdHMgPSB7XG4gIGRhdGE6IG1lcmdlRGF0YUZuLFxuICBwcm9wczogbWVyZ2VFbWl0c09yUHJvcHNPcHRpb25zLFxuICBlbWl0czogbWVyZ2VFbWl0c09yUHJvcHNPcHRpb25zLFxuICAvLyBvYmplY3RzXG4gIG1ldGhvZHM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcbiAgY29tcHV0ZWQ6IG1lcmdlT2JqZWN0T3B0aW9ucyxcbiAgLy8gbGlmZWN5Y2xlXG4gIGJlZm9yZUNyZWF0ZTogbWVyZ2VBc0FycmF5LFxuICBjcmVhdGVkOiBtZXJnZUFzQXJyYXksXG4gIGJlZm9yZU1vdW50OiBtZXJnZUFzQXJyYXksXG4gIG1vdW50ZWQ6IG1lcmdlQXNBcnJheSxcbiAgYmVmb3JlVXBkYXRlOiBtZXJnZUFzQXJyYXksXG4gIHVwZGF0ZWQ6IG1lcmdlQXNBcnJheSxcbiAgYmVmb3JlRGVzdHJveTogbWVyZ2VBc0FycmF5LFxuICBiZWZvcmVVbm1vdW50OiBtZXJnZUFzQXJyYXksXG4gIGRlc3Ryb3llZDogbWVyZ2VBc0FycmF5LFxuICB1bm1vdW50ZWQ6IG1lcmdlQXNBcnJheSxcbiAgYWN0aXZhdGVkOiBtZXJnZUFzQXJyYXksXG4gIGRlYWN0aXZhdGVkOiBtZXJnZUFzQXJyYXksXG4gIGVycm9yQ2FwdHVyZWQ6IG1lcmdlQXNBcnJheSxcbiAgc2VydmVyUHJlZmV0Y2g6IG1lcmdlQXNBcnJheSxcbiAgLy8gYXNzZXRzXG4gIGNvbXBvbmVudHM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcbiAgZGlyZWN0aXZlczogbWVyZ2VPYmplY3RPcHRpb25zLFxuICAvLyB3YXRjaFxuICB3YXRjaDogbWVyZ2VXYXRjaE9wdGlvbnMsXG4gIC8vIHByb3ZpZGUgLyBpbmplY3RcbiAgcHJvdmlkZTogbWVyZ2VEYXRhRm4sXG4gIGluamVjdDogbWVyZ2VJbmplY3Rcbn07XG5mdW5jdGlvbiBtZXJnZURhdGFGbih0bywgZnJvbSkge1xuICBpZiAoIWZyb20pIHtcbiAgICByZXR1cm4gdG87XG4gIH1cbiAgaWYgKCF0bykge1xuICAgIHJldHVybiBmcm9tO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4oKSB7XG4gICAgcmV0dXJuIChleHRlbmQpKFxuICAgICAgaXNGdW5jdGlvbih0bykgPyB0by5jYWxsKHRoaXMsIHRoaXMpIDogdG8sXG4gICAgICBpc0Z1bmN0aW9uKGZyb20pID8gZnJvbS5jYWxsKHRoaXMsIHRoaXMpIDogZnJvbVxuICAgICk7XG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZUluamVjdCh0bywgZnJvbSkge1xuICByZXR1cm4gbWVyZ2VPYmplY3RPcHRpb25zKG5vcm1hbGl6ZUluamVjdCh0byksIG5vcm1hbGl6ZUluamVjdChmcm9tKSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QocmF3KSB7XG4gIGlmIChpc0FycmF5KHJhdykpIHtcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhdy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzW3Jhd1tpXV0gPSByYXdbaV07XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgcmV0dXJuIHJhdztcbn1cbmZ1bmN0aW9uIG1lcmdlQXNBcnJheSh0bywgZnJvbSkge1xuICByZXR1cm4gdG8gPyBbLi4ubmV3IFNldChbXS5jb25jYXQodG8sIGZyb20pKV0gOiBmcm9tO1xufVxuZnVuY3Rpb24gbWVyZ2VPYmplY3RPcHRpb25zKHRvLCBmcm9tKSB7XG4gIHJldHVybiB0byA/IGV4dGVuZCgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgdG8sIGZyb20pIDogZnJvbTtcbn1cbmZ1bmN0aW9uIG1lcmdlRW1pdHNPclByb3BzT3B0aW9ucyh0bywgZnJvbSkge1xuICBpZiAodG8pIHtcbiAgICBpZiAoaXNBcnJheSh0bykgJiYgaXNBcnJheShmcm9tKSkge1xuICAgICAgcmV0dXJuIFsuLi4vKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4udG8sIC4uLmZyb21dKV07XG4gICAgfVxuICAgIHJldHVybiBleHRlbmQoXG4gICAgICAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIG5vcm1hbGl6ZVByb3BzT3JFbWl0cyh0byksXG4gICAgICBub3JtYWxpemVQcm9wc09yRW1pdHMoZnJvbSAhPSBudWxsID8gZnJvbSA6IHt9KVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZyb207XG4gIH1cbn1cbmZ1bmN0aW9uIG1lcmdlV2F0Y2hPcHRpb25zKHRvLCBmcm9tKSB7XG4gIGlmICghdG8pIHJldHVybiBmcm9tO1xuICBpZiAoIWZyb20pIHJldHVybiB0bztcbiAgY29uc3QgbWVyZ2VkID0gZXh0ZW5kKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB0byk7XG4gIGZvciAoY29uc3Qga2V5IGluIGZyb20pIHtcbiAgICBtZXJnZWRba2V5XSA9IG1lcmdlQXNBcnJheSh0b1trZXldLCBmcm9tW2tleV0pO1xuICB9XG4gIHJldHVybiBtZXJnZWQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFwcENvbnRleHQoKSB7XG4gIHJldHVybiB7XG4gICAgYXBwOiBudWxsLFxuICAgIGNvbmZpZzoge1xuICAgICAgaXNOYXRpdmVUYWc6IE5PLFxuICAgICAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuICAgICAgZ2xvYmFsUHJvcGVydGllczoge30sXG4gICAgICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IHt9LFxuICAgICAgZXJyb3JIYW5kbGVyOiB2b2lkIDAsXG4gICAgICB3YXJuSGFuZGxlcjogdm9pZCAwLFxuICAgICAgY29tcGlsZXJPcHRpb25zOiB7fVxuICAgIH0sXG4gICAgbWl4aW5zOiBbXSxcbiAgICBjb21wb25lbnRzOiB7fSxcbiAgICBkaXJlY3RpdmVzOiB7fSxcbiAgICBwcm92aWRlczogLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgb3B0aW9uc0NhY2hlOiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSxcbiAgICBwcm9wc0NhY2hlOiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSxcbiAgICBlbWl0c0NhY2hlOiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKVxuICB9O1xufVxubGV0IHVpZCQxID0gMDtcbmZ1bmN0aW9uIGNyZWF0ZUFwcEFQSShyZW5kZXIsIGh5ZHJhdGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUFwcChyb290Q29tcG9uZW50LCByb290UHJvcHMgPSBudWxsKSB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKHJvb3RDb21wb25lbnQpKSB7XG4gICAgICByb290Q29tcG9uZW50ID0gZXh0ZW5kKHt9LCByb290Q29tcG9uZW50KTtcbiAgICB9XG4gICAgaWYgKHJvb3RQcm9wcyAhPSBudWxsICYmICFpc09iamVjdChyb290UHJvcHMpKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShgcm9vdCBwcm9wcyBwYXNzZWQgdG8gYXBwLm1vdW50KCkgbXVzdCBiZSBhbiBvYmplY3QuYCk7XG4gICAgICByb290UHJvcHMgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQXBwQ29udGV4dCgpO1xuICAgIGNvbnN0IGluc3RhbGxlZFBsdWdpbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbiAgICBjb25zdCBwbHVnaW5DbGVhbnVwRm5zID0gW107XG4gICAgbGV0IGlzTW91bnRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGFwcCA9IGNvbnRleHQuYXBwID0ge1xuICAgICAgX3VpZDogdWlkJDErKyxcbiAgICAgIF9jb21wb25lbnQ6IHJvb3RDb21wb25lbnQsXG4gICAgICBfcHJvcHM6IHJvb3RQcm9wcyxcbiAgICAgIF9jb250YWluZXI6IG51bGwsXG4gICAgICBfY29udGV4dDogY29udGV4dCxcbiAgICAgIF9pbnN0YW5jZTogbnVsbCxcbiAgICAgIHZlcnNpb24sXG4gICAgICBnZXQgY29uZmlnKCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5jb25maWc7XG4gICAgICB9LFxuICAgICAgc2V0IGNvbmZpZyh2KSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYGFwcC5jb25maWcgY2Fubm90IGJlIHJlcGxhY2VkLiBNb2RpZnkgaW5kaXZpZHVhbCBvcHRpb25zIGluc3RlYWQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2UocGx1Z2luLCAuLi5vcHRpb25zKSB7XG4gICAgICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmhhcyhwbHVnaW4pKSB7XG4gICAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuJDEoYFBsdWdpbiBoYXMgYWxyZWFkeSBiZWVuIGFwcGxpZWQgdG8gdGFyZ2V0IGFwcC5gKTtcbiAgICAgICAgfSBlbHNlIGlmIChwbHVnaW4gJiYgaXNGdW5jdGlvbihwbHVnaW4uaW5zdGFsbCkpIHtcbiAgICAgICAgICBpbnN0YWxsZWRQbHVnaW5zLmFkZChwbHVnaW4pO1xuICAgICAgICAgIHBsdWdpbi5pbnN0YWxsKGFwcCwgLi4ub3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihwbHVnaW4pKSB7XG4gICAgICAgICAgaW5zdGFsbGVkUGx1Z2lucy5hZGQocGx1Z2luKTtcbiAgICAgICAgICBwbHVnaW4oYXBwLCAuLi5vcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYEEgcGx1Z2luIG11c3QgZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0IHdpdGggYW4gXCJpbnN0YWxsXCIgZnVuY3Rpb24uYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgIH0sXG4gICAgICBtaXhpbihtaXhpbikge1xuICAgICAgICBpZiAoX19WVUVfT1BUSU9OU19BUElfXykge1xuICAgICAgICAgIGlmICghY29udGV4dC5taXhpbnMuaW5jbHVkZXMobWl4aW4pKSB7XG4gICAgICAgICAgICBjb250ZXh0Lm1peGlucy5wdXNoKG1peGluKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgICAgXCJNaXhpbiBoYXMgYWxyZWFkeSBiZWVuIGFwcGxpZWQgdG8gdGFyZ2V0IGFwcFwiICsgKG1peGluLm5hbWUgPyBgOiAke21peGluLm5hbWV9YCA6IFwiXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybiQxKFwiTWl4aW5zIGFyZSBvbmx5IGF2YWlsYWJsZSBpbiBidWlsZHMgc3VwcG9ydGluZyBPcHRpb25zIEFQSVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwO1xuICAgICAgfSxcbiAgICAgIGNvbXBvbmVudChuYW1lLCBjb21wb25lbnQpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSwgY29udGV4dC5jb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjb250ZXh0LmNvbXBvbmVudHNbbmFtZV0pIHtcbiAgICAgICAgICB3YXJuJDEoYENvbXBvbmVudCBcIiR7bmFtZX1cIiBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgaW4gdGFyZ2V0IGFwcC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmNvbXBvbmVudHNbbmFtZV0gPSBjb21wb25lbnQ7XG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgICB9LFxuICAgICAgZGlyZWN0aXZlKG5hbWUsIGRpcmVjdGl2ZSkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRpcmVjdGl2ZSkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY29udGV4dC5kaXJlY3RpdmVzW25hbWVdKSB7XG4gICAgICAgICAgd2FybiQxKGBEaXJlY3RpdmUgXCIke25hbWV9XCIgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIGluIHRhcmdldCBhcHAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5kaXJlY3RpdmVzW25hbWVdID0gZGlyZWN0aXZlO1xuICAgICAgICByZXR1cm4gYXBwO1xuICAgICAgfSxcbiAgICAgIG1vdW50KHJvb3RDb250YWluZXIsIGlzSHlkcmF0ZSwgbmFtZXNwYWNlKSB7XG4gICAgICAgIGlmICghaXNNb3VudGVkKSB7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgcm9vdENvbnRhaW5lci5fX3Z1ZV9hcHBfXykge1xuICAgICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgICBgVGhlcmUgaXMgYWxyZWFkeSBhbiBhcHAgaW5zdGFuY2UgbW91bnRlZCBvbiB0aGUgaG9zdCBjb250YWluZXIuXG4gSWYgeW91IHdhbnQgdG8gbW91bnQgYW5vdGhlciBhcHAgb24gdGhlIHNhbWUgaG9zdCBjb250YWluZXIsIHlvdSBuZWVkIHRvIHVubW91bnQgdGhlIHByZXZpb3VzIGFwcCBieSBjYWxsaW5nIFxcYGFwcC51bm1vdW50KClcXGAgZmlyc3QuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgdm5vZGUgPSBhcHAuX2NlVk5vZGUgfHwgY3JlYXRlVk5vZGUocm9vdENvbXBvbmVudCwgcm9vdFByb3BzKTtcbiAgICAgICAgICB2bm9kZS5hcHBDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICBpZiAobmFtZXNwYWNlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBuYW1lc3BhY2UgPSBcInN2Z1wiO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmFtZXNwYWNlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgbmFtZXNwYWNlID0gdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgY29udGV4dC5yZWxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIHJlbmRlcihcbiAgICAgICAgICAgICAgICBjbG9uZVZOb2RlKHZub2RlKSxcbiAgICAgICAgICAgICAgICByb290Q29udGFpbmVyLFxuICAgICAgICAgICAgICAgIG5hbWVzcGFjZVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzSHlkcmF0ZSAmJiBoeWRyYXRlKSB7XG4gICAgICAgICAgICBoeWRyYXRlKHZub2RlLCByb290Q29udGFpbmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVuZGVyKHZub2RlLCByb290Q29udGFpbmVyLCBuYW1lc3BhY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICAgIGFwcC5fY29udGFpbmVyID0gcm9vdENvbnRhaW5lcjtcbiAgICAgICAgICByb290Q29udGFpbmVyLl9fdnVlX2FwcF9fID0gYXBwO1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgICAgYXBwLl9pbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudDtcbiAgICAgICAgICAgIGRldnRvb2xzSW5pdEFwcChhcHAsIHZlcnNpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50UHVibGljSW5zdGFuY2Uodm5vZGUuY29tcG9uZW50KTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYEFwcCBoYXMgYWxyZWFkeSBiZWVuIG1vdW50ZWQuXG5JZiB5b3Ugd2FudCB0byByZW1vdW50IHRoZSBzYW1lIGFwcCwgbW92ZSB5b3VyIGFwcCBjcmVhdGlvbiBsb2dpYyBpbnRvIGEgZmFjdG9yeSBmdW5jdGlvbiBhbmQgY3JlYXRlIGZyZXNoIGFwcCBpbnN0YW5jZXMgZm9yIGVhY2ggbW91bnQgLSBlLmcuIFxcYGNvbnN0IGNyZWF0ZU15QXBwID0gKCkgPT4gY3JlYXRlQXBwKEFwcClcXGBgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uVW5tb3VudChjbGVhbnVwRm4pIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdHlwZW9mIGNsZWFudXBGbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYEV4cGVjdGVkIGZ1bmN0aW9uIGFzIGZpcnN0IGFyZ3VtZW50IHRvIGFwcC5vblVubW91bnQoKSwgYnV0IGdvdCAke3R5cGVvZiBjbGVhbnVwRm59YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcGx1Z2luQ2xlYW51cEZucy5wdXNoKGNsZWFudXBGbik7XG4gICAgICB9LFxuICAgICAgdW5tb3VudCgpIHtcbiAgICAgICAgaWYgKGlzTW91bnRlZCkge1xuICAgICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgICAgICAgICAgcGx1Z2luQ2xlYW51cEZucyxcbiAgICAgICAgICAgIGFwcC5faW5zdGFuY2UsXG4gICAgICAgICAgICAxNlxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVuZGVyKG51bGwsIGFwcC5fY29udGFpbmVyKTtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICAgIGFwcC5faW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgICAgZGV2dG9vbHNVbm1vdW50QXBwKGFwcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSBhcHAuX2NvbnRhaW5lci5fX3Z1ZV9hcHBfXztcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybiQxKGBDYW5ub3QgdW5tb3VudCBhbiBhcHAgdGhhdCBpcyBub3QgbW91bnRlZC5gKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByb3ZpZGUoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBrZXkgaW4gY29udGV4dC5wcm92aWRlcykge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBBcHAgYWxyZWFkeSBwcm92aWRlcyBwcm9wZXJ0eSB3aXRoIGtleSBcIiR7U3RyaW5nKGtleSl9XCIuIEl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gd2l0aCB0aGUgbmV3IHZhbHVlLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQucHJvdmlkZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gYXBwO1xuICAgICAgfSxcbiAgICAgIHJ1bldpdGhDb250ZXh0KGZuKSB7XG4gICAgICAgIGNvbnN0IGxhc3RBcHAgPSBjdXJyZW50QXBwO1xuICAgICAgICBjdXJyZW50QXBwID0gYXBwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGN1cnJlbnRBcHAgPSBsYXN0QXBwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gYXBwO1xuICB9O1xufVxubGV0IGN1cnJlbnRBcHAgPSBudWxsO1xuXG5mdW5jdGlvbiBwcm92aWRlKGtleSwgdmFsdWUpIHtcbiAgaWYgKCFjdXJyZW50SW5zdGFuY2UpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybiQxKGBwcm92aWRlKCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgc2V0dXAoKS5gKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IHByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnByb3ZpZGVzO1xuICAgIGNvbnN0IHBhcmVudFByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnBhcmVudCAmJiBjdXJyZW50SW5zdGFuY2UucGFyZW50LnByb3ZpZGVzO1xuICAgIGlmIChwYXJlbnRQcm92aWRlcyA9PT0gcHJvdmlkZXMpIHtcbiAgICAgIHByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnByb3ZpZGVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRQcm92aWRlcyk7XG4gICAgfVxuICAgIHByb3ZpZGVzW2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gaW5qZWN0KGtleSwgZGVmYXVsdFZhbHVlLCB0cmVhdERlZmF1bHRBc0ZhY3RvcnkgPSBmYWxzZSkge1xuICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG4gIGlmIChpbnN0YW5jZSB8fCBjdXJyZW50QXBwKSB7XG4gICAgY29uc3QgcHJvdmlkZXMgPSBjdXJyZW50QXBwID8gY3VycmVudEFwcC5fY29udGV4dC5wcm92aWRlcyA6IGluc3RhbmNlID8gaW5zdGFuY2UucGFyZW50ID09IG51bGwgPyBpbnN0YW5jZS52bm9kZS5hcHBDb250ZXh0ICYmIGluc3RhbmNlLnZub2RlLmFwcENvbnRleHQucHJvdmlkZXMgOiBpbnN0YW5jZS5wYXJlbnQucHJvdmlkZXMgOiB2b2lkIDA7XG4gICAgaWYgKHByb3ZpZGVzICYmIGtleSBpbiBwcm92aWRlcykge1xuICAgICAgcmV0dXJuIHByb3ZpZGVzW2tleV07XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSAmJiBpc0Z1bmN0aW9uKGRlZmF1bHRWYWx1ZSkgPyBkZWZhdWx0VmFsdWUuY2FsbChpbnN0YW5jZSAmJiBpbnN0YW5jZS5wcm94eSkgOiBkZWZhdWx0VmFsdWU7XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuJDEoYGluamVjdGlvbiBcIiR7U3RyaW5nKGtleSl9XCIgbm90IGZvdW5kLmApO1xuICAgIH1cbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FybiQxKGBpbmplY3QoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpIG9yIGZ1bmN0aW9uYWwgY29tcG9uZW50cy5gKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFzSW5qZWN0aW9uQ29udGV4dCgpIHtcbiAgcmV0dXJuICEhKGN1cnJlbnRJbnN0YW5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgfHwgY3VycmVudEFwcCk7XG59XG5cbmNvbnN0IGludGVybmFsT2JqZWN0UHJvdG8gPSB7fTtcbmNvbnN0IGNyZWF0ZUludGVybmFsT2JqZWN0ID0gKCkgPT4gT2JqZWN0LmNyZWF0ZShpbnRlcm5hbE9iamVjdFByb3RvKTtcbmNvbnN0IGlzSW50ZXJuYWxPYmplY3QgPSAob2JqKSA9PiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gaW50ZXJuYWxPYmplY3RQcm90bztcblxuZnVuY3Rpb24gaW5pdFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgaXNTdGF0ZWZ1bCwgaXNTU1IgPSBmYWxzZSkge1xuICBjb25zdCBwcm9wcyA9IHt9O1xuICBjb25zdCBhdHRycyA9IGNyZWF0ZUludGVybmFsT2JqZWN0KCk7XG4gIGluc3RhbmNlLnByb3BzRGVmYXVsdHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdKSB7XG4gICAgaWYgKCEoa2V5IGluIHByb3BzKSkge1xuICAgICAgcHJvcHNba2V5XSA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB2YWxpZGF0ZVByb3BzKHJhd1Byb3BzIHx8IHt9LCBwcm9wcywgaW5zdGFuY2UpO1xuICB9XG4gIGlmIChpc1N0YXRlZnVsKSB7XG4gICAgaW5zdGFuY2UucHJvcHMgPSBpc1NTUiA/IHByb3BzIDogc2hhbGxvd1JlYWN0aXZlKHByb3BzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWluc3RhbmNlLnR5cGUucHJvcHMpIHtcbiAgICAgIGluc3RhbmNlLnByb3BzID0gYXR0cnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlLnByb3BzID0gcHJvcHM7XG4gICAgfVxuICB9XG4gIGluc3RhbmNlLmF0dHJzID0gYXR0cnM7XG59XG5mdW5jdGlvbiBpc0luSG1yQ29udGV4dChpbnN0YW5jZSkge1xuICB3aGlsZSAoaW5zdGFuY2UpIHtcbiAgICBpZiAoaW5zdGFuY2UudHlwZS5fX2htcklkKSByZXR1cm4gdHJ1ZTtcbiAgICBpbnN0YW5jZSA9IGluc3RhbmNlLnBhcmVudDtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCByYXdQcmV2UHJvcHMsIG9wdGltaXplZCkge1xuICBjb25zdCB7XG4gICAgcHJvcHMsXG4gICAgYXR0cnMsXG4gICAgdm5vZGU6IHsgcGF0Y2hGbGFnIH1cbiAgfSA9IGluc3RhbmNlO1xuICBjb25zdCByYXdDdXJyZW50UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XG4gIGNvbnN0IFtvcHRpb25zXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcbiAgbGV0IGhhc0F0dHJzQ2hhbmdlZCA9IGZhbHNlO1xuICBpZiAoXG4gICAgLy8gYWx3YXlzIGZvcmNlIGZ1bGwgZGlmZiBpbiBkZXZcbiAgICAvLyAtICMxOTQyIGlmIGhtciBpcyBlbmFibGVkIHdpdGggc2ZjIGNvbXBvbmVudFxuICAgIC8vIC0gdml0ZSM4NzIgbm9uLXNmYyBjb21wb25lbnQgdXNlZCBieSBzZmMgY29tcG9uZW50XG4gICAgISghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSW5IbXJDb250ZXh0KGluc3RhbmNlKSkgJiYgKG9wdGltaXplZCB8fCBwYXRjaEZsYWcgPiAwKSAmJiAhKHBhdGNoRmxhZyAmIDE2KVxuICApIHtcbiAgICBpZiAocGF0Y2hGbGFnICYgOCkge1xuICAgICAgY29uc3QgcHJvcHNUb1VwZGF0ZSA9IGluc3RhbmNlLnZub2RlLmR5bmFtaWNQcm9wcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNUb1VwZGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQga2V5ID0gcHJvcHNUb1VwZGF0ZVtpXTtcbiAgICAgICAgaWYgKGlzRW1pdExpc3RlbmVyKGluc3RhbmNlLmVtaXRzT3B0aW9ucywga2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcmF3UHJvcHNba2V5XTtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoaGFzT3duKGF0dHJzLCBrZXkpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IGF0dHJzW2tleV0pIHtcbiAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjYW1lbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgICAgICAgcHJvcHNbY2FtZWxpemVkS2V5XSA9IHJlc29sdmVQcm9wVmFsdWUoXG4gICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgIHJhd0N1cnJlbnRQcm9wcyxcbiAgICAgICAgICAgICAgY2FtZWxpemVkS2V5LFxuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IGF0dHJzW2tleV0pIHtcbiAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChzZXRGdWxsUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBwcm9wcywgYXR0cnMpKSB7XG4gICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICBsZXQga2ViYWJLZXk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmF3Q3VycmVudFByb3BzKSB7XG4gICAgICBpZiAoIXJhd1Byb3BzIHx8IC8vIGZvciBjYW1lbENhc2VcbiAgICAgICFoYXNPd24ocmF3UHJvcHMsIGtleSkgJiYgLy8gaXQncyBwb3NzaWJsZSB0aGUgb3JpZ2luYWwgcHJvcHMgd2FzIHBhc3NlZCBpbiBhcyBrZWJhYi1jYXNlXG4gICAgICAvLyBhbmQgY29udmVydGVkIHRvIGNhbWVsQ2FzZSAoIzk1NSlcbiAgICAgICgoa2ViYWJLZXkgPSBoeXBoZW5hdGUoa2V5KSkgPT09IGtleSB8fCAhaGFzT3duKHJhd1Byb3BzLCBrZWJhYktleSkpKSB7XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKHJhd1ByZXZQcm9wcyAmJiAvLyBmb3IgY2FtZWxDYXNlXG4gICAgICAgICAgKHJhd1ByZXZQcm9wc1trZXldICE9PSB2b2lkIDAgfHwgLy8gZm9yIGtlYmFiLWNhc2VcbiAgICAgICAgICByYXdQcmV2UHJvcHNba2ViYWJLZXldICE9PSB2b2lkIDApKSB7XG4gICAgICAgICAgICBwcm9wc1trZXldID0gcmVzb2x2ZVByb3BWYWx1ZShcbiAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgcmF3Q3VycmVudFByb3BzLFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBwcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhdHRycyAhPT0gcmF3Q3VycmVudFByb3BzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgICAgICBpZiAoIXJhd1Byb3BzIHx8ICFoYXNPd24ocmF3UHJvcHMsIGtleSkgJiYgdHJ1ZSkge1xuICAgICAgICAgIGRlbGV0ZSBhdHRyc1trZXldO1xuICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGhhc0F0dHJzQ2hhbmdlZCkge1xuICAgIHRyaWdnZXIoaW5zdGFuY2UuYXR0cnMsIFwic2V0XCIsIFwiXCIpO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgdmFsaWRhdGVQcm9wcyhyYXdQcm9wcyB8fCB7fSwgcHJvcHMsIGluc3RhbmNlKTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKSB7XG4gIGNvbnN0IFtvcHRpb25zLCBuZWVkQ2FzdEtleXNdID0gaW5zdGFuY2UucHJvcHNPcHRpb25zO1xuICBsZXQgaGFzQXR0cnNDaGFuZ2VkID0gZmFsc2U7XG4gIGxldCByYXdDYXN0VmFsdWVzO1xuICBpZiAocmF3UHJvcHMpIHtcbiAgICBmb3IgKGxldCBrZXkgaW4gcmF3UHJvcHMpIHtcbiAgICAgIGlmIChpc1Jlc2VydmVkUHJvcChrZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSByYXdQcm9wc1trZXldO1xuICAgICAgbGV0IGNhbWVsS2V5O1xuICAgICAgaWYgKG9wdGlvbnMgJiYgaGFzT3duKG9wdGlvbnMsIGNhbWVsS2V5ID0gY2FtZWxpemUoa2V5KSkpIHtcbiAgICAgICAgaWYgKCFuZWVkQ2FzdEtleXMgfHwgIW5lZWRDYXN0S2V5cy5pbmNsdWRlcyhjYW1lbEtleSkpIHtcbiAgICAgICAgICBwcm9wc1tjYW1lbEtleV0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAocmF3Q2FzdFZhbHVlcyB8fCAocmF3Q2FzdFZhbHVlcyA9IHt9KSlbY2FtZWxLZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWlzRW1pdExpc3RlbmVyKGluc3RhbmNlLmVtaXRzT3B0aW9ucywga2V5KSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gYXR0cnMpIHx8IHZhbHVlICE9PSBhdHRyc1trZXldKSB7XG4gICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG5lZWRDYXN0S2V5cykge1xuICAgIGNvbnN0IHJhd0N1cnJlbnRQcm9wcyA9IHRvUmF3KHByb3BzKTtcbiAgICBjb25zdCBjYXN0VmFsdWVzID0gcmF3Q2FzdFZhbHVlcyB8fCBFTVBUWV9PQko7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZWVkQ2FzdEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IG5lZWRDYXN0S2V5c1tpXTtcbiAgICAgIHByb3BzW2tleV0gPSByZXNvbHZlUHJvcFZhbHVlKFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICByYXdDdXJyZW50UHJvcHMsXG4gICAgICAgIGtleSxcbiAgICAgICAgY2FzdFZhbHVlc1trZXldLFxuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgIWhhc093bihjYXN0VmFsdWVzLCBrZXkpXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaGFzQXR0cnNDaGFuZ2VkO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVByb3BWYWx1ZShvcHRpb25zLCBwcm9wcywga2V5LCB2YWx1ZSwgaW5zdGFuY2UsIGlzQWJzZW50KSB7XG4gIGNvbnN0IG9wdCA9IG9wdGlvbnNba2V5XTtcbiAgaWYgKG9wdCAhPSBudWxsKSB7XG4gICAgY29uc3QgaGFzRGVmYXVsdCA9IGhhc093bihvcHQsIFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoaGFzRGVmYXVsdCAmJiB2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBvcHQuZGVmYXVsdDtcbiAgICAgIGlmIChvcHQudHlwZSAhPT0gRnVuY3Rpb24gJiYgIW9wdC5za2lwRmFjdG9yeSAmJiBpc0Z1bmN0aW9uKGRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wc0RlZmF1bHRzIH0gPSBpbnN0YW5jZTtcbiAgICAgICAgaWYgKGtleSBpbiBwcm9wc0RlZmF1bHRzKSB7XG4gICAgICAgICAgdmFsdWUgPSBwcm9wc0RlZmF1bHRzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcmVzZXQgPSBzZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICAgIHZhbHVlID0gcHJvcHNEZWZhdWx0c1trZXldID0gZGVmYXVsdFZhbHVlLmNhbGwoXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcHJvcHNcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGluc3RhbmNlLmNlKSB7XG4gICAgICAgIGluc3RhbmNlLmNlLl9zZXRQcm9wKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0WzAgLyogc2hvdWxkQ2FzdCAqL10pIHtcbiAgICAgIGlmIChpc0Fic2VudCAmJiAhaGFzRGVmYXVsdCkge1xuICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChvcHRbMSAvKiBzaG91bGRDYXN0VHJ1ZSAqL10gJiYgKHZhbHVlID09PSBcIlwiIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkpIHtcbiAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5jb25zdCBtaXhpblByb3BzQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzT3B0aW9ucyhjb21wLCBhcHBDb250ZXh0LCBhc01peGluID0gZmFsc2UpIHtcbiAgY29uc3QgY2FjaGUgPSBfX1ZVRV9PUFRJT05TX0FQSV9fICYmIGFzTWl4aW4gPyBtaXhpblByb3BzQ2FjaGUgOiBhcHBDb250ZXh0LnByb3BzQ2FjaGU7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChjb21wKTtcbiAgaWYgKGNhY2hlZCkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbiAgY29uc3QgcmF3ID0gY29tcC5wcm9wcztcbiAgY29uc3Qgbm9ybWFsaXplZCA9IHt9O1xuICBjb25zdCBuZWVkQ2FzdEtleXMgPSBbXTtcbiAgbGV0IGhhc0V4dGVuZHMgPSBmYWxzZTtcbiAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgIWlzRnVuY3Rpb24oY29tcCkpIHtcbiAgICBjb25zdCBleHRlbmRQcm9wcyA9IChyYXcyKSA9PiB7XG4gICAgICBoYXNFeHRlbmRzID0gdHJ1ZTtcbiAgICAgIGNvbnN0IFtwcm9wcywga2V5c10gPSBub3JtYWxpemVQcm9wc09wdGlvbnMocmF3MiwgYXBwQ29udGV4dCwgdHJ1ZSk7XG4gICAgICBleHRlbmQobm9ybWFsaXplZCwgcHJvcHMpO1xuICAgICAgaWYgKGtleXMpIG5lZWRDYXN0S2V5cy5wdXNoKC4uLmtleXMpO1xuICAgIH07XG4gICAgaWYgKCFhc01peGluICYmIGFwcENvbnRleHQubWl4aW5zLmxlbmd0aCkge1xuICAgICAgYXBwQ29udGV4dC5taXhpbnMuZm9yRWFjaChleHRlbmRQcm9wcyk7XG4gICAgfVxuICAgIGlmIChjb21wLmV4dGVuZHMpIHtcbiAgICAgIGV4dGVuZFByb3BzKGNvbXAuZXh0ZW5kcyk7XG4gICAgfVxuICAgIGlmIChjb21wLm1peGlucykge1xuICAgICAgY29tcC5taXhpbnMuZm9yRWFjaChleHRlbmRQcm9wcyk7XG4gICAgfVxuICB9XG4gIGlmICghcmF3ICYmICFoYXNFeHRlbmRzKSB7XG4gICAgaWYgKGlzT2JqZWN0KGNvbXApKSB7XG4gICAgICBjYWNoZS5zZXQoY29tcCwgRU1QVFlfQVJSKTtcbiAgICB9XG4gICAgcmV0dXJuIEVNUFRZX0FSUjtcbiAgfVxuICBpZiAoaXNBcnJheShyYXcpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc1N0cmluZyhyYXdbaV0pKSB7XG4gICAgICAgIHdhcm4kMShgcHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LmAsIHJhd1tpXSk7XG4gICAgICB9XG4gICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0gY2FtZWxpemUocmF3W2ldKTtcbiAgICAgIGlmICh2YWxpZGF0ZVByb3BOYW1lKG5vcm1hbGl6ZWRLZXkpKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRbbm9ybWFsaXplZEtleV0gPSBFTVBUWV9PQko7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHJhdykge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc09iamVjdChyYXcpKSB7XG4gICAgICB3YXJuJDEoYGludmFsaWQgcHJvcHMgb3B0aW9uc2AsIHJhdyk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHJhdykge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XG4gICAgICBpZiAodmFsaWRhdGVQcm9wTmFtZShub3JtYWxpemVkS2V5KSkge1xuICAgICAgICBjb25zdCBvcHQgPSByYXdba2V5XTtcbiAgICAgICAgY29uc3QgcHJvcCA9IG5vcm1hbGl6ZWRbbm9ybWFsaXplZEtleV0gPSBpc0FycmF5KG9wdCkgfHwgaXNGdW5jdGlvbihvcHQpID8geyB0eXBlOiBvcHQgfSA6IGV4dGVuZCh7fSwgb3B0KTtcbiAgICAgICAgY29uc3QgcHJvcFR5cGUgPSBwcm9wLnR5cGU7XG4gICAgICAgIGxldCBzaG91bGRDYXN0ID0gZmFsc2U7XG4gICAgICAgIGxldCBzaG91bGRDYXN0VHJ1ZSA9IHRydWU7XG4gICAgICAgIGlmIChpc0FycmF5KHByb3BUeXBlKSkge1xuICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwcm9wVHlwZS5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBwcm9wVHlwZVtpbmRleF07XG4gICAgICAgICAgICBjb25zdCB0eXBlTmFtZSA9IGlzRnVuY3Rpb24odHlwZSkgJiYgdHlwZS5uYW1lO1xuICAgICAgICAgICAgaWYgKHR5cGVOYW1lID09PSBcIkJvb2xlYW5cIikge1xuICAgICAgICAgICAgICBzaG91bGRDYXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVOYW1lID09PSBcIlN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIHNob3VsZENhc3RUcnVlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNob3VsZENhc3QgPSBpc0Z1bmN0aW9uKHByb3BUeXBlKSAmJiBwcm9wVHlwZS5uYW1lID09PSBcIkJvb2xlYW5cIjtcbiAgICAgICAgfVxuICAgICAgICBwcm9wWzAgLyogc2hvdWxkQ2FzdCAqL10gPSBzaG91bGRDYXN0O1xuICAgICAgICBwcm9wWzEgLyogc2hvdWxkQ2FzdFRydWUgKi9dID0gc2hvdWxkQ2FzdFRydWU7XG4gICAgICAgIGlmIChzaG91bGRDYXN0IHx8IGhhc093bihwcm9wLCBcImRlZmF1bHRcIikpIHtcbiAgICAgICAgICBuZWVkQ2FzdEtleXMucHVzaChub3JtYWxpemVkS2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCByZXMgPSBbbm9ybWFsaXplZCwgbmVlZENhc3RLZXlzXTtcbiAgaWYgKGlzT2JqZWN0KGNvbXApKSB7XG4gICAgY2FjaGUuc2V0KGNvbXAsIHJlcyk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcE5hbWUoa2V5KSB7XG4gIGlmIChrZXlbMF0gIT09IFwiJFwiICYmICFpc1Jlc2VydmVkUHJvcChrZXkpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4kMShgSW52YWxpZCBwcm9wIG5hbWU6IFwiJHtrZXl9XCIgaXMgYSByZXNlcnZlZCBwcm9wZXJ0eS5gKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRUeXBlKGN0b3IpIHtcbiAgaWYgKGN0b3IgPT09IG51bGwpIHtcbiAgICByZXR1cm4gXCJudWxsXCI7XG4gIH1cbiAgaWYgKHR5cGVvZiBjdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gY3Rvci5uYW1lIHx8IFwiXCI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGN0b3IgPT09IFwib2JqZWN0XCIpIHtcbiAgICBjb25zdCBuYW1lID0gY3Rvci5jb25zdHJ1Y3RvciAmJiBjdG9yLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgcmV0dXJuIG5hbWUgfHwgXCJcIjtcbiAgfVxuICByZXR1cm4gXCJcIjtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcHMocmF3UHJvcHMsIHByb3BzLCBpbnN0YW5jZSkge1xuICBjb25zdCByZXNvbHZlZFZhbHVlcyA9IHRvUmF3KHByb3BzKTtcbiAgY29uc3Qgb3B0aW9ucyA9IGluc3RhbmNlLnByb3BzT3B0aW9uc1swXTtcbiAgY29uc3QgY2FtZWxpemVQcm9wc0tleSA9IE9iamVjdC5rZXlzKHJhd1Byb3BzKS5tYXAoKGtleSkgPT4gY2FtZWxpemUoa2V5KSk7XG4gIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMpIHtcbiAgICBsZXQgb3B0ID0gb3B0aW9uc1trZXldO1xuICAgIGlmIChvcHQgPT0gbnVsbCkgY29udGludWU7XG4gICAgdmFsaWRhdGVQcm9wKFxuICAgICAga2V5LFxuICAgICAgcmVzb2x2ZWRWYWx1ZXNba2V5XSxcbiAgICAgIG9wdCxcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkocmVzb2x2ZWRWYWx1ZXMpIDogcmVzb2x2ZWRWYWx1ZXMsXG4gICAgICAhY2FtZWxpemVQcm9wc0tleS5pbmNsdWRlcyhrZXkpXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wKG5hbWUsIHZhbHVlLCBwcm9wLCBwcm9wcywgaXNBYnNlbnQpIHtcbiAgY29uc3QgeyB0eXBlLCByZXF1aXJlZCwgdmFsaWRhdG9yLCBza2lwQ2hlY2sgfSA9IHByb3A7XG4gIGlmIChyZXF1aXJlZCAmJiBpc0Fic2VudCkge1xuICAgIHdhcm4kMSgnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFyZXF1aXJlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZSAhPSBudWxsICYmIHR5cGUgIT09IHRydWUgJiYgIXNraXBDaGVjaykge1xuICAgIGxldCBpc1ZhbGlkID0gZmFsc2U7XG4gICAgY29uc3QgdHlwZXMgPSBpc0FycmF5KHR5cGUpID8gdHlwZSA6IFt0eXBlXTtcbiAgICBjb25zdCBleHBlY3RlZFR5cGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGggJiYgIWlzVmFsaWQ7IGkrKykge1xuICAgICAgY29uc3QgeyB2YWxpZCwgZXhwZWN0ZWRUeXBlIH0gPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlc1tpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goZXhwZWN0ZWRUeXBlIHx8IFwiXCIpO1xuICAgICAgaXNWYWxpZCA9IHZhbGlkO1xuICAgIH1cbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIHdhcm4kMShnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgaWYgKHZhbGlkYXRvciAmJiAhdmFsaWRhdG9yKHZhbHVlLCBwcm9wcykpIHtcbiAgICB3YXJuJDEoJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nKTtcbiAgfVxufVxuY29uc3QgaXNTaW1wbGVUeXBlID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIFwiU3RyaW5nLE51bWJlcixCb29sZWFuLEZ1bmN0aW9uLFN5bWJvbCxCaWdJbnRcIlxuKTtcbmZ1bmN0aW9uIGFzc2VydFR5cGUodmFsdWUsIHR5cGUpIHtcbiAgbGV0IHZhbGlkO1xuICBjb25zdCBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBcIm51bGxcIikge1xuICAgIHZhbGlkID0gdmFsdWUgPT09IG51bGw7XG4gIH0gZWxzZSBpZiAoaXNTaW1wbGVUeXBlKGV4cGVjdGVkVHlwZSkpIHtcbiAgICBjb25zdCB0ID0gdHlwZW9mIHZhbHVlO1xuICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKCF2YWxpZCAmJiB0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBcIk9iamVjdFwiKSB7XG4gICAgdmFsaWQgPSBpc09iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBcIkFycmF5XCIpIHtcbiAgICB2YWxpZCA9IGlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgaWYgKGV4cGVjdGVkVHlwZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGBQcm9wIHR5cGUgW10gZm9yIHByb3AgXCIke25hbWV9XCIgd29uJ3QgbWF0Y2ggYW55dGhpbmcuIERpZCB5b3UgbWVhbiB0byB1c2UgdHlwZSBBcnJheSBpbnN0ZWFkP2A7XG4gIH1cbiAgbGV0IG1lc3NhZ2UgPSBgSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIiR7bmFtZX1cIi4gRXhwZWN0ZWQgJHtleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKFwiIHwgXCIpfWA7XG4gIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZXNbMF07XG4gIGNvbnN0IHJlY2VpdmVkVHlwZSA9IHRvUmF3VHlwZSh2YWx1ZSk7XG4gIGNvbnN0IGV4cGVjdGVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCBleHBlY3RlZFR5cGUpO1xuICBjb25zdCByZWNlaXZlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgcmVjZWl2ZWRUeXBlKTtcbiAgaWYgKGV4cGVjdGVkVHlwZXMubGVuZ3RoID09PSAxICYmIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmICFpc0Jvb2xlYW4oZXhwZWN0ZWRUeXBlLCByZWNlaXZlZFR5cGUpKSB7XG4gICAgbWVzc2FnZSArPSBgIHdpdGggdmFsdWUgJHtleHBlY3RlZFZhbHVlfWA7XG4gIH1cbiAgbWVzc2FnZSArPSBgLCBnb3QgJHtyZWNlaXZlZFR5cGV9IGA7XG4gIGlmIChpc0V4cGxpY2FibGUocmVjZWl2ZWRUeXBlKSkge1xuICAgIG1lc3NhZ2UgKz0gYHdpdGggdmFsdWUgJHtyZWNlaXZlZFZhbHVlfS5gO1xuICB9XG4gIHJldHVybiBtZXNzYWdlO1xufVxuZnVuY3Rpb24gc3R5bGVWYWx1ZSh2YWx1ZSwgdHlwZSkge1xuICBpZiAodHlwZSA9PT0gXCJTdHJpbmdcIikge1xuICAgIHJldHVybiBgXCIke3ZhbHVlfVwiYDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBcIk51bWJlclwiKSB7XG4gICAgcmV0dXJuIGAke051bWJlcih2YWx1ZSl9YDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYCR7dmFsdWV9YDtcbiAgfVxufVxuZnVuY3Rpb24gaXNFeHBsaWNhYmxlKHR5cGUpIHtcbiAgY29uc3QgZXhwbGljaXRUeXBlcyA9IFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImJvb2xlYW5cIl07XG4gIHJldHVybiBleHBsaWNpdFR5cGVzLnNvbWUoKGVsZW0pID0+IHR5cGUudG9Mb3dlckNhc2UoKSA9PT0gZWxlbSk7XG59XG5mdW5jdGlvbiBpc0Jvb2xlYW4oLi4uYXJncykge1xuICByZXR1cm4gYXJncy5zb21lKChlbGVtKSA9PiBlbGVtLnRvTG93ZXJDYXNlKCkgPT09IFwiYm9vbGVhblwiKTtcbn1cblxuY29uc3QgaXNJbnRlcm5hbEtleSA9IChrZXkpID0+IGtleVswXSA9PT0gXCJfXCIgfHwga2V5ID09PSBcIiRzdGFibGVcIjtcbmNvbnN0IG5vcm1hbGl6ZVNsb3RWYWx1ZSA9ICh2YWx1ZSkgPT4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAobm9ybWFsaXplVk5vZGUpIDogW25vcm1hbGl6ZVZOb2RlKHZhbHVlKV07XG5jb25zdCBub3JtYWxpemVTbG90ID0gKGtleSwgcmF3U2xvdCwgY3R4KSA9PiB7XG4gIGlmIChyYXdTbG90Ll9uKSB7XG4gICAgcmV0dXJuIHJhd1Nsb3Q7XG4gIH1cbiAgY29uc3Qgbm9ybWFsaXplZCA9IHdpdGhDdHgoKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjdXJyZW50SW5zdGFuY2UgJiYgKCFjdHggfHwgY3R4LnJvb3QgPT09IGN1cnJlbnRJbnN0YW5jZS5yb290KSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgU2xvdCBcIiR7a2V5fVwiIGludm9rZWQgb3V0c2lkZSBvZiB0aGUgcmVuZGVyIGZ1bmN0aW9uOiB0aGlzIHdpbGwgbm90IHRyYWNrIGRlcGVuZGVuY2llcyB1c2VkIGluIHRoZSBzbG90LiBJbnZva2UgdGhlIHNsb3QgZnVuY3Rpb24gaW5zaWRlIHRoZSByZW5kZXIgZnVuY3Rpb24gaW5zdGVhZC5gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplU2xvdFZhbHVlKHJhd1Nsb3QoLi4uYXJncykpO1xuICB9LCBjdHgpO1xuICBub3JtYWxpemVkLl9jID0gZmFsc2U7XG4gIHJldHVybiBub3JtYWxpemVkO1xufTtcbmNvbnN0IG5vcm1hbGl6ZU9iamVjdFNsb3RzID0gKHJhd1Nsb3RzLCBzbG90cywgaW5zdGFuY2UpID0+IHtcbiAgY29uc3QgY3R4ID0gcmF3U2xvdHMuX2N0eDtcbiAgZm9yIChjb25zdCBrZXkgaW4gcmF3U2xvdHMpIHtcbiAgICBpZiAoaXNJbnRlcm5hbEtleShrZXkpKSBjb250aW51ZTtcbiAgICBjb25zdCB2YWx1ZSA9IHJhd1Nsb3RzW2tleV07XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICBzbG90c1trZXldID0gbm9ybWFsaXplU2xvdChrZXksIHZhbHVlLCBjdHgpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdHJ1ZSkge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYE5vbi1mdW5jdGlvbiB2YWx1ZSBlbmNvdW50ZXJlZCBmb3Igc2xvdCBcIiR7a2V5fVwiLiBQcmVmZXIgZnVuY3Rpb24gc2xvdHMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplU2xvdFZhbHVlKHZhbHVlKTtcbiAgICAgIHNsb3RzW2tleV0gPSAoKSA9PiBub3JtYWxpemVkO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IG5vcm1hbGl6ZVZOb2RlU2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuKSA9PiB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc0tlZXBBbGl2ZShpbnN0YW5jZS52bm9kZSkgJiYgdHJ1ZSkge1xuICAgIHdhcm4kMShcbiAgICAgIGBOb24tZnVuY3Rpb24gdmFsdWUgZW5jb3VudGVyZWQgZm9yIGRlZmF1bHQgc2xvdC4gUHJlZmVyIGZ1bmN0aW9uIHNsb3RzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuYFxuICAgICk7XG4gIH1cbiAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVNsb3RWYWx1ZShjaGlsZHJlbik7XG4gIGluc3RhbmNlLnNsb3RzLmRlZmF1bHQgPSAoKSA9PiBub3JtYWxpemVkO1xufTtcbmNvbnN0IGFzc2lnblNsb3RzID0gKHNsb3RzLCBjaGlsZHJlbiwgb3B0aW1pemVkKSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IGluIGNoaWxkcmVuKSB7XG4gICAgaWYgKG9wdGltaXplZCB8fCBrZXkgIT09IFwiX1wiKSB7XG4gICAgICBzbG90c1trZXldID0gY2hpbGRyZW5ba2V5XTtcbiAgICB9XG4gIH1cbn07XG5jb25zdCBpbml0U2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpID0+IHtcbiAgY29uc3Qgc2xvdHMgPSBpbnN0YW5jZS5zbG90cyA9IGNyZWF0ZUludGVybmFsT2JqZWN0KCk7XG4gIGlmIChpbnN0YW5jZS52bm9kZS5zaGFwZUZsYWcgJiAzMikge1xuICAgIGNvbnN0IHR5cGUgPSBjaGlsZHJlbi5fO1xuICAgIGlmICh0eXBlKSB7XG4gICAgICBhc3NpZ25TbG90cyhzbG90cywgY2hpbGRyZW4sIG9wdGltaXplZCk7XG4gICAgICBpZiAob3B0aW1pemVkKSB7XG4gICAgICAgIGRlZihzbG90cywgXCJfXCIsIHR5cGUsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub3JtYWxpemVPYmplY3RTbG90cyhjaGlsZHJlbiwgc2xvdHMpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjaGlsZHJlbikge1xuICAgIG5vcm1hbGl6ZVZOb2RlU2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcbiAgfVxufTtcbmNvbnN0IHVwZGF0ZVNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbiwgb3B0aW1pemVkKSA9PiB7XG4gIGNvbnN0IHsgdm5vZGUsIHNsb3RzIH0gPSBpbnN0YW5jZTtcbiAgbGV0IG5lZWREZWxldGlvbkNoZWNrID0gdHJ1ZTtcbiAgbGV0IGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCA9IEVNUFRZX09CSjtcbiAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDMyKSB7XG4gICAgY29uc3QgdHlwZSA9IGNoaWxkcmVuLl87XG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSG1yVXBkYXRpbmcpIHtcbiAgICAgICAgYXNzaWduU2xvdHMoc2xvdHMsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpO1xuICAgICAgICB0cmlnZ2VyKGluc3RhbmNlLCBcInNldFwiLCBcIiRzbG90c1wiKTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW1pemVkICYmIHR5cGUgPT09IDEpIHtcbiAgICAgICAgbmVlZERlbGV0aW9uQ2hlY2sgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2lnblNsb3RzKHNsb3RzLCBjaGlsZHJlbiwgb3B0aW1pemVkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmVlZERlbGV0aW9uQ2hlY2sgPSAhY2hpbGRyZW4uJHN0YWJsZTtcbiAgICAgIG5vcm1hbGl6ZU9iamVjdFNsb3RzKGNoaWxkcmVuLCBzbG90cyk7XG4gICAgfVxuICAgIGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuKSB7XG4gICAgbm9ybWFsaXplVk5vZGVTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4pO1xuICAgIGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCA9IHsgZGVmYXVsdDogMSB9O1xuICB9XG4gIGlmIChuZWVkRGVsZXRpb25DaGVjaykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNsb3RzKSB7XG4gICAgICBpZiAoIWlzSW50ZXJuYWxLZXkoa2V5KSAmJiBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXRba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSBzbG90c1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubGV0IHN1cHBvcnRlZDtcbmxldCBwZXJmO1xuZnVuY3Rpb24gc3RhcnRNZWFzdXJlKGluc3RhbmNlLCB0eXBlKSB7XG4gIGlmIChpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5wZXJmb3JtYW5jZSAmJiBpc1N1cHBvcnRlZCgpKSB7XG4gICAgcGVyZi5tYXJrKGB2dWUtJHt0eXBlfS0ke2luc3RhbmNlLnVpZH1gKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICBkZXZ0b29sc1BlcmZTdGFydChpbnN0YW5jZSwgdHlwZSwgaXNTdXBwb3J0ZWQoKSA/IHBlcmYubm93KCkgOiBEYXRlLm5vdygpKTtcbiAgfVxufVxuZnVuY3Rpb24gZW5kTWVhc3VyZShpbnN0YW5jZSwgdHlwZSkge1xuICBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcucGVyZm9ybWFuY2UgJiYgaXNTdXBwb3J0ZWQoKSkge1xuICAgIGNvbnN0IHN0YXJ0VGFnID0gYHZ1ZS0ke3R5cGV9LSR7aW5zdGFuY2UudWlkfWA7XG4gICAgY29uc3QgZW5kVGFnID0gc3RhcnRUYWcgKyBgOmVuZGA7XG4gICAgcGVyZi5tYXJrKGVuZFRhZyk7XG4gICAgcGVyZi5tZWFzdXJlKFxuICAgICAgYDwke2Zvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIGluc3RhbmNlLnR5cGUpfT4gJHt0eXBlfWAsXG4gICAgICBzdGFydFRhZyxcbiAgICAgIGVuZFRhZ1xuICAgICk7XG4gICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICBkZXZ0b29sc1BlcmZFbmQoaW5zdGFuY2UsIHR5cGUsIGlzU3VwcG9ydGVkKCkgPyBwZXJmLm5vdygpIDogRGF0ZS5ub3coKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzU3VwcG9ydGVkKCkge1xuICBpZiAoc3VwcG9ydGVkICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gc3VwcG9ydGVkO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5wZXJmb3JtYW5jZSkge1xuICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgcGVyZiA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgfSBlbHNlIHtcbiAgICBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gc3VwcG9ydGVkO1xufVxuXG5mdW5jdGlvbiBpbml0RmVhdHVyZUZsYWdzKCkge1xuICBjb25zdCBuZWVkV2FybiA9IFtdO1xuICBpZiAodHlwZW9mIF9fVlVFX09QVElPTlNfQVBJX18gIT09IFwiYm9vbGVhblwiKSB7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBuZWVkV2Fybi5wdXNoKGBfX1ZVRV9PUFRJT05TX0FQSV9fYCk7XG4gICAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX09QVElPTlNfQVBJX18gPSB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgX19WVUVfUFJPRF9ERVZUT09MU19fICE9PSBcImJvb2xlYW5cIikge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbmVlZFdhcm4ucHVzaChgX19WVUVfUFJPRF9ERVZUT09MU19fYCk7XG4gICAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX1BST0RfREVWVE9PTFNfXyA9IGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fICE9PSBcImJvb2xlYW5cIikge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbmVlZFdhcm4ucHVzaChgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fYCk7XG4gICAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXyA9IGZhbHNlO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG5lZWRXYXJuLmxlbmd0aCkge1xuICAgIGNvbnN0IG11bHRpID0gbmVlZFdhcm4ubGVuZ3RoID4gMTtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBgRmVhdHVyZSBmbGFnJHttdWx0aSA/IGBzYCA6IGBgfSAke25lZWRXYXJuLmpvaW4oXCIsIFwiKX0gJHttdWx0aSA/IGBhcmVgIDogYGlzYH0gbm90IGV4cGxpY2l0bHkgZGVmaW5lZC4gWW91IGFyZSBydW5uaW5nIHRoZSBlc20tYnVuZGxlciBidWlsZCBvZiBWdWUsIHdoaWNoIGV4cGVjdHMgdGhlc2UgY29tcGlsZS10aW1lIGZlYXR1cmUgZmxhZ3MgdG8gYmUgZ2xvYmFsbHkgaW5qZWN0ZWQgdmlhIHRoZSBidW5kbGVyIGNvbmZpZyBpbiBvcmRlciB0byBnZXQgYmV0dGVyIHRyZWUtc2hha2luZyBpbiB0aGUgcHJvZHVjdGlvbiBidW5kbGUuXG5cbkZvciBtb3JlIGRldGFpbHMsIHNlZSBodHRwczovL2xpbmsudnVlanMub3JnL2ZlYXR1cmUtZmxhZ3MuYFxuICAgICk7XG4gIH1cbn1cblxuY29uc3QgcXVldWVQb3N0UmVuZGVyRWZmZWN0ID0gcXVldWVFZmZlY3RXaXRoU3VzcGVuc2UgO1xuZnVuY3Rpb24gY3JlYXRlUmVuZGVyZXIob3B0aW9ucykge1xuICByZXR1cm4gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIob3B0aW9ucykge1xuICByZXR1cm4gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMsIGNyZWF0ZUh5ZHJhdGlvbkZ1bmN0aW9ucyk7XG59XG5mdW5jdGlvbiBiYXNlQ3JlYXRlUmVuZGVyZXIob3B0aW9ucywgY3JlYXRlSHlkcmF0aW9uRm5zKSB7XG4gIHtcbiAgICBpbml0RmVhdHVyZUZsYWdzKCk7XG4gIH1cbiAgY29uc3QgdGFyZ2V0ID0gZ2V0R2xvYmFsVGhpcygpO1xuICB0YXJnZXQuX19WVUVfXyA9IHRydWU7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgIHNldERldnRvb2xzSG9vayQxKHRhcmdldC5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fLCB0YXJnZXQpO1xuICB9XG4gIGNvbnN0IHtcbiAgICBpbnNlcnQ6IGhvc3RJbnNlcnQsXG4gICAgcmVtb3ZlOiBob3N0UmVtb3ZlLFxuICAgIHBhdGNoUHJvcDogaG9zdFBhdGNoUHJvcCxcbiAgICBjcmVhdGVFbGVtZW50OiBob3N0Q3JlYXRlRWxlbWVudCxcbiAgICBjcmVhdGVUZXh0OiBob3N0Q3JlYXRlVGV4dCxcbiAgICBjcmVhdGVDb21tZW50OiBob3N0Q3JlYXRlQ29tbWVudCxcbiAgICBzZXRUZXh0OiBob3N0U2V0VGV4dCxcbiAgICBzZXRFbGVtZW50VGV4dDogaG9zdFNldEVsZW1lbnRUZXh0LFxuICAgIHBhcmVudE5vZGU6IGhvc3RQYXJlbnROb2RlLFxuICAgIG5leHRTaWJsaW5nOiBob3N0TmV4dFNpYmxpbmcsXG4gICAgc2V0U2NvcGVJZDogaG9zdFNldFNjb3BlSWQgPSBOT09QLFxuICAgIGluc2VydFN0YXRpY0NvbnRlbnQ6IGhvc3RJbnNlcnRTdGF0aWNDb250ZW50XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBwYXRjaCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yID0gbnVsbCwgcGFyZW50Q29tcG9uZW50ID0gbnVsbCwgcGFyZW50U3VzcGVuc2UgPSBudWxsLCBuYW1lc3BhY2UgPSB2b2lkIDAsIHNsb3RTY29wZUlkcyA9IG51bGwsIG9wdGltaXplZCA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNIbXJVcGRhdGluZyA/IGZhbHNlIDogISFuMi5keW5hbWljQ2hpbGRyZW4pID0+IHtcbiAgICBpZiAobjEgPT09IG4yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuMSAmJiAhaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcbiAgICAgIGFuY2hvciA9IGdldE5leHRIb3N0Tm9kZShuMSk7XG4gICAgICB1bm1vdW50KG4xLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgIG4xID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG4yLnBhdGNoRmxhZyA9PT0gLTIpIHtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgbjIuZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeyB0eXBlLCByZWYsIHNoYXBlRmxhZyB9ID0gbjI7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFRleHQ6XG4gICAgICAgIHByb2Nlc3NUZXh0KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ29tbWVudDpcbiAgICAgICAgcHJvY2Vzc0NvbW1lbnROb2RlKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGljOlxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgICAgIG1vdW50U3RhdGljTm9kZShuMiwgY29udGFpbmVyLCBhbmNob3IsIG5hbWVzcGFjZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHBhdGNoU3RhdGljTm9kZShuMSwgbjIsIGNvbnRhaW5lciwgbmFtZXNwYWNlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgIHByb2Nlc3NGcmFnbWVudChcbiAgICAgICAgICBuMSxcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxKSB7XG4gICAgICAgICAgcHJvY2Vzc0VsZW1lbnQoXG4gICAgICAgICAgICBuMSxcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDYpIHtcbiAgICAgICAgICBwcm9jZXNzQ29tcG9uZW50KFxuICAgICAgICAgICAgbjEsXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiA2NCkge1xuICAgICAgICAgIHR5cGUucHJvY2VzcyhcbiAgICAgICAgICAgIG4xLFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgICAgIGludGVybmFsc1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICAgICAgdHlwZS5wcm9jZXNzKFxuICAgICAgICAgICAgbjEsXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICAgICAgaW50ZXJuYWxzXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybiQxKFwiSW52YWxpZCBWTm9kZSB0eXBlOlwiLCB0eXBlLCBgKCR7dHlwZW9mIHR5cGV9KWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyZWYgIT0gbnVsbCAmJiBwYXJlbnRDb21wb25lbnQpIHtcbiAgICAgIHNldFJlZihyZWYsIG4xICYmIG4xLnJlZiwgcGFyZW50U3VzcGVuc2UsIG4yIHx8IG4xLCAhbjIpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcHJvY2Vzc1RleHQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcikgPT4ge1xuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBob3N0SW5zZXJ0KFxuICAgICAgICBuMi5lbCA9IGhvc3RDcmVhdGVUZXh0KG4yLmNoaWxkcmVuKSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3JcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVsID0gbjIuZWwgPSBuMS5lbDtcbiAgICAgIGlmIChuMi5jaGlsZHJlbiAhPT0gbjEuY2hpbGRyZW4pIHtcbiAgICAgICAgaG9zdFNldFRleHQoZWwsIG4yLmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NDb21tZW50Tm9kZSA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKSA9PiB7XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIGhvc3RJbnNlcnQoXG4gICAgICAgIG4yLmVsID0gaG9zdENyZWF0ZUNvbW1lbnQobjIuY2hpbGRyZW4gfHwgXCJcIiksXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBuMi5lbCA9IG4xLmVsO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbW91bnRTdGF0aWNOb2RlID0gKG4yLCBjb250YWluZXIsIGFuY2hvciwgbmFtZXNwYWNlKSA9PiB7XG4gICAgW24yLmVsLCBuMi5hbmNob3JdID0gaG9zdEluc2VydFN0YXRpY0NvbnRlbnQoXG4gICAgICBuMi5jaGlsZHJlbixcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIGFuY2hvcixcbiAgICAgIG5hbWVzcGFjZSxcbiAgICAgIG4yLmVsLFxuICAgICAgbjIuYW5jaG9yXG4gICAgKTtcbiAgfTtcbiAgY29uc3QgcGF0Y2hTdGF0aWNOb2RlID0gKG4xLCBuMiwgY29udGFpbmVyLCBuYW1lc3BhY2UpID0+IHtcbiAgICBpZiAobjIuY2hpbGRyZW4gIT09IG4xLmNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBhbmNob3IgPSBob3N0TmV4dFNpYmxpbmcobjEuYW5jaG9yKTtcbiAgICAgIHJlbW92ZVN0YXRpY05vZGUobjEpO1xuICAgICAgW24yLmVsLCBuMi5hbmNob3JdID0gaG9zdEluc2VydFN0YXRpY0NvbnRlbnQoXG4gICAgICAgIG4yLmNoaWxkcmVuLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgbmFtZXNwYWNlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBuMi5lbCA9IG4xLmVsO1xuICAgICAgbjIuYW5jaG9yID0gbjEuYW5jaG9yO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbW92ZVN0YXRpY05vZGUgPSAoeyBlbCwgYW5jaG9yIH0sIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpID0+IHtcbiAgICBsZXQgbmV4dDtcbiAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGFuY2hvcikge1xuICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhlbCk7XG4gICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIG5leHRTaWJsaW5nKTtcbiAgICAgIGVsID0gbmV4dDtcbiAgICB9XG4gICAgaG9zdEluc2VydChhbmNob3IsIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpO1xuICB9O1xuICBjb25zdCByZW1vdmVTdGF0aWNOb2RlID0gKHsgZWwsIGFuY2hvciB9KSA9PiB7XG4gICAgbGV0IG5leHQ7XG4gICAgd2hpbGUgKGVsICYmIGVsICE9PSBhbmNob3IpIHtcbiAgICAgIG5leHQgPSBob3N0TmV4dFNpYmxpbmcoZWwpO1xuICAgICAgaG9zdFJlbW92ZShlbCk7XG4gICAgICBlbCA9IG5leHQ7XG4gICAgfVxuICAgIGhvc3RSZW1vdmUoYW5jaG9yKTtcbiAgfTtcbiAgY29uc3QgcHJvY2Vzc0VsZW1lbnQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGlmIChuMi50eXBlID09PSBcInN2Z1wiKSB7XG4gICAgICBuYW1lc3BhY2UgPSBcInN2Z1wiO1xuICAgIH0gZWxzZSBpZiAobjIudHlwZSA9PT0gXCJtYXRoXCIpIHtcbiAgICAgIG5hbWVzcGFjZSA9IFwibWF0aG1sXCI7XG4gICAgfVxuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBtb3VudEVsZW1lbnQoXG4gICAgICAgIG4yLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0Y2hFbGVtZW50KFxuICAgICAgICBuMSxcbiAgICAgICAgbjIsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3VudEVsZW1lbnQgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgbGV0IGVsO1xuICAgIGxldCB2bm9kZUhvb2s7XG4gICAgY29uc3QgeyBwcm9wcywgc2hhcGVGbGFnLCB0cmFuc2l0aW9uLCBkaXJzIH0gPSB2bm9kZTtcbiAgICBlbCA9IHZub2RlLmVsID0gaG9zdENyZWF0ZUVsZW1lbnQoXG4gICAgICB2bm9kZS50eXBlLFxuICAgICAgbmFtZXNwYWNlLFxuICAgICAgcHJvcHMgJiYgcHJvcHMuaXMsXG4gICAgICBwcm9wc1xuICAgICk7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDgpIHtcbiAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChlbCwgdm5vZGUuY2hpbGRyZW4pO1xuICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgIG1vdW50Q2hpbGRyZW4oXG4gICAgICAgIHZub2RlLmNoaWxkcmVuLFxuICAgICAgICBlbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgcmVzb2x2ZUNoaWxkcmVuTmFtZXNwYWNlKHZub2RlLCBuYW1lc3BhY2UpLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGRpcnMpIHtcbiAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJjcmVhdGVkXCIpO1xuICAgIH1cbiAgICBzZXRTY29wZUlkKGVsLCB2bm9kZSwgdm5vZGUuc2NvcGVJZCwgc2xvdFNjb3BlSWRzLCBwYXJlbnRDb21wb25lbnQpO1xuICAgIGlmIChwcm9wcykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gXCJ2YWx1ZVwiICYmICFpc1Jlc2VydmVkUHJvcChrZXkpKSB7XG4gICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBudWxsLCBwcm9wc1trZXldLCBuYW1lc3BhY2UsIHBhcmVudENvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChcInZhbHVlXCIgaW4gcHJvcHMpIHtcbiAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgXCJ2YWx1ZVwiLCBudWxsLCBwcm9wcy52YWx1ZSwgbmFtZXNwYWNlKTtcbiAgICAgIH1cbiAgICAgIGlmICh2bm9kZUhvb2sgPSBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpIHtcbiAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgZGVmKGVsLCBcIl9fdm5vZGVcIiwgdm5vZGUsIHRydWUpO1xuICAgICAgZGVmKGVsLCBcIl9fdnVlUGFyZW50Q29tcG9uZW50XCIsIHBhcmVudENvbXBvbmVudCwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChkaXJzKSB7XG4gICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwiYmVmb3JlTW91bnRcIik7XG4gICAgfVxuICAgIGNvbnN0IG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzID0gbmVlZFRyYW5zaXRpb24ocGFyZW50U3VzcGVuc2UsIHRyYW5zaXRpb24pO1xuICAgIGlmIChuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcykge1xuICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XG4gICAgfVxuICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSB8fCBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyB8fCBkaXJzKSB7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICB2bm9kZUhvb2sgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzICYmIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xuICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJtb3VudGVkXCIpO1xuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2V0U2NvcGVJZCA9IChlbCwgdm5vZGUsIHNjb3BlSWQsIHNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50KSA9PiB7XG4gICAgaWYgKHNjb3BlSWQpIHtcbiAgICAgIGhvc3RTZXRTY29wZUlkKGVsLCBzY29wZUlkKTtcbiAgICB9XG4gICAgaWYgKHNsb3RTY29wZUlkcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbG90U2NvcGVJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaG9zdFNldFNjb3BlSWQoZWwsIHNsb3RTY29wZUlkc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJlbnRDb21wb25lbnQpIHtcbiAgICAgIGxldCBzdWJUcmVlID0gcGFyZW50Q29tcG9uZW50LnN1YlRyZWU7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzdWJUcmVlLnBhdGNoRmxhZyA+IDAgJiYgc3ViVHJlZS5wYXRjaEZsYWcgJiAyMDQ4KSB7XG4gICAgICAgIHN1YlRyZWUgPSBmaWx0ZXJTaW5nbGVSb290KHN1YlRyZWUuY2hpbGRyZW4pIHx8IHN1YlRyZWU7XG4gICAgICB9XG4gICAgICBpZiAodm5vZGUgPT09IHN1YlRyZWUgfHwgaXNTdXNwZW5zZShzdWJUcmVlLnR5cGUpICYmIChzdWJUcmVlLnNzQ29udGVudCA9PT0gdm5vZGUgfHwgc3ViVHJlZS5zc0ZhbGxiYWNrID09PSB2bm9kZSkpIHtcbiAgICAgICAgY29uc3QgcGFyZW50Vk5vZGUgPSBwYXJlbnRDb21wb25lbnQudm5vZGU7XG4gICAgICAgIHNldFNjb3BlSWQoXG4gICAgICAgICAgZWwsXG4gICAgICAgICAgcGFyZW50Vk5vZGUsXG4gICAgICAgICAgcGFyZW50Vk5vZGUuc2NvcGVJZCxcbiAgICAgICAgICBwYXJlbnRWTm9kZS5zbG90U2NvcGVJZHMsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LnBhcmVudFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgbW91bnRDaGlsZHJlbiA9IChjaGlsZHJlbiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHN0YXJ0ID0gMCkgPT4ge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoY2hpbGRyZW5baV0pIDogbm9ybWFsaXplVk5vZGUoY2hpbGRyZW5baV0pO1xuICAgICAgcGF0Y2goXG4gICAgICAgIG51bGwsXG4gICAgICAgIGNoaWxkLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdGNoRWxlbWVudCA9IChuMSwgbjIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCBlbCA9IG4yLmVsID0gbjEuZWw7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBlbC5fX3Zub2RlID0gbjI7XG4gICAgfVxuICAgIGxldCB7IHBhdGNoRmxhZywgZHluYW1pY0NoaWxkcmVuLCBkaXJzIH0gPSBuMjtcbiAgICBwYXRjaEZsYWcgfD0gbjEucGF0Y2hGbGFnICYgMTY7XG4gICAgY29uc3Qgb2xkUHJvcHMgPSBuMS5wcm9wcyB8fCBFTVBUWV9PQko7XG4gICAgY29uc3QgbmV3UHJvcHMgPSBuMi5wcm9wcyB8fCBFTVBUWV9PQko7XG4gICAgbGV0IHZub2RlSG9vaztcbiAgICBwYXJlbnRDb21wb25lbnQgJiYgdG9nZ2xlUmVjdXJzZShwYXJlbnRDb21wb25lbnQsIGZhbHNlKTtcbiAgICBpZiAodm5vZGVIb29rID0gbmV3UHJvcHMub25Wbm9kZUJlZm9yZVVwZGF0ZSkge1xuICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCBuMiwgbjEpO1xuICAgIH1cbiAgICBpZiAoZGlycykge1xuICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayhuMiwgbjEsIHBhcmVudENvbXBvbmVudCwgXCJiZWZvcmVVcGRhdGVcIik7XG4gICAgfVxuICAgIHBhcmVudENvbXBvbmVudCAmJiB0b2dnbGVSZWN1cnNlKHBhcmVudENvbXBvbmVudCwgdHJ1ZSk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNIbXJVcGRhdGluZykge1xuICAgICAgcGF0Y2hGbGFnID0gMDtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG9sZFByb3BzLmlubmVySFRNTCAmJiBuZXdQcm9wcy5pbm5lckhUTUwgPT0gbnVsbCB8fCBvbGRQcm9wcy50ZXh0Q29udGVudCAmJiBuZXdQcm9wcy50ZXh0Q29udGVudCA9PSBudWxsKSB7XG4gICAgICBob3N0U2V0RWxlbWVudFRleHQoZWwsIFwiXCIpO1xuICAgIH1cbiAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4oXG4gICAgICAgIG4xLmR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICBlbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgcmVzb2x2ZUNoaWxkcmVuTmFtZXNwYWNlKG4yLCBuYW1lc3BhY2UpLFxuICAgICAgICBzbG90U2NvcGVJZHNcbiAgICAgICk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghb3B0aW1pemVkKSB7XG4gICAgICBwYXRjaENoaWxkcmVuKFxuICAgICAgICBuMSxcbiAgICAgICAgbjIsXG4gICAgICAgIGVsLFxuICAgICAgICBudWxsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICByZXNvbHZlQ2hpbGRyZW5OYW1lc3BhY2UobjIsIG5hbWVzcGFjZSksXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChwYXRjaEZsYWcgPiAwKSB7XG4gICAgICBpZiAocGF0Y2hGbGFnICYgMTYpIHtcbiAgICAgICAgcGF0Y2hQcm9wcyhlbCwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIG5hbWVzcGFjZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocGF0Y2hGbGFnICYgMikge1xuICAgICAgICAgIGlmIChvbGRQcm9wcy5jbGFzcyAhPT0gbmV3UHJvcHMuY2xhc3MpIHtcbiAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIFwiY2xhc3NcIiwgbnVsbCwgbmV3UHJvcHMuY2xhc3MsIG5hbWVzcGFjZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiA0KSB7XG4gICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgXCJzdHlsZVwiLCBvbGRQcm9wcy5zdHlsZSwgbmV3UHJvcHMuc3R5bGUsIG5hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDgpIHtcbiAgICAgICAgICBjb25zdCBwcm9wc1RvVXBkYXRlID0gbjIuZHluYW1pY1Byb3BzO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNUb1VwZGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gcHJvcHNUb1VwZGF0ZVtpXTtcbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSBvbGRQcm9wc1trZXldO1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5ld1Byb3BzW2tleV07XG4gICAgICAgICAgICBpZiAobmV4dCAhPT0gcHJldiB8fCBrZXkgPT09IFwidmFsdWVcIikge1xuICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIHByZXYsIG5leHQsIG5hbWVzcGFjZSwgcGFyZW50Q29tcG9uZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXRjaEZsYWcgJiAxKSB7XG4gICAgICAgIGlmIChuMS5jaGlsZHJlbiAhPT0gbjIuY2hpbGRyZW4pIHtcbiAgICAgICAgICBob3N0U2V0RWxlbWVudFRleHQoZWwsIG4yLmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIW9wdGltaXplZCAmJiBkeW5hbWljQ2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgcGF0Y2hQcm9wcyhlbCwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIG5hbWVzcGFjZSk7XG4gICAgfVxuICAgIGlmICgodm5vZGVIb29rID0gbmV3UHJvcHMub25Wbm9kZVVwZGF0ZWQpIHx8IGRpcnMpIHtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIG4yLCBuMSk7XG4gICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayhuMiwgbjEsIHBhcmVudENvbXBvbmVudCwgXCJ1cGRhdGVkXCIpO1xuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF0Y2hCbG9ja0NoaWxkcmVuID0gKG9sZENoaWxkcmVuLCBuZXdDaGlsZHJlbiwgZmFsbGJhY2tDb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgb2xkVk5vZGUgPSBvbGRDaGlsZHJlbltpXTtcbiAgICAgIGNvbnN0IG5ld1ZOb2RlID0gbmV3Q2hpbGRyZW5baV07XG4gICAgICBjb25zdCBjb250YWluZXIgPSAoXG4gICAgICAgIC8vIG9sZFZOb2RlIG1heSBiZSBhbiBlcnJvcmVkIGFzeW5jIHNldHVwKCkgY29tcG9uZW50IGluc2lkZSBTdXNwZW5zZVxuICAgICAgICAvLyB3aGljaCB3aWxsIG5vdCBoYXZlIGEgbW91bnRlZCBlbGVtZW50XG4gICAgICAgIG9sZFZOb2RlLmVsICYmIC8vIC0gSW4gdGhlIGNhc2Ugb2YgYSBGcmFnbWVudCwgd2UgbmVlZCB0byBwcm92aWRlIHRoZSBhY3R1YWwgcGFyZW50XG4gICAgICAgIC8vIG9mIHRoZSBGcmFnbWVudCBpdHNlbGYgc28gaXQgY2FuIG1vdmUgaXRzIGNoaWxkcmVuLlxuICAgICAgICAob2xkVk5vZGUudHlwZSA9PT0gRnJhZ21lbnQgfHwgLy8gLSBJbiB0aGUgY2FzZSBvZiBkaWZmZXJlbnQgbm9kZXMsIHRoZXJlIGlzIGdvaW5nIHRvIGJlIGEgcmVwbGFjZW1lbnRcbiAgICAgICAgLy8gd2hpY2ggYWxzbyByZXF1aXJlcyB0aGUgY29ycmVjdCBwYXJlbnQgY29udGFpbmVyXG4gICAgICAgICFpc1NhbWVWTm9kZVR5cGUob2xkVk5vZGUsIG5ld1ZOb2RlKSB8fCAvLyAtIEluIHRoZSBjYXNlIG9mIGEgY29tcG9uZW50LCBpdCBjb3VsZCBjb250YWluIGFueXRoaW5nLlxuICAgICAgICBvbGRWTm9kZS5zaGFwZUZsYWcgJiAoNiB8IDY0KSkgPyBob3N0UGFyZW50Tm9kZShvbGRWTm9kZS5lbCkgOiAoXG4gICAgICAgICAgLy8gSW4gb3RoZXIgY2FzZXMsIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIG5vdCBhY3R1YWxseSB1c2VkIHNvIHdlXG4gICAgICAgICAgLy8ganVzdCBwYXNzIHRoZSBibG9jayBlbGVtZW50IGhlcmUgdG8gYXZvaWQgYSBET00gcGFyZW50Tm9kZSBjYWxsLlxuICAgICAgICAgIGZhbGxiYWNrQ29udGFpbmVyXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBwYXRjaChcbiAgICAgICAgb2xkVk5vZGUsXG4gICAgICAgIG5ld1ZOb2RlLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF0Y2hQcm9wcyA9IChlbCwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIG5hbWVzcGFjZSkgPT4ge1xuICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMpIHtcbiAgICAgIGlmIChvbGRQcm9wcyAhPT0gRU1QVFlfT0JKKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9sZFByb3BzKSB7XG4gICAgICAgICAgaWYgKCFpc1Jlc2VydmVkUHJvcChrZXkpICYmICEoa2V5IGluIG5ld1Byb3BzKSkge1xuICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChcbiAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgb2xkUHJvcHNba2V5XSxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXdQcm9wcykge1xuICAgICAgICBpZiAoaXNSZXNlcnZlZFByb3Aoa2V5KSkgY29udGludWU7XG4gICAgICAgIGNvbnN0IG5leHQgPSBuZXdQcm9wc1trZXldO1xuICAgICAgICBjb25zdCBwcmV2ID0gb2xkUHJvcHNba2V5XTtcbiAgICAgICAgaWYgKG5leHQgIT09IHByZXYgJiYga2V5ICE9PSBcInZhbHVlXCIpIHtcbiAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIHByZXYsIG5leHQsIG5hbWVzcGFjZSwgcGFyZW50Q29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKFwidmFsdWVcIiBpbiBuZXdQcm9wcykge1xuICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBcInZhbHVlXCIsIG9sZFByb3BzLnZhbHVlLCBuZXdQcm9wcy52YWx1ZSwgbmFtZXNwYWNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NGcmFnbWVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgZnJhZ21lbnRTdGFydEFuY2hvciA9IG4yLmVsID0gbjEgPyBuMS5lbCA6IGhvc3RDcmVhdGVUZXh0KFwiXCIpO1xuICAgIGNvbnN0IGZyYWdtZW50RW5kQW5jaG9yID0gbjIuYW5jaG9yID0gbjEgPyBuMS5hbmNob3IgOiBob3N0Q3JlYXRlVGV4dChcIlwiKTtcbiAgICBsZXQgeyBwYXRjaEZsYWcsIGR5bmFtaWNDaGlsZHJlbiwgc2xvdFNjb3BlSWRzOiBmcmFnbWVudFNsb3RTY29wZUlkcyB9ID0gbjI7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgLy8gIzU1MjMgZGV2IHJvb3QgZnJhZ21lbnQgbWF5IGluaGVyaXQgZGlyZWN0aXZlc1xuICAgIChpc0htclVwZGF0aW5nIHx8IHBhdGNoRmxhZyAmIDIwNDgpKSB7XG4gICAgICBwYXRjaEZsYWcgPSAwO1xuICAgICAgb3B0aW1pemVkID0gZmFsc2U7XG4gICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZnJhZ21lbnRTbG90U2NvcGVJZHMpIHtcbiAgICAgIHNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkcyA/IHNsb3RTY29wZUlkcy5jb25jYXQoZnJhZ21lbnRTbG90U2NvcGVJZHMpIDogZnJhZ21lbnRTbG90U2NvcGVJZHM7XG4gICAgfVxuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBob3N0SW5zZXJ0KGZyYWdtZW50U3RhcnRBbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIGhvc3RJbnNlcnQoZnJhZ21lbnRFbmRBbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIG1vdW50Q2hpbGRyZW4oXG4gICAgICAgIC8vICMxMDAwN1xuICAgICAgICAvLyBzdWNoIGZyYWdtZW50IGxpa2UgYDw+PC8+YCB3aWxsIGJlIGNvbXBpbGVkIGludG9cbiAgICAgICAgLy8gYSBmcmFnbWVudCB3aGljaCBkb2Vzbid0IGhhdmUgYSBjaGlsZHJlbi5cbiAgICAgICAgLy8gSW4gdGhpcyBjYXNlIGZhbGxiYWNrIHRvIGFuIGVtcHR5IGFycmF5XG4gICAgICAgIG4yLmNoaWxkcmVuIHx8IFtdLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGZyYWdtZW50RW5kQW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGF0Y2hGbGFnID4gMCAmJiBwYXRjaEZsYWcgJiA2NCAmJiBkeW5hbWljQ2hpbGRyZW4gJiYgLy8gIzI3MTUgdGhlIHByZXZpb3VzIGZyYWdtZW50IGNvdWxkJ3ZlIGJlZW4gYSBCQUlMZWQgb25lIGFzIGEgcmVzdWx0XG4gICAgICAvLyBvZiByZW5kZXJTbG90KCkgd2l0aCBubyB2YWxpZCBjaGlsZHJlblxuICAgICAgbjEuZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihcbiAgICAgICAgICBuMS5keW5hbWljQ2hpbGRyZW4sXG4gICAgICAgICAgZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkc1xuICAgICAgICApO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAvLyAjMjA4MCBpZiB0aGUgc3RhYmxlIGZyYWdtZW50IGhhcyBhIGtleSwgaXQncyBhIDx0ZW1wbGF0ZSB2LWZvcj4gdGhhdCBtYXlcbiAgICAgICAgICAvLyAgZ2V0IG1vdmVkIGFyb3VuZC4gTWFrZSBzdXJlIGFsbCByb290IGxldmVsIHZub2RlcyBpbmhlcml0IGVsLlxuICAgICAgICAgIC8vICMyMTM0IG9yIGlmIGl0J3MgYSBjb21wb25lbnQgcm9vdCwgaXQgbWF5IGFsc28gZ2V0IG1vdmVkIGFyb3VuZFxuICAgICAgICAgIC8vIGFzIHRoZSBjb21wb25lbnQgaXMgYmVpbmcgbW92ZWQuXG4gICAgICAgICAgbjIua2V5ICE9IG51bGwgfHwgcGFyZW50Q29tcG9uZW50ICYmIG4yID09PSBwYXJlbnRDb21wb25lbnQuc3ViVHJlZVxuICAgICAgICApIHtcbiAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKFxuICAgICAgICAgICAgbjEsXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgIC8qIHNoYWxsb3cgKi9cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRjaENoaWxkcmVuKFxuICAgICAgICAgIG4xLFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBmcmFnbWVudEVuZEFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NDb21wb25lbnQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIG4yLnNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkcztcbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgaWYgKG4yLnNoYXBlRmxhZyAmIDUxMikge1xuICAgICAgICBwYXJlbnRDb21wb25lbnQuY3R4LmFjdGl2YXRlKFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW91bnRDb21wb25lbnQoXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVDb21wb25lbnQobjEsIG4yLCBvcHRpbWl6ZWQpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbW91bnRDb21wb25lbnQgPSAoaW5pdGlhbFZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IChpbml0aWFsVk5vZGUuY29tcG9uZW50ID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2UoXG4gICAgICBpbml0aWFsVk5vZGUsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBwYXJlbnRTdXNwZW5zZVxuICAgICkpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGluc3RhbmNlLnR5cGUuX19obXJJZCkge1xuICAgICAgcmVnaXN0ZXJITVIoaW5zdGFuY2UpO1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KGluaXRpYWxWTm9kZSk7XG4gICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBtb3VudGApO1xuICAgIH1cbiAgICBpZiAoaXNLZWVwQWxpdmUoaW5pdGlhbFZOb2RlKSkge1xuICAgICAgaW5zdGFuY2UuY3R4LnJlbmRlcmVyID0gaW50ZXJuYWxzO1xuICAgIH1cbiAgICB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBpbml0YCk7XG4gICAgICB9XG4gICAgICBzZXR1cENvbXBvbmVudChpbnN0YW5jZSwgZmFsc2UsIG9wdGltaXplZCk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgaW5pdGApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5zdGFuY2UuYXN5bmNEZXApIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSG1yVXBkYXRpbmcpIGluaXRpYWxWTm9kZS5lbCA9IG51bGw7XG4gICAgICBwYXJlbnRTdXNwZW5zZSAmJiBwYXJlbnRTdXNwZW5zZS5yZWdpc3RlckRlcChpbnN0YW5jZSwgc2V0dXBSZW5kZXJFZmZlY3QsIG9wdGltaXplZCk7XG4gICAgICBpZiAoIWluaXRpYWxWTm9kZS5lbCkge1xuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IGluc3RhbmNlLnN1YlRyZWUgPSBjcmVhdGVWTm9kZShDb21tZW50KTtcbiAgICAgICAgcHJvY2Vzc0NvbW1lbnROb2RlKG51bGwsIHBsYWNlaG9sZGVyLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldHVwUmVuZGVyRWZmZWN0KFxuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgaW5pdGlhbFZOb2RlLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBtb3VudGApO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdXBkYXRlQ29tcG9uZW50ID0gKG4xLCBuMiwgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBuMi5jb21wb25lbnQgPSBuMS5jb21wb25lbnQ7XG4gICAgaWYgKHNob3VsZFVwZGF0ZUNvbXBvbmVudChuMSwgbjIsIG9wdGltaXplZCkpIHtcbiAgICAgIGlmIChpbnN0YW5jZS5hc3luY0RlcCAmJiAhaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChuMik7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyKGluc3RhbmNlLCBuMiwgb3B0aW1pemVkKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3RhbmNlLm5leHQgPSBuMjtcbiAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG4yLmVsID0gbjEuZWw7XG4gICAgICBpbnN0YW5jZS52bm9kZSA9IG4yO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2V0dXBSZW5kZXJFZmZlY3QgPSAoaW5zdGFuY2UsIGluaXRpYWxWTm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IGNvbXBvbmVudFVwZGF0ZUZuID0gKCkgPT4ge1xuICAgICAgaWYgKCFpbnN0YW5jZS5pc01vdW50ZWQpIHtcbiAgICAgICAgbGV0IHZub2RlSG9vaztcbiAgICAgICAgY29uc3QgeyBlbCwgcHJvcHMgfSA9IGluaXRpYWxWTm9kZTtcbiAgICAgICAgY29uc3QgeyBibSwgbSwgcGFyZW50LCByb290LCB0eXBlIH0gPSBpbnN0YW5jZTtcbiAgICAgICAgY29uc3QgaXNBc3luY1dyYXBwZXJWTm9kZSA9IGlzQXN5bmNXcmFwcGVyKGluaXRpYWxWTm9kZSk7XG4gICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIGZhbHNlKTtcbiAgICAgICAgaWYgKGJtKSB7XG4gICAgICAgICAgaW52b2tlQXJyYXlGbnMoYm0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNBc3luY1dyYXBwZXJWTm9kZSAmJiAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSkge1xuICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgaW5pdGlhbFZOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCB0cnVlKTtcbiAgICAgICAgaWYgKGVsICYmIGh5ZHJhdGVOb2RlKSB7XG4gICAgICAgICAgY29uc3QgaHlkcmF0ZVN1YlRyZWUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc3RhbmNlLnN1YlRyZWUgPSByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKTtcbiAgICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYGh5ZHJhdGVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGh5ZHJhdGVOb2RlKFxuICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgaW5zdGFuY2Uuc3ViVHJlZSxcbiAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGh5ZHJhdGVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChpc0FzeW5jV3JhcHBlclZOb2RlICYmIHR5cGUuX19hc3luY0h5ZHJhdGUpIHtcbiAgICAgICAgICAgIHR5cGUuX19hc3luY0h5ZHJhdGUoXG4gICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgaHlkcmF0ZVN1YlRyZWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGh5ZHJhdGVTdWJUcmVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChyb290LmNlKSB7XG4gICAgICAgICAgICByb290LmNlLl9pbmplY3RDaGlsZFN0eWxlKHR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHN1YlRyZWUgPSBpbnN0YW5jZS5zdWJUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSk7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhdGNoKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHN1YlRyZWUsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluaXRpYWxWTm9kZS5lbCA9IHN1YlRyZWUuZWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QobSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNBc3luY1dyYXBwZXJWTm9kZSAmJiAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpKSB7XG4gICAgICAgICAgY29uc3Qgc2NvcGVkSW5pdGlhbFZOb2RlID0gaW5pdGlhbFZOb2RlO1xuICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChcbiAgICAgICAgICAgICgpID0+IGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgc2NvcGVkSW5pdGlhbFZOb2RlKSxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdGlhbFZOb2RlLnNoYXBlRmxhZyAmIDI1NiB8fCBwYXJlbnQgJiYgaXNBc3luY1dyYXBwZXIocGFyZW50LnZub2RlKSAmJiBwYXJlbnQudm5vZGUuc2hhcGVGbGFnICYgMjU2KSB7XG4gICAgICAgICAgaW5zdGFuY2UuYSAmJiBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoaW5zdGFuY2UuYSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlLmlzTW91bnRlZCA9IHRydWU7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50QWRkZWQoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGluaXRpYWxWTm9kZSA9IGNvbnRhaW5lciA9IGFuY2hvciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgeyBuZXh0LCBidSwgdSwgcGFyZW50LCB2bm9kZSB9ID0gaW5zdGFuY2U7XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBub25IeWRyYXRlZEFzeW5jUm9vdCA9IGxvY2F0ZU5vbkh5ZHJhdGVkQXN5bmNSb290KGluc3RhbmNlKTtcbiAgICAgICAgICBpZiAobm9uSHlkcmF0ZWRBc3luY1Jvb3QpIHtcbiAgICAgICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgIG5leHQuZWwgPSB2bm9kZS5lbDtcbiAgICAgICAgICAgICAgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyKGluc3RhbmNlLCBuZXh0LCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9uSHlkcmF0ZWRBc3luY1Jvb3QuYXN5bmNEZXAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICghaW5zdGFuY2UuaXNVbm1vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRVcGRhdGVGbigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9yaWdpbk5leHQgPSBuZXh0O1xuICAgICAgICBsZXQgdm5vZGVIb29rO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChuZXh0IHx8IGluc3RhbmNlLnZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCBmYWxzZSk7XG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgbmV4dC5lbCA9IHZub2RlLmVsO1xuICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbmV4dCwgb3B0aW1pemVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0ID0gdm5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1KSB7XG4gICAgICAgICAgaW52b2tlQXJyYXlGbnMoYnUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2bm9kZUhvb2sgPSBuZXh0LnByb3BzICYmIG5leHQucHJvcHMub25Wbm9kZUJlZm9yZVVwZGF0ZSkge1xuICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgbmV4dCwgdm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHRUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZUcmVlID0gaW5zdGFuY2Uuc3ViVHJlZTtcbiAgICAgICAgaW5zdGFuY2Uuc3ViVHJlZSA9IG5leHRUcmVlO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XG4gICAgICAgIH1cbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgcHJldlRyZWUsXG4gICAgICAgICAgbmV4dFRyZWUsXG4gICAgICAgICAgLy8gcGFyZW50IG1heSBoYXZlIGNoYW5nZWQgaWYgaXQncyBpbiBhIHRlbGVwb3J0XG4gICAgICAgICAgaG9zdFBhcmVudE5vZGUocHJldlRyZWUuZWwpLFxuICAgICAgICAgIC8vIGFuY2hvciBtYXkgaGF2ZSBjaGFuZ2VkIGlmIGl0J3MgaW4gYSBmcmFnbWVudFxuICAgICAgICAgIGdldE5leHRIb3N0Tm9kZShwcmV2VHJlZSksXG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlXG4gICAgICAgICk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dC5lbCA9IG5leHRUcmVlLmVsO1xuICAgICAgICBpZiAob3JpZ2luTmV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgIHVwZGF0ZUhPQ0hvc3RFbChpbnN0YW5jZSwgbmV4dFRyZWUuZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1KSB7XG4gICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KHUsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodm5vZGVIb29rID0gbmV4dC5wcm9wcyAmJiBuZXh0LnByb3BzLm9uVm5vZGVVcGRhdGVkKSB7XG4gICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KFxuICAgICAgICAgICAgKCkgPT4gaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBuZXh0LCB2bm9kZSksXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGluc3RhbmNlLnNjb3BlLm9uKCk7XG4gICAgY29uc3QgZWZmZWN0ID0gaW5zdGFuY2UuZWZmZWN0ID0gbmV3IFJlYWN0aXZlRWZmZWN0KGNvbXBvbmVudFVwZGF0ZUZuKTtcbiAgICBpbnN0YW5jZS5zY29wZS5vZmYoKTtcbiAgICBjb25zdCB1cGRhdGUgPSBpbnN0YW5jZS51cGRhdGUgPSBlZmZlY3QucnVuLmJpbmQoZWZmZWN0KTtcbiAgICBjb25zdCBqb2IgPSBpbnN0YW5jZS5qb2IgPSBlZmZlY3QucnVuSWZEaXJ0eS5iaW5kKGVmZmVjdCk7XG4gICAgam9iLmkgPSBpbnN0YW5jZTtcbiAgICBqb2IuaWQgPSBpbnN0YW5jZS51aWQ7XG4gICAgZWZmZWN0LnNjaGVkdWxlciA9ICgpID0+IHF1ZXVlSm9iKGpvYik7XG4gICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgdHJ1ZSk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGVmZmVjdC5vblRyYWNrID0gaW5zdGFuY2UucnRjID8gKGUpID0+IGludm9rZUFycmF5Rm5zKGluc3RhbmNlLnJ0YywgZSkgOiB2b2lkIDA7XG4gICAgICBlZmZlY3Qub25UcmlnZ2VyID0gaW5zdGFuY2UucnRnID8gKGUpID0+IGludm9rZUFycmF5Rm5zKGluc3RhbmNlLnJ0ZywgZSkgOiB2b2lkIDA7XG4gICAgfVxuICAgIHVwZGF0ZSgpO1xuICB9O1xuICBjb25zdCB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIgPSAoaW5zdGFuY2UsIG5leHRWTm9kZSwgb3B0aW1pemVkKSA9PiB7XG4gICAgbmV4dFZOb2RlLmNvbXBvbmVudCA9IGluc3RhbmNlO1xuICAgIGNvbnN0IHByZXZQcm9wcyA9IGluc3RhbmNlLnZub2RlLnByb3BzO1xuICAgIGluc3RhbmNlLnZub2RlID0gbmV4dFZOb2RlO1xuICAgIGluc3RhbmNlLm5leHQgPSBudWxsO1xuICAgIHVwZGF0ZVByb3BzKGluc3RhbmNlLCBuZXh0Vk5vZGUucHJvcHMsIHByZXZQcm9wcywgb3B0aW1pemVkKTtcbiAgICB1cGRhdGVTbG90cyhpbnN0YW5jZSwgbmV4dFZOb2RlLmNoaWxkcmVuLCBvcHRpbWl6ZWQpO1xuICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICBmbHVzaFByZUZsdXNoQ2JzKGluc3RhbmNlKTtcbiAgICByZXNldFRyYWNraW5nKCk7XG4gIH07XG4gIGNvbnN0IHBhdGNoQ2hpbGRyZW4gPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3QgYzEgPSBuMSAmJiBuMS5jaGlsZHJlbjtcbiAgICBjb25zdCBwcmV2U2hhcGVGbGFnID0gbjEgPyBuMS5zaGFwZUZsYWcgOiAwO1xuICAgIGNvbnN0IGMyID0gbjIuY2hpbGRyZW47XG4gICAgY29uc3QgeyBwYXRjaEZsYWcsIHNoYXBlRmxhZyB9ID0gbjI7XG4gICAgaWYgKHBhdGNoRmxhZyA+IDApIHtcbiAgICAgIGlmIChwYXRjaEZsYWcgJiAxMjgpIHtcbiAgICAgICAgcGF0Y2hLZXllZENoaWxkcmVuKFxuICAgICAgICAgIGMxLFxuICAgICAgICAgIGMyLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAocGF0Y2hGbGFnICYgMjU2KSB7XG4gICAgICAgIHBhdGNoVW5rZXllZENoaWxkcmVuKFxuICAgICAgICAgIGMxLFxuICAgICAgICAgIGMyLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDgpIHtcbiAgICAgIGlmIChwcmV2U2hhcGVGbGFnICYgMTYpIHtcbiAgICAgICAgdW5tb3VudENoaWxkcmVuKGMxLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChjMiAhPT0gYzEpIHtcbiAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGNvbnRhaW5lciwgYzIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgICAgIHBhdGNoS2V5ZWRDaGlsZHJlbihcbiAgICAgICAgICAgIGMxLFxuICAgICAgICAgICAgYzIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdW5tb3VudENoaWxkcmVuKGMxLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByZXZTaGFwZUZsYWcgJiA4KSB7XG4gICAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGNvbnRhaW5lciwgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgICAgbW91bnRDaGlsZHJlbihcbiAgICAgICAgICAgIGMyLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBwYXRjaFVua2V5ZWRDaGlsZHJlbiA9IChjMSwgYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgYzEgPSBjMSB8fCBFTVBUWV9BUlI7XG4gICAgYzIgPSBjMiB8fCBFTVBUWV9BUlI7XG4gICAgY29uc3Qgb2xkTGVuZ3RoID0gYzEubGVuZ3RoO1xuICAgIGNvbnN0IG5ld0xlbmd0aCA9IGMyLmxlbmd0aDtcbiAgICBjb25zdCBjb21tb25MZW5ndGggPSBNYXRoLm1pbihvbGRMZW5ndGgsIG5ld0xlbmd0aCk7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGNvbW1vbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBuZXh0Q2hpbGQgPSBjMltpXSA9IG9wdGltaXplZCA/IGNsb25lSWZNb3VudGVkKGMyW2ldKSA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKTtcbiAgICAgIHBhdGNoKFxuICAgICAgICBjMVtpXSxcbiAgICAgICAgbmV4dENoaWxkLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChvbGRMZW5ndGggPiBuZXdMZW5ndGgpIHtcbiAgICAgIHVubW91bnRDaGlsZHJlbihcbiAgICAgICAgYzEsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIHRydWUsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBjb21tb25MZW5ndGhcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vdW50Q2hpbGRyZW4oXG4gICAgICAgIGMyLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgY29tbW9uTGVuZ3RoXG4gICAgICApO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF0Y2hLZXllZENoaWxkcmVuID0gKGMxLCBjMiwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3QgbDIgPSBjMi5sZW5ndGg7XG4gICAgbGV0IGUxID0gYzEubGVuZ3RoIC0gMTtcbiAgICBsZXQgZTIgPSBsMiAtIDE7XG4gICAgd2hpbGUgKGkgPD0gZTEgJiYgaSA8PSBlMikge1xuICAgICAgY29uc3QgbjEgPSBjMVtpXTtcbiAgICAgIGNvbnN0IG4yID0gYzJbaV0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjMltpXSkgOiBub3JtYWxpemVWTm9kZShjMltpXSk7XG4gICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbjEsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9XG4gICAgd2hpbGUgKGkgPD0gZTEgJiYgaSA8PSBlMikge1xuICAgICAgY29uc3QgbjEgPSBjMVtlMV07XG4gICAgICBjb25zdCBuMiA9IGMyW2UyXSA9IG9wdGltaXplZCA/IGNsb25lSWZNb3VudGVkKGMyW2UyXSkgOiBub3JtYWxpemVWTm9kZShjMltlMl0pO1xuICAgICAgaWYgKGlzU2FtZVZOb2RlVHlwZShuMSwgbjIpKSB7XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG4xLFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBlMS0tO1xuICAgICAgZTItLTtcbiAgICB9XG4gICAgaWYgKGkgPiBlMSkge1xuICAgICAgaWYgKGkgPD0gZTIpIHtcbiAgICAgICAgY29uc3QgbmV4dFBvcyA9IGUyICsgMTtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gbmV4dFBvcyA8IGwyID8gYzJbbmV4dFBvc10uZWwgOiBwYXJlbnRBbmNob3I7XG4gICAgICAgIHdoaWxlIChpIDw9IGUyKSB7XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgYzJbaV0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjMltpXSkgOiBub3JtYWxpemVWTm9kZShjMltpXSksXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpID4gZTIpIHtcbiAgICAgIHdoaWxlIChpIDw9IGUxKSB7XG4gICAgICAgIHVubW91bnQoYzFbaV0sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHMxID0gaTtcbiAgICAgIGNvbnN0IHMyID0gaTtcbiAgICAgIGNvbnN0IGtleVRvTmV3SW5kZXhNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgZm9yIChpID0gczI7IGkgPD0gZTI7IGkrKykge1xuICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSBjMltpXSA9IG9wdGltaXplZCA/IGNsb25lSWZNb3VudGVkKGMyW2ldKSA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKTtcbiAgICAgICAgaWYgKG5leHRDaGlsZC5rZXkgIT0gbnVsbCkge1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGtleVRvTmV3SW5kZXhNYXAuaGFzKG5leHRDaGlsZC5rZXkpKSB7XG4gICAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAgIGBEdXBsaWNhdGUga2V5cyBmb3VuZCBkdXJpbmcgdXBkYXRlOmAsXG4gICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG5leHRDaGlsZC5rZXkpLFxuICAgICAgICAgICAgICBgTWFrZSBzdXJlIGtleXMgYXJlIHVuaXF1ZS5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrZXlUb05ld0luZGV4TWFwLnNldChuZXh0Q2hpbGQua2V5LCBpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGo7XG4gICAgICBsZXQgcGF0Y2hlZCA9IDA7XG4gICAgICBjb25zdCB0b0JlUGF0Y2hlZCA9IGUyIC0gczIgKyAxO1xuICAgICAgbGV0IG1vdmVkID0gZmFsc2U7XG4gICAgICBsZXQgbWF4TmV3SW5kZXhTb0ZhciA9IDA7XG4gICAgICBjb25zdCBuZXdJbmRleFRvT2xkSW5kZXhNYXAgPSBuZXcgQXJyYXkodG9CZVBhdGNoZWQpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRvQmVQYXRjaGVkOyBpKyspIG5ld0luZGV4VG9PbGRJbmRleE1hcFtpXSA9IDA7XG4gICAgICBmb3IgKGkgPSBzMTsgaSA8PSBlMTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHByZXZDaGlsZCA9IGMxW2ldO1xuICAgICAgICBpZiAocGF0Y2hlZCA+PSB0b0JlUGF0Y2hlZCkge1xuICAgICAgICAgIHVubW91bnQocHJldkNoaWxkLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3SW5kZXg7XG4gICAgICAgIGlmIChwcmV2Q2hpbGQua2V5ICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdJbmRleCA9IGtleVRvTmV3SW5kZXhNYXAuZ2V0KHByZXZDaGlsZC5rZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoaiA9IHMyOyBqIDw9IGUyOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChuZXdJbmRleFRvT2xkSW5kZXhNYXBbaiAtIHMyXSA9PT0gMCAmJiBpc1NhbWVWTm9kZVR5cGUocHJldkNoaWxkLCBjMltqXSkpIHtcbiAgICAgICAgICAgICAgbmV3SW5kZXggPSBqO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0luZGV4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICB1bm1vdW50KHByZXZDaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3SW5kZXhUb09sZEluZGV4TWFwW25ld0luZGV4IC0gczJdID0gaSArIDE7XG4gICAgICAgICAgaWYgKG5ld0luZGV4ID49IG1heE5ld0luZGV4U29GYXIpIHtcbiAgICAgICAgICAgIG1heE5ld0luZGV4U29GYXIgPSBuZXdJbmRleDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW92ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXRjaChcbiAgICAgICAgICAgIHByZXZDaGlsZCxcbiAgICAgICAgICAgIGMyW25ld0luZGV4XSxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgICAgcGF0Y2hlZCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZSA9IG1vdmVkID8gZ2V0U2VxdWVuY2UobmV3SW5kZXhUb09sZEluZGV4TWFwKSA6IEVNUFRZX0FSUjtcbiAgICAgIGogPSBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZS5sZW5ndGggLSAxO1xuICAgICAgZm9yIChpID0gdG9CZVBhdGNoZWQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBuZXh0SW5kZXggPSBzMiArIGk7XG4gICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IGMyW25leHRJbmRleF07XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHRJbmRleCArIDEgPCBsMiA/IGMyW25leHRJbmRleCArIDFdLmVsIDogcGFyZW50QW5jaG9yO1xuICAgICAgICBpZiAobmV3SW5kZXhUb09sZEluZGV4TWFwW2ldID09PSAwKSB7XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgbmV4dENoaWxkLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKG1vdmVkKSB7XG4gICAgICAgICAgaWYgKGogPCAwIHx8IGkgIT09IGluY3JlYXNpbmdOZXdJbmRleFNlcXVlbmNlW2pdKSB7XG4gICAgICAgICAgICBtb3ZlKG5leHRDaGlsZCwgY29udGFpbmVyLCBhbmNob3IsIDIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3ZlID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUsIHBhcmVudFN1c3BlbnNlID0gbnVsbCkgPT4ge1xuICAgIGNvbnN0IHsgZWwsIHR5cGUsIHRyYW5zaXRpb24sIGNoaWxkcmVuLCBzaGFwZUZsYWcgfSA9IHZub2RlO1xuICAgIGlmIChzaGFwZUZsYWcgJiA2KSB7XG4gICAgICBtb3ZlKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlLCBjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICB2bm9kZS5zdXNwZW5zZS5tb3ZlKGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzaGFwZUZsYWcgJiA2NCkge1xuICAgICAgdHlwZS5tb3ZlKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgaW50ZXJuYWxzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IEZyYWdtZW50KSB7XG4gICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1vdmUoY2hpbGRyZW5baV0sIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XG4gICAgICB9XG4gICAgICBob3N0SW5zZXJ0KHZub2RlLmFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gU3RhdGljKSB7XG4gICAgICBtb3ZlU3RhdGljTm9kZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZWVkVHJhbnNpdGlvbjIgPSBtb3ZlVHlwZSAhPT0gMiAmJiBzaGFwZUZsYWcgJiAxICYmIHRyYW5zaXRpb247XG4gICAgaWYgKG5lZWRUcmFuc2l0aW9uMikge1xuICAgICAgaWYgKG1vdmVUeXBlID09PSAwKSB7XG4gICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xuICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB0cmFuc2l0aW9uLmVudGVyKGVsKSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeyBsZWF2ZSwgZGVsYXlMZWF2ZSwgYWZ0ZXJMZWF2ZSB9ID0gdHJhbnNpdGlvbjtcbiAgICAgICAgY29uc3QgcmVtb3ZlMiA9ICgpID0+IGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgY29uc3QgcGVyZm9ybUxlYXZlID0gKCkgPT4ge1xuICAgICAgICAgIGxlYXZlKGVsLCAoKSA9PiB7XG4gICAgICAgICAgICByZW1vdmUyKCk7XG4gICAgICAgICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICAgICAgICBkZWxheUxlYXZlKGVsLCByZW1vdmUyLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlcmZvcm1MZWF2ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHVubW91bnQgPSAodm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlID0gZmFsc2UsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIHByb3BzLFxuICAgICAgcmVmLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBkeW5hbWljQ2hpbGRyZW4sXG4gICAgICBzaGFwZUZsYWcsXG4gICAgICBwYXRjaEZsYWcsXG4gICAgICBkaXJzLFxuICAgICAgY2FjaGVJbmRleFxuICAgIH0gPSB2bm9kZTtcbiAgICBpZiAocGF0Y2hGbGFnID09PSAtMikge1xuICAgICAgb3B0aW1pemVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChyZWYgIT0gbnVsbCkge1xuICAgICAgc2V0UmVmKHJlZiwgbnVsbCwgcGFyZW50U3VzcGVuc2UsIHZub2RlLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKGNhY2hlSW5kZXggIT0gbnVsbCkge1xuICAgICAgcGFyZW50Q29tcG9uZW50LnJlbmRlckNhY2hlW2NhY2hlSW5kZXhdID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAoc2hhcGVGbGFnICYgMjU2KSB7XG4gICAgICBwYXJlbnRDb21wb25lbnQuY3R4LmRlYWN0aXZhdGUodm5vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaG91bGRJbnZva2VEaXJzID0gc2hhcGVGbGFnICYgMSAmJiBkaXJzO1xuICAgIGNvbnN0IHNob3VsZEludm9rZVZub2RlSG9vayA9ICFpc0FzeW5jV3JhcHBlcih2bm9kZSk7XG4gICAgbGV0IHZub2RlSG9vaztcbiAgICBpZiAoc2hvdWxkSW52b2tlVm5vZGVIb29rICYmICh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlQmVmb3JlVW5tb3VudCkpIHtcbiAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgIH1cbiAgICBpZiAoc2hhcGVGbGFnICYgNikge1xuICAgICAgdW5tb3VudENvbXBvbmVudCh2bm9kZS5jb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgICAgdm5vZGUuc3VzcGVuc2UudW5tb3VudChwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkSW52b2tlRGlycykge1xuICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwiYmVmb3JlVW5tb3VudFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaGFwZUZsYWcgJiA2NCkge1xuICAgICAgICB2bm9kZS50eXBlLnJlbW92ZShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgaW50ZXJuYWxzLFxuICAgICAgICAgIGRvUmVtb3ZlXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGR5bmFtaWNDaGlsZHJlbiAmJiAvLyAjNTE1NFxuICAgICAgLy8gd2hlbiB2LW9uY2UgaXMgdXNlZCBpbnNpZGUgYSBibG9jaywgc2V0QmxvY2tUcmFja2luZygtMSkgbWFya3MgdGhlXG4gICAgICAvLyBwYXJlbnQgYmxvY2sgd2l0aCBoYXNPbmNlOiB0cnVlXG4gICAgICAvLyBzbyB0aGF0IGl0IGRvZXNuJ3QgdGFrZSB0aGUgZmFzdCBwYXRoIGR1cmluZyB1bm1vdW50IC0gb3RoZXJ3aXNlXG4gICAgICAvLyBjb21wb25lbnRzIG5lc3RlZCBpbiB2LW9uY2UgYXJlIG5ldmVyIHVubW91bnRlZC5cbiAgICAgICFkeW5hbWljQ2hpbGRyZW4uaGFzT25jZSAmJiAvLyAjMTE1MzogZmFzdCBwYXRoIHNob3VsZCBub3QgYmUgdGFrZW4gZm9yIG5vbi1zdGFibGUgKHYtZm9yKSBmcmFnbWVudHNcbiAgICAgICh0eXBlICE9PSBGcmFnbWVudCB8fCBwYXRjaEZsYWcgPiAwICYmIHBhdGNoRmxhZyAmIDY0KSkge1xuICAgICAgICB1bm1vdW50Q2hpbGRyZW4oXG4gICAgICAgICAgZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IEZyYWdtZW50ICYmIHBhdGNoRmxhZyAmICgxMjggfCAyNTYpIHx8ICFvcHRpbWl6ZWQgJiYgc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgICAgdW5tb3VudENoaWxkcmVuKGNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChkb1JlbW92ZSkge1xuICAgICAgICByZW1vdmUodm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2hvdWxkSW52b2tlVm5vZGVIb29rICYmICh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlVW5tb3VudGVkKSB8fCBzaG91bGRJbnZva2VEaXJzKSB7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICB2bm9kZUhvb2sgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICAgIHNob3VsZEludm9rZURpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBcInVubW91bnRlZFwiKTtcbiAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlbW92ZSA9ICh2bm9kZSkgPT4ge1xuICAgIGNvbnN0IHsgdHlwZSwgZWwsIGFuY2hvciwgdHJhbnNpdGlvbiB9ID0gdm5vZGU7XG4gICAgaWYgKHR5cGUgPT09IEZyYWdtZW50KSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB2bm9kZS5wYXRjaEZsYWcgPiAwICYmIHZub2RlLnBhdGNoRmxhZyAmIDIwNDggJiYgdHJhbnNpdGlvbiAmJiAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQpIHtcbiAgICAgICAgdm5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gQ29tbWVudCkge1xuICAgICAgICAgICAgaG9zdFJlbW92ZShjaGlsZC5lbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZShjaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUZyYWdtZW50KGVsLCBhbmNob3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gU3RhdGljKSB7XG4gICAgICByZW1vdmVTdGF0aWNOb2RlKHZub2RlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGVyZm9ybVJlbW92ZSA9ICgpID0+IHtcbiAgICAgIGhvc3RSZW1vdmUoZWwpO1xuICAgICAgaWYgKHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkICYmIHRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSkge1xuICAgICAgICB0cmFuc2l0aW9uLmFmdGVyTGVhdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxICYmIHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkKSB7XG4gICAgICBjb25zdCB7IGxlYXZlLCBkZWxheUxlYXZlIH0gPSB0cmFuc2l0aW9uO1xuICAgICAgY29uc3QgcGVyZm9ybUxlYXZlID0gKCkgPT4gbGVhdmUoZWwsIHBlcmZvcm1SZW1vdmUpO1xuICAgICAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICAgICAgZGVsYXlMZWF2ZSh2bm9kZS5lbCwgcGVyZm9ybVJlbW92ZSwgcGVyZm9ybUxlYXZlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlcmZvcm1MZWF2ZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZXJmb3JtUmVtb3ZlKCk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZW1vdmVGcmFnbWVudCA9IChjdXIsIGVuZCkgPT4ge1xuICAgIGxldCBuZXh0O1xuICAgIHdoaWxlIChjdXIgIT09IGVuZCkge1xuICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhjdXIpO1xuICAgICAgaG9zdFJlbW92ZShjdXIpO1xuICAgICAgY3VyID0gbmV4dDtcbiAgICB9XG4gICAgaG9zdFJlbW92ZShlbmQpO1xuICB9O1xuICBjb25zdCB1bm1vdW50Q29tcG9uZW50ID0gKGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpID0+IHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpbnN0YW5jZS50eXBlLl9faG1ySWQpIHtcbiAgICAgIHVucmVnaXN0ZXJITVIoaW5zdGFuY2UpO1xuICAgIH1cbiAgICBjb25zdCB7IGJ1bSwgc2NvcGUsIGpvYiwgc3ViVHJlZSwgdW0sIG0sIGEgfSA9IGluc3RhbmNlO1xuICAgIGludmFsaWRhdGVNb3VudChtKTtcbiAgICBpbnZhbGlkYXRlTW91bnQoYSk7XG4gICAgaWYgKGJ1bSkge1xuICAgICAgaW52b2tlQXJyYXlGbnMoYnVtKTtcbiAgICB9XG4gICAgc2NvcGUuc3RvcCgpO1xuICAgIGlmIChqb2IpIHtcbiAgICAgIGpvYi5mbGFncyB8PSA4O1xuICAgICAgdW5tb3VudChzdWJUcmVlLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcbiAgICB9XG4gICAgaWYgKHVtKSB7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QodW0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICB9XG4gICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgIGluc3RhbmNlLmlzVW5tb3VudGVkID0gdHJ1ZTtcbiAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgaWYgKHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggJiYgIXBhcmVudFN1c3BlbnNlLmlzVW5tb3VudGVkICYmIGluc3RhbmNlLmFzeW5jRGVwICYmICFpbnN0YW5jZS5hc3luY1Jlc29sdmVkICYmIGluc3RhbmNlLnN1c3BlbnNlSWQgPT09IHBhcmVudFN1c3BlbnNlLnBlbmRpbmdJZCkge1xuICAgICAgcGFyZW50U3VzcGVuc2UuZGVwcy0tO1xuICAgICAgaWYgKHBhcmVudFN1c3BlbnNlLmRlcHMgPT09IDApIHtcbiAgICAgICAgcGFyZW50U3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZChpbnN0YW5jZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCB1bm1vdW50Q2hpbGRyZW4gPSAoY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlID0gZmFsc2UsIG9wdGltaXplZCA9IGZhbHNlLCBzdGFydCA9IDApID0+IHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdW5tb3VudChjaGlsZHJlbltpXSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUsIG9wdGltaXplZCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBnZXROZXh0SG9zdE5vZGUgPSAodm5vZGUpID0+IHtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNikge1xuICAgICAgcmV0dXJuIGdldE5leHRIb3N0Tm9kZSh2bm9kZS5jb21wb25lbnQuc3ViVHJlZSk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgIHJldHVybiB2bm9kZS5zdXNwZW5zZS5uZXh0KCk7XG4gICAgfVxuICAgIGNvbnN0IGVsID0gaG9zdE5leHRTaWJsaW5nKHZub2RlLmFuY2hvciB8fCB2bm9kZS5lbCk7XG4gICAgY29uc3QgdGVsZXBvcnRFbmQgPSBlbCAmJiBlbFtUZWxlcG9ydEVuZEtleV07XG4gICAgcmV0dXJuIHRlbGVwb3J0RW5kID8gaG9zdE5leHRTaWJsaW5nKHRlbGVwb3J0RW5kKSA6IGVsO1xuICB9O1xuICBsZXQgaXNGbHVzaGluZyA9IGZhbHNlO1xuICBjb25zdCByZW5kZXIgPSAodm5vZGUsIGNvbnRhaW5lciwgbmFtZXNwYWNlKSA9PiB7XG4gICAgaWYgKHZub2RlID09IG51bGwpIHtcbiAgICAgIGlmIChjb250YWluZXIuX3Zub2RlKSB7XG4gICAgICAgIHVubW91bnQoY29udGFpbmVyLl92bm9kZSwgbnVsbCwgbnVsbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGNoKFxuICAgICAgICBjb250YWluZXIuX3Zub2RlIHx8IG51bGwsXG4gICAgICAgIHZub2RlLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG5hbWVzcGFjZVxuICAgICAgKTtcbiAgICB9XG4gICAgY29udGFpbmVyLl92bm9kZSA9IHZub2RlO1xuICAgIGlmICghaXNGbHVzaGluZykge1xuICAgICAgaXNGbHVzaGluZyA9IHRydWU7XG4gICAgICBmbHVzaFByZUZsdXNoQ2JzKCk7XG4gICAgICBmbHVzaFBvc3RGbHVzaENicygpO1xuICAgICAgaXNGbHVzaGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHA6IHBhdGNoLFxuICAgIHVtOiB1bm1vdW50LFxuICAgIG06IG1vdmUsXG4gICAgcjogcmVtb3ZlLFxuICAgIG10OiBtb3VudENvbXBvbmVudCxcbiAgICBtYzogbW91bnRDaGlsZHJlbixcbiAgICBwYzogcGF0Y2hDaGlsZHJlbixcbiAgICBwYmM6IHBhdGNoQmxvY2tDaGlsZHJlbixcbiAgICBuOiBnZXROZXh0SG9zdE5vZGUsXG4gICAgbzogb3B0aW9uc1xuICB9O1xuICBsZXQgaHlkcmF0ZTtcbiAgbGV0IGh5ZHJhdGVOb2RlO1xuICBpZiAoY3JlYXRlSHlkcmF0aW9uRm5zKSB7XG4gICAgW2h5ZHJhdGUsIGh5ZHJhdGVOb2RlXSA9IGNyZWF0ZUh5ZHJhdGlvbkZucyhcbiAgICAgIGludGVybmFsc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZW5kZXIsXG4gICAgaHlkcmF0ZSxcbiAgICBjcmVhdGVBcHA6IGNyZWF0ZUFwcEFQSShyZW5kZXIsIGh5ZHJhdGUpXG4gIH07XG59XG5mdW5jdGlvbiByZXNvbHZlQ2hpbGRyZW5OYW1lc3BhY2UoeyB0eXBlLCBwcm9wcyB9LCBjdXJyZW50TmFtZXNwYWNlKSB7XG4gIHJldHVybiBjdXJyZW50TmFtZXNwYWNlID09PSBcInN2Z1wiICYmIHR5cGUgPT09IFwiZm9yZWlnbk9iamVjdFwiIHx8IGN1cnJlbnROYW1lc3BhY2UgPT09IFwibWF0aG1sXCIgJiYgdHlwZSA9PT0gXCJhbm5vdGF0aW9uLXhtbFwiICYmIHByb3BzICYmIHByb3BzLmVuY29kaW5nICYmIHByb3BzLmVuY29kaW5nLmluY2x1ZGVzKFwiaHRtbFwiKSA/IHZvaWQgMCA6IGN1cnJlbnROYW1lc3BhY2U7XG59XG5mdW5jdGlvbiB0b2dnbGVSZWN1cnNlKHsgZWZmZWN0LCBqb2IgfSwgYWxsb3dlZCkge1xuICBpZiAoYWxsb3dlZCkge1xuICAgIGVmZmVjdC5mbGFncyB8PSAzMjtcbiAgICBqb2IuZmxhZ3MgfD0gNDtcbiAgfSBlbHNlIHtcbiAgICBlZmZlY3QuZmxhZ3MgJj0gfjMyO1xuICAgIGpvYi5mbGFncyAmPSB+NDtcbiAgfVxufVxuZnVuY3Rpb24gbmVlZFRyYW5zaXRpb24ocGFyZW50U3VzcGVuc2UsIHRyYW5zaXRpb24pIHtcbiAgcmV0dXJuICghcGFyZW50U3VzcGVuc2UgfHwgcGFyZW50U3VzcGVuc2UgJiYgIXBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpICYmIHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkO1xufVxuZnVuY3Rpb24gdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHNoYWxsb3cgPSBmYWxzZSkge1xuICBjb25zdCBjaDEgPSBuMS5jaGlsZHJlbjtcbiAgY29uc3QgY2gyID0gbjIuY2hpbGRyZW47XG4gIGlmIChpc0FycmF5KGNoMSkgJiYgaXNBcnJheShjaDIpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaDEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGMxID0gY2gxW2ldO1xuICAgICAgbGV0IGMyID0gY2gyW2ldO1xuICAgICAgaWYgKGMyLnNoYXBlRmxhZyAmIDEgJiYgIWMyLmR5bmFtaWNDaGlsZHJlbikge1xuICAgICAgICBpZiAoYzIucGF0Y2hGbGFnIDw9IDAgfHwgYzIucGF0Y2hGbGFnID09PSAzMikge1xuICAgICAgICAgIGMyID0gY2gyW2ldID0gY2xvbmVJZk1vdW50ZWQoY2gyW2ldKTtcbiAgICAgICAgICBjMi5lbCA9IGMxLmVsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2hhbGxvdyAmJiBjMi5wYXRjaEZsYWcgIT09IC0yKVxuICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4oYzEsIGMyKTtcbiAgICAgIH1cbiAgICAgIGlmIChjMi50eXBlID09PSBUZXh0KSB7XG4gICAgICAgIGMyLmVsID0gYzEuZWw7XG4gICAgICB9XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjMi50eXBlID09PSBDb21tZW50ICYmICFjMi5lbCkge1xuICAgICAgICBjMi5lbCA9IGMxLmVsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0U2VxdWVuY2UoYXJyKSB7XG4gIGNvbnN0IHAgPSBhcnIuc2xpY2UoKTtcbiAgY29uc3QgcmVzdWx0ID0gWzBdO1xuICBsZXQgaSwgaiwgdSwgdiwgYztcbiAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgYXJySSA9IGFycltpXTtcbiAgICBpZiAoYXJySSAhPT0gMCkge1xuICAgICAgaiA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoYXJyW2pdIDwgYXJySSkge1xuICAgICAgICBwW2ldID0gajtcbiAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdSA9IDA7XG4gICAgICB2ID0gcmVzdWx0Lmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAodSA8IHYpIHtcbiAgICAgICAgYyA9IHUgKyB2ID4+IDE7XG4gICAgICAgIGlmIChhcnJbcmVzdWx0W2NdXSA8IGFyckkpIHtcbiAgICAgICAgICB1ID0gYyArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdiA9IGM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhcnJJIDwgYXJyW3Jlc3VsdFt1XV0pIHtcbiAgICAgICAgaWYgKHUgPiAwKSB7XG4gICAgICAgICAgcFtpXSA9IHJlc3VsdFt1IC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W3VdID0gaTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdSA9IHJlc3VsdC5sZW5ndGg7XG4gIHYgPSByZXN1bHRbdSAtIDFdO1xuICB3aGlsZSAodS0tID4gMCkge1xuICAgIHJlc3VsdFt1XSA9IHY7XG4gICAgdiA9IHBbdl07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGxvY2F0ZU5vbkh5ZHJhdGVkQXN5bmNSb290KGluc3RhbmNlKSB7XG4gIGNvbnN0IHN1YkNvbXBvbmVudCA9IGluc3RhbmNlLnN1YlRyZWUuY29tcG9uZW50O1xuICBpZiAoc3ViQ29tcG9uZW50KSB7XG4gICAgaWYgKHN1YkNvbXBvbmVudC5hc3luY0RlcCAmJiAhc3ViQ29tcG9uZW50LmFzeW5jUmVzb2x2ZWQpIHtcbiAgICAgIHJldHVybiBzdWJDb21wb25lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsb2NhdGVOb25IeWRyYXRlZEFzeW5jUm9vdChzdWJDb21wb25lbnQpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaW52YWxpZGF0ZU1vdW50KGhvb2tzKSB7XG4gIGlmIChob29rcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspXG4gICAgICBob29rc1tpXS5mbGFncyB8PSA4O1xuICB9XG59XG5cbmNvbnN0IHNzckNvbnRleHRLZXkgPSBTeW1ib2wuZm9yKFwidi1zY3hcIik7XG5jb25zdCB1c2VTU1JDb250ZXh0ID0gKCkgPT4ge1xuICB7XG4gICAgY29uc3QgY3R4ID0gaW5qZWN0KHNzckNvbnRleHRLZXkpO1xuICAgIGlmICghY3R4KSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShcbiAgICAgICAgYFNlcnZlciByZW5kZXJpbmcgY29udGV4dCBub3QgcHJvdmlkZWQuIE1ha2Ugc3VyZSB0byBvbmx5IGNhbGwgdXNlU1NSQ29udGV4dCgpIGNvbmRpdGlvbmFsbHkgaW4gdGhlIHNlcnZlciBidWlsZC5gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gY3R4O1xuICB9XG59O1xuXG5mdW5jdGlvbiB3YXRjaEVmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRvV2F0Y2goZWZmZWN0LCBudWxsLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHdhdGNoUG9zdEVmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRvV2F0Y2goXG4gICAgZWZmZWN0LFxuICAgIG51bGwsXG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGV4dGVuZCh7fSwgb3B0aW9ucywgeyBmbHVzaDogXCJwb3N0XCIgfSkgOiB7IGZsdXNoOiBcInBvc3RcIiB9XG4gICk7XG59XG5mdW5jdGlvbiB3YXRjaFN5bmNFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XG4gIHJldHVybiBkb1dhdGNoKFxuICAgIGVmZmVjdCxcbiAgICBudWxsLFxuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBleHRlbmQoe30sIG9wdGlvbnMsIHsgZmx1c2g6IFwic3luY1wiIH0pIDogeyBmbHVzaDogXCJzeW5jXCIgfVxuICApO1xufVxuZnVuY3Rpb24gd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucykge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNGdW5jdGlvbihjYikpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgXFxgd2F0Y2goZm4sIG9wdGlvbnM/KVxcYCBzaWduYXR1cmUgaGFzIGJlZW4gbW92ZWQgdG8gYSBzZXBhcmF0ZSBBUEkuIFVzZSBcXGB3YXRjaEVmZmVjdChmbiwgb3B0aW9ucz8pXFxgIGluc3RlYWQuIFxcYHdhdGNoXFxgIG5vdyBvbmx5IHN1cHBvcnRzIFxcYHdhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnM/KSBzaWduYXR1cmUuYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGRvV2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBkb1dhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMgPSBFTVBUWV9PQkopIHtcbiAgY29uc3QgeyBpbW1lZGlhdGUsIGRlZXAsIGZsdXNoLCBvbmNlIH0gPSBvcHRpb25zO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhY2IpIHtcbiAgICBpZiAoaW1tZWRpYXRlICE9PSB2b2lkIDApIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYHdhdGNoKCkgXCJpbW1lZGlhdGVcIiBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyB0aGUgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZGVlcCAhPT0gdm9pZCAwKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGB3YXRjaCgpIFwiZGVlcFwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSB3YXRjaChzb3VyY2UsIGNhbGxiYWNrLCBvcHRpb25zPykgc2lnbmF0dXJlLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChvbmNlICE9PSB2b2lkIDApIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYHdhdGNoKCkgXCJvbmNlXCIgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgdGhlIHdhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgYmFzZVdhdGNoT3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSBiYXNlV2F0Y2hPcHRpb25zLm9uV2FybiA9IHdhcm4kMTtcbiAgY29uc3QgcnVuc0ltbWVkaWF0ZWx5ID0gY2IgJiYgaW1tZWRpYXRlIHx8ICFjYiAmJiBmbHVzaCAhPT0gXCJwb3N0XCI7XG4gIGxldCBzc3JDbGVhbnVwO1xuICBpZiAoaXNJblNTUkNvbXBvbmVudFNldHVwKSB7XG4gICAgaWYgKGZsdXNoID09PSBcInN5bmNcIikge1xuICAgICAgY29uc3QgY3R4ID0gdXNlU1NSQ29udGV4dCgpO1xuICAgICAgc3NyQ2xlYW51cCA9IGN0eC5fX3dhdGNoZXJIYW5kbGVzIHx8IChjdHguX193YXRjaGVySGFuZGxlcyA9IFtdKTtcbiAgICB9IGVsc2UgaWYgKCFydW5zSW1tZWRpYXRlbHkpIHtcbiAgICAgIGNvbnN0IHdhdGNoU3RvcEhhbmRsZSA9ICgpID0+IHtcbiAgICAgIH07XG4gICAgICB3YXRjaFN0b3BIYW5kbGUuc3RvcCA9IE5PT1A7XG4gICAgICB3YXRjaFN0b3BIYW5kbGUucmVzdW1lID0gTk9PUDtcbiAgICAgIHdhdGNoU3RvcEhhbmRsZS5wYXVzZSA9IE5PT1A7XG4gICAgICByZXR1cm4gd2F0Y2hTdG9wSGFuZGxlO1xuICAgIH1cbiAgfVxuICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgYmFzZVdhdGNoT3B0aW9ucy5jYWxsID0gKGZuLCB0eXBlLCBhcmdzKSA9PiBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpO1xuICBsZXQgaXNQcmUgPSBmYWxzZTtcbiAgaWYgKGZsdXNoID09PSBcInBvc3RcIikge1xuICAgIGJhc2VXYXRjaE9wdGlvbnMuc2NoZWR1bGVyID0gKGpvYikgPT4ge1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGpvYiwgaW5zdGFuY2UgJiYgaW5zdGFuY2Uuc3VzcGVuc2UpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoZmx1c2ggIT09IFwic3luY1wiKSB7XG4gICAgaXNQcmUgPSB0cnVlO1xuICAgIGJhc2VXYXRjaE9wdGlvbnMuc2NoZWR1bGVyID0gKGpvYiwgaXNGaXJzdFJ1bikgPT4ge1xuICAgICAgaWYgKGlzRmlyc3RSdW4pIHtcbiAgICAgICAgam9iKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUpvYihqb2IpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgYmFzZVdhdGNoT3B0aW9ucy5hdWdtZW50Sm9iID0gKGpvYikgPT4ge1xuICAgIGlmIChjYikge1xuICAgICAgam9iLmZsYWdzIHw9IDQ7XG4gICAgfVxuICAgIGlmIChpc1ByZSkge1xuICAgICAgam9iLmZsYWdzIHw9IDI7XG4gICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgam9iLmlkID0gaW5zdGFuY2UudWlkO1xuICAgICAgICBqb2IuaSA9IGluc3RhbmNlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3Qgd2F0Y2hIYW5kbGUgPSB3YXRjaCQxKHNvdXJjZSwgY2IsIGJhc2VXYXRjaE9wdGlvbnMpO1xuICBpZiAoaXNJblNTUkNvbXBvbmVudFNldHVwKSB7XG4gICAgaWYgKHNzckNsZWFudXApIHtcbiAgICAgIHNzckNsZWFudXAucHVzaCh3YXRjaEhhbmRsZSk7XG4gICAgfSBlbHNlIGlmIChydW5zSW1tZWRpYXRlbHkpIHtcbiAgICAgIHdhdGNoSGFuZGxlKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB3YXRjaEhhbmRsZTtcbn1cbmZ1bmN0aW9uIGluc3RhbmNlV2F0Y2goc291cmNlLCB2YWx1ZSwgb3B0aW9ucykge1xuICBjb25zdCBwdWJsaWNUaGlzID0gdGhpcy5wcm94eTtcbiAgY29uc3QgZ2V0dGVyID0gaXNTdHJpbmcoc291cmNlKSA/IHNvdXJjZS5pbmNsdWRlcyhcIi5cIikgPyBjcmVhdGVQYXRoR2V0dGVyKHB1YmxpY1RoaXMsIHNvdXJjZSkgOiAoKSA9PiBwdWJsaWNUaGlzW3NvdXJjZV0gOiBzb3VyY2UuYmluZChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKTtcbiAgbGV0IGNiO1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBjYiA9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGNiID0gdmFsdWUuaGFuZGxlcjtcbiAgICBvcHRpb25zID0gdmFsdWU7XG4gIH1cbiAgY29uc3QgcmVzZXQgPSBzZXRDdXJyZW50SW5zdGFuY2UodGhpcyk7XG4gIGNvbnN0IHJlcyA9IGRvV2F0Y2goZ2V0dGVyLCBjYi5iaW5kKHB1YmxpY1RoaXMpLCBvcHRpb25zKTtcbiAgcmVzZXQoKTtcbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhdGhHZXR0ZXIoY3R4LCBwYXRoKSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gcGF0aC5zcGxpdChcIi5cIik7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGV0IGN1ciA9IGN0eDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aCAmJiBjdXI7IGkrKykge1xuICAgICAgY3VyID0gY3VyW3NlZ21lbnRzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlTW9kZWwocHJvcHMsIG5hbWUsIG9wdGlvbnMgPSBFTVBUWV9PQkopIHtcbiAgY29uc3QgaSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaSkge1xuICAgIHdhcm4kMShgdXNlTW9kZWwoKSBjYWxsZWQgd2l0aG91dCBhY3RpdmUgaW5zdGFuY2UuYCk7XG4gICAgcmV0dXJuIHJlZigpO1xuICB9XG4gIGNvbnN0IGNhbWVsaXplZE5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWkucHJvcHNPcHRpb25zWzBdW2NhbWVsaXplZE5hbWVdKSB7XG4gICAgd2FybiQxKGB1c2VNb2RlbCgpIGNhbGxlZCB3aXRoIHByb3AgXCIke25hbWV9XCIgd2hpY2ggaXMgbm90IGRlY2xhcmVkLmApO1xuICAgIHJldHVybiByZWYoKTtcbiAgfVxuICBjb25zdCBoeXBoZW5hdGVkTmFtZSA9IGh5cGhlbmF0ZShuYW1lKTtcbiAgY29uc3QgbW9kaWZpZXJzID0gZ2V0TW9kZWxNb2RpZmllcnMocHJvcHMsIGNhbWVsaXplZE5hbWUpO1xuICBjb25zdCByZXMgPSBjdXN0b21SZWYoKHRyYWNrLCB0cmlnZ2VyKSA9PiB7XG4gICAgbGV0IGxvY2FsVmFsdWU7XG4gICAgbGV0IHByZXZTZXRWYWx1ZSA9IEVNUFRZX09CSjtcbiAgICBsZXQgcHJldkVtaXR0ZWRWYWx1ZTtcbiAgICB3YXRjaFN5bmNFZmZlY3QoKCkgPT4ge1xuICAgICAgY29uc3QgcHJvcFZhbHVlID0gcHJvcHNbY2FtZWxpemVkTmFtZV07XG4gICAgICBpZiAoaGFzQ2hhbmdlZChsb2NhbFZhbHVlLCBwcm9wVmFsdWUpKSB7XG4gICAgICAgIGxvY2FsVmFsdWUgPSBwcm9wVmFsdWU7XG4gICAgICAgIHRyaWdnZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0KCkge1xuICAgICAgICB0cmFjaygpO1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5nZXQgPyBvcHRpb25zLmdldChsb2NhbFZhbHVlKSA6IGxvY2FsVmFsdWU7XG4gICAgICB9LFxuICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGVtaXR0ZWRWYWx1ZSA9IG9wdGlvbnMuc2V0ID8gb3B0aW9ucy5zZXQodmFsdWUpIDogdmFsdWU7XG4gICAgICAgIGlmICghaGFzQ2hhbmdlZChlbWl0dGVkVmFsdWUsIGxvY2FsVmFsdWUpICYmICEocHJldlNldFZhbHVlICE9PSBFTVBUWV9PQkogJiYgaGFzQ2hhbmdlZCh2YWx1ZSwgcHJldlNldFZhbHVlKSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmF3UHJvcHMgPSBpLnZub2RlLnByb3BzO1xuICAgICAgICBpZiAoIShyYXdQcm9wcyAmJiAvLyBjaGVjayBpZiBwYXJlbnQgaGFzIHBhc3NlZCB2LW1vZGVsXG4gICAgICAgIChuYW1lIGluIHJhd1Byb3BzIHx8IGNhbWVsaXplZE5hbWUgaW4gcmF3UHJvcHMgfHwgaHlwaGVuYXRlZE5hbWUgaW4gcmF3UHJvcHMpICYmIChgb25VcGRhdGU6JHtuYW1lfWAgaW4gcmF3UHJvcHMgfHwgYG9uVXBkYXRlOiR7Y2FtZWxpemVkTmFtZX1gIGluIHJhd1Byb3BzIHx8IGBvblVwZGF0ZToke2h5cGhlbmF0ZWROYW1lfWAgaW4gcmF3UHJvcHMpKSkge1xuICAgICAgICAgIGxvY2FsVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0cmlnZ2VyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaS5lbWl0KGB1cGRhdGU6JHtuYW1lfWAsIGVtaXR0ZWRWYWx1ZSk7XG4gICAgICAgIGlmIChoYXNDaGFuZ2VkKHZhbHVlLCBlbWl0dGVkVmFsdWUpICYmIGhhc0NoYW5nZWQodmFsdWUsIHByZXZTZXRWYWx1ZSkgJiYgIWhhc0NoYW5nZWQoZW1pdHRlZFZhbHVlLCBwcmV2RW1pdHRlZFZhbHVlKSkge1xuICAgICAgICAgIHRyaWdnZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2U2V0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcHJldkVtaXR0ZWRWYWx1ZSA9IGVtaXR0ZWRWYWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgcmVzW1N5bWJvbC5pdGVyYXRvcl0gPSAoKSA9PiB7XG4gICAgbGV0IGkyID0gMDtcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dCgpIHtcbiAgICAgICAgaWYgKGkyIDwgMikge1xuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBpMisrID8gbW9kaWZpZXJzIHx8IEVNUFRZX09CSiA6IHJlcywgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICByZXR1cm4gcmVzO1xufVxuY29uc3QgZ2V0TW9kZWxNb2RpZmllcnMgPSAocHJvcHMsIG1vZGVsTmFtZSkgPT4ge1xuICByZXR1cm4gbW9kZWxOYW1lID09PSBcIm1vZGVsVmFsdWVcIiB8fCBtb2RlbE5hbWUgPT09IFwibW9kZWwtdmFsdWVcIiA/IHByb3BzLm1vZGVsTW9kaWZpZXJzIDogcHJvcHNbYCR7bW9kZWxOYW1lfU1vZGlmaWVyc2BdIHx8IHByb3BzW2Ake2NhbWVsaXplKG1vZGVsTmFtZSl9TW9kaWZpZXJzYF0gfHwgcHJvcHNbYCR7aHlwaGVuYXRlKG1vZGVsTmFtZSl9TW9kaWZpZXJzYF07XG59O1xuXG5mdW5jdGlvbiBlbWl0KGluc3RhbmNlLCBldmVudCwgLi4ucmF3QXJncykge1xuICBpZiAoaW5zdGFuY2UuaXNVbm1vdW50ZWQpIHJldHVybjtcbiAgY29uc3QgcHJvcHMgPSBpbnN0YW5jZS52bm9kZS5wcm9wcyB8fCBFTVBUWV9PQko7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY29uc3Qge1xuICAgICAgZW1pdHNPcHRpb25zLFxuICAgICAgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXVxuICAgIH0gPSBpbnN0YW5jZTtcbiAgICBpZiAoZW1pdHNPcHRpb25zKSB7XG4gICAgICBpZiAoIShldmVudCBpbiBlbWl0c09wdGlvbnMpICYmIHRydWUpIHtcbiAgICAgICAgaWYgKCFwcm9wc09wdGlvbnMgfHwgISh0b0hhbmRsZXJLZXkoY2FtZWxpemUoZXZlbnQpKSBpbiBwcm9wc09wdGlvbnMpKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYENvbXBvbmVudCBlbWl0dGVkIGV2ZW50IFwiJHtldmVudH1cIiBidXQgaXQgaXMgbmVpdGhlciBkZWNsYXJlZCBpbiB0aGUgZW1pdHMgb3B0aW9uIG5vciBhcyBhbiBcIiR7dG9IYW5kbGVyS2V5KGNhbWVsaXplKGV2ZW50KSl9XCIgcHJvcC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gZW1pdHNPcHRpb25zW2V2ZW50XTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsaWRhdG9yKSkge1xuICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSB2YWxpZGF0b3IoLi4ucmF3QXJncyk7XG4gICAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIGV2ZW50IGFyZ3VtZW50czogZXZlbnQgdmFsaWRhdGlvbiBmYWlsZWQgZm9yIGV2ZW50IFwiJHtldmVudH1cIi5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBsZXQgYXJncyA9IHJhd0FyZ3M7XG4gIGNvbnN0IGlzTW9kZWxMaXN0ZW5lciA9IGV2ZW50LnN0YXJ0c1dpdGgoXCJ1cGRhdGU6XCIpO1xuICBjb25zdCBtb2RpZmllcnMgPSBpc01vZGVsTGlzdGVuZXIgJiYgZ2V0TW9kZWxNb2RpZmllcnMocHJvcHMsIGV2ZW50LnNsaWNlKDcpKTtcbiAgaWYgKG1vZGlmaWVycykge1xuICAgIGlmIChtb2RpZmllcnMudHJpbSkge1xuICAgICAgYXJncyA9IHJhd0FyZ3MubWFwKChhKSA9PiBpc1N0cmluZyhhKSA/IGEudHJpbSgpIDogYSk7XG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMubnVtYmVyKSB7XG4gICAgICBhcmdzID0gcmF3QXJncy5tYXAobG9vc2VUb051bWJlcik7XG4gICAgfVxuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgIGRldnRvb2xzQ29tcG9uZW50RW1pdChpbnN0YW5jZSwgZXZlbnQsIGFyZ3MpO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY29uc3QgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgcHJvcHNbdG9IYW5kbGVyS2V5KGxvd2VyQ2FzZUV2ZW50KV0pIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYEV2ZW50IFwiJHtsb3dlckNhc2VFdmVudH1cIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCAke2Zvcm1hdENvbXBvbmVudE5hbWUoXG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgaW5zdGFuY2UudHlwZVxuICAgICAgICApfSBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXCIke2V2ZW50fVwiLiBOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSB2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXCIke2h5cGhlbmF0ZShcbiAgICAgICAgICBldmVudFxuICAgICAgICApfVwiIGluc3RlYWQgb2YgXCIke2V2ZW50fVwiLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGxldCBoYW5kbGVyTmFtZTtcbiAgbGV0IGhhbmRsZXIgPSBwcm9wc1toYW5kbGVyTmFtZSA9IHRvSGFuZGxlcktleShldmVudCldIHx8IC8vIGFsc28gdHJ5IGNhbWVsQ2FzZSBldmVudCBoYW5kbGVyICgjMjI0OSlcbiAgcHJvcHNbaGFuZGxlck5hbWUgPSB0b0hhbmRsZXJLZXkoY2FtZWxpemUoZXZlbnQpKV07XG4gIGlmICghaGFuZGxlciAmJiBpc01vZGVsTGlzdGVuZXIpIHtcbiAgICBoYW5kbGVyID0gcHJvcHNbaGFuZGxlck5hbWUgPSB0b0hhbmRsZXJLZXkoaHlwaGVuYXRlKGV2ZW50KSldO1xuICB9XG4gIGlmIChoYW5kbGVyKSB7XG4gICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoXG4gICAgICBoYW5kbGVyLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICA2LFxuICAgICAgYXJnc1xuICAgICk7XG4gIH1cbiAgY29uc3Qgb25jZUhhbmRsZXIgPSBwcm9wc1toYW5kbGVyTmFtZSArIGBPbmNlYF07XG4gIGlmIChvbmNlSGFuZGxlcikge1xuICAgIGlmICghaW5zdGFuY2UuZW1pdHRlZCkge1xuICAgICAgaW5zdGFuY2UuZW1pdHRlZCA9IHt9O1xuICAgIH0gZWxzZSBpZiAoaW5zdGFuY2UuZW1pdHRlZFtoYW5kbGVyTmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW5zdGFuY2UuZW1pdHRlZFtoYW5kbGVyTmFtZV0gPSB0cnVlO1xuICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgICAgb25jZUhhbmRsZXIsXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDYsXG4gICAgICBhcmdzXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplRW1pdHNPcHRpb25zKGNvbXAsIGFwcENvbnRleHQsIGFzTWl4aW4gPSBmYWxzZSkge1xuICBjb25zdCBjYWNoZSA9IGFwcENvbnRleHQuZW1pdHNDYWNoZTtcbiAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGNvbXApO1xuICBpZiAoY2FjaGVkICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG4gIGNvbnN0IHJhdyA9IGNvbXAuZW1pdHM7XG4gIGxldCBub3JtYWxpemVkID0ge307XG4gIGxldCBoYXNFeHRlbmRzID0gZmFsc2U7XG4gIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XG4gICAgY29uc3QgZXh0ZW5kRW1pdHMgPSAocmF3MikgPT4ge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZEZyb21FeHRlbmQgPSBub3JtYWxpemVFbWl0c09wdGlvbnMocmF3MiwgYXBwQ29udGV4dCwgdHJ1ZSk7XG4gICAgICBpZiAobm9ybWFsaXplZEZyb21FeHRlbmQpIHtcbiAgICAgICAgaGFzRXh0ZW5kcyA9IHRydWU7XG4gICAgICAgIGV4dGVuZChub3JtYWxpemVkLCBub3JtYWxpemVkRnJvbUV4dGVuZCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoIWFzTWl4aW4gJiYgYXBwQ29udGV4dC5taXhpbnMubGVuZ3RoKSB7XG4gICAgICBhcHBDb250ZXh0Lm1peGlucy5mb3JFYWNoKGV4dGVuZEVtaXRzKTtcbiAgICB9XG4gICAgaWYgKGNvbXAuZXh0ZW5kcykge1xuICAgICAgZXh0ZW5kRW1pdHMoY29tcC5leHRlbmRzKTtcbiAgICB9XG4gICAgaWYgKGNvbXAubWl4aW5zKSB7XG4gICAgICBjb21wLm1peGlucy5mb3JFYWNoKGV4dGVuZEVtaXRzKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFyYXcgJiYgIWhhc0V4dGVuZHMpIHtcbiAgICBpZiAoaXNPYmplY3QoY29tcCkpIHtcbiAgICAgIGNhY2hlLnNldChjb21wLCBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGlzQXJyYXkocmF3KSkge1xuICAgIHJhdy5mb3JFYWNoKChrZXkpID0+IG5vcm1hbGl6ZWRba2V5XSA9IG51bGwpO1xuICB9IGVsc2Uge1xuICAgIGV4dGVuZChub3JtYWxpemVkLCByYXcpO1xuICB9XG4gIGlmIChpc09iamVjdChjb21wKSkge1xuICAgIGNhY2hlLnNldChjb21wLCBub3JtYWxpemVkKTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cbmZ1bmN0aW9uIGlzRW1pdExpc3RlbmVyKG9wdGlvbnMsIGtleSkge1xuICBpZiAoIW9wdGlvbnMgfHwgIWlzT24oa2V5KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBrZXkgPSBrZXkuc2xpY2UoMikucmVwbGFjZSgvT25jZSQvLCBcIlwiKTtcbiAgcmV0dXJuIGhhc093bihvcHRpb25zLCBrZXlbMF0udG9Mb3dlckNhc2UoKSArIGtleS5zbGljZSgxKSkgfHwgaGFzT3duKG9wdGlvbnMsIGh5cGhlbmF0ZShrZXkpKSB8fCBoYXNPd24ob3B0aW9ucywga2V5KTtcbn1cblxubGV0IGFjY2Vzc2VkQXR0cnMgPSBmYWxzZTtcbmZ1bmN0aW9uIG1hcmtBdHRyc0FjY2Vzc2VkKCkge1xuICBhY2Nlc3NlZEF0dHJzID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpIHtcbiAgY29uc3Qge1xuICAgIHR5cGU6IENvbXBvbmVudCxcbiAgICB2bm9kZSxcbiAgICBwcm94eSxcbiAgICB3aXRoUHJveHksXG4gICAgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXSxcbiAgICBzbG90cyxcbiAgICBhdHRycyxcbiAgICBlbWl0LFxuICAgIHJlbmRlcixcbiAgICByZW5kZXJDYWNoZSxcbiAgICBwcm9wcyxcbiAgICBkYXRhLFxuICAgIHNldHVwU3RhdGUsXG4gICAgY3R4LFxuICAgIGluaGVyaXRBdHRyc1xuICB9ID0gaW5zdGFuY2U7XG4gIGNvbnN0IHByZXYgPSBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoaW5zdGFuY2UpO1xuICBsZXQgcmVzdWx0O1xuICBsZXQgZmFsbHRocm91Z2hBdHRycztcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBhY2Nlc3NlZEF0dHJzID0gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNCkge1xuICAgICAgY29uc3QgcHJveHlUb1VzZSA9IHdpdGhQcm94eSB8fCBwcm94eTtcbiAgICAgIGNvbnN0IHRoaXNQcm94eSA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2V0dXBTdGF0ZS5fX2lzU2NyaXB0U2V0dXAgPyBuZXcgUHJveHkocHJveHlUb1VzZSwge1xuICAgICAgICBnZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYFByb3BlcnR5ICcke1N0cmluZyhcbiAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICApfScgd2FzIGFjY2Vzc2VkIHZpYSAndGhpcycuIEF2b2lkIHVzaW5nICd0aGlzJyBpbiB0ZW1wbGF0ZXMuYFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcik7XG4gICAgICAgIH1cbiAgICAgIH0pIDogcHJveHlUb1VzZTtcbiAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVZOb2RlKFxuICAgICAgICByZW5kZXIuY2FsbChcbiAgICAgICAgICB0aGlzUHJveHksXG4gICAgICAgICAgcHJveHlUb1VzZSxcbiAgICAgICAgICByZW5kZXJDYWNoZSxcbiAgICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KHByb3BzKSA6IHByb3BzLFxuICAgICAgICAgIHNldHVwU3RhdGUsXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBjdHhcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBhdHRycztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVuZGVyMiA9IENvbXBvbmVudDtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGF0dHJzID09PSBwcm9wcykge1xuICAgICAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gbm9ybWFsaXplVk5vZGUoXG4gICAgICAgIHJlbmRlcjIubGVuZ3RoID4gMSA/IHJlbmRlcjIoXG4gICAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShwcm9wcykgOiBwcm9wcyxcbiAgICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8ge1xuICAgICAgICAgICAgZ2V0IGF0dHJzKCkge1xuICAgICAgICAgICAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xuICAgICAgICAgICAgICByZXR1cm4gc2hhbGxvd1JlYWRvbmx5KGF0dHJzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzbG90cyxcbiAgICAgICAgICAgIGVtaXRcbiAgICAgICAgICB9IDogeyBhdHRycywgc2xvdHMsIGVtaXQgfVxuICAgICAgICApIDogcmVuZGVyMihcbiAgICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KHByb3BzKSA6IHByb3BzLFxuICAgICAgICAgIG51bGxcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBDb21wb25lbnQucHJvcHMgPyBhdHRycyA6IGdldEZ1bmN0aW9uYWxGYWxsdGhyb3VnaChhdHRycyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBibG9ja1N0YWNrLmxlbmd0aCA9IDA7XG4gICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgMSk7XG4gICAgcmVzdWx0ID0gY3JlYXRlVk5vZGUoQ29tbWVudCk7XG4gIH1cbiAgbGV0IHJvb3QgPSByZXN1bHQ7XG4gIGxldCBzZXRSb290ID0gdm9pZCAwO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiByZXN1bHQucGF0Y2hGbGFnID4gMCAmJiByZXN1bHQucGF0Y2hGbGFnICYgMjA0OCkge1xuICAgIFtyb290LCBzZXRSb290XSA9IGdldENoaWxkUm9vdChyZXN1bHQpO1xuICB9XG4gIGlmIChmYWxsdGhyb3VnaEF0dHJzICYmIGluaGVyaXRBdHRycyAhPT0gZmFsc2UpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZmFsbHRocm91Z2hBdHRycyk7XG4gICAgY29uc3QgeyBzaGFwZUZsYWcgfSA9IHJvb3Q7XG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICBpZiAoc2hhcGVGbGFnICYgKDEgfCA2KSkge1xuICAgICAgICBpZiAocHJvcHNPcHRpb25zICYmIGtleXMuc29tZShpc01vZGVsTGlzdGVuZXIpKSB7XG4gICAgICAgICAgZmFsbHRocm91Z2hBdHRycyA9IGZpbHRlck1vZGVsTGlzdGVuZXJzKFxuICAgICAgICAgICAgZmFsbHRocm91Z2hBdHRycyxcbiAgICAgICAgICAgIHByb3BzT3B0aW9uc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcm9vdCA9IGNsb25lVk5vZGUocm9vdCwgZmFsbHRocm91Z2hBdHRycywgZmFsc2UsIHRydWUpO1xuICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFhY2Nlc3NlZEF0dHJzICYmIHJvb3QudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICBjb25zdCBhbGxBdHRycyA9IE9iamVjdC5rZXlzKGF0dHJzKTtcbiAgICAgICAgY29uc3QgZXZlbnRBdHRycyA9IFtdO1xuICAgICAgICBjb25zdCBleHRyYUF0dHJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gYWxsQXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gYWxsQXR0cnNbaV07XG4gICAgICAgICAgaWYgKGlzT24oa2V5KSkge1xuICAgICAgICAgICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSkge1xuICAgICAgICAgICAgICBldmVudEF0dHJzLnB1c2goa2V5WzJdLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHRyYUF0dHJzLnB1c2goa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dHJhQXR0cnMubGVuZ3RoKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYEV4dHJhbmVvdXMgbm9uLXByb3BzIGF0dHJpYnV0ZXMgKCR7ZXh0cmFBdHRycy5qb2luKFwiLCBcIil9KSB3ZXJlIHBhc3NlZCB0byBjb21wb25lbnQgYnV0IGNvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGluaGVyaXRlZCBiZWNhdXNlIGNvbXBvbmVudCByZW5kZXJzIGZyYWdtZW50IG9yIHRleHQgb3IgdGVsZXBvcnQgcm9vdCBub2Rlcy5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnRBdHRycy5sZW5ndGgpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgRXh0cmFuZW91cyBub24tZW1pdHMgZXZlbnQgbGlzdGVuZXJzICgke2V2ZW50QXR0cnMuam9pbihcIiwgXCIpfSkgd2VyZSBwYXNzZWQgdG8gY29tcG9uZW50IGJ1dCBjb3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBpbmhlcml0ZWQgYmVjYXVzZSBjb21wb25lbnQgcmVuZGVycyBmcmFnbWVudCBvciB0ZXh0IHJvb3Qgbm9kZXMuIElmIHRoZSBsaXN0ZW5lciBpcyBpbnRlbmRlZCB0byBiZSBhIGNvbXBvbmVudCBjdXN0b20gZXZlbnQgbGlzdGVuZXIgb25seSwgZGVjbGFyZSBpdCB1c2luZyB0aGUgXCJlbWl0c1wiIG9wdGlvbi5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodm5vZGUuZGlycykge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc0VsZW1lbnRSb290KHJvb3QpKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBSdW50aW1lIGRpcmVjdGl2ZSB1c2VkIG9uIGNvbXBvbmVudCB3aXRoIG5vbi1lbGVtZW50IHJvb3Qgbm9kZS4gVGhlIGRpcmVjdGl2ZXMgd2lsbCBub3QgZnVuY3Rpb24gYXMgaW50ZW5kZWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcm9vdCA9IGNsb25lVk5vZGUocm9vdCwgbnVsbCwgZmFsc2UsIHRydWUpO1xuICAgIHJvb3QuZGlycyA9IHJvb3QuZGlycyA/IHJvb3QuZGlycy5jb25jYXQodm5vZGUuZGlycykgOiB2bm9kZS5kaXJzO1xuICB9XG4gIGlmICh2bm9kZS50cmFuc2l0aW9uKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzRWxlbWVudFJvb3Qocm9vdCkpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYENvbXBvbmVudCBpbnNpZGUgPFRyYW5zaXRpb24+IHJlbmRlcnMgbm9uLWVsZW1lbnQgcm9vdCBub2RlIHRoYXQgY2Fubm90IGJlIGFuaW1hdGVkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHNldFRyYW5zaXRpb25Ib29rcyhyb290LCB2bm9kZS50cmFuc2l0aW9uKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzZXRSb290KSB7XG4gICAgc2V0Um9vdChyb290KTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSByb290O1xuICB9XG4gIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShwcmV2KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGdldENoaWxkUm9vdCA9ICh2bm9kZSkgPT4ge1xuICBjb25zdCByYXdDaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICBjb25zdCBkeW5hbWljQ2hpbGRyZW4gPSB2bm9kZS5keW5hbWljQ2hpbGRyZW47XG4gIGNvbnN0IGNoaWxkUm9vdCA9IGZpbHRlclNpbmdsZVJvb3QocmF3Q2hpbGRyZW4sIGZhbHNlKTtcbiAgaWYgKCFjaGlsZFJvb3QpIHtcbiAgICByZXR1cm4gW3Zub2RlLCB2b2lkIDBdO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY2hpbGRSb290LnBhdGNoRmxhZyA+IDAgJiYgY2hpbGRSb290LnBhdGNoRmxhZyAmIDIwNDgpIHtcbiAgICByZXR1cm4gZ2V0Q2hpbGRSb290KGNoaWxkUm9vdCk7XG4gIH1cbiAgY29uc3QgaW5kZXggPSByYXdDaGlsZHJlbi5pbmRleE9mKGNoaWxkUm9vdCk7XG4gIGNvbnN0IGR5bmFtaWNJbmRleCA9IGR5bmFtaWNDaGlsZHJlbiA/IGR5bmFtaWNDaGlsZHJlbi5pbmRleE9mKGNoaWxkUm9vdCkgOiAtMTtcbiAgY29uc3Qgc2V0Um9vdCA9ICh1cGRhdGVkUm9vdCkgPT4ge1xuICAgIHJhd0NoaWxkcmVuW2luZGV4XSA9IHVwZGF0ZWRSb290O1xuICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgIGlmIChkeW5hbWljSW5kZXggPiAtMSkge1xuICAgICAgICBkeW5hbWljQ2hpbGRyZW5bZHluYW1pY0luZGV4XSA9IHVwZGF0ZWRSb290O1xuICAgICAgfSBlbHNlIGlmICh1cGRhdGVkUm9vdC5wYXRjaEZsYWcgPiAwKSB7XG4gICAgICAgIHZub2RlLmR5bmFtaWNDaGlsZHJlbiA9IFsuLi5keW5hbWljQ2hpbGRyZW4sIHVwZGF0ZWRSb290XTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBbbm9ybWFsaXplVk5vZGUoY2hpbGRSb290KSwgc2V0Um9vdF07XG59O1xuZnVuY3Rpb24gZmlsdGVyU2luZ2xlUm9vdChjaGlsZHJlbiwgcmVjdXJzZSA9IHRydWUpIHtcbiAgbGV0IHNpbmdsZVJvb3Q7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChpc1ZOb2RlKGNoaWxkKSkge1xuICAgICAgaWYgKGNoaWxkLnR5cGUgIT09IENvbW1lbnQgfHwgY2hpbGQuY2hpbGRyZW4gPT09IFwidi1pZlwiKSB7XG4gICAgICAgIGlmIChzaW5nbGVSb290KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNpbmdsZVJvb3QgPSBjaGlsZDtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiByZWN1cnNlICYmIHNpbmdsZVJvb3QucGF0Y2hGbGFnID4gMCAmJiBzaW5nbGVSb290LnBhdGNoRmxhZyAmIDIwNDgpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJTaW5nbGVSb290KHNpbmdsZVJvb3QuY2hpbGRyZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHJldHVybiBzaW5nbGVSb290O1xufVxuY29uc3QgZ2V0RnVuY3Rpb25hbEZhbGx0aHJvdWdoID0gKGF0dHJzKSA9PiB7XG4gIGxldCByZXM7XG4gIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XG4gICAgaWYgKGtleSA9PT0gXCJjbGFzc1wiIHx8IGtleSA9PT0gXCJzdHlsZVwiIHx8IGlzT24oa2V5KSkge1xuICAgICAgKHJlcyB8fCAocmVzID0ge30pKVtrZXldID0gYXR0cnNba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5jb25zdCBmaWx0ZXJNb2RlbExpc3RlbmVycyA9IChhdHRycywgcHJvcHMpID0+IHtcbiAgY29uc3QgcmVzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XG4gICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSB8fCAhKGtleS5zbGljZSg5KSBpbiBwcm9wcykpIHtcbiAgICAgIHJlc1trZXldID0gYXR0cnNba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5jb25zdCBpc0VsZW1lbnRSb290ID0gKHZub2RlKSA9PiB7XG4gIHJldHVybiB2bm9kZS5zaGFwZUZsYWcgJiAoNiB8IDEpIHx8IHZub2RlLnR5cGUgPT09IENvbW1lbnQ7XG59O1xuZnVuY3Rpb24gc2hvdWxkVXBkYXRlQ29tcG9uZW50KHByZXZWTm9kZSwgbmV4dFZOb2RlLCBvcHRpbWl6ZWQpIHtcbiAgY29uc3QgeyBwcm9wczogcHJldlByb3BzLCBjaGlsZHJlbjogcHJldkNoaWxkcmVuLCBjb21wb25lbnQgfSA9IHByZXZWTm9kZTtcbiAgY29uc3QgeyBwcm9wczogbmV4dFByb3BzLCBjaGlsZHJlbjogbmV4dENoaWxkcmVuLCBwYXRjaEZsYWcgfSA9IG5leHRWTm9kZTtcbiAgY29uc3QgZW1pdHMgPSBjb21wb25lbnQuZW1pdHNPcHRpb25zO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAocHJldkNoaWxkcmVuIHx8IG5leHRDaGlsZHJlbikgJiYgaXNIbXJVcGRhdGluZykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChuZXh0Vk5vZGUuZGlycyB8fCBuZXh0Vk5vZGUudHJhbnNpdGlvbikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChvcHRpbWl6ZWQgJiYgcGF0Y2hGbGFnID49IDApIHtcbiAgICBpZiAocGF0Y2hGbGFnICYgMTAyNCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChwYXRjaEZsYWcgJiAxNikge1xuICAgICAgaWYgKCFwcmV2UHJvcHMpIHtcbiAgICAgICAgcmV0dXJuICEhbmV4dFByb3BzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc1Byb3BzQ2hhbmdlZChwcmV2UHJvcHMsIG5leHRQcm9wcywgZW1pdHMpO1xuICAgIH0gZWxzZSBpZiAocGF0Y2hGbGFnICYgOCkge1xuICAgICAgY29uc3QgZHluYW1pY1Byb3BzID0gbmV4dFZOb2RlLmR5bmFtaWNQcm9wcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHluYW1pY1Byb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGR5bmFtaWNQcm9wc1tpXTtcbiAgICAgICAgaWYgKG5leHRQcm9wc1trZXldICE9PSBwcmV2UHJvcHNba2V5XSAmJiAhaXNFbWl0TGlzdGVuZXIoZW1pdHMsIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocHJldkNoaWxkcmVuIHx8IG5leHRDaGlsZHJlbikge1xuICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4gfHwgIW5leHRDaGlsZHJlbi4kc3RhYmxlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJldlByb3BzID09PSBuZXh0UHJvcHMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFwcmV2UHJvcHMpIHtcbiAgICAgIHJldHVybiAhIW5leHRQcm9wcztcbiAgICB9XG4gICAgaWYgKCFuZXh0UHJvcHMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0cyk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0c09wdGlvbnMpIHtcbiAgY29uc3QgbmV4dEtleXMgPSBPYmplY3Qua2V5cyhuZXh0UHJvcHMpO1xuICBpZiAobmV4dEtleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhwcmV2UHJvcHMpLmxlbmd0aCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBuZXh0S2V5c1tpXTtcbiAgICBpZiAobmV4dFByb3BzW2tleV0gIT09IHByZXZQcm9wc1trZXldICYmICFpc0VtaXRMaXN0ZW5lcihlbWl0c09wdGlvbnMsIGtleSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiB1cGRhdGVIT0NIb3N0RWwoeyB2bm9kZSwgcGFyZW50IH0sIGVsKSB7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBjb25zdCByb290ID0gcGFyZW50LnN1YlRyZWU7XG4gICAgaWYgKHJvb3Quc3VzcGVuc2UgJiYgcm9vdC5zdXNwZW5zZS5hY3RpdmVCcmFuY2ggPT09IHZub2RlKSB7XG4gICAgICByb290LmVsID0gdm5vZGUuZWw7XG4gICAgfVxuICAgIGlmIChyb290ID09PSB2bm9kZSkge1xuICAgICAgKHZub2RlID0gcGFyZW50LnZub2RlKS5lbCA9IGVsO1xuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGlzU3VzcGVuc2UgPSAodHlwZSkgPT4gdHlwZS5fX2lzU3VzcGVuc2U7XG5sZXQgc3VzcGVuc2VJZCA9IDA7XG5jb25zdCBTdXNwZW5zZUltcGwgPSB7XG4gIG5hbWU6IFwiU3VzcGVuc2VcIixcbiAgLy8gSW4gb3JkZXIgdG8gbWFrZSBTdXNwZW5zZSB0cmVlLXNoYWthYmxlLCB3ZSBuZWVkIHRvIGF2b2lkIGltcG9ydGluZyBpdFxuICAvLyBkaXJlY3RseSBpbiB0aGUgcmVuZGVyZXIuIFRoZSByZW5kZXJlciBjaGVja3MgZm9yIHRoZSBfX2lzU3VzcGVuc2UgZmxhZ1xuICAvLyBvbiBhIHZub2RlJ3MgdHlwZSBhbmQgY2FsbHMgdGhlIGBwcm9jZXNzYCBtZXRob2QsIHBhc3NpbmcgaW4gcmVuZGVyZXJcbiAgLy8gaW50ZXJuYWxzLlxuICBfX2lzU3VzcGVuc2U6IHRydWUsXG4gIHByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMpIHtcbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgbW91bnRTdXNwZW5zZShcbiAgICAgICAgbjIsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICByZW5kZXJlckludGVybmFsc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLmRlcHMgPiAwICYmICFuMS5zdXNwZW5zZS5pc0luRmFsbGJhY2spIHtcbiAgICAgICAgbjIuc3VzcGVuc2UgPSBuMS5zdXNwZW5zZTtcbiAgICAgICAgbjIuc3VzcGVuc2Uudm5vZGUgPSBuMjtcbiAgICAgICAgbjIuZWwgPSBuMS5lbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcGF0Y2hTdXNwZW5zZShcbiAgICAgICAgbjEsXG4gICAgICAgIG4yLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICByZW5kZXJlckludGVybmFsc1xuICAgICAgKTtcbiAgICB9XG4gIH0sXG4gIGh5ZHJhdGU6IGh5ZHJhdGVTdXNwZW5zZSxcbiAgbm9ybWFsaXplOiBub3JtYWxpemVTdXNwZW5zZUNoaWxkcmVuXG59O1xuY29uc3QgU3VzcGVuc2UgPSBTdXNwZW5zZUltcGwgO1xuZnVuY3Rpb24gdHJpZ2dlckV2ZW50KHZub2RlLCBuYW1lKSB7XG4gIGNvbnN0IGV2ZW50TGlzdGVuZXIgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wc1tuYW1lXTtcbiAgaWYgKGlzRnVuY3Rpb24oZXZlbnRMaXN0ZW5lcikpIHtcbiAgICBldmVudExpc3RlbmVyKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2Uodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscykge1xuICBjb25zdCB7XG4gICAgcDogcGF0Y2gsXG4gICAgbzogeyBjcmVhdGVFbGVtZW50IH1cbiAgfSA9IHJlbmRlcmVySW50ZXJuYWxzO1xuICBjb25zdCBoaWRkZW5Db250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBjb25zdCBzdXNwZW5zZSA9IHZub2RlLnN1c3BlbnNlID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShcbiAgICB2bm9kZSxcbiAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgY29udGFpbmVyLFxuICAgIGhpZGRlbkNvbnRhaW5lcixcbiAgICBhbmNob3IsXG4gICAgbmFtZXNwYWNlLFxuICAgIHNsb3RTY29wZUlkcyxcbiAgICBvcHRpbWl6ZWQsXG4gICAgcmVuZGVyZXJJbnRlcm5hbHNcbiAgKTtcbiAgcGF0Y2goXG4gICAgbnVsbCxcbiAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gdm5vZGUuc3NDb250ZW50LFxuICAgIGhpZGRlbkNvbnRhaW5lcixcbiAgICBudWxsLFxuICAgIHBhcmVudENvbXBvbmVudCxcbiAgICBzdXNwZW5zZSxcbiAgICBuYW1lc3BhY2UsXG4gICAgc2xvdFNjb3BlSWRzXG4gICk7XG4gIGlmIChzdXNwZW5zZS5kZXBzID4gMCkge1xuICAgIHRyaWdnZXJFdmVudCh2bm9kZSwgXCJvblBlbmRpbmdcIik7XG4gICAgdHJpZ2dlckV2ZW50KHZub2RlLCBcIm9uRmFsbGJhY2tcIik7XG4gICAgcGF0Y2goXG4gICAgICBudWxsLFxuICAgICAgdm5vZGUuc3NGYWxsYmFjayxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIGFuY2hvcixcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIG51bGwsXG4gICAgICAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxuICAgICAgbmFtZXNwYWNlLFxuICAgICAgc2xvdFNjb3BlSWRzXG4gICAgKTtcbiAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIHZub2RlLnNzRmFsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIHN1c3BlbnNlLnJlc29sdmUoZmFsc2UsIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBwYXRjaFN1c3BlbnNlKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgeyBwOiBwYXRjaCwgdW06IHVubW91bnQsIG86IHsgY3JlYXRlRWxlbWVudCB9IH0pIHtcbiAgY29uc3Qgc3VzcGVuc2UgPSBuMi5zdXNwZW5zZSA9IG4xLnN1c3BlbnNlO1xuICBzdXNwZW5zZS52bm9kZSA9IG4yO1xuICBuMi5lbCA9IG4xLmVsO1xuICBjb25zdCBuZXdCcmFuY2ggPSBuMi5zc0NvbnRlbnQ7XG4gIGNvbnN0IG5ld0ZhbGxiYWNrID0gbjIuc3NGYWxsYmFjaztcbiAgY29uc3QgeyBhY3RpdmVCcmFuY2gsIHBlbmRpbmdCcmFuY2gsIGlzSW5GYWxsYmFjaywgaXNIeWRyYXRpbmcgfSA9IHN1c3BlbnNlO1xuICBpZiAocGVuZGluZ0JyYW5jaCkge1xuICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBuZXdCcmFuY2g7XG4gICAgaWYgKGlzU2FtZVZOb2RlVHlwZShuZXdCcmFuY2gsIHBlbmRpbmdCcmFuY2gpKSB7XG4gICAgICBwYXRjaChcbiAgICAgICAgcGVuZGluZ0JyYW5jaCxcbiAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XG4gICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNJbkZhbGxiYWNrKSB7XG4gICAgICAgIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgICBwYXRjaChcbiAgICAgICAgICAgIGFjdGl2ZUJyYW5jaCxcbiAgICAgICAgICAgIG5ld0ZhbGxiYWNrLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3RmFsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1c3BlbnNlLnBlbmRpbmdJZCA9IHN1c3BlbnNlSWQrKztcbiAgICAgIGlmIChpc0h5ZHJhdGluZykge1xuICAgICAgICBzdXNwZW5zZS5pc0h5ZHJhdGluZyA9IGZhbHNlO1xuICAgICAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggPSBwZW5kaW5nQnJhbmNoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5tb3VudChwZW5kaW5nQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlKTtcbiAgICAgIH1cbiAgICAgIHN1c3BlbnNlLmRlcHMgPSAwO1xuICAgICAgc3VzcGVuc2UuZWZmZWN0cy5sZW5ndGggPSAwO1xuICAgICAgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGlmIChpc0luRmFsbGJhY2spIHtcbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgICAgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcbiAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBhY3RpdmVCcmFuY2gsXG4gICAgICAgICAgICBuZXdGYWxsYmFjayxcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIG5ld0ZhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhY3RpdmVCcmFuY2ggJiYgaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgYWN0aXZlQnJhbmNoKSkge1xuICAgICAgICBwYXRjaChcbiAgICAgICAgICBhY3RpdmVCcmFuY2gsXG4gICAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICAgIHN1c3BlbnNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRjaChcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIG5ld0JyYW5jaCxcbiAgICAgICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xuICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYWN0aXZlQnJhbmNoICYmIGlzU2FtZVZOb2RlVHlwZShuZXdCcmFuY2gsIGFjdGl2ZUJyYW5jaCkpIHtcbiAgICAgIHBhdGNoKFxuICAgICAgICBhY3RpdmVCcmFuY2gsXG4gICAgICAgIG5ld0JyYW5jaCxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIG5ld0JyYW5jaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXJFdmVudChuMiwgXCJvblBlbmRpbmdcIik7XG4gICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbmV3QnJhbmNoO1xuICAgICAgaWYgKG5ld0JyYW5jaC5zaGFwZUZsYWcgJiA1MTIpIHtcbiAgICAgICAgc3VzcGVuc2UucGVuZGluZ0lkID0gbmV3QnJhbmNoLmNvbXBvbmVudC5zdXNwZW5zZUlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VzcGVuc2UucGVuZGluZ0lkID0gc3VzcGVuc2VJZCsrO1xuICAgICAgfVxuICAgICAgcGF0Y2goXG4gICAgICAgIG51bGwsXG4gICAgICAgIG5ld0JyYW5jaCxcbiAgICAgICAgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLFxuICAgICAgICBudWxsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xuICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IHRpbWVvdXQsIHBlbmRpbmdJZCB9ID0gc3VzcGVuc2U7XG4gICAgICAgIGlmICh0aW1lb3V0ID4gMCkge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdJZCA9PT0gcGVuZGluZ0lkKSB7XG4gICAgICAgICAgICAgIHN1c3BlbnNlLmZhbGxiYWNrKG5ld0ZhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aW1lb3V0ID09PSAwKSB7XG4gICAgICAgICAgc3VzcGVuc2UuZmFsbGJhY2sobmV3RmFsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5sZXQgaGFzV2FybmVkID0gZmFsc2U7XG5mdW5jdGlvbiBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KHZub2RlLCBwYXJlbnRTdXNwZW5zZSwgcGFyZW50Q29tcG9uZW50LCBjb250YWluZXIsIGhpZGRlbkNvbnRhaW5lciwgYW5jaG9yLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgaXNIeWRyYXRpbmcgPSBmYWxzZSkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB0cnVlICYmICFoYXNXYXJuZWQpIHtcbiAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gXCJpbmZvXCIgOiBcImxvZ1wiXShcbiAgICAgIGA8U3VzcGVuc2U+IGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlIGFuZCBpdHMgQVBJIHdpbGwgbGlrZWx5IGNoYW5nZS5gXG4gICAgKTtcbiAgfVxuICBjb25zdCB7XG4gICAgcDogcGF0Y2gsXG4gICAgbTogbW92ZSxcbiAgICB1bTogdW5tb3VudCxcbiAgICBuOiBuZXh0LFxuICAgIG86IHsgcGFyZW50Tm9kZSwgcmVtb3ZlIH1cbiAgfSA9IHJlbmRlcmVySW50ZXJuYWxzO1xuICBsZXQgcGFyZW50U3VzcGVuc2VJZDtcbiAgY29uc3QgaXNTdXNwZW5zaWJsZSA9IGlzVk5vZGVTdXNwZW5zaWJsZSh2bm9kZSk7XG4gIGlmIChpc1N1c3BlbnNpYmxlKSB7XG4gICAgaWYgKHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgIHBhcmVudFN1c3BlbnNlSWQgPSBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nSWQ7XG4gICAgICBwYXJlbnRTdXNwZW5zZS5kZXBzKys7XG4gICAgfVxuICB9XG4gIGNvbnN0IHRpbWVvdXQgPSB2bm9kZS5wcm9wcyA/IHRvTnVtYmVyKHZub2RlLnByb3BzLnRpbWVvdXQpIDogdm9pZCAwO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGFzc2VydE51bWJlcih0aW1lb3V0LCBgU3VzcGVuc2UgdGltZW91dGApO1xuICB9XG4gIGNvbnN0IGluaXRpYWxBbmNob3IgPSBhbmNob3I7XG4gIGNvbnN0IHN1c3BlbnNlID0ge1xuICAgIHZub2RlLFxuICAgIHBhcmVudDogcGFyZW50U3VzcGVuc2UsXG4gICAgcGFyZW50Q29tcG9uZW50LFxuICAgIG5hbWVzcGFjZSxcbiAgICBjb250YWluZXIsXG4gICAgaGlkZGVuQ29udGFpbmVyLFxuICAgIGRlcHM6IDAsXG4gICAgcGVuZGluZ0lkOiBzdXNwZW5zZUlkKyssXG4gICAgdGltZW91dDogdHlwZW9mIHRpbWVvdXQgPT09IFwibnVtYmVyXCIgPyB0aW1lb3V0IDogLTEsXG4gICAgYWN0aXZlQnJhbmNoOiBudWxsLFxuICAgIHBlbmRpbmdCcmFuY2g6IG51bGwsXG4gICAgaXNJbkZhbGxiYWNrOiAhaXNIeWRyYXRpbmcsXG4gICAgaXNIeWRyYXRpbmcsXG4gICAgaXNVbm1vdW50ZWQ6IGZhbHNlLFxuICAgIGVmZmVjdHM6IFtdLFxuICAgIHJlc29sdmUocmVzdW1lID0gZmFsc2UsIHN5bmMgPSBmYWxzZSkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgaWYgKCFyZXN1bWUgJiYgIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgc3VzcGVuc2UucmVzb2x2ZSgpIGlzIGNhbGxlZCB3aXRob3V0IGEgcGVuZGluZyBicmFuY2guYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1c3BlbnNlLmlzVW5tb3VudGVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYHN1c3BlbnNlLnJlc29sdmUoKSBpcyBjYWxsZWQgb24gYW4gYWxyZWFkeSB1bm1vdW50ZWQgc3VzcGVuc2UgYm91bmRhcnkuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdm5vZGU6IHZub2RlMixcbiAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICBwZW5kaW5nQnJhbmNoLFxuICAgICAgICBwZW5kaW5nSWQsXG4gICAgICAgIGVmZmVjdHMsXG4gICAgICAgIHBhcmVudENvbXBvbmVudDogcGFyZW50Q29tcG9uZW50MixcbiAgICAgICAgY29udGFpbmVyOiBjb250YWluZXIyXG4gICAgICB9ID0gc3VzcGVuc2U7XG4gICAgICBsZXQgZGVsYXlFbnRlciA9IGZhbHNlO1xuICAgICAgaWYgKHN1c3BlbnNlLmlzSHlkcmF0aW5nKSB7XG4gICAgICAgIHN1c3BlbnNlLmlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCFyZXN1bWUpIHtcbiAgICAgICAgZGVsYXlFbnRlciA9IGFjdGl2ZUJyYW5jaCAmJiBwZW5kaW5nQnJhbmNoLnRyYW5zaXRpb24gJiYgcGVuZGluZ0JyYW5jaC50cmFuc2l0aW9uLm1vZGUgPT09IFwib3V0LWluXCI7XG4gICAgICAgIGlmIChkZWxheUVudGVyKSB7XG4gICAgICAgICAgYWN0aXZlQnJhbmNoLnRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChwZW5kaW5nSWQgPT09IHN1c3BlbnNlLnBlbmRpbmdJZCkge1xuICAgICAgICAgICAgICBtb3ZlKFxuICAgICAgICAgICAgICAgIHBlbmRpbmdCcmFuY2gsXG4gICAgICAgICAgICAgICAgY29udGFpbmVyMixcbiAgICAgICAgICAgICAgICBhbmNob3IgPT09IGluaXRpYWxBbmNob3IgPyBuZXh0KGFjdGl2ZUJyYW5jaCkgOiBhbmNob3IsXG4gICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBxdWV1ZVBvc3RGbHVzaENiKGVmZmVjdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGl2ZUJyYW5jaCkge1xuICAgICAgICAgIGlmIChwYXJlbnROb2RlKGFjdGl2ZUJyYW5jaC5lbCkgPT09IGNvbnRhaW5lcjIpIHtcbiAgICAgICAgICAgIGFuY2hvciA9IG5leHQoYWN0aXZlQnJhbmNoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdW5tb3VudChhY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudDIsIHN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlbGF5RW50ZXIpIHtcbiAgICAgICAgICBtb3ZlKHBlbmRpbmdCcmFuY2gsIGNvbnRhaW5lcjIsIGFuY2hvciwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgcGVuZGluZ0JyYW5jaCk7XG4gICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbnVsbDtcbiAgICAgIHN1c3BlbnNlLmlzSW5GYWxsYmFjayA9IGZhbHNlO1xuICAgICAgbGV0IHBhcmVudCA9IHN1c3BlbnNlLnBhcmVudDtcbiAgICAgIGxldCBoYXNVbnJlc29sdmVkQW5jZXN0b3IgPSBmYWxzZTtcbiAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudC5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICAgICAgcGFyZW50LmVmZmVjdHMucHVzaCguLi5lZmZlY3RzKTtcbiAgICAgICAgICBoYXNVbnJlc29sdmVkQW5jZXN0b3IgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoIWhhc1VucmVzb2x2ZWRBbmNlc3RvciAmJiAhZGVsYXlFbnRlcikge1xuICAgICAgICBxdWV1ZVBvc3RGbHVzaENiKGVmZmVjdHMpO1xuICAgICAgfVxuICAgICAgc3VzcGVuc2UuZWZmZWN0cyA9IFtdO1xuICAgICAgaWYgKGlzU3VzcGVuc2libGUpIHtcbiAgICAgICAgaWYgKHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggJiYgcGFyZW50U3VzcGVuc2VJZCA9PT0gcGFyZW50U3VzcGVuc2UucGVuZGluZ0lkKSB7XG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UuZGVwcy0tO1xuICAgICAgICAgIGlmIChwYXJlbnRTdXNwZW5zZS5kZXBzID09PSAwICYmICFzeW5jKSB7XG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cmlnZ2VyRXZlbnQodm5vZGUyLCBcIm9uUmVzb2x2ZVwiKTtcbiAgICB9LFxuICAgIGZhbGxiYWNrKGZhbGxiYWNrVk5vZGUpIHtcbiAgICAgIGlmICghc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IHZub2RlOiB2bm9kZTIsIGFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50OiBwYXJlbnRDb21wb25lbnQyLCBjb250YWluZXI6IGNvbnRhaW5lcjIsIG5hbWVzcGFjZTogbmFtZXNwYWNlMiB9ID0gc3VzcGVuc2U7XG4gICAgICB0cmlnZ2VyRXZlbnQodm5vZGUyLCBcIm9uRmFsbGJhY2tcIik7XG4gICAgICBjb25zdCBhbmNob3IyID0gbmV4dChhY3RpdmVCcmFuY2gpO1xuICAgICAgY29uc3QgbW91bnRGYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFzdXNwZW5zZS5pc0luRmFsbGJhY2spIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBmYWxsYmFja1ZOb2RlLFxuICAgICAgICAgIGNvbnRhaW5lcjIsXG4gICAgICAgICAgYW5jaG9yMixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQyLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcbiAgICAgICAgICBuYW1lc3BhY2UyLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBmYWxsYmFja1ZOb2RlKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBkZWxheUVudGVyID0gZmFsbGJhY2tWTm9kZS50cmFuc2l0aW9uICYmIGZhbGxiYWNrVk5vZGUudHJhbnNpdGlvbi5tb2RlID09PSBcIm91dC1pblwiO1xuICAgICAgaWYgKGRlbGF5RW50ZXIpIHtcbiAgICAgICAgYWN0aXZlQnJhbmNoLnRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSA9IG1vdW50RmFsbGJhY2s7XG4gICAgICB9XG4gICAgICBzdXNwZW5zZS5pc0luRmFsbGJhY2sgPSB0cnVlO1xuICAgICAgdW5tb3VudChcbiAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQyLFxuICAgICAgICBudWxsLFxuICAgICAgICAvLyBubyBzdXNwZW5zZSBzbyB1bm1vdW50IGhvb2tzIGZpcmUgbm93XG4gICAgICAgIHRydWVcbiAgICAgICAgLy8gc2hvdWxkUmVtb3ZlXG4gICAgICApO1xuICAgICAgaWYgKCFkZWxheUVudGVyKSB7XG4gICAgICAgIG1vdW50RmFsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdmUoY29udGFpbmVyMiwgYW5jaG9yMiwgdHlwZSkge1xuICAgICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoICYmIG1vdmUoc3VzcGVuc2UuYWN0aXZlQnJhbmNoLCBjb250YWluZXIyLCBhbmNob3IyLCB0eXBlKTtcbiAgICAgIHN1c3BlbnNlLmNvbnRhaW5lciA9IGNvbnRhaW5lcjI7XG4gICAgfSxcbiAgICBuZXh0KCkge1xuICAgICAgcmV0dXJuIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCAmJiBuZXh0KHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCk7XG4gICAgfSxcbiAgICByZWdpc3RlckRlcChpbnN0YW5jZSwgc2V0dXBSZW5kZXJFZmZlY3QsIG9wdGltaXplZDIpIHtcbiAgICAgIGNvbnN0IGlzSW5QZW5kaW5nU3VzcGVuc2UgPSAhIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2g7XG4gICAgICBpZiAoaXNJblBlbmRpbmdTdXNwZW5zZSkge1xuICAgICAgICBzdXNwZW5zZS5kZXBzKys7XG4gICAgICB9XG4gICAgICBjb25zdCBoeWRyYXRlZEVsID0gaW5zdGFuY2Uudm5vZGUuZWw7XG4gICAgICBpbnN0YW5jZS5hc3luY0RlcC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIDApO1xuICAgICAgfSkudGhlbigoYXN5bmNTZXR1cFJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAoaW5zdGFuY2UuaXNVbm1vdW50ZWQgfHwgc3VzcGVuc2UuaXNVbm1vdW50ZWQgfHwgc3VzcGVuc2UucGVuZGluZ0lkICE9PSBpbnN0YW5jZS5zdXNwZW5zZUlkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlLmFzeW5jUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IHZub2RlOiB2bm9kZTIgfSA9IGluc3RhbmNlO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dCh2bm9kZTIpO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBhc3luY1NldHVwUmVzdWx0LCBmYWxzZSk7XG4gICAgICAgIGlmIChoeWRyYXRlZEVsKSB7XG4gICAgICAgICAgdm5vZGUyLmVsID0gaHlkcmF0ZWRFbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9ICFoeWRyYXRlZEVsICYmIGluc3RhbmNlLnN1YlRyZWUuZWw7XG4gICAgICAgIHNldHVwUmVuZGVyRWZmZWN0KFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIHZub2RlMixcbiAgICAgICAgICAvLyBjb21wb25lbnQgbWF5IGhhdmUgYmVlbiBtb3ZlZCBiZWZvcmUgcmVzb2x2ZS5cbiAgICAgICAgICAvLyBpZiB0aGlzIGlzIG5vdCBhIGh5ZHJhdGlvbiwgaW5zdGFuY2Uuc3ViVHJlZSB3aWxsIGJlIHRoZSBjb21tZW50XG4gICAgICAgICAgLy8gcGxhY2Vob2xkZXIuXG4gICAgICAgICAgcGFyZW50Tm9kZShoeWRyYXRlZEVsIHx8IGluc3RhbmNlLnN1YlRyZWUuZWwpLFxuICAgICAgICAgIC8vIGFuY2hvciB3aWxsIG5vdCBiZSB1c2VkIGlmIHRoaXMgaXMgaHlkcmF0aW9uLCBzbyBvbmx5IG5lZWQgdG9cbiAgICAgICAgICAvLyBjb25zaWRlciB0aGUgY29tbWVudCBwbGFjZWhvbGRlciBjYXNlLlxuICAgICAgICAgIGh5ZHJhdGVkRWwgPyBudWxsIDogbmV4dChpbnN0YW5jZS5zdWJUcmVlKSxcbiAgICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgb3B0aW1pemVkMlxuICAgICAgICApO1xuICAgICAgICBpZiAocGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICByZW1vdmUocGxhY2Vob2xkZXIpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZUhPQ0hvc3RFbChpbnN0YW5jZSwgdm5vZGUyLmVsKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0luUGVuZGluZ1N1c3BlbnNlICYmIC0tc3VzcGVuc2UuZGVwcyA9PT0gMCkge1xuICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICB1bm1vdW50KHBhcmVudFN1c3BlbnNlMiwgZG9SZW1vdmUpIHtcbiAgICAgIHN1c3BlbnNlLmlzVW5tb3VudGVkID0gdHJ1ZTtcbiAgICAgIGlmIChzdXNwZW5zZS5hY3RpdmVCcmFuY2gpIHtcbiAgICAgICAgdW5tb3VudChcbiAgICAgICAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2gsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlMixcbiAgICAgICAgICBkb1JlbW92ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgICAgdW5tb3VudChcbiAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZTIsXG4gICAgICAgICAgZG9SZW1vdmVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBzdXNwZW5zZTtcbn1cbmZ1bmN0aW9uIGh5ZHJhdGVTdXNwZW5zZShub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGh5ZHJhdGVOb2RlKSB7XG4gIGNvbnN0IHN1c3BlbnNlID0gdm5vZGUuc3VzcGVuc2UgPSBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KFxuICAgIHZub2RlLFxuICAgIHBhcmVudFN1c3BlbnNlLFxuICAgIHBhcmVudENvbXBvbmVudCxcbiAgICBub2RlLnBhcmVudE5vZGUsXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgbnVsbCxcbiAgICBuYW1lc3BhY2UsXG4gICAgc2xvdFNjb3BlSWRzLFxuICAgIG9wdGltaXplZCxcbiAgICByZW5kZXJlckludGVybmFscyxcbiAgICB0cnVlXG4gICk7XG4gIGNvbnN0IHJlc3VsdCA9IGh5ZHJhdGVOb2RlKFxuICAgIG5vZGUsXG4gICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IHZub2RlLnNzQ29udGVudCxcbiAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgc3VzcGVuc2UsXG4gICAgc2xvdFNjb3BlSWRzLFxuICAgIG9wdGltaXplZFxuICApO1xuICBpZiAoc3VzcGVuc2UuZGVwcyA9PT0gMCkge1xuICAgIHN1c3BlbnNlLnJlc29sdmUoZmFsc2UsIHRydWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemVTdXNwZW5zZUNoaWxkcmVuKHZub2RlKSB7XG4gIGNvbnN0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiB9ID0gdm5vZGU7XG4gIGNvbnN0IGlzU2xvdENoaWxkcmVuID0gc2hhcGVGbGFnICYgMzI7XG4gIHZub2RlLnNzQ29udGVudCA9IG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChcbiAgICBpc1Nsb3RDaGlsZHJlbiA/IGNoaWxkcmVuLmRlZmF1bHQgOiBjaGlsZHJlblxuICApO1xuICB2bm9kZS5zc0ZhbGxiYWNrID0gaXNTbG90Q2hpbGRyZW4gPyBub3JtYWxpemVTdXNwZW5zZVNsb3QoY2hpbGRyZW4uZmFsbGJhY2spIDogY3JlYXRlVk5vZGUoQ29tbWVudCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVTdXNwZW5zZVNsb3Qocykge1xuICBsZXQgYmxvY2s7XG4gIGlmIChpc0Z1bmN0aW9uKHMpKSB7XG4gICAgY29uc3QgdHJhY2tCbG9jayA9IGlzQmxvY2tUcmVlRW5hYmxlZCAmJiBzLl9jO1xuICAgIGlmICh0cmFja0Jsb2NrKSB7XG4gICAgICBzLl9kID0gZmFsc2U7XG4gICAgICBvcGVuQmxvY2soKTtcbiAgICB9XG4gICAgcyA9IHMoKTtcbiAgICBpZiAodHJhY2tCbG9jaykge1xuICAgICAgcy5fZCA9IHRydWU7XG4gICAgICBibG9jayA9IGN1cnJlbnRCbG9jaztcbiAgICAgIGNsb3NlQmxvY2soKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQXJyYXkocykpIHtcbiAgICBjb25zdCBzaW5nbGVDaGlsZCA9IGZpbHRlclNpbmdsZVJvb3Qocyk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIXNpbmdsZUNoaWxkICYmIHMuZmlsdGVyKChjaGlsZCkgPT4gY2hpbGQgIT09IE5VTExfRFlOQU1JQ19DT01QT05FTlQpLmxlbmd0aCA+IDApIHtcbiAgICAgIHdhcm4kMShgPFN1c3BlbnNlPiBzbG90cyBleHBlY3QgYSBzaW5nbGUgcm9vdCBub2RlLmApO1xuICAgIH1cbiAgICBzID0gc2luZ2xlQ2hpbGQ7XG4gIH1cbiAgcyA9IG5vcm1hbGl6ZVZOb2RlKHMpO1xuICBpZiAoYmxvY2sgJiYgIXMuZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgcy5keW5hbWljQ2hpbGRyZW4gPSBibG9jay5maWx0ZXIoKGMpID0+IGMgIT09IHMpO1xuICB9XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24gcXVldWVFZmZlY3RXaXRoU3VzcGVuc2UoZm4sIHN1c3BlbnNlKSB7XG4gIGlmIChzdXNwZW5zZSAmJiBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XG4gICAgaWYgKGlzQXJyYXkoZm4pKSB7XG4gICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goLi4uZm4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goZm4pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBxdWV1ZVBvc3RGbHVzaENiKGZuKTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBicmFuY2gpIHtcbiAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoID0gYnJhbmNoO1xuICBjb25zdCB7IHZub2RlLCBwYXJlbnRDb21wb25lbnQgfSA9IHN1c3BlbnNlO1xuICBsZXQgZWwgPSBicmFuY2guZWw7XG4gIHdoaWxlICghZWwgJiYgYnJhbmNoLmNvbXBvbmVudCkge1xuICAgIGJyYW5jaCA9IGJyYW5jaC5jb21wb25lbnQuc3ViVHJlZTtcbiAgICBlbCA9IGJyYW5jaC5lbDtcbiAgfVxuICB2bm9kZS5lbCA9IGVsO1xuICBpZiAocGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC5zdWJUcmVlID09PSB2bm9kZSkge1xuICAgIHBhcmVudENvbXBvbmVudC52bm9kZS5lbCA9IGVsO1xuICAgIHVwZGF0ZUhPQ0hvc3RFbChwYXJlbnRDb21wb25lbnQsIGVsKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNWTm9kZVN1c3BlbnNpYmxlKHZub2RlKSB7XG4gIGNvbnN0IHN1c3BlbnNpYmxlID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMuc3VzcGVuc2libGU7XG4gIHJldHVybiBzdXNwZW5zaWJsZSAhPSBudWxsICYmIHN1c3BlbnNpYmxlICE9PSBmYWxzZTtcbn1cblxuY29uc3QgRnJhZ21lbnQgPSBTeW1ib2wuZm9yKFwidi1mZ3RcIik7XG5jb25zdCBUZXh0ID0gU3ltYm9sLmZvcihcInYtdHh0XCIpO1xuY29uc3QgQ29tbWVudCA9IFN5bWJvbC5mb3IoXCJ2LWNtdFwiKTtcbmNvbnN0IFN0YXRpYyA9IFN5bWJvbC5mb3IoXCJ2LXN0Y1wiKTtcbmNvbnN0IGJsb2NrU3RhY2sgPSBbXTtcbmxldCBjdXJyZW50QmxvY2sgPSBudWxsO1xuZnVuY3Rpb24gb3BlbkJsb2NrKGRpc2FibGVUcmFja2luZyA9IGZhbHNlKSB7XG4gIGJsb2NrU3RhY2sucHVzaChjdXJyZW50QmxvY2sgPSBkaXNhYmxlVHJhY2tpbmcgPyBudWxsIDogW10pO1xufVxuZnVuY3Rpb24gY2xvc2VCbG9jaygpIHtcbiAgYmxvY2tTdGFjay5wb3AoKTtcbiAgY3VycmVudEJsb2NrID0gYmxvY2tTdGFja1tibG9ja1N0YWNrLmxlbmd0aCAtIDFdIHx8IG51bGw7XG59XG5sZXQgaXNCbG9ja1RyZWVFbmFibGVkID0gMTtcbmZ1bmN0aW9uIHNldEJsb2NrVHJhY2tpbmcodmFsdWUsIGluVk9uY2UgPSBmYWxzZSkge1xuICBpc0Jsb2NrVHJlZUVuYWJsZWQgKz0gdmFsdWU7XG4gIGlmICh2YWx1ZSA8IDAgJiYgY3VycmVudEJsb2NrICYmIGluVk9uY2UpIHtcbiAgICBjdXJyZW50QmxvY2suaGFzT25jZSA9IHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldHVwQmxvY2sodm5vZGUpIHtcbiAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID0gaXNCbG9ja1RyZWVFbmFibGVkID4gMCA/IGN1cnJlbnRCbG9jayB8fCBFTVBUWV9BUlIgOiBudWxsO1xuICBjbG9zZUJsb2NrKCk7XG4gIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmIGN1cnJlbnRCbG9jaykge1xuICAgIGN1cnJlbnRCbG9jay5wdXNoKHZub2RlKTtcbiAgfVxuICByZXR1cm4gdm5vZGU7XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50QmxvY2sodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgc2hhcGVGbGFnKSB7XG4gIHJldHVybiBzZXR1cEJsb2NrKFxuICAgIGNyZWF0ZUJhc2VWTm9kZShcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgcGF0Y2hGbGFnLFxuICAgICAgZHluYW1pY1Byb3BzLFxuICAgICAgc2hhcGVGbGFnLFxuICAgICAgdHJ1ZVxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMpIHtcbiAgcmV0dXJuIHNldHVwQmxvY2soXG4gICAgY3JlYXRlVk5vZGUoXG4gICAgICB0eXBlLFxuICAgICAgcHJvcHMsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIHBhdGNoRmxhZyxcbiAgICAgIGR5bmFtaWNQcm9wcyxcbiAgICAgIHRydWVcbiAgICApXG4gICk7XG59XG5mdW5jdGlvbiBpc1ZOb2RlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA/IHZhbHVlLl9fdl9pc1ZOb2RlID09PSB0cnVlIDogZmFsc2U7XG59XG5mdW5jdGlvbiBpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG4yLnNoYXBlRmxhZyAmIDYgJiYgbjEuY29tcG9uZW50KSB7XG4gICAgY29uc3QgZGlydHlJbnN0YW5jZXMgPSBobXJEaXJ0eUNvbXBvbmVudHMuZ2V0KG4yLnR5cGUpO1xuICAgIGlmIChkaXJ0eUluc3RhbmNlcyAmJiBkaXJ0eUluc3RhbmNlcy5oYXMobjEuY29tcG9uZW50KSkge1xuICAgICAgbjEuc2hhcGVGbGFnICY9IH4yNTY7XG4gICAgICBuMi5zaGFwZUZsYWcgJj0gfjUxMjtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG4xLnR5cGUgPT09IG4yLnR5cGUgJiYgbjEua2V5ID09PSBuMi5rZXk7XG59XG5sZXQgdm5vZGVBcmdzVHJhbnNmb3JtZXI7XG5mdW5jdGlvbiB0cmFuc2Zvcm1WTm9kZUFyZ3ModHJhbnNmb3JtZXIpIHtcbiAgdm5vZGVBcmdzVHJhbnNmb3JtZXIgPSB0cmFuc2Zvcm1lcjtcbn1cbmNvbnN0IGNyZWF0ZVZOb2RlV2l0aEFyZ3NUcmFuc2Zvcm0gPSAoLi4uYXJncykgPT4ge1xuICByZXR1cm4gX2NyZWF0ZVZOb2RlKFxuICAgIC4uLnZub2RlQXJnc1RyYW5zZm9ybWVyID8gdm5vZGVBcmdzVHJhbnNmb3JtZXIoYXJncywgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKSA6IGFyZ3NcbiAgKTtcbn07XG5jb25zdCBub3JtYWxpemVLZXkgPSAoeyBrZXkgfSkgPT4ga2V5ICE9IG51bGwgPyBrZXkgOiBudWxsO1xuY29uc3Qgbm9ybWFsaXplUmVmID0gKHtcbiAgcmVmLFxuICByZWZfa2V5LFxuICByZWZfZm9yXG59KSA9PiB7XG4gIGlmICh0eXBlb2YgcmVmID09PSBcIm51bWJlclwiKSB7XG4gICAgcmVmID0gXCJcIiArIHJlZjtcbiAgfVxuICByZXR1cm4gcmVmICE9IG51bGwgPyBpc1N0cmluZyhyZWYpIHx8IGlzUmVmKHJlZikgfHwgaXNGdW5jdGlvbihyZWYpID8geyBpOiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsIHI6IHJlZiwgazogcmVmX2tleSwgZjogISFyZWZfZm9yIH0gOiByZWYgOiBudWxsO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VWTm9kZSh0eXBlLCBwcm9wcyA9IG51bGwsIGNoaWxkcmVuID0gbnVsbCwgcGF0Y2hGbGFnID0gMCwgZHluYW1pY1Byb3BzID0gbnVsbCwgc2hhcGVGbGFnID0gdHlwZSA9PT0gRnJhZ21lbnQgPyAwIDogMSwgaXNCbG9ja05vZGUgPSBmYWxzZSwgbmVlZEZ1bGxDaGlsZHJlbk5vcm1hbGl6YXRpb24gPSBmYWxzZSkge1xuICBjb25zdCB2bm9kZSA9IHtcbiAgICBfX3ZfaXNWTm9kZTogdHJ1ZSxcbiAgICBfX3Zfc2tpcDogdHJ1ZSxcbiAgICB0eXBlLFxuICAgIHByb3BzLFxuICAgIGtleTogcHJvcHMgJiYgbm9ybWFsaXplS2V5KHByb3BzKSxcbiAgICByZWY6IHByb3BzICYmIG5vcm1hbGl6ZVJlZihwcm9wcyksXG4gICAgc2NvcGVJZDogY3VycmVudFNjb3BlSWQsXG4gICAgc2xvdFNjb3BlSWRzOiBudWxsLFxuICAgIGNoaWxkcmVuLFxuICAgIGNvbXBvbmVudDogbnVsbCxcbiAgICBzdXNwZW5zZTogbnVsbCxcbiAgICBzc0NvbnRlbnQ6IG51bGwsXG4gICAgc3NGYWxsYmFjazogbnVsbCxcbiAgICBkaXJzOiBudWxsLFxuICAgIHRyYW5zaXRpb246IG51bGwsXG4gICAgZWw6IG51bGwsXG4gICAgYW5jaG9yOiBudWxsLFxuICAgIHRhcmdldDogbnVsbCxcbiAgICB0YXJnZXRTdGFydDogbnVsbCxcbiAgICB0YXJnZXRBbmNob3I6IG51bGwsXG4gICAgc3RhdGljQ291bnQ6IDAsXG4gICAgc2hhcGVGbGFnLFxuICAgIHBhdGNoRmxhZyxcbiAgICBkeW5hbWljUHJvcHMsXG4gICAgZHluYW1pY0NoaWxkcmVuOiBudWxsLFxuICAgIGFwcENvbnRleHQ6IG51bGwsXG4gICAgY3R4OiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2VcbiAgfTtcbiAgaWYgKG5lZWRGdWxsQ2hpbGRyZW5Ob3JtYWxpemF0aW9uKSB7XG4gICAgbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuKTtcbiAgICBpZiAoc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICB0eXBlLm5vcm1hbGl6ZSh2bm9kZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGNoaWxkcmVuKSB7XG4gICAgdm5vZGUuc2hhcGVGbGFnIHw9IGlzU3RyaW5nKGNoaWxkcmVuKSA/IDggOiAxNjtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB2bm9kZS5rZXkgIT09IHZub2RlLmtleSkge1xuICAgIHdhcm4kMShgVk5vZGUgY3JlYXRlZCB3aXRoIGludmFsaWQga2V5IChOYU4pLiBWTm9kZSB0eXBlOmAsIHZub2RlLnR5cGUpO1xuICB9XG4gIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmIC8vIGF2b2lkIGEgYmxvY2sgbm9kZSBmcm9tIHRyYWNraW5nIGl0c2VsZlxuICAhaXNCbG9ja05vZGUgJiYgLy8gaGFzIGN1cnJlbnQgcGFyZW50IGJsb2NrXG4gIGN1cnJlbnRCbG9jayAmJiAvLyBwcmVzZW5jZSBvZiBhIHBhdGNoIGZsYWcgaW5kaWNhdGVzIHRoaXMgbm9kZSBuZWVkcyBwYXRjaGluZyBvbiB1cGRhdGVzLlxuICAvLyBjb21wb25lbnQgbm9kZXMgYWxzbyBzaG91bGQgYWx3YXlzIGJlIHBhdGNoZWQsIGJlY2F1c2UgZXZlbiBpZiB0aGVcbiAgLy8gY29tcG9uZW50IGRvZXNuJ3QgbmVlZCB0byB1cGRhdGUsIGl0IG5lZWRzIHRvIHBlcnNpc3QgdGhlIGluc3RhbmNlIG9uIHRvXG4gIC8vIHRoZSBuZXh0IHZub2RlIHNvIHRoYXQgaXQgY2FuIGJlIHByb3Blcmx5IHVubW91bnRlZCBsYXRlci5cbiAgKHZub2RlLnBhdGNoRmxhZyA+IDAgfHwgc2hhcGVGbGFnICYgNikgJiYgLy8gdGhlIEVWRU5UUyBmbGFnIGlzIG9ubHkgZm9yIGh5ZHJhdGlvbiBhbmQgaWYgaXQgaXMgdGhlIG9ubHkgZmxhZywgdGhlXG4gIC8vIHZub2RlIHNob3VsZCBub3QgYmUgY29uc2lkZXJlZCBkeW5hbWljIGR1ZSB0byBoYW5kbGVyIGNhY2hpbmcuXG4gIHZub2RlLnBhdGNoRmxhZyAhPT0gMzIpIHtcbiAgICBjdXJyZW50QmxvY2sucHVzaCh2bm9kZSk7XG4gIH1cbiAgcmV0dXJuIHZub2RlO1xufVxuY29uc3QgY3JlYXRlVk5vZGUgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gY3JlYXRlVk5vZGVXaXRoQXJnc1RyYW5zZm9ybSA6IF9jcmVhdGVWTm9kZTtcbmZ1bmN0aW9uIF9jcmVhdGVWTm9kZSh0eXBlLCBwcm9wcyA9IG51bGwsIGNoaWxkcmVuID0gbnVsbCwgcGF0Y2hGbGFnID0gMCwgZHluYW1pY1Byb3BzID0gbnVsbCwgaXNCbG9ja05vZGUgPSBmYWxzZSkge1xuICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICF0eXBlKSB7XG4gICAgICB3YXJuJDEoYEludmFsaWQgdm5vZGUgdHlwZSB3aGVuIGNyZWF0aW5nIHZub2RlOiAke3R5cGV9LmApO1xuICAgIH1cbiAgICB0eXBlID0gQ29tbWVudDtcbiAgfVxuICBpZiAoaXNWTm9kZSh0eXBlKSkge1xuICAgIGNvbnN0IGNsb25lZCA9IGNsb25lVk5vZGUoXG4gICAgICB0eXBlLFxuICAgICAgcHJvcHMsXG4gICAgICB0cnVlXG4gICAgICAvKiBtZXJnZVJlZjogdHJ1ZSAqL1xuICAgICk7XG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBub3JtYWxpemVDaGlsZHJlbihjbG9uZWQsIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgIWlzQmxvY2tOb2RlICYmIGN1cnJlbnRCbG9jaykge1xuICAgICAgaWYgKGNsb25lZC5zaGFwZUZsYWcgJiA2KSB7XG4gICAgICAgIGN1cnJlbnRCbG9ja1tjdXJyZW50QmxvY2suaW5kZXhPZih0eXBlKV0gPSBjbG9uZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50QmxvY2sucHVzaChjbG9uZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBjbG9uZWQucGF0Y2hGbGFnID0gLTI7XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxuICBpZiAoaXNDbGFzc0NvbXBvbmVudCh0eXBlKSkge1xuICAgIHR5cGUgPSB0eXBlLl9fdmNjT3B0cztcbiAgfVxuICBpZiAocHJvcHMpIHtcbiAgICBwcm9wcyA9IGd1YXJkUmVhY3RpdmVQcm9wcyhwcm9wcyk7XG4gICAgbGV0IHsgY2xhc3M6IGtsYXNzLCBzdHlsZSB9ID0gcHJvcHM7XG4gICAgaWYgKGtsYXNzICYmICFpc1N0cmluZyhrbGFzcykpIHtcbiAgICAgIHByb3BzLmNsYXNzID0gbm9ybWFsaXplQ2xhc3Moa2xhc3MpO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3Qoc3R5bGUpKSB7XG4gICAgICBpZiAoaXNQcm94eShzdHlsZSkgJiYgIWlzQXJyYXkoc3R5bGUpKSB7XG4gICAgICAgIHN0eWxlID0gZXh0ZW5kKHt9LCBzdHlsZSk7XG4gICAgICB9XG4gICAgICBwcm9wcy5zdHlsZSA9IG5vcm1hbGl6ZVN0eWxlKHN0eWxlKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc2hhcGVGbGFnID0gaXNTdHJpbmcodHlwZSkgPyAxIDogaXNTdXNwZW5zZSh0eXBlKSA/IDEyOCA6IGlzVGVsZXBvcnQodHlwZSkgPyA2NCA6IGlzT2JqZWN0KHR5cGUpID8gNCA6IGlzRnVuY3Rpb24odHlwZSkgPyAyIDogMDtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2hhcGVGbGFnICYgNCAmJiBpc1Byb3h5KHR5cGUpKSB7XG4gICAgdHlwZSA9IHRvUmF3KHR5cGUpO1xuICAgIHdhcm4kMShcbiAgICAgIGBWdWUgcmVjZWl2ZWQgYSBDb21wb25lbnQgdGhhdCB3YXMgbWFkZSBhIHJlYWN0aXZlIG9iamVjdC4gVGhpcyBjYW4gbGVhZCB0byB1bm5lY2Vzc2FyeSBwZXJmb3JtYW5jZSBvdmVyaGVhZCBhbmQgc2hvdWxkIGJlIGF2b2lkZWQgYnkgbWFya2luZyB0aGUgY29tcG9uZW50IHdpdGggXFxgbWFya1Jhd1xcYCBvciB1c2luZyBcXGBzaGFsbG93UmVmXFxgIGluc3RlYWQgb2YgXFxgcmVmXFxgLmAsXG4gICAgICBgXG5Db21wb25lbnQgdGhhdCB3YXMgbWFkZSByZWFjdGl2ZTogYCxcbiAgICAgIHR5cGVcbiAgICApO1xuICB9XG4gIHJldHVybiBjcmVhdGVCYXNlVk5vZGUoXG4gICAgdHlwZSxcbiAgICBwcm9wcyxcbiAgICBjaGlsZHJlbixcbiAgICBwYXRjaEZsYWcsXG4gICAgZHluYW1pY1Byb3BzLFxuICAgIHNoYXBlRmxhZyxcbiAgICBpc0Jsb2NrTm9kZSxcbiAgICB0cnVlXG4gICk7XG59XG5mdW5jdGlvbiBndWFyZFJlYWN0aXZlUHJvcHMocHJvcHMpIHtcbiAgaWYgKCFwcm9wcykgcmV0dXJuIG51bGw7XG4gIHJldHVybiBpc1Byb3h5KHByb3BzKSB8fCBpc0ludGVybmFsT2JqZWN0KHByb3BzKSA/IGV4dGVuZCh7fSwgcHJvcHMpIDogcHJvcHM7XG59XG5mdW5jdGlvbiBjbG9uZVZOb2RlKHZub2RlLCBleHRyYVByb3BzLCBtZXJnZVJlZiA9IGZhbHNlLCBjbG9uZVRyYW5zaXRpb24gPSBmYWxzZSkge1xuICBjb25zdCB7IHByb3BzLCByZWYsIHBhdGNoRmxhZywgY2hpbGRyZW4sIHRyYW5zaXRpb24gfSA9IHZub2RlO1xuICBjb25zdCBtZXJnZWRQcm9wcyA9IGV4dHJhUHJvcHMgPyBtZXJnZVByb3BzKHByb3BzIHx8IHt9LCBleHRyYVByb3BzKSA6IHByb3BzO1xuICBjb25zdCBjbG9uZWQgPSB7XG4gICAgX192X2lzVk5vZGU6IHRydWUsXG4gICAgX192X3NraXA6IHRydWUsXG4gICAgdHlwZTogdm5vZGUudHlwZSxcbiAgICBwcm9wczogbWVyZ2VkUHJvcHMsXG4gICAga2V5OiBtZXJnZWRQcm9wcyAmJiBub3JtYWxpemVLZXkobWVyZ2VkUHJvcHMpLFxuICAgIHJlZjogZXh0cmFQcm9wcyAmJiBleHRyYVByb3BzLnJlZiA/IChcbiAgICAgIC8vICMyMDc4IGluIHRoZSBjYXNlIG9mIDxjb21wb25lbnQgOmlzPVwidm5vZGVcIiByZWY9XCJleHRyYVwiLz5cbiAgICAgIC8vIGlmIHRoZSB2bm9kZSBpdHNlbGYgYWxyZWFkeSBoYXMgYSByZWYsIGNsb25lVk5vZGUgd2lsbCBuZWVkIHRvIG1lcmdlXG4gICAgICAvLyB0aGUgcmVmcyBzbyB0aGUgc2luZ2xlIHZub2RlIGNhbiBiZSBzZXQgb24gbXVsdGlwbGUgcmVmc1xuICAgICAgbWVyZ2VSZWYgJiYgcmVmID8gaXNBcnJheShyZWYpID8gcmVmLmNvbmNhdChub3JtYWxpemVSZWYoZXh0cmFQcm9wcykpIDogW3JlZiwgbm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpXSA6IG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKVxuICAgICkgOiByZWYsXG4gICAgc2NvcGVJZDogdm5vZGUuc2NvcGVJZCxcbiAgICBzbG90U2NvcGVJZHM6IHZub2RlLnNsb3RTY29wZUlkcyxcbiAgICBjaGlsZHJlbjogISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBwYXRjaEZsYWcgPT09IC0xICYmIGlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4ubWFwKGRlZXBDbG9uZVZOb2RlKSA6IGNoaWxkcmVuLFxuICAgIHRhcmdldDogdm5vZGUudGFyZ2V0LFxuICAgIHRhcmdldFN0YXJ0OiB2bm9kZS50YXJnZXRTdGFydCxcbiAgICB0YXJnZXRBbmNob3I6IHZub2RlLnRhcmdldEFuY2hvcixcbiAgICBzdGF0aWNDb3VudDogdm5vZGUuc3RhdGljQ291bnQsXG4gICAgc2hhcGVGbGFnOiB2bm9kZS5zaGFwZUZsYWcsXG4gICAgLy8gaWYgdGhlIHZub2RlIGlzIGNsb25lZCB3aXRoIGV4dHJhIHByb3BzLCB3ZSBjYW4gbm8gbG9uZ2VyIGFzc3VtZSBpdHNcbiAgICAvLyBleGlzdGluZyBwYXRjaCBmbGFnIHRvIGJlIHJlbGlhYmxlIGFuZCBuZWVkIHRvIGFkZCB0aGUgRlVMTF9QUk9QUyBmbGFnLlxuICAgIC8vIG5vdGU6IHByZXNlcnZlIGZsYWcgZm9yIGZyYWdtZW50cyBzaW5jZSB0aGV5IHVzZSB0aGUgZmxhZyBmb3IgY2hpbGRyZW5cbiAgICAvLyBmYXN0IHBhdGhzIG9ubHkuXG4gICAgcGF0Y2hGbGFnOiBleHRyYVByb3BzICYmIHZub2RlLnR5cGUgIT09IEZyYWdtZW50ID8gcGF0Y2hGbGFnID09PSAtMSA/IDE2IDogcGF0Y2hGbGFnIHwgMTYgOiBwYXRjaEZsYWcsXG4gICAgZHluYW1pY1Byb3BzOiB2bm9kZS5keW5hbWljUHJvcHMsXG4gICAgZHluYW1pY0NoaWxkcmVuOiB2bm9kZS5keW5hbWljQ2hpbGRyZW4sXG4gICAgYXBwQ29udGV4dDogdm5vZGUuYXBwQ29udGV4dCxcbiAgICBkaXJzOiB2bm9kZS5kaXJzLFxuICAgIHRyYW5zaXRpb24sXG4gICAgLy8gVGhlc2Ugc2hvdWxkIHRlY2huaWNhbGx5IG9ubHkgYmUgbm9uLW51bGwgb24gbW91bnRlZCBWTm9kZXMuIEhvd2V2ZXIsXG4gICAgLy8gdGhleSAqc2hvdWxkKiBiZSBjb3BpZWQgZm9yIGtlcHQtYWxpdmUgdm5vZGVzLiBTbyB3ZSBqdXN0IGFsd2F5cyBjb3B5XG4gICAgLy8gdGhlbSBzaW5jZSB0aGVtIGJlaW5nIG5vbi1udWxsIGR1cmluZyBhIG1vdW50IGRvZXNuJ3QgYWZmZWN0IHRoZSBsb2dpYyBhc1xuICAgIC8vIHRoZXkgd2lsbCBzaW1wbHkgYmUgb3ZlcndyaXR0ZW4uXG4gICAgY29tcG9uZW50OiB2bm9kZS5jb21wb25lbnQsXG4gICAgc3VzcGVuc2U6IHZub2RlLnN1c3BlbnNlLFxuICAgIHNzQ29udGVudDogdm5vZGUuc3NDb250ZW50ICYmIGNsb25lVk5vZGUodm5vZGUuc3NDb250ZW50KSxcbiAgICBzc0ZhbGxiYWNrOiB2bm9kZS5zc0ZhbGxiYWNrICYmIGNsb25lVk5vZGUodm5vZGUuc3NGYWxsYmFjayksXG4gICAgZWw6IHZub2RlLmVsLFxuICAgIGFuY2hvcjogdm5vZGUuYW5jaG9yLFxuICAgIGN0eDogdm5vZGUuY3R4LFxuICAgIGNlOiB2bm9kZS5jZVxuICB9O1xuICBpZiAodHJhbnNpdGlvbiAmJiBjbG9uZVRyYW5zaXRpb24pIHtcbiAgICBzZXRUcmFuc2l0aW9uSG9va3MoXG4gICAgICBjbG9uZWQsXG4gICAgICB0cmFuc2l0aW9uLmNsb25lKGNsb25lZClcbiAgICApO1xuICB9XG4gIHJldHVybiBjbG9uZWQ7XG59XG5mdW5jdGlvbiBkZWVwQ2xvbmVWTm9kZSh2bm9kZSkge1xuICBjb25zdCBjbG9uZWQgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgaWYgKGlzQXJyYXkodm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgY2xvbmVkLmNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW4ubWFwKGRlZXBDbG9uZVZOb2RlKTtcbiAgfVxuICByZXR1cm4gY2xvbmVkO1xufVxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlKHRleHQgPSBcIiBcIiwgZmxhZyA9IDApIHtcbiAgcmV0dXJuIGNyZWF0ZVZOb2RlKFRleHQsIG51bGwsIHRleHQsIGZsYWcpO1xufVxuZnVuY3Rpb24gY3JlYXRlU3RhdGljVk5vZGUoY29udGVudCwgbnVtYmVyT2ZOb2Rlcykge1xuICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKFN0YXRpYywgbnVsbCwgY29udGVudCk7XG4gIHZub2RlLnN0YXRpY0NvdW50ID0gbnVtYmVyT2ZOb2RlcztcbiAgcmV0dXJuIHZub2RlO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudFZOb2RlKHRleHQgPSBcIlwiLCBhc0Jsb2NrID0gZmFsc2UpIHtcbiAgcmV0dXJuIGFzQmxvY2sgPyAob3BlbkJsb2NrKCksIGNyZWF0ZUJsb2NrKENvbW1lbnQsIG51bGwsIHRleHQpKSA6IGNyZWF0ZVZOb2RlKENvbW1lbnQsIG51bGwsIHRleHQpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplVk5vZGUoY2hpbGQpIHtcbiAgaWYgKGNoaWxkID09IG51bGwgfHwgdHlwZW9mIGNoaWxkID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiBjcmVhdGVWTm9kZShDb21tZW50KTtcbiAgfSBlbHNlIGlmIChpc0FycmF5KGNoaWxkKSkge1xuICAgIHJldHVybiBjcmVhdGVWTm9kZShcbiAgICAgIEZyYWdtZW50LFxuICAgICAgbnVsbCxcbiAgICAgIC8vICMzNjY2LCBhdm9pZCByZWZlcmVuY2UgcG9sbHV0aW9uIHdoZW4gcmV1c2luZyB2bm9kZVxuICAgICAgY2hpbGQuc2xpY2UoKVxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNWTm9kZShjaGlsZCkpIHtcbiAgICByZXR1cm4gY2xvbmVJZk1vdW50ZWQoY2hpbGQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVWTm9kZShUZXh0LCBudWxsLCBTdHJpbmcoY2hpbGQpKTtcbiAgfVxufVxuZnVuY3Rpb24gY2xvbmVJZk1vdW50ZWQoY2hpbGQpIHtcbiAgcmV0dXJuIGNoaWxkLmVsID09PSBudWxsICYmIGNoaWxkLnBhdGNoRmxhZyAhPT0gLTEgfHwgY2hpbGQubWVtbyA/IGNoaWxkIDogY2xvbmVWTm9kZShjaGlsZCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4pIHtcbiAgbGV0IHR5cGUgPSAwO1xuICBjb25zdCB7IHNoYXBlRmxhZyB9ID0gdm5vZGU7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgdHlwZSA9IDE2O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJvYmplY3RcIikge1xuICAgIGlmIChzaGFwZUZsYWcgJiAoMSB8IDY0KSkge1xuICAgICAgY29uc3Qgc2xvdCA9IGNoaWxkcmVuLmRlZmF1bHQ7XG4gICAgICBpZiAoc2xvdCkge1xuICAgICAgICBzbG90Ll9jICYmIChzbG90Ll9kID0gZmFsc2UpO1xuICAgICAgICBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgc2xvdCgpKTtcbiAgICAgICAgc2xvdC5fYyAmJiAoc2xvdC5fZCA9IHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gMzI7XG4gICAgICBjb25zdCBzbG90RmxhZyA9IGNoaWxkcmVuLl87XG4gICAgICBpZiAoIXNsb3RGbGFnICYmICFpc0ludGVybmFsT2JqZWN0KGNoaWxkcmVuKSkge1xuICAgICAgICBjaGlsZHJlbi5fY3R4ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICAgICAgfSBlbHNlIGlmIChzbG90RmxhZyA9PT0gMyAmJiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5zbG90cy5fID09PSAxKSB7XG4gICAgICAgICAgY2hpbGRyZW4uXyA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hpbGRyZW4uXyA9IDI7XG4gICAgICAgICAgdm5vZGUucGF0Y2hGbGFnIHw9IDEwMjQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihjaGlsZHJlbikpIHtcbiAgICBjaGlsZHJlbiA9IHsgZGVmYXVsdDogY2hpbGRyZW4sIF9jdHg6IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSB9O1xuICAgIHR5cGUgPSAzMjtcbiAgfSBlbHNlIHtcbiAgICBjaGlsZHJlbiA9IFN0cmluZyhjaGlsZHJlbik7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDY0KSB7XG4gICAgICB0eXBlID0gMTY7XG4gICAgICBjaGlsZHJlbiA9IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZSA9IDg7XG4gICAgfVxuICB9XG4gIHZub2RlLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHZub2RlLnNoYXBlRmxhZyB8PSB0eXBlO1xufVxuZnVuY3Rpb24gbWVyZ2VQcm9wcyguLi5hcmdzKSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0b01lcmdlID0gYXJnc1tpXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0b01lcmdlKSB7XG4gICAgICBpZiAoa2V5ID09PSBcImNsYXNzXCIpIHtcbiAgICAgICAgaWYgKHJldC5jbGFzcyAhPT0gdG9NZXJnZS5jbGFzcykge1xuICAgICAgICAgIHJldC5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKFtyZXQuY2xhc3MsIHRvTWVyZ2UuY2xhc3NdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwic3R5bGVcIikge1xuICAgICAgICByZXQuc3R5bGUgPSBub3JtYWxpemVTdHlsZShbcmV0LnN0eWxlLCB0b01lcmdlLnN0eWxlXSk7XG4gICAgICB9IGVsc2UgaWYgKGlzT24oa2V5KSkge1xuICAgICAgICBjb25zdCBleGlzdGluZyA9IHJldFtrZXldO1xuICAgICAgICBjb25zdCBpbmNvbWluZyA9IHRvTWVyZ2Vba2V5XTtcbiAgICAgICAgaWYgKGluY29taW5nICYmIGV4aXN0aW5nICE9PSBpbmNvbWluZyAmJiAhKGlzQXJyYXkoZXhpc3RpbmcpICYmIGV4aXN0aW5nLmluY2x1ZGVzKGluY29taW5nKSkpIHtcbiAgICAgICAgICByZXRba2V5XSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBpbmNvbWluZykgOiBpbmNvbWluZztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgIT09IFwiXCIpIHtcbiAgICAgICAgcmV0W2tleV0gPSB0b01lcmdlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBpbnZva2VWTm9kZUhvb2soaG9vaywgaW5zdGFuY2UsIHZub2RlLCBwcmV2Vk5vZGUgPSBudWxsKSB7XG4gIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIGluc3RhbmNlLCA3LCBbXG4gICAgdm5vZGUsXG4gICAgcHJldlZOb2RlXG4gIF0pO1xufVxuXG5jb25zdCBlbXB0eUFwcENvbnRleHQgPSBjcmVhdGVBcHBDb250ZXh0KCk7XG5sZXQgdWlkID0gMDtcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlKHZub2RlLCBwYXJlbnQsIHN1c3BlbnNlKSB7XG4gIGNvbnN0IHR5cGUgPSB2bm9kZS50eXBlO1xuICBjb25zdCBhcHBDb250ZXh0ID0gKHBhcmVudCA/IHBhcmVudC5hcHBDb250ZXh0IDogdm5vZGUuYXBwQ29udGV4dCkgfHwgZW1wdHlBcHBDb250ZXh0O1xuICBjb25zdCBpbnN0YW5jZSA9IHtcbiAgICB1aWQ6IHVpZCsrLFxuICAgIHZub2RlLFxuICAgIHR5cGUsXG4gICAgcGFyZW50LFxuICAgIGFwcENvbnRleHQsXG4gICAgcm9vdDogbnVsbCxcbiAgICAvLyB0byBiZSBpbW1lZGlhdGVseSBzZXRcbiAgICBuZXh0OiBudWxsLFxuICAgIHN1YlRyZWU6IG51bGwsXG4gICAgLy8gd2lsbCBiZSBzZXQgc3luY2hyb25vdXNseSByaWdodCBhZnRlciBjcmVhdGlvblxuICAgIGVmZmVjdDogbnVsbCxcbiAgICB1cGRhdGU6IG51bGwsXG4gICAgLy8gd2lsbCBiZSBzZXQgc3luY2hyb25vdXNseSByaWdodCBhZnRlciBjcmVhdGlvblxuICAgIGpvYjogbnVsbCxcbiAgICBzY29wZTogbmV3IEVmZmVjdFNjb3BlKFxuICAgICAgdHJ1ZVxuICAgICAgLyogZGV0YWNoZWQgKi9cbiAgICApLFxuICAgIHJlbmRlcjogbnVsbCxcbiAgICBwcm94eTogbnVsbCxcbiAgICBleHBvc2VkOiBudWxsLFxuICAgIGV4cG9zZVByb3h5OiBudWxsLFxuICAgIHdpdGhQcm94eTogbnVsbCxcbiAgICBwcm92aWRlczogcGFyZW50ID8gcGFyZW50LnByb3ZpZGVzIDogT2JqZWN0LmNyZWF0ZShhcHBDb250ZXh0LnByb3ZpZGVzKSxcbiAgICBpZHM6IHBhcmVudCA/IHBhcmVudC5pZHMgOiBbXCJcIiwgMCwgMF0sXG4gICAgYWNjZXNzQ2FjaGU6IG51bGwsXG4gICAgcmVuZGVyQ2FjaGU6IFtdLFxuICAgIC8vIGxvY2FsIHJlc29sdmVkIGFzc2V0c1xuICAgIGNvbXBvbmVudHM6IG51bGwsXG4gICAgZGlyZWN0aXZlczogbnVsbCxcbiAgICAvLyByZXNvbHZlZCBwcm9wcyBhbmQgZW1pdHMgb3B0aW9uc1xuICAgIHByb3BzT3B0aW9uczogbm9ybWFsaXplUHJvcHNPcHRpb25zKHR5cGUsIGFwcENvbnRleHQpLFxuICAgIGVtaXRzT3B0aW9uczogbm9ybWFsaXplRW1pdHNPcHRpb25zKHR5cGUsIGFwcENvbnRleHQpLFxuICAgIC8vIGVtaXRcbiAgICBlbWl0OiBudWxsLFxuICAgIC8vIHRvIGJlIHNldCBpbW1lZGlhdGVseVxuICAgIGVtaXR0ZWQ6IG51bGwsXG4gICAgLy8gcHJvcHMgZGVmYXVsdCB2YWx1ZVxuICAgIHByb3BzRGVmYXVsdHM6IEVNUFRZX09CSixcbiAgICAvLyBpbmhlcml0QXR0cnNcbiAgICBpbmhlcml0QXR0cnM6IHR5cGUuaW5oZXJpdEF0dHJzLFxuICAgIC8vIHN0YXRlXG4gICAgY3R4OiBFTVBUWV9PQkosXG4gICAgZGF0YTogRU1QVFlfT0JKLFxuICAgIHByb3BzOiBFTVBUWV9PQkosXG4gICAgYXR0cnM6IEVNUFRZX09CSixcbiAgICBzbG90czogRU1QVFlfT0JKLFxuICAgIHJlZnM6IEVNUFRZX09CSixcbiAgICBzZXR1cFN0YXRlOiBFTVBUWV9PQkosXG4gICAgc2V0dXBDb250ZXh0OiBudWxsLFxuICAgIC8vIHN1c3BlbnNlIHJlbGF0ZWRcbiAgICBzdXNwZW5zZSxcbiAgICBzdXNwZW5zZUlkOiBzdXNwZW5zZSA/IHN1c3BlbnNlLnBlbmRpbmdJZCA6IDAsXG4gICAgYXN5bmNEZXA6IG51bGwsXG4gICAgYXN5bmNSZXNvbHZlZDogZmFsc2UsXG4gICAgLy8gbGlmZWN5Y2xlIGhvb2tzXG4gICAgLy8gbm90IHVzaW5nIGVudW1zIGhlcmUgYmVjYXVzZSBpdCByZXN1bHRzIGluIGNvbXB1dGVkIHByb3BlcnRpZXNcbiAgICBpc01vdW50ZWQ6IGZhbHNlLFxuICAgIGlzVW5tb3VudGVkOiBmYWxzZSxcbiAgICBpc0RlYWN0aXZhdGVkOiBmYWxzZSxcbiAgICBiYzogbnVsbCxcbiAgICBjOiBudWxsLFxuICAgIGJtOiBudWxsLFxuICAgIG06IG51bGwsXG4gICAgYnU6IG51bGwsXG4gICAgdTogbnVsbCxcbiAgICB1bTogbnVsbCxcbiAgICBidW06IG51bGwsXG4gICAgZGE6IG51bGwsXG4gICAgYTogbnVsbCxcbiAgICBydGc6IG51bGwsXG4gICAgcnRjOiBudWxsLFxuICAgIGVjOiBudWxsLFxuICAgIHNwOiBudWxsXG4gIH07XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgaW5zdGFuY2UuY3R4ID0gY3JlYXRlRGV2UmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XG4gIH0gZWxzZSB7XG4gICAgaW5zdGFuY2UuY3R4ID0geyBfOiBpbnN0YW5jZSB9O1xuICB9XG4gIGluc3RhbmNlLnJvb3QgPSBwYXJlbnQgPyBwYXJlbnQucm9vdCA6IGluc3RhbmNlO1xuICBpbnN0YW5jZS5lbWl0ID0gZW1pdC5iaW5kKG51bGwsIGluc3RhbmNlKTtcbiAgaWYgKHZub2RlLmNlKSB7XG4gICAgdm5vZGUuY2UoaW5zdGFuY2UpO1xuICB9XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmxldCBjdXJyZW50SW5zdGFuY2UgPSBudWxsO1xuY29uc3QgZ2V0Q3VycmVudEluc3RhbmNlID0gKCkgPT4gY3VycmVudEluc3RhbmNlIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbmxldCBpbnRlcm5hbFNldEN1cnJlbnRJbnN0YW5jZTtcbmxldCBzZXRJblNTUlNldHVwU3RhdGU7XG57XG4gIGNvbnN0IGcgPSBnZXRHbG9iYWxUaGlzKCk7XG4gIGNvbnN0IHJlZ2lzdGVyR2xvYmFsU2V0dGVyID0gKGtleSwgc2V0dGVyKSA9PiB7XG4gICAgbGV0IHNldHRlcnM7XG4gICAgaWYgKCEoc2V0dGVycyA9IGdba2V5XSkpIHNldHRlcnMgPSBnW2tleV0gPSBbXTtcbiAgICBzZXR0ZXJzLnB1c2goc2V0dGVyKTtcbiAgICByZXR1cm4gKHYpID0+IHtcbiAgICAgIGlmIChzZXR0ZXJzLmxlbmd0aCA+IDEpIHNldHRlcnMuZm9yRWFjaCgoc2V0KSA9PiBzZXQodikpO1xuICAgICAgZWxzZSBzZXR0ZXJzWzBdKHYpO1xuICAgIH07XG4gIH07XG4gIGludGVybmFsU2V0Q3VycmVudEluc3RhbmNlID0gcmVnaXN0ZXJHbG9iYWxTZXR0ZXIoXG4gICAgYF9fVlVFX0lOU1RBTkNFX1NFVFRFUlNfX2AsXG4gICAgKHYpID0+IGN1cnJlbnRJbnN0YW5jZSA9IHZcbiAgKTtcbiAgc2V0SW5TU1JTZXR1cFN0YXRlID0gcmVnaXN0ZXJHbG9iYWxTZXR0ZXIoXG4gICAgYF9fVlVFX1NTUl9TRVRURVJTX19gLFxuICAgICh2KSA9PiBpc0luU1NSQ29tcG9uZW50U2V0dXAgPSB2XG4gICk7XG59XG5jb25zdCBzZXRDdXJyZW50SW5zdGFuY2UgPSAoaW5zdGFuY2UpID0+IHtcbiAgY29uc3QgcHJldiA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgaW50ZXJuYWxTZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xuICBpbnN0YW5jZS5zY29wZS5vbigpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGluc3RhbmNlLnNjb3BlLm9mZigpO1xuICAgIGludGVybmFsU2V0Q3VycmVudEluc3RhbmNlKHByZXYpO1xuICB9O1xufTtcbmNvbnN0IHVuc2V0Q3VycmVudEluc3RhbmNlID0gKCkgPT4ge1xuICBjdXJyZW50SW5zdGFuY2UgJiYgY3VycmVudEluc3RhbmNlLnNjb3BlLm9mZigpO1xuICBpbnRlcm5hbFNldEN1cnJlbnRJbnN0YW5jZShudWxsKTtcbn07XG5jb25zdCBpc0J1aWx0SW5UYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcInNsb3QsY29tcG9uZW50XCIpO1xuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUsIHsgaXNOYXRpdmVUYWcgfSkge1xuICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGlzTmF0aXZlVGFnKG5hbWUpKSB7XG4gICAgd2FybiQxKFxuICAgICAgXCJEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50IGlkOiBcIiArIG5hbWVcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBpc1N0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlKSB7XG4gIHJldHVybiBpbnN0YW5jZS52bm9kZS5zaGFwZUZsYWcgJiA0O1xufVxubGV0IGlzSW5TU1JDb21wb25lbnRTZXR1cCA9IGZhbHNlO1xuZnVuY3Rpb24gc2V0dXBDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSID0gZmFsc2UsIG9wdGltaXplZCA9IGZhbHNlKSB7XG4gIGlzU1NSICYmIHNldEluU1NSU2V0dXBTdGF0ZShpc1NTUik7XG4gIGNvbnN0IHsgcHJvcHMsIGNoaWxkcmVuIH0gPSBpbnN0YW5jZS52bm9kZTtcbiAgY29uc3QgaXNTdGF0ZWZ1bCA9IGlzU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UpO1xuICBpbml0UHJvcHMoaW5zdGFuY2UsIHByb3BzLCBpc1N0YXRlZnVsLCBpc1NTUik7XG4gIGluaXRTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4sIG9wdGltaXplZCk7XG4gIGNvbnN0IHNldHVwUmVzdWx0ID0gaXNTdGF0ZWZ1bCA/IHNldHVwU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSKSA6IHZvaWQgMDtcbiAgaXNTU1IgJiYgc2V0SW5TU1JTZXR1cFN0YXRlKGZhbHNlKTtcbiAgcmV0dXJuIHNldHVwUmVzdWx0O1xufVxuZnVuY3Rpb24gc2V0dXBTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSwgaXNTU1IpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGlmIChDb21wb25lbnQubmFtZSkge1xuICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKENvbXBvbmVudC5uYW1lLCBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZyk7XG4gICAgfVxuICAgIGlmIChDb21wb25lbnQuY29tcG9uZW50cykge1xuICAgICAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhDb21wb25lbnQuY29tcG9uZW50cyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lc1tpXSwgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoQ29tcG9uZW50LmRpcmVjdGl2ZXMpIHtcbiAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoQ29tcG9uZW50LmRpcmVjdGl2ZXMpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoQ29tcG9uZW50LmNvbXBpbGVyT3B0aW9ucyAmJiBpc1J1bnRpbWVPbmx5KCkpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYFwiY29tcGlsZXJPcHRpb25zXCIgaXMgb25seSBzdXBwb3J0ZWQgd2hlbiB1c2luZyBhIGJ1aWxkIG9mIFZ1ZSB0aGF0IGluY2x1ZGVzIHRoZSBydW50aW1lIGNvbXBpbGVyLiBTaW5jZSB5b3UgYXJlIHVzaW5nIGEgcnVudGltZS1vbmx5IGJ1aWxkLCB0aGUgb3B0aW9ucyBzaG91bGQgYmUgcGFzc2VkIHZpYSB5b3VyIGJ1aWxkIHRvb2wgY29uZmlnIGluc3RlYWQuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaW5zdGFuY2UuYWNjZXNzQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaW5zdGFuY2UucHJveHkgPSBuZXcgUHJveHkoaW5zdGFuY2UuY3R4LCBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGV4cG9zZVByb3BzT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcbiAgfVxuICBjb25zdCB7IHNldHVwIH0gPSBDb21wb25lbnQ7XG4gIGlmIChzZXR1cCkge1xuICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICBjb25zdCBzZXR1cENvbnRleHQgPSBpbnN0YW5jZS5zZXR1cENvbnRleHQgPSBzZXR1cC5sZW5ndGggPiAxID8gY3JlYXRlU2V0dXBDb250ZXh0KGluc3RhbmNlKSA6IG51bGw7XG4gICAgY29uc3QgcmVzZXQgPSBzZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgIGNvbnN0IHNldHVwUmVzdWx0ID0gY2FsbFdpdGhFcnJvckhhbmRsaW5nKFxuICAgICAgc2V0dXAsXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDAsXG4gICAgICBbXG4gICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkoaW5zdGFuY2UucHJvcHMpIDogaW5zdGFuY2UucHJvcHMsXG4gICAgICAgIHNldHVwQ29udGV4dFxuICAgICAgXVxuICAgICk7XG4gICAgY29uc3QgaXNBc3luY1NldHVwID0gaXNQcm9taXNlKHNldHVwUmVzdWx0KTtcbiAgICByZXNldFRyYWNraW5nKCk7XG4gICAgcmVzZXQoKTtcbiAgICBpZiAoKGlzQXN5bmNTZXR1cCB8fCBpbnN0YW5jZS5zcCkgJiYgIWlzQXN5bmNXcmFwcGVyKGluc3RhbmNlKSkge1xuICAgICAgbWFya0FzeW5jQm91bmRhcnkoaW5zdGFuY2UpO1xuICAgIH1cbiAgICBpZiAoaXNBc3luY1NldHVwKSB7XG4gICAgICBzZXR1cFJlc3VsdC50aGVuKHVuc2V0Q3VycmVudEluc3RhbmNlLCB1bnNldEN1cnJlbnRJbnN0YW5jZSk7XG4gICAgICBpZiAoaXNTU1IpIHtcbiAgICAgICAgcmV0dXJuIHNldHVwUmVzdWx0LnRoZW4oKHJlc29sdmVkUmVzdWx0KSA9PiB7XG4gICAgICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHJlc29sdmVkUmVzdWx0LCBpc1NTUik7XG4gICAgICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgaW5zdGFuY2UsIDApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3RhbmNlLmFzeW5jRGVwID0gc2V0dXBSZXN1bHQ7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpbnN0YW5jZS5zdXNwZW5zZSkge1xuICAgICAgICAgIGNvbnN0IG5hbWUgPSAoX2EgPSBDb21wb25lbnQubmFtZSkgIT0gbnVsbCA/IF9hIDogXCJBbm9ueW1vdXNcIjtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgQ29tcG9uZW50IDwke25hbWV9Pjogc2V0dXAgZnVuY3Rpb24gcmV0dXJuZWQgYSBwcm9taXNlLCBidXQgbm8gPFN1c3BlbnNlPiBib3VuZGFyeSB3YXMgZm91bmQgaW4gdGhlIHBhcmVudCBjb21wb25lbnQgdHJlZS4gQSBjb21wb25lbnQgd2l0aCBhc3luYyBzZXR1cCgpIG11c3QgYmUgbmVzdGVkIGluIGEgPFN1c3BlbnNlPiBpbiBvcmRlciB0byBiZSByZW5kZXJlZC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgc2V0dXBSZXN1bHQsIGlzU1NSKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHNldHVwUmVzdWx0LCBpc1NTUikge1xuICBpZiAoaXNGdW5jdGlvbihzZXR1cFJlc3VsdCkpIHtcbiAgICBpZiAoaW5zdGFuY2UudHlwZS5fX3NzcklubGluZVJlbmRlcikge1xuICAgICAgaW5zdGFuY2Uuc3NyUmVuZGVyID0gc2V0dXBSZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlLnJlbmRlciA9IHNldHVwUmVzdWx0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChzZXR1cFJlc3VsdCkpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc1ZOb2RlKHNldHVwUmVzdWx0KSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgc2V0dXAoKSBzaG91bGQgbm90IHJldHVybiBWTm9kZXMgZGlyZWN0bHkgLSByZXR1cm4gYSByZW5kZXIgZnVuY3Rpb24gaW5zdGVhZC5gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGluc3RhbmNlLmRldnRvb2xzUmF3U2V0dXBTdGF0ZSA9IHNldHVwUmVzdWx0O1xuICAgIH1cbiAgICBpbnN0YW5jZS5zZXR1cFN0YXRlID0gcHJveHlSZWZzKHNldHVwUmVzdWx0KTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgZXhwb3NlU2V0dXBTdGF0ZU9uUmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2V0dXBSZXN1bHQgIT09IHZvaWQgMCkge1xuICAgIHdhcm4kMShcbiAgICAgIGBzZXR1cCgpIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LiBSZWNlaXZlZDogJHtzZXR1cFJlc3VsdCA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIHNldHVwUmVzdWx0fWBcbiAgICApO1xuICB9XG4gIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUik7XG59XG5sZXQgY29tcGlsZTtcbmxldCBpbnN0YWxsV2l0aFByb3h5O1xuZnVuY3Rpb24gcmVnaXN0ZXJSdW50aW1lQ29tcGlsZXIoX2NvbXBpbGUpIHtcbiAgY29tcGlsZSA9IF9jb21waWxlO1xuICBpbnN0YWxsV2l0aFByb3h5ID0gKGkpID0+IHtcbiAgICBpZiAoaS5yZW5kZXIuX3JjKSB7XG4gICAgICBpLndpdGhQcm94eSA9IG5ldyBQcm94eShpLmN0eCwgUnVudGltZUNvbXBpbGVkUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzKTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBpc1J1bnRpbWVPbmx5ID0gKCkgPT4gIWNvbXBpbGU7XG5mdW5jdGlvbiBmaW5pc2hDb21wb25lbnRTZXR1cChpbnN0YW5jZSwgaXNTU1IsIHNraXBPcHRpb25zKSB7XG4gIGNvbnN0IENvbXBvbmVudCA9IGluc3RhbmNlLnR5cGU7XG4gIGlmICghaW5zdGFuY2UucmVuZGVyKSB7XG4gICAgaWYgKCFpc1NTUiAmJiBjb21waWxlICYmICFDb21wb25lbnQucmVuZGVyKSB7XG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IENvbXBvbmVudC50ZW1wbGF0ZSB8fCBfX1ZVRV9PUFRJT05TX0FQSV9fICYmIHJlc29sdmVNZXJnZWRPcHRpb25zKGluc3RhbmNlKS50ZW1wbGF0ZTtcbiAgICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYGNvbXBpbGVgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGlzQ3VzdG9tRWxlbWVudCwgY29tcGlsZXJPcHRpb25zIH0gPSBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZztcbiAgICAgICAgY29uc3QgeyBkZWxpbWl0ZXJzLCBjb21waWxlck9wdGlvbnM6IGNvbXBvbmVudENvbXBpbGVyT3B0aW9ucyB9ID0gQ29tcG9uZW50O1xuICAgICAgICBjb25zdCBmaW5hbENvbXBpbGVyT3B0aW9ucyA9IGV4dGVuZChcbiAgICAgICAgICBleHRlbmQoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlzQ3VzdG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgZGVsaW1pdGVyc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBpbGVyT3B0aW9uc1xuICAgICAgICAgICksXG4gICAgICAgICAgY29tcG9uZW50Q29tcGlsZXJPcHRpb25zXG4gICAgICAgICk7XG4gICAgICAgIENvbXBvbmVudC5yZW5kZXIgPSBjb21waWxlKHRlbXBsYXRlLCBmaW5hbENvbXBpbGVyT3B0aW9ucyk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGNvbXBpbGVgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpbnN0YW5jZS5yZW5kZXIgPSBDb21wb25lbnQucmVuZGVyIHx8IE5PT1A7XG4gICAgaWYgKGluc3RhbGxXaXRoUHJveHkpIHtcbiAgICAgIGluc3RhbGxXaXRoUHJveHkoaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiB0cnVlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBzZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICB0cnkge1xuICAgICAgYXBwbHlPcHRpb25zKGluc3RhbmNlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgcmVzZXRUcmFja2luZygpO1xuICAgICAgcmVzZXQoKTtcbiAgICB9XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIUNvbXBvbmVudC5yZW5kZXIgJiYgaW5zdGFuY2UucmVuZGVyID09PSBOT09QICYmICFpc1NTUikge1xuICAgIGlmICghY29tcGlsZSAmJiBDb21wb25lbnQudGVtcGxhdGUpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYENvbXBvbmVudCBwcm92aWRlZCB0ZW1wbGF0ZSBvcHRpb24gYnV0IHJ1bnRpbWUgY29tcGlsYXRpb24gaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJ1aWxkIG9mIFZ1ZS5gICsgKGAgQ29uZmlndXJlIHlvdXIgYnVuZGxlciB0byBhbGlhcyBcInZ1ZVwiIHRvIFwidnVlL2Rpc3QvdnVlLmVzbS1idW5kbGVyLmpzXCIuYCApXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuJDEoYENvbXBvbmVudCBpcyBtaXNzaW5nIHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbjogYCwgQ29tcG9uZW50KTtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IGF0dHJzUHJveHlIYW5kbGVycyA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyB7XG4gIGdldCh0YXJnZXQsIGtleSkge1xuICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XG4gICAgdHJhY2sodGFyZ2V0LCBcImdldFwiLCBcIlwiKTtcbiAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gIH0sXG4gIHNldCgpIHtcbiAgICB3YXJuJDEoYHNldHVwQ29udGV4dC5hdHRycyBpcyByZWFkb25seS5gKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIGRlbGV0ZVByb3BlcnR5KCkge1xuICAgIHdhcm4kMShgc2V0dXBDb250ZXh0LmF0dHJzIGlzIHJlYWRvbmx5LmApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSA6IHtcbiAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgdHJhY2sodGFyZ2V0LCBcImdldFwiLCBcIlwiKTtcbiAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gIH1cbn07XG5mdW5jdGlvbiBnZXRTbG90c1Byb3h5KGluc3RhbmNlKSB7XG4gIHJldHVybiBuZXcgUHJveHkoaW5zdGFuY2Uuc2xvdHMsIHtcbiAgICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHRyYWNrKGluc3RhbmNlLCBcImdldFwiLCBcIiRzbG90c1wiKTtcbiAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlU2V0dXBDb250ZXh0KGluc3RhbmNlKSB7XG4gIGNvbnN0IGV4cG9zZSA9IChleHBvc2VkKSA9PiB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGlmIChpbnN0YW5jZS5leHBvc2VkKSB7XG4gICAgICAgIHdhcm4kMShgZXhwb3NlKCkgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IG9uY2UgcGVyIHNldHVwKCkuYCk7XG4gICAgICB9XG4gICAgICBpZiAoZXhwb3NlZCAhPSBudWxsKSB7XG4gICAgICAgIGxldCBleHBvc2VkVHlwZSA9IHR5cGVvZiBleHBvc2VkO1xuICAgICAgICBpZiAoZXhwb3NlZFR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShleHBvc2VkKSkge1xuICAgICAgICAgICAgZXhwb3NlZFR5cGUgPSBcImFycmF5XCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1JlZihleHBvc2VkKSkge1xuICAgICAgICAgICAgZXhwb3NlZFR5cGUgPSBcInJlZlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwb3NlZFR5cGUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgZXhwb3NlKCkgc2hvdWxkIGJlIHBhc3NlZCBhIHBsYWluIG9iamVjdCwgcmVjZWl2ZWQgJHtleHBvc2VkVHlwZX0uYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaW5zdGFuY2UuZXhwb3NlZCA9IGV4cG9zZWQgfHwge307XG4gIH07XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgbGV0IGF0dHJzUHJveHk7XG4gICAgbGV0IHNsb3RzUHJveHk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgZ2V0IGF0dHJzKCkge1xuICAgICAgICByZXR1cm4gYXR0cnNQcm94eSB8fCAoYXR0cnNQcm94eSA9IG5ldyBQcm94eShpbnN0YW5jZS5hdHRycywgYXR0cnNQcm94eUhhbmRsZXJzKSk7XG4gICAgICB9LFxuICAgICAgZ2V0IHNsb3RzKCkge1xuICAgICAgICByZXR1cm4gc2xvdHNQcm94eSB8fCAoc2xvdHNQcm94eSA9IGdldFNsb3RzUHJveHkoaW5zdGFuY2UpKTtcbiAgICAgIH0sXG4gICAgICBnZXQgZW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIChldmVudCwgLi4uYXJncykgPT4gaW5zdGFuY2UuZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgICB9LFxuICAgICAgZXhwb3NlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGF0dHJzOiBuZXcgUHJveHkoaW5zdGFuY2UuYXR0cnMsIGF0dHJzUHJveHlIYW5kbGVycyksXG4gICAgICBzbG90czogaW5zdGFuY2Uuc2xvdHMsXG4gICAgICBlbWl0OiBpbnN0YW5jZS5lbWl0LFxuICAgICAgZXhwb3NlXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50UHVibGljSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgaWYgKGluc3RhbmNlLmV4cG9zZWQpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuZXhwb3NlUHJveHkgfHwgKGluc3RhbmNlLmV4cG9zZVByb3h5ID0gbmV3IFByb3h5KHByb3h5UmVmcyhtYXJrUmF3KGluc3RhbmNlLmV4cG9zZWQpKSwge1xuICAgICAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSBpbiBwdWJsaWNQcm9wZXJ0aWVzTWFwKSB7XG4gICAgICAgICAgcmV0dXJuIHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XShpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBoYXModGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSBpbiB0YXJnZXQgfHwga2V5IGluIHB1YmxpY1Byb3BlcnRpZXNNYXA7XG4gICAgICB9XG4gICAgfSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpbnN0YW5jZS5wcm94eTtcbiAgfVxufVxuY29uc3QgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbmNvbnN0IGNsYXNzaWZ5ID0gKHN0cikgPT4gc3RyLnJlcGxhY2UoY2xhc3NpZnlSRSwgKGMpID0+IGMudG9VcHBlckNhc2UoKSkucmVwbGFjZSgvWy1fXS9nLCBcIlwiKTtcbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50LCBpbmNsdWRlSW5mZXJyZWQgPSB0cnVlKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKENvbXBvbmVudCkgPyBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgOiBDb21wb25lbnQubmFtZSB8fCBpbmNsdWRlSW5mZXJyZWQgJiYgQ29tcG9uZW50Ll9fbmFtZTtcbn1cbmZ1bmN0aW9uIGZvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIENvbXBvbmVudCwgaXNSb290ID0gZmFsc2UpIHtcbiAgbGV0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCk7XG4gIGlmICghbmFtZSAmJiBDb21wb25lbnQuX19maWxlKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBDb21wb25lbnQuX19maWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLlxcdyskLyk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBuYW1lID0gbWF0Y2hbMV07XG4gICAgfVxuICB9XG4gIGlmICghbmFtZSAmJiBpbnN0YW5jZSAmJiBpbnN0YW5jZS5wYXJlbnQpIHtcbiAgICBjb25zdCBpbmZlckZyb21SZWdpc3RyeSA9IChyZWdpc3RyeSkgPT4ge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVnaXN0cnkpIHtcbiAgICAgICAgaWYgKHJlZ2lzdHJ5W2tleV0gPT09IENvbXBvbmVudCkge1xuICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIG5hbWUgPSBpbmZlckZyb21SZWdpc3RyeShcbiAgICAgIGluc3RhbmNlLmNvbXBvbmVudHMgfHwgaW5zdGFuY2UucGFyZW50LnR5cGUuY29tcG9uZW50c1xuICAgICkgfHwgaW5mZXJGcm9tUmVnaXN0cnkoaW5zdGFuY2UuYXBwQ29udGV4dC5jb21wb25lbnRzKTtcbiAgfVxuICByZXR1cm4gbmFtZSA/IGNsYXNzaWZ5KG5hbWUpIDogaXNSb290ID8gYEFwcGAgOiBgQW5vbnltb3VzYDtcbn1cbmZ1bmN0aW9uIGlzQ2xhc3NDb21wb25lbnQodmFsdWUpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24odmFsdWUpICYmIFwiX192Y2NPcHRzXCIgaW4gdmFsdWU7XG59XG5cbmNvbnN0IGNvbXB1dGVkID0gKGdldHRlck9yT3B0aW9ucywgZGVidWdPcHRpb25zKSA9PiB7XG4gIGNvbnN0IGMgPSBjb21wdXRlZCQxKGdldHRlck9yT3B0aW9ucywgZGVidWdPcHRpb25zLCBpc0luU1NSQ29tcG9uZW50U2V0dXApO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IGkgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICBpZiAoaSAmJiBpLmFwcENvbnRleHQuY29uZmlnLndhcm5SZWN1cnNpdmVDb21wdXRlZCkge1xuICAgICAgYy5fd2FyblJlY3Vyc2l2ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBjO1xufTtcblxuZnVuY3Rpb24gaCh0eXBlLCBwcm9wc09yQ2hpbGRyZW4sIGNoaWxkcmVuKSB7XG4gIGNvbnN0IGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICBpZiAobCA9PT0gMikge1xuICAgIGlmIChpc09iamVjdChwcm9wc09yQ2hpbGRyZW4pICYmICFpc0FycmF5KHByb3BzT3JDaGlsZHJlbikpIHtcbiAgICAgIGlmIChpc1ZOb2RlKHByb3BzT3JDaGlsZHJlbikpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIG51bGwsIFtwcm9wc09yQ2hpbGRyZW5dKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wc09yQ2hpbGRyZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgbnVsbCwgcHJvcHNPckNoaWxkcmVuKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGwgPiAzKSB7XG4gICAgICBjaGlsZHJlbiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgfSBlbHNlIGlmIChsID09PSAzICYmIGlzVk5vZGUoY2hpbGRyZW4pKSB7XG4gICAgICBjaGlsZHJlbiA9IFtjaGlsZHJlbl07XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wc09yQ2hpbGRyZW4sIGNoaWxkcmVuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q3VzdG9tRm9ybWF0dGVyKCkge1xuICBpZiAoISEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB2dWVTdHlsZSA9IHsgc3R5bGU6IFwiY29sb3I6IzNiYTc3NlwiIH07XG4gIGNvbnN0IG51bWJlclN0eWxlID0geyBzdHlsZTogXCJjb2xvcjojMTY3N2ZmXCIgfTtcbiAgY29uc3Qgc3RyaW5nU3R5bGUgPSB7IHN0eWxlOiBcImNvbG9yOiNmNTIyMmRcIiB9O1xuICBjb25zdCBrZXl3b3JkU3R5bGUgPSB7IHN0eWxlOiBcImNvbG9yOiNlYjJmOTZcIiB9O1xuICBjb25zdCBmb3JtYXR0ZXIgPSB7XG4gICAgX192dWVfY3VzdG9tX2Zvcm1hdHRlcjogdHJ1ZSxcbiAgICBoZWFkZXIob2JqKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAob2JqLl9faXNWdWUpIHtcbiAgICAgICAgcmV0dXJuIFtcImRpdlwiLCB2dWVTdHlsZSwgYFZ1ZUluc3RhbmNlYF07XG4gICAgICB9IGVsc2UgaWYgKGlzUmVmKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIFtcInNwYW5cIiwgdnVlU3R5bGUsIGdlblJlZkZsYWcob2JqKV0sXG4gICAgICAgICAgXCI8XCIsXG4gICAgICAgICAgLy8gYXZvaWQgZGVidWdnZXIgYWNjZXNzaW5nIHZhbHVlIGFmZmVjdGluZyBiZWhhdmlvclxuICAgICAgICAgIGZvcm1hdFZhbHVlKFwiX3ZhbHVlXCIgaW4gb2JqID8gb2JqLl92YWx1ZSA6IG9iaiksXG4gICAgICAgICAgYD5gXG4gICAgICAgIF07XG4gICAgICB9IGVsc2UgaWYgKGlzUmVhY3RpdmUob2JqKSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge30sXG4gICAgICAgICAgW1wic3BhblwiLCB2dWVTdHlsZSwgaXNTaGFsbG93KG9iaikgPyBcIlNoYWxsb3dSZWFjdGl2ZVwiIDogXCJSZWFjdGl2ZVwiXSxcbiAgICAgICAgICBcIjxcIixcbiAgICAgICAgICBmb3JtYXRWYWx1ZShvYmopLFxuICAgICAgICAgIGA+JHtpc1JlYWRvbmx5KG9iaikgPyBgIChyZWFkb25seSlgIDogYGB9YFxuICAgICAgICBdO1xuICAgICAgfSBlbHNlIGlmIChpc1JlYWRvbmx5KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIFtcInNwYW5cIiwgdnVlU3R5bGUsIGlzU2hhbGxvdyhvYmopID8gXCJTaGFsbG93UmVhZG9ubHlcIiA6IFwiUmVhZG9ubHlcIl0sXG4gICAgICAgICAgXCI8XCIsXG4gICAgICAgICAgZm9ybWF0VmFsdWUob2JqKSxcbiAgICAgICAgICBcIj5cIlxuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBoYXNCb2R5KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19pc1Z1ZTtcbiAgICB9LFxuICAgIGJvZHkob2JqKSB7XG4gICAgICBpZiAob2JqICYmIG9iai5fX2lzVnVlKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7fSxcbiAgICAgICAgICAuLi5mb3JtYXRJbnN0YW5jZShvYmouJClcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGZvcm1hdEluc3RhbmNlKGluc3RhbmNlKSB7XG4gICAgY29uc3QgYmxvY2tzID0gW107XG4gICAgaWYgKGluc3RhbmNlLnR5cGUucHJvcHMgJiYgaW5zdGFuY2UucHJvcHMpIHtcbiAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soXCJwcm9wc1wiLCB0b1JhdyhpbnN0YW5jZS5wcm9wcykpKTtcbiAgICB9XG4gICAgaWYgKGluc3RhbmNlLnNldHVwU3RhdGUgIT09IEVNUFRZX09CSikge1xuICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jayhcInNldHVwXCIsIGluc3RhbmNlLnNldHVwU3RhdGUpKTtcbiAgICB9XG4gICAgaWYgKGluc3RhbmNlLmRhdGEgIT09IEVNUFRZX09CSikge1xuICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jayhcImRhdGFcIiwgdG9SYXcoaW5zdGFuY2UuZGF0YSkpKTtcbiAgICB9XG4gICAgY29uc3QgY29tcHV0ZWQgPSBleHRyYWN0S2V5cyhpbnN0YW5jZSwgXCJjb21wdXRlZFwiKTtcbiAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soXCJjb21wdXRlZFwiLCBjb21wdXRlZCkpO1xuICAgIH1cbiAgICBjb25zdCBpbmplY3RlZCA9IGV4dHJhY3RLZXlzKGluc3RhbmNlLCBcImluamVjdFwiKTtcbiAgICBpZiAoaW5qZWN0ZWQpIHtcbiAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soXCJpbmplY3RlZFwiLCBpbmplY3RlZCkpO1xuICAgIH1cbiAgICBibG9ja3MucHVzaChbXG4gICAgICBcImRpdlwiLFxuICAgICAge30sXG4gICAgICBbXG4gICAgICAgIFwic3BhblwiLFxuICAgICAgICB7XG4gICAgICAgICAgc3R5bGU6IGtleXdvcmRTdHlsZS5zdHlsZSArIFwiO29wYWNpdHk6MC42NlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiJCAoaW50ZXJuYWwpOiBcIlxuICAgICAgXSxcbiAgICAgIFtcIm9iamVjdFwiLCB7IG9iamVjdDogaW5zdGFuY2UgfV1cbiAgICBdKTtcbiAgICByZXR1cm4gYmxvY2tzO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlQmxvY2sodHlwZSwgdGFyZ2V0KSB7XG4gICAgdGFyZ2V0ID0gZXh0ZW5kKHt9LCB0YXJnZXQpO1xuICAgIGlmICghT2JqZWN0LmtleXModGFyZ2V0KS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIHt9XTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7IHN0eWxlOiBcImxpbmUtaGVpZ2h0OjEuMjVlbTttYXJnaW4tYm90dG9tOjAuNmVtXCIgfSxcbiAgICAgIFtcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIHN0eWxlOiBcImNvbG9yOiM0NzY1ODJcIlxuICAgICAgICB9LFxuICAgICAgICB0eXBlXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7XG4gICAgICAgICAgc3R5bGU6IFwicGFkZGluZy1sZWZ0OjEuMjVlbVwiXG4gICAgICAgIH0sXG4gICAgICAgIC4uLk9iamVjdC5rZXlzKHRhcmdldCkubWFwKChrZXkpID0+IHtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgW1wic3BhblwiLCBrZXl3b3JkU3R5bGUsIGtleSArIFwiOiBcIl0sXG4gICAgICAgICAgICBmb3JtYXRWYWx1ZSh0YXJnZXRba2V5XSwgZmFsc2UpXG4gICAgICAgICAgXTtcbiAgICAgICAgfSlcbiAgICAgIF1cbiAgICBdO1xuICB9XG4gIGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHYsIGFzUmF3ID0gdHJ1ZSkge1xuICAgIGlmICh0eXBlb2YgdiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIFtcInNwYW5cIiwgbnVtYmVyU3R5bGUsIHZdO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIHN0cmluZ1N0eWxlLCBKU09OLnN0cmluZ2lmeSh2KV07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIGtleXdvcmRTdHlsZSwgdl07XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2KSkge1xuICAgICAgcmV0dXJuIFtcIm9iamVjdFwiLCB7IG9iamVjdDogYXNSYXcgPyB0b1Jhdyh2KSA6IHYgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIHN0cmluZ1N0eWxlLCBTdHJpbmcodildO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBleHRyYWN0S2V5cyhpbnN0YW5jZSwgdHlwZSkge1xuICAgIGNvbnN0IENvbXAgPSBpbnN0YW5jZS50eXBlO1xuICAgIGlmIChpc0Z1bmN0aW9uKENvbXApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGV4dHJhY3RlZCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGluc3RhbmNlLmN0eCkge1xuICAgICAgaWYgKGlzS2V5T2ZUeXBlKENvbXAsIGtleSwgdHlwZSkpIHtcbiAgICAgICAgZXh0cmFjdGVkW2tleV0gPSBpbnN0YW5jZS5jdHhba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4dHJhY3RlZDtcbiAgfVxuICBmdW5jdGlvbiBpc0tleU9mVHlwZShDb21wLCBrZXksIHR5cGUpIHtcbiAgICBjb25zdCBvcHRzID0gQ29tcFt0eXBlXTtcbiAgICBpZiAoaXNBcnJheShvcHRzKSAmJiBvcHRzLmluY2x1ZGVzKGtleSkgfHwgaXNPYmplY3Qob3B0cykgJiYga2V5IGluIG9wdHMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoQ29tcC5leHRlbmRzICYmIGlzS2V5T2ZUeXBlKENvbXAuZXh0ZW5kcywga2V5LCB0eXBlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChDb21wLm1peGlucyAmJiBDb21wLm1peGlucy5zb21lKChtKSA9PiBpc0tleU9mVHlwZShtLCBrZXksIHR5cGUpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdlblJlZkZsYWcodikge1xuICAgIGlmIChpc1NoYWxsb3codikpIHtcbiAgICAgIHJldHVybiBgU2hhbGxvd1JlZmA7XG4gICAgfVxuICAgIGlmICh2LmVmZmVjdCkge1xuICAgICAgcmV0dXJuIGBDb21wdXRlZFJlZmA7XG4gICAgfVxuICAgIHJldHVybiBgUmVmYDtcbiAgfVxuICBpZiAod2luZG93LmRldnRvb2xzRm9ybWF0dGVycykge1xuICAgIHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMucHVzaChmb3JtYXR0ZXIpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMgPSBbZm9ybWF0dGVyXTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3aXRoTWVtbyhtZW1vLCByZW5kZXIsIGNhY2hlLCBpbmRleCkge1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZVtpbmRleF07XG4gIGlmIChjYWNoZWQgJiYgaXNNZW1vU2FtZShjYWNoZWQsIG1lbW8pKSB7XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfVxuICBjb25zdCByZXQgPSByZW5kZXIoKTtcbiAgcmV0Lm1lbW8gPSBtZW1vLnNsaWNlKCk7XG4gIHJldC5jYWNoZUluZGV4ID0gaW5kZXg7XG4gIHJldHVybiBjYWNoZVtpbmRleF0gPSByZXQ7XG59XG5mdW5jdGlvbiBpc01lbW9TYW1lKGNhY2hlZCwgbWVtbykge1xuICBjb25zdCBwcmV2ID0gY2FjaGVkLm1lbW87XG4gIGlmIChwcmV2Lmxlbmd0aCAhPSBtZW1vLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXYubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaGFzQ2hhbmdlZChwcmV2W2ldLCBtZW1vW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiBjdXJyZW50QmxvY2spIHtcbiAgICBjdXJyZW50QmxvY2sucHVzaChjYWNoZWQpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5jb25zdCB2ZXJzaW9uID0gXCIzLjUuMTNcIjtcbmNvbnN0IHdhcm4gPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gd2FybiQxIDogTk9PUDtcbmNvbnN0IEVycm9yVHlwZVN0cmluZ3MgPSBFcnJvclR5cGVTdHJpbmdzJDEgO1xuY29uc3QgZGV2dG9vbHMgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IHRydWUgPyBkZXZ0b29scyQxIDogdm9pZCAwO1xuY29uc3Qgc2V0RGV2dG9vbHNIb29rID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCB0cnVlID8gc2V0RGV2dG9vbHNIb29rJDEgOiBOT09QO1xuY29uc3QgX3NzclV0aWxzID0ge1xuICBjcmVhdGVDb21wb25lbnRJbnN0YW5jZSxcbiAgc2V0dXBDb21wb25lbnQsXG4gIHJlbmRlckNvbXBvbmVudFJvb3QsXG4gIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSxcbiAgaXNWTm9kZTogaXNWTm9kZSxcbiAgbm9ybWFsaXplVk5vZGUsXG4gIGdldENvbXBvbmVudFB1YmxpY0luc3RhbmNlLFxuICBlbnN1cmVWYWxpZFZOb2RlLFxuICBwdXNoV2FybmluZ0NvbnRleHQsXG4gIHBvcFdhcm5pbmdDb250ZXh0XG59O1xuY29uc3Qgc3NyVXRpbHMgPSBfc3NyVXRpbHMgO1xuY29uc3QgcmVzb2x2ZUZpbHRlciA9IG51bGw7XG5jb25zdCBjb21wYXRVdGlscyA9IG51bGw7XG5jb25zdCBEZXByZWNhdGlvblR5cGVzID0gbnVsbDtcblxuZXhwb3J0IHsgQmFzZVRyYW5zaXRpb24sIEJhc2VUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLCBDb21tZW50LCBEZXByZWNhdGlvblR5cGVzLCBFcnJvckNvZGVzLCBFcnJvclR5cGVTdHJpbmdzLCBGcmFnbWVudCwgS2VlcEFsaXZlLCBTdGF0aWMsIFN1c3BlbnNlLCBUZWxlcG9ydCwgVGV4dCwgYXNzZXJ0TnVtYmVyLCBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZywgY2FsbFdpdGhFcnJvckhhbmRsaW5nLCBjbG9uZVZOb2RlLCBjb21wYXRVdGlscywgY29tcHV0ZWQsIGNyZWF0ZUJsb2NrLCBjcmVhdGVDb21tZW50Vk5vZGUsIGNyZWF0ZUVsZW1lbnRCbG9jaywgY3JlYXRlQmFzZVZOb2RlIGFzIGNyZWF0ZUVsZW1lbnRWTm9kZSwgY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIsIGNyZWF0ZVByb3BzUmVzdFByb3h5LCBjcmVhdGVSZW5kZXJlciwgY3JlYXRlU2xvdHMsIGNyZWF0ZVN0YXRpY1ZOb2RlLCBjcmVhdGVUZXh0Vk5vZGUsIGNyZWF0ZVZOb2RlLCBkZWZpbmVBc3luY0NvbXBvbmVudCwgZGVmaW5lQ29tcG9uZW50LCBkZWZpbmVFbWl0cywgZGVmaW5lRXhwb3NlLCBkZWZpbmVNb2RlbCwgZGVmaW5lT3B0aW9ucywgZGVmaW5lUHJvcHMsIGRlZmluZVNsb3RzLCBkZXZ0b29scywgZ2V0Q3VycmVudEluc3RhbmNlLCBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4sIGd1YXJkUmVhY3RpdmVQcm9wcywgaCwgaGFuZGxlRXJyb3IsIGhhc0luamVjdGlvbkNvbnRleHQsIGh5ZHJhdGVPbklkbGUsIGh5ZHJhdGVPbkludGVyYWN0aW9uLCBoeWRyYXRlT25NZWRpYVF1ZXJ5LCBoeWRyYXRlT25WaXNpYmxlLCBpbml0Q3VzdG9tRm9ybWF0dGVyLCBpbmplY3QsIGlzTWVtb1NhbWUsIGlzUnVudGltZU9ubHksIGlzVk5vZGUsIG1lcmdlRGVmYXVsdHMsIG1lcmdlTW9kZWxzLCBtZXJnZVByb3BzLCBuZXh0VGljaywgb25BY3RpdmF0ZWQsIG9uQmVmb3JlTW91bnQsIG9uQmVmb3JlVW5tb3VudCwgb25CZWZvcmVVcGRhdGUsIG9uRGVhY3RpdmF0ZWQsIG9uRXJyb3JDYXB0dXJlZCwgb25Nb3VudGVkLCBvblJlbmRlclRyYWNrZWQsIG9uUmVuZGVyVHJpZ2dlcmVkLCBvblNlcnZlclByZWZldGNoLCBvblVubW91bnRlZCwgb25VcGRhdGVkLCBvcGVuQmxvY2ssIHBvcFNjb3BlSWQsIHByb3ZpZGUsIHB1c2hTY29wZUlkLCBxdWV1ZVBvc3RGbHVzaENiLCByZWdpc3RlclJ1bnRpbWVDb21waWxlciwgcmVuZGVyTGlzdCwgcmVuZGVyU2xvdCwgcmVzb2x2ZUNvbXBvbmVudCwgcmVzb2x2ZURpcmVjdGl2ZSwgcmVzb2x2ZUR5bmFtaWNDb21wb25lbnQsIHJlc29sdmVGaWx0ZXIsIHJlc29sdmVUcmFuc2l0aW9uSG9va3MsIHNldEJsb2NrVHJhY2tpbmcsIHNldERldnRvb2xzSG9vaywgc2V0VHJhbnNpdGlvbkhvb2tzLCBzc3JDb250ZXh0S2V5LCBzc3JVdGlscywgdG9IYW5kbGVycywgdHJhbnNmb3JtVk5vZGVBcmdzLCB1c2VBdHRycywgdXNlSWQsIHVzZU1vZGVsLCB1c2VTU1JDb250ZXh0LCB1c2VTbG90cywgdXNlVGVtcGxhdGVSZWYsIHVzZVRyYW5zaXRpb25TdGF0ZSwgdmVyc2lvbiwgd2Fybiwgd2F0Y2gsIHdhdGNoRWZmZWN0LCB3YXRjaFBvc3RFZmZlY3QsIHdhdGNoU3luY0VmZmVjdCwgd2l0aEFzeW5jQ29udGV4dCwgd2l0aEN0eCwgd2l0aERlZmF1bHRzLCB3aXRoRGlyZWN0aXZlcywgd2l0aE1lbW8sIHdpdGhTY29wZUlkIH07XG4iLCIvKipcbiogQHZ1ZS9ydW50aW1lLWRvbSB2My41LjEzXG4qIChjKSAyMDE4LXByZXNlbnQgWXV4aSAoRXZhbikgWW91IGFuZCBWdWUgY29udHJpYnV0b3JzXG4qIEBsaWNlbnNlIE1JVFxuKiovXG5pbXBvcnQgeyB3YXJuLCBoLCBCYXNlVHJhbnNpdGlvbiwgYXNzZXJ0TnVtYmVyLCBCYXNlVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycywgZ2V0Q3VycmVudEluc3RhbmNlLCBvbkJlZm9yZVVwZGF0ZSwgcXVldWVQb3N0Rmx1c2hDYiwgb25Nb3VudGVkLCB3YXRjaCwgb25Vbm1vdW50ZWQsIEZyYWdtZW50LCBTdGF0aWMsIGNhbWVsaXplLCBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZywgZGVmaW5lQ29tcG9uZW50LCBuZXh0VGljaywgdW5yZWYsIGNyZWF0ZVZOb2RlLCB1c2VUcmFuc2l0aW9uU3RhdGUsIG9uVXBkYXRlZCwgdG9SYXcsIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbiwgc2V0VHJhbnNpdGlvbkhvb2tzLCByZXNvbHZlVHJhbnNpdGlvbkhvb2tzLCBUZXh0LCBpc1J1bnRpbWVPbmx5LCBjcmVhdGVSZW5kZXJlciwgY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIgfSBmcm9tICdAdnVlL3J1bnRpbWUtY29yZSc7XG5leHBvcnQgKiBmcm9tICdAdnVlL3J1bnRpbWUtY29yZSc7XG5pbXBvcnQgeyBleHRlbmQsIGlzT2JqZWN0LCB0b051bWJlciwgaXNBcnJheSwgTk9PUCwgaXNTdHJpbmcsIGh5cGhlbmF0ZSwgY2FwaXRhbGl6ZSwgaW5jbHVkZUJvb2xlYW5BdHRyLCBpc1N5bWJvbCwgaXNTcGVjaWFsQm9vbGVhbkF0dHIsIGlzRnVuY3Rpb24sIGlzT24sIGlzTW9kZWxMaXN0ZW5lciwgY2FtZWxpemUgYXMgY2FtZWxpemUkMSwgaXNQbGFpbk9iamVjdCwgaGFzT3duLCBFTVBUWV9PQkosIGxvb3NlVG9OdW1iZXIsIGxvb3NlSW5kZXhPZiwgaXNTZXQsIGxvb3NlRXF1YWwsIGludm9rZUFycmF5Rm5zLCBpc0hUTUxUYWcsIGlzU1ZHVGFnLCBpc01hdGhNTFRhZyB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxubGV0IHBvbGljeSA9IHZvaWQgMDtcbmNvbnN0IHR0ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cudHJ1c3RlZFR5cGVzO1xuaWYgKHR0KSB7XG4gIHRyeSB7XG4gICAgcG9saWN5ID0gLyogQF9fUFVSRV9fICovIHR0LmNyZWF0ZVBvbGljeShcInZ1ZVwiLCB7XG4gICAgICBjcmVhdGVIVE1MOiAodmFsKSA9PiB2YWxcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgRXJyb3IgY3JlYXRpbmcgdHJ1c3RlZCB0eXBlcyBwb2xpY3k6ICR7ZX1gKTtcbiAgfVxufVxuY29uc3QgdW5zYWZlVG9UcnVzdGVkSFRNTCA9IHBvbGljeSA/ICh2YWwpID0+IHBvbGljeS5jcmVhdGVIVE1MKHZhbCkgOiAodmFsKSA9PiB2YWw7XG5jb25zdCBzdmdOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtcbmNvbnN0IG1hdGhtbE5TID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI7XG5jb25zdCBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudCA6IG51bGw7XG5jb25zdCB0ZW1wbGF0ZUNvbnRhaW5lciA9IGRvYyAmJiAvKiBAX19QVVJFX18gKi8gZG9jLmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbmNvbnN0IG5vZGVPcHMgPSB7XG4gIGluc2VydDogKGNoaWxkLCBwYXJlbnQsIGFuY2hvcikgPT4ge1xuICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIGFuY2hvciB8fCBudWxsKTtcbiAgfSxcbiAgcmVtb3ZlOiAoY2hpbGQpID0+IHtcbiAgICBjb25zdCBwYXJlbnQgPSBjaGlsZC5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgfVxuICB9LFxuICBjcmVhdGVFbGVtZW50OiAodGFnLCBuYW1lc3BhY2UsIGlzLCBwcm9wcykgPT4ge1xuICAgIGNvbnN0IGVsID0gbmFtZXNwYWNlID09PSBcInN2Z1wiID8gZG9jLmNyZWF0ZUVsZW1lbnROUyhzdmdOUywgdGFnKSA6IG5hbWVzcGFjZSA9PT0gXCJtYXRobWxcIiA/IGRvYy5jcmVhdGVFbGVtZW50TlMobWF0aG1sTlMsIHRhZykgOiBpcyA/IGRvYy5jcmVhdGVFbGVtZW50KHRhZywgeyBpcyB9KSA6IGRvYy5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgaWYgKHRhZyA9PT0gXCJzZWxlY3RcIiAmJiBwcm9wcyAmJiBwcm9wcy5tdWx0aXBsZSAhPSBudWxsKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiLCBwcm9wcy5tdWx0aXBsZSk7XG4gICAgfVxuICAgIHJldHVybiBlbDtcbiAgfSxcbiAgY3JlYXRlVGV4dDogKHRleHQpID0+IGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSxcbiAgY3JlYXRlQ29tbWVudDogKHRleHQpID0+IGRvYy5jcmVhdGVDb21tZW50KHRleHQpLFxuICBzZXRUZXh0OiAobm9kZSwgdGV4dCkgPT4ge1xuICAgIG5vZGUubm9kZVZhbHVlID0gdGV4dDtcbiAgfSxcbiAgc2V0RWxlbWVudFRleHQ6IChlbCwgdGV4dCkgPT4ge1xuICAgIGVsLnRleHRDb250ZW50ID0gdGV4dDtcbiAgfSxcbiAgcGFyZW50Tm9kZTogKG5vZGUpID0+IG5vZGUucGFyZW50Tm9kZSxcbiAgbmV4dFNpYmxpbmc6IChub2RlKSA9PiBub2RlLm5leHRTaWJsaW5nLFxuICBxdWVyeVNlbGVjdG9yOiAoc2VsZWN0b3IpID0+IGRvYy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSxcbiAgc2V0U2NvcGVJZChlbCwgaWQpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoaWQsIFwiXCIpO1xuICB9LFxuICAvLyBfX1VOU0FGRV9fXG4gIC8vIFJlYXNvbjogaW5uZXJIVE1MLlxuICAvLyBTdGF0aWMgY29udGVudCBoZXJlIGNhbiBvbmx5IGNvbWUgZnJvbSBjb21waWxlZCB0ZW1wbGF0ZXMuXG4gIC8vIEFzIGxvbmcgYXMgdGhlIHVzZXIgb25seSB1c2VzIHRydXN0ZWQgdGVtcGxhdGVzLCB0aGlzIGlzIHNhZmUuXG4gIGluc2VydFN0YXRpY0NvbnRlbnQoY29udGVudCwgcGFyZW50LCBhbmNob3IsIG5hbWVzcGFjZSwgc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IGJlZm9yZSA9IGFuY2hvciA/IGFuY2hvci5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnQubGFzdENoaWxkO1xuICAgIGlmIChzdGFydCAmJiAoc3RhcnQgPT09IGVuZCB8fCBzdGFydC5uZXh0U2libGluZykpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoc3RhcnQuY2xvbmVOb2RlKHRydWUpLCBhbmNob3IpO1xuICAgICAgICBpZiAoc3RhcnQgPT09IGVuZCB8fCAhKHN0YXJ0ID0gc3RhcnQubmV4dFNpYmxpbmcpKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGVtcGxhdGVDb250YWluZXIuaW5uZXJIVE1MID0gdW5zYWZlVG9UcnVzdGVkSFRNTChcbiAgICAgICAgbmFtZXNwYWNlID09PSBcInN2Z1wiID8gYDxzdmc+JHtjb250ZW50fTwvc3ZnPmAgOiBuYW1lc3BhY2UgPT09IFwibWF0aG1sXCIgPyBgPG1hdGg+JHtjb250ZW50fTwvbWF0aD5gIDogY29udGVudFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGVtcGxhdGVDb250YWluZXIuY29udGVudDtcbiAgICAgIGlmIChuYW1lc3BhY2UgPT09IFwic3ZnXCIgfHwgbmFtZXNwYWNlID09PSBcIm1hdGhtbFwiKSB7XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSB0ZW1wbGF0ZS5maXJzdENoaWxkO1xuICAgICAgICB3aGlsZSAod3JhcHBlci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgdGVtcGxhdGUuYXBwZW5kQ2hpbGQod3JhcHBlci5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wbGF0ZS5yZW1vdmVDaGlsZCh3cmFwcGVyKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodGVtcGxhdGUsIGFuY2hvcik7XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAvLyBmaXJzdFxuICAgICAgYmVmb3JlID8gYmVmb3JlLm5leHRTaWJsaW5nIDogcGFyZW50LmZpcnN0Q2hpbGQsXG4gICAgICAvLyBsYXN0XG4gICAgICBhbmNob3IgPyBhbmNob3IucHJldmlvdXNTaWJsaW5nIDogcGFyZW50Lmxhc3RDaGlsZFxuICAgIF07XG4gIH1cbn07XG5cbmNvbnN0IFRSQU5TSVRJT04gPSBcInRyYW5zaXRpb25cIjtcbmNvbnN0IEFOSU1BVElPTiA9IFwiYW5pbWF0aW9uXCI7XG5jb25zdCB2dGNLZXkgPSBTeW1ib2woXCJfdnRjXCIpO1xuY29uc3QgRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyA9IHtcbiAgbmFtZTogU3RyaW5nLFxuICB0eXBlOiBTdHJpbmcsXG4gIGNzczoge1xuICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgZGVmYXVsdDogdHJ1ZVxuICB9LFxuICBkdXJhdGlvbjogW1N0cmluZywgTnVtYmVyLCBPYmplY3RdLFxuICBlbnRlckZyb21DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyVG9DbGFzczogU3RyaW5nLFxuICBhcHBlYXJGcm9tQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBsZWF2ZUZyb21DbGFzczogU3RyaW5nLFxuICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nXG59O1xuY29uc3QgVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyA9IC8qIEBfX1BVUkVfXyAqLyBleHRlbmQoXG4gIHt9LFxuICBCYXNlVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyxcbiAgRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9yc1xuKTtcbmNvbnN0IGRlY29yYXRlJDEgPSAodCkgPT4ge1xuICB0LmRpc3BsYXlOYW1lID0gXCJUcmFuc2l0aW9uXCI7XG4gIHQucHJvcHMgPSBUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzO1xuICByZXR1cm4gdDtcbn07XG5jb25zdCBUcmFuc2l0aW9uID0gLyogQF9fUFVSRV9fICovIGRlY29yYXRlJDEoXG4gIChwcm9wcywgeyBzbG90cyB9KSA9PiBoKEJhc2VUcmFuc2l0aW9uLCByZXNvbHZlVHJhbnNpdGlvblByb3BzKHByb3BzKSwgc2xvdHMpXG4pO1xuY29uc3QgY2FsbEhvb2sgPSAoaG9vaywgYXJncyA9IFtdKSA9PiB7XG4gIGlmIChpc0FycmF5KGhvb2spKSB7XG4gICAgaG9vay5mb3JFYWNoKChoMikgPT4gaDIoLi4uYXJncykpO1xuICB9IGVsc2UgaWYgKGhvb2spIHtcbiAgICBob29rKC4uLmFyZ3MpO1xuICB9XG59O1xuY29uc3QgaGFzRXhwbGljaXRDYWxsYmFjayA9IChob29rKSA9PiB7XG4gIHJldHVybiBob29rID8gaXNBcnJheShob29rKSA/IGhvb2suc29tZSgoaDIpID0+IGgyLmxlbmd0aCA+IDEpIDogaG9vay5sZW5ndGggPiAxIDogZmFsc2U7XG59O1xuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhyYXdQcm9wcykge1xuICBjb25zdCBiYXNlUHJvcHMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gcmF3UHJvcHMpIHtcbiAgICBpZiAoIShrZXkgaW4gRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycykpIHtcbiAgICAgIGJhc2VQcm9wc1trZXldID0gcmF3UHJvcHNba2V5XTtcbiAgICB9XG4gIH1cbiAgaWYgKHJhd1Byb3BzLmNzcyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gYmFzZVByb3BzO1xuICB9XG4gIGNvbnN0IHtcbiAgICBuYW1lID0gXCJ2XCIsXG4gICAgdHlwZSxcbiAgICBkdXJhdGlvbixcbiAgICBlbnRlckZyb21DbGFzcyA9IGAke25hbWV9LWVudGVyLWZyb21gLFxuICAgIGVudGVyQWN0aXZlQ2xhc3MgPSBgJHtuYW1lfS1lbnRlci1hY3RpdmVgLFxuICAgIGVudGVyVG9DbGFzcyA9IGAke25hbWV9LWVudGVyLXRvYCxcbiAgICBhcHBlYXJGcm9tQ2xhc3MgPSBlbnRlckZyb21DbGFzcyxcbiAgICBhcHBlYXJBY3RpdmVDbGFzcyA9IGVudGVyQWN0aXZlQ2xhc3MsXG4gICAgYXBwZWFyVG9DbGFzcyA9IGVudGVyVG9DbGFzcyxcbiAgICBsZWF2ZUZyb21DbGFzcyA9IGAke25hbWV9LWxlYXZlLWZyb21gLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3MgPSBgJHtuYW1lfS1sZWF2ZS1hY3RpdmVgLFxuICAgIGxlYXZlVG9DbGFzcyA9IGAke25hbWV9LWxlYXZlLXRvYFxuICB9ID0gcmF3UHJvcHM7XG4gIGNvbnN0IGR1cmF0aW9ucyA9IG5vcm1hbGl6ZUR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgY29uc3QgZW50ZXJEdXJhdGlvbiA9IGR1cmF0aW9ucyAmJiBkdXJhdGlvbnNbMF07XG4gIGNvbnN0IGxlYXZlRHVyYXRpb24gPSBkdXJhdGlvbnMgJiYgZHVyYXRpb25zWzFdO1xuICBjb25zdCB7XG4gICAgb25CZWZvcmVFbnRlcixcbiAgICBvbkVudGVyLFxuICAgIG9uRW50ZXJDYW5jZWxsZWQsXG4gICAgb25MZWF2ZSxcbiAgICBvbkxlYXZlQ2FuY2VsbGVkLFxuICAgIG9uQmVmb3JlQXBwZWFyID0gb25CZWZvcmVFbnRlcixcbiAgICBvbkFwcGVhciA9IG9uRW50ZXIsXG4gICAgb25BcHBlYXJDYW5jZWxsZWQgPSBvbkVudGVyQ2FuY2VsbGVkXG4gIH0gPSBiYXNlUHJvcHM7XG4gIGNvbnN0IGZpbmlzaEVudGVyID0gKGVsLCBpc0FwcGVhciwgZG9uZSwgaXNDYW5jZWxsZWQpID0+IHtcbiAgICBlbC5fZW50ZXJDYW5jZWxsZWQgPSBpc0NhbmNlbGxlZDtcbiAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyVG9DbGFzcyA6IGVudGVyVG9DbGFzcyk7XG4gICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhckFjdGl2ZUNsYXNzIDogZW50ZXJBY3RpdmVDbGFzcyk7XG4gICAgZG9uZSAmJiBkb25lKCk7XG4gIH07XG4gIGNvbnN0IGZpbmlzaExlYXZlID0gKGVsLCBkb25lKSA9PiB7XG4gICAgZWwuX2lzTGVhdmluZyA9IGZhbHNlO1xuICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVGcm9tQ2xhc3MpO1xuICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgIGRvbmUgJiYgZG9uZSgpO1xuICB9O1xuICBjb25zdCBtYWtlRW50ZXJIb29rID0gKGlzQXBwZWFyKSA9PiB7XG4gICAgcmV0dXJuIChlbCwgZG9uZSkgPT4ge1xuICAgICAgY29uc3QgaG9vayA9IGlzQXBwZWFyID8gb25BcHBlYXIgOiBvbkVudGVyO1xuICAgICAgY29uc3QgcmVzb2x2ZSA9ICgpID0+IGZpbmlzaEVudGVyKGVsLCBpc0FwcGVhciwgZG9uZSk7XG4gICAgICBjYWxsSG9vayhob29rLCBbZWwsIHJlc29sdmVdKTtcbiAgICAgIG5leHRGcmFtZSgoKSA9PiB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJGcm9tQ2xhc3MgOiBlbnRlckZyb21DbGFzcyk7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJUb0NsYXNzIDogZW50ZXJUb0NsYXNzKTtcbiAgICAgICAgaWYgKCFoYXNFeHBsaWNpdENhbGxiYWNrKGhvb2spKSB7XG4gICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBlbnRlckR1cmF0aW9uLCByZXNvbHZlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIGV4dGVuZChiYXNlUHJvcHMsIHtcbiAgICBvbkJlZm9yZUVudGVyKGVsKSB7XG4gICAgICBjYWxsSG9vayhvbkJlZm9yZUVudGVyLCBbZWxdKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgZW50ZXJGcm9tQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBlbnRlckFjdGl2ZUNsYXNzKTtcbiAgICB9LFxuICAgIG9uQmVmb3JlQXBwZWFyKGVsKSB7XG4gICAgICBjYWxsSG9vayhvbkJlZm9yZUFwcGVhciwgW2VsXSk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFwcGVhckZyb21DbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFwcGVhckFjdGl2ZUNsYXNzKTtcbiAgICB9LFxuICAgIG9uRW50ZXI6IG1ha2VFbnRlckhvb2soZmFsc2UpLFxuICAgIG9uQXBwZWFyOiBtYWtlRW50ZXJIb29rKHRydWUpLFxuICAgIG9uTGVhdmUoZWwsIGRvbmUpIHtcbiAgICAgIGVsLl9pc0xlYXZpbmcgPSB0cnVlO1xuICAgICAgY29uc3QgcmVzb2x2ZSA9ICgpID0+IGZpbmlzaExlYXZlKGVsLCBkb25lKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVGcm9tQ2xhc3MpO1xuICAgICAgaWYgKCFlbC5fZW50ZXJDYW5jZWxsZWQpIHtcbiAgICAgICAgZm9yY2VSZWZsb3coKTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICAgIGZvcmNlUmVmbG93KCk7XG4gICAgICB9XG4gICAgICBuZXh0RnJhbWUoKCkgPT4ge1xuICAgICAgICBpZiAoIWVsLl9pc0xlYXZpbmcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgaWYgKCFoYXNFeHBsaWNpdENhbGxiYWNrKG9uTGVhdmUpKSB7XG4gICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBsZWF2ZUR1cmF0aW9uLCByZXNvbHZlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjYWxsSG9vayhvbkxlYXZlLCBbZWwsIHJlc29sdmVdKTtcbiAgICB9LFxuICAgIG9uRW50ZXJDYW5jZWxsZWQoZWwpIHtcbiAgICAgIGZpbmlzaEVudGVyKGVsLCBmYWxzZSwgdm9pZCAwLCB0cnVlKTtcbiAgICAgIGNhbGxIb29rKG9uRW50ZXJDYW5jZWxsZWQsIFtlbF0pO1xuICAgIH0sXG4gICAgb25BcHBlYXJDYW5jZWxsZWQoZWwpIHtcbiAgICAgIGZpbmlzaEVudGVyKGVsLCB0cnVlLCB2b2lkIDAsIHRydWUpO1xuICAgICAgY2FsbEhvb2sob25BcHBlYXJDYW5jZWxsZWQsIFtlbF0pO1xuICAgIH0sXG4gICAgb25MZWF2ZUNhbmNlbGxlZChlbCkge1xuICAgICAgZmluaXNoTGVhdmUoZWwpO1xuICAgICAgY2FsbEhvb2sob25MZWF2ZUNhbmNlbGxlZCwgW2VsXSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUR1cmF0aW9uKGR1cmF0aW9uKSB7XG4gIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoZHVyYXRpb24pKSB7XG4gICAgcmV0dXJuIFtOdW1iZXJPZihkdXJhdGlvbi5lbnRlciksIE51bWJlck9mKGR1cmF0aW9uLmxlYXZlKV07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbiA9IE51bWJlck9mKGR1cmF0aW9uKTtcbiAgICByZXR1cm4gW24sIG5dO1xuICB9XG59XG5mdW5jdGlvbiBOdW1iZXJPZih2YWwpIHtcbiAgY29uc3QgcmVzID0gdG9OdW1iZXIodmFsKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBhc3NlcnROdW1iZXIocmVzLCBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBkdXJhdGlvblwiKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcbiAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaCgoYykgPT4gYyAmJiBlbC5jbGFzc0xpc3QuYWRkKGMpKTtcbiAgKGVsW3Z0Y0tleV0gfHwgKGVsW3Z0Y0tleV0gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKSkuYWRkKGNscyk7XG59XG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGNscykge1xuICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKChjKSA9PiBjICYmIGVsLmNsYXNzTGlzdC5yZW1vdmUoYykpO1xuICBjb25zdCBfdnRjID0gZWxbdnRjS2V5XTtcbiAgaWYgKF92dGMpIHtcbiAgICBfdnRjLmRlbGV0ZShjbHMpO1xuICAgIGlmICghX3Z0Yy5zaXplKSB7XG4gICAgICBlbFt2dGNLZXldID0gdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbmV4dEZyYW1lKGNiKSB7XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNiKTtcbiAgfSk7XG59XG5sZXQgZW5kSWQgPSAwO1xuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzKGVsLCBleHBlY3RlZFR5cGUsIGV4cGxpY2l0VGltZW91dCwgcmVzb2x2ZSkge1xuICBjb25zdCBpZCA9IGVsLl9lbmRJZCA9ICsrZW5kSWQ7XG4gIGNvbnN0IHJlc29sdmVJZk5vdFN0YWxlID0gKCkgPT4ge1xuICAgIGlmIChpZCA9PT0gZWwuX2VuZElkKSB7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfVxuICB9O1xuICBpZiAoZXhwbGljaXRUaW1lb3V0ICE9IG51bGwpIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChyZXNvbHZlSWZOb3RTdGFsZSwgZXhwbGljaXRUaW1lb3V0KTtcbiAgfVxuICBjb25zdCB7IHR5cGUsIHRpbWVvdXQsIHByb3BDb3VudCB9ID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIGlmICghdHlwZSkge1xuICAgIHJldHVybiByZXNvbHZlKCk7XG4gIH1cbiAgY29uc3QgZW5kRXZlbnQgPSB0eXBlICsgXCJlbmRcIjtcbiAgbGV0IGVuZGVkID0gMDtcbiAgY29uc3QgZW5kID0gKCkgPT4ge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZW5kRXZlbnQsIG9uRW5kKTtcbiAgICByZXNvbHZlSWZOb3RTdGFsZSgpO1xuICB9O1xuICBjb25zdCBvbkVuZCA9IChlKSA9PiB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCAmJiArK2VuZGVkID49IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9O1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfSwgdGltZW91dCArIDEpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGVuZEV2ZW50LCBvbkVuZCk7XG59XG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKSB7XG4gIGNvbnN0IHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgY29uc3QgZ2V0U3R5bGVQcm9wZXJ0aWVzID0gKGtleSkgPT4gKHN0eWxlc1trZXldIHx8IFwiXCIpLnNwbGl0KFwiLCBcIik7XG4gIGNvbnN0IHRyYW5zaXRpb25EZWxheXMgPSBnZXRTdHlsZVByb3BlcnRpZXMoYCR7VFJBTlNJVElPTn1EZWxheWApO1xuICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb25zID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke1RSQU5TSVRJT059RHVyYXRpb25gKTtcbiAgY29uc3QgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICBjb25zdCBhbmltYXRpb25EZWxheXMgPSBnZXRTdHlsZVByb3BlcnRpZXMoYCR7QU5JTUFUSU9OfURlbGF5YCk7XG4gIGNvbnN0IGFuaW1hdGlvbkR1cmF0aW9ucyA9IGdldFN0eWxlUHJvcGVydGllcyhgJHtBTklNQVRJT059RHVyYXRpb25gKTtcbiAgY29uc3QgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuICBsZXQgdHlwZSA9IG51bGw7XG4gIGxldCB0aW1lb3V0ID0gMDtcbiAgbGV0IHByb3BDb3VudCA9IDA7XG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICB0eXBlID0gdGltZW91dCA+IDAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXQgPyBUUkFOU0lUSU9OIDogQU5JTUFUSU9OIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlID8gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aCA6IDA7XG4gIH1cbiAgY29uc3QgaGFzVHJhbnNmb3JtID0gdHlwZSA9PT0gVFJBTlNJVElPTiAmJiAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvLnRlc3QoXG4gICAgZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke1RSQU5TSVRJT059UHJvcGVydHlgKS50b1N0cmluZygpXG4gICk7XG4gIHJldHVybiB7XG4gICAgdHlwZSxcbiAgICB0aW1lb3V0LFxuICAgIHByb3BDb3VudCxcbiAgICBoYXNUcmFuc2Zvcm1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFRpbWVvdXQoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICB9XG4gIHJldHVybiBNYXRoLm1heCguLi5kdXJhdGlvbnMubWFwKChkLCBpKSA9PiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pKSk7XG59XG5mdW5jdGlvbiB0b01zKHMpIHtcbiAgaWYgKHMgPT09IFwiYXV0b1wiKSByZXR1cm4gMDtcbiAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKS5yZXBsYWNlKFwiLFwiLCBcIi5cIikpICogMWUzO1xufVxuZnVuY3Rpb24gZm9yY2VSZWZsb3coKSB7XG4gIHJldHVybiBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcbn1cblxuZnVuY3Rpb24gcGF0Y2hDbGFzcyhlbCwgdmFsdWUsIGlzU1ZHKSB7XG4gIGNvbnN0IHRyYW5zaXRpb25DbGFzc2VzID0gZWxbdnRjS2V5XTtcbiAgaWYgKHRyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgdmFsdWUgPSAodmFsdWUgPyBbdmFsdWUsIC4uLnRyYW5zaXRpb25DbGFzc2VzXSA6IFsuLi50cmFuc2l0aW9uQ2xhc3Nlc10pLmpvaW4oXCIgXCIpO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKFwiY2xhc3NcIik7XG4gIH0gZWxzZSBpZiAoaXNTVkcpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZWwuY2xhc3NOYW1lID0gdmFsdWU7XG4gIH1cbn1cblxuY29uc3QgdlNob3dPcmlnaW5hbERpc3BsYXkgPSBTeW1ib2woXCJfdm9kXCIpO1xuY29uc3QgdlNob3dIaWRkZW4gPSBTeW1ib2woXCJfdnNoXCIpO1xuY29uc3QgdlNob3cgPSB7XG4gIGJlZm9yZU1vdW50KGVsLCB7IHZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XG4gICAgZWxbdlNob3dPcmlnaW5hbERpc3BsYXldID0gZWwuc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodHJhbnNpdGlvbiAmJiB2YWx1ZSkge1xuICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoZWwsIHsgdmFsdWUgfSwgeyB0cmFuc2l0aW9uIH0pIHtcbiAgICBpZiAodHJhbnNpdGlvbiAmJiB2YWx1ZSkge1xuICAgICAgdHJhbnNpdGlvbi5lbnRlcihlbCk7XG4gICAgfVxuICB9LFxuICB1cGRhdGVkKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xuICAgIGlmICghdmFsdWUgPT09ICFvbGRWYWx1ZSkgcmV0dXJuO1xuICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XG4gICAgICAgIHNldERpc3BsYXkoZWwsIHRydWUpO1xuICAgICAgICB0cmFuc2l0aW9uLmVudGVyKGVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zaXRpb24ubGVhdmUoZWwsICgpID0+IHtcbiAgICAgICAgICBzZXREaXNwbGF5KGVsLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XG4gICAgfVxuICB9LFxuICBiZWZvcmVVbm1vdW50KGVsLCB7IHZhbHVlIH0pIHtcbiAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XG4gIH1cbn07XG5pZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICB2U2hvdy5uYW1lID0gXCJzaG93XCI7XG59XG5mdW5jdGlvbiBzZXREaXNwbGF5KGVsLCB2YWx1ZSkge1xuICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbFt2U2hvd09yaWdpbmFsRGlzcGxheV0gOiBcIm5vbmVcIjtcbiAgZWxbdlNob3dIaWRkZW5dID0gIXZhbHVlO1xufVxuZnVuY3Rpb24gaW5pdFZTaG93Rm9yU1NSKCkge1xuICB2U2hvdy5nZXRTU1JQcm9wcyA9ICh7IHZhbHVlIH0pID0+IHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4geyBzdHlsZTogeyBkaXNwbGF5OiBcIm5vbmVcIiB9IH07XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBDU1NfVkFSX1RFWFQgPSBTeW1ib2woISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IFwiQ1NTX1ZBUl9URVhUXCIgOiBcIlwiKTtcbmZ1bmN0aW9uIHVzZUNzc1ZhcnMoZ2V0dGVyKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGlmICghaW5zdGFuY2UpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYHVzZUNzc1ZhcnMgaXMgY2FsbGVkIHdpdGhvdXQgY3VycmVudCBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlLmApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB1cGRhdGVUZWxlcG9ydHMgPSBpbnN0YW5jZS51dCA9ICh2YXJzID0gZ2V0dGVyKGluc3RhbmNlLnByb3h5KSkgPT4ge1xuICAgIEFycmF5LmZyb20oXG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGBbZGF0YS12LW93bmVyPVwiJHtpbnN0YW5jZS51aWR9XCJdYClcbiAgICApLmZvckVhY2goKG5vZGUpID0+IHNldFZhcnNPbk5vZGUobm9kZSwgdmFycykpO1xuICB9O1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGluc3RhbmNlLmdldENzc1ZhcnMgPSAoKSA9PiBnZXR0ZXIoaW5zdGFuY2UucHJveHkpO1xuICB9XG4gIGNvbnN0IHNldFZhcnMgPSAoKSA9PiB7XG4gICAgY29uc3QgdmFycyA9IGdldHRlcihpbnN0YW5jZS5wcm94eSk7XG4gICAgaWYgKGluc3RhbmNlLmNlKSB7XG4gICAgICBzZXRWYXJzT25Ob2RlKGluc3RhbmNlLmNlLCB2YXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VmFyc09uVk5vZGUoaW5zdGFuY2Uuc3ViVHJlZSwgdmFycyk7XG4gICAgfVxuICAgIHVwZGF0ZVRlbGVwb3J0cyh2YXJzKTtcbiAgfTtcbiAgb25CZWZvcmVVcGRhdGUoKCkgPT4ge1xuICAgIHF1ZXVlUG9zdEZsdXNoQ2Ioc2V0VmFycyk7XG4gIH0pO1xuICBvbk1vdW50ZWQoKCkgPT4ge1xuICAgIHdhdGNoKHNldFZhcnMsIE5PT1AsIHsgZmx1c2g6IFwicG9zdFwiIH0pO1xuICAgIGNvbnN0IG9iID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoc2V0VmFycyk7XG4gICAgb2Iub2JzZXJ2ZShpbnN0YW5jZS5zdWJUcmVlLmVsLnBhcmVudE5vZGUsIHsgY2hpbGRMaXN0OiB0cnVlIH0pO1xuICAgIG9uVW5tb3VudGVkKCgpID0+IG9iLmRpc2Nvbm5lY3QoKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gc2V0VmFyc09uVk5vZGUodm5vZGUsIHZhcnMpIHtcbiAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEyOCkge1xuICAgIGNvbnN0IHN1c3BlbnNlID0gdm5vZGUuc3VzcGVuc2U7XG4gICAgdm5vZGUgPSBzdXNwZW5zZS5hY3RpdmVCcmFuY2g7XG4gICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggJiYgIXN1c3BlbnNlLmlzSHlkcmF0aW5nKSB7XG4gICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goKCkgPT4ge1xuICAgICAgICBzZXRWYXJzT25WTm9kZShzdXNwZW5zZS5hY3RpdmVCcmFuY2gsIHZhcnMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHdoaWxlICh2bm9kZS5jb21wb25lbnQpIHtcbiAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudC5zdWJUcmVlO1xuICB9XG4gIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxICYmIHZub2RlLmVsKSB7XG4gICAgc2V0VmFyc09uTm9kZSh2bm9kZS5lbCwgdmFycyk7XG4gIH0gZWxzZSBpZiAodm5vZGUudHlwZSA9PT0gRnJhZ21lbnQpIHtcbiAgICB2bm9kZS5jaGlsZHJlbi5mb3JFYWNoKChjKSA9PiBzZXRWYXJzT25WTm9kZShjLCB2YXJzKSk7XG4gIH0gZWxzZSBpZiAodm5vZGUudHlwZSA9PT0gU3RhdGljKSB7XG4gICAgbGV0IHsgZWwsIGFuY2hvciB9ID0gdm5vZGU7XG4gICAgd2hpbGUgKGVsKSB7XG4gICAgICBzZXRWYXJzT25Ob2RlKGVsLCB2YXJzKTtcbiAgICAgIGlmIChlbCA9PT0gYW5jaG9yKSBicmVhaztcbiAgICAgIGVsID0gZWwubmV4dFNpYmxpbmc7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRWYXJzT25Ob2RlKGVsLCB2YXJzKSB7XG4gIGlmIChlbC5ub2RlVHlwZSA9PT0gMSkge1xuICAgIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XG4gICAgbGV0IGNzc1RleHQgPSBcIlwiO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHZhcnMpIHtcbiAgICAgIHN0eWxlLnNldFByb3BlcnR5KGAtLSR7a2V5fWAsIHZhcnNba2V5XSk7XG4gICAgICBjc3NUZXh0ICs9IGAtLSR7a2V5fTogJHt2YXJzW2tleV19O2A7XG4gICAgfVxuICAgIHN0eWxlW0NTU19WQVJfVEVYVF0gPSBjc3NUZXh0O1xuICB9XG59XG5cbmNvbnN0IGRpc3BsYXlSRSA9IC8oXnw7KVxccypkaXNwbGF5XFxzKjovO1xuZnVuY3Rpb24gcGF0Y2hTdHlsZShlbCwgcHJldiwgbmV4dCkge1xuICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xuICBjb25zdCBpc0Nzc1N0cmluZyA9IGlzU3RyaW5nKG5leHQpO1xuICBsZXQgaGFzQ29udHJvbGxlZERpc3BsYXkgPSBmYWxzZTtcbiAgaWYgKG5leHQgJiYgIWlzQ3NzU3RyaW5nKSB7XG4gICAgaWYgKHByZXYpIHtcbiAgICAgIGlmICghaXNTdHJpbmcocHJldikpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJldikge1xuICAgICAgICAgIGlmIChuZXh0W2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0U3R5bGUoc3R5bGUsIGtleSwgXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IHByZXZTdHlsZSBvZiBwcmV2LnNwbGl0KFwiO1wiKSkge1xuICAgICAgICAgIGNvbnN0IGtleSA9IHByZXZTdHlsZS5zbGljZSgwLCBwcmV2U3R5bGUuaW5kZXhPZihcIjpcIikpLnRyaW0oKTtcbiAgICAgICAgICBpZiAobmV4dFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIHNldFN0eWxlKHN0eWxlLCBrZXksIFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXh0KSB7XG4gICAgICBpZiAoa2V5ID09PSBcImRpc3BsYXlcIikge1xuICAgICAgICBoYXNDb250cm9sbGVkRGlzcGxheSA9IHRydWU7XG4gICAgICB9XG4gICAgICBzZXRTdHlsZShzdHlsZSwga2V5LCBuZXh0W2tleV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNDc3NTdHJpbmcpIHtcbiAgICAgIGlmIChwcmV2ICE9PSBuZXh0KSB7XG4gICAgICAgIGNvbnN0IGNzc1ZhclRleHQgPSBzdHlsZVtDU1NfVkFSX1RFWFRdO1xuICAgICAgICBpZiAoY3NzVmFyVGV4dCkge1xuICAgICAgICAgIG5leHQgKz0gXCI7XCIgKyBjc3NWYXJUZXh0O1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlLmNzc1RleHQgPSBuZXh0O1xuICAgICAgICBoYXNDb250cm9sbGVkRGlzcGxheSA9IGRpc3BsYXlSRS50ZXN0KG5leHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJldikge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFwic3R5bGVcIik7XG4gICAgfVxuICB9XG4gIGlmICh2U2hvd09yaWdpbmFsRGlzcGxheSBpbiBlbCkge1xuICAgIGVsW3ZTaG93T3JpZ2luYWxEaXNwbGF5XSA9IGhhc0NvbnRyb2xsZWREaXNwbGF5ID8gc3R5bGUuZGlzcGxheSA6IFwiXCI7XG4gICAgaWYgKGVsW3ZTaG93SGlkZGVuXSkge1xuICAgICAgc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIH1cbiAgfVxufVxuY29uc3Qgc2VtaWNvbG9uUkUgPSAvW15cXFxcXTtcXHMqJC87XG5jb25zdCBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xuZnVuY3Rpb24gc2V0U3R5bGUoc3R5bGUsIG5hbWUsIHZhbCkge1xuICBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgdmFsLmZvckVhY2goKHYpID0+IHNldFN0eWxlKHN0eWxlLCBuYW1lLCB2KSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbCA9PSBudWxsKSB2YWwgPSBcIlwiO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBpZiAoc2VtaWNvbG9uUkUudGVzdCh2YWwpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYFVuZXhwZWN0ZWQgc2VtaWNvbG9uIGF0IHRoZSBlbmQgb2YgJyR7bmFtZX0nIHN0eWxlIHZhbHVlOiAnJHt2YWx9J2BcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5hbWUuc3RhcnRzV2l0aChcIi0tXCIpKSB7XG4gICAgICBzdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwcmVmaXhlZCA9IGF1dG9QcmVmaXgoc3R5bGUsIG5hbWUpO1xuICAgICAgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgICAgICBzdHlsZS5zZXRQcm9wZXJ0eShcbiAgICAgICAgICBoeXBoZW5hdGUocHJlZml4ZWQpLFxuICAgICAgICAgIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCBcIlwiKSxcbiAgICAgICAgICBcImltcG9ydGFudFwiXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZVtwcmVmaXhlZF0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jb25zdCBwcmVmaXhlcyA9IFtcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCJdO1xuY29uc3QgcHJlZml4Q2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGF1dG9QcmVmaXgoc3R5bGUsIHJhd05hbWUpIHtcbiAgY29uc3QgY2FjaGVkID0gcHJlZml4Q2FjaGVbcmF3TmFtZV07XG4gIGlmIChjYWNoZWQpIHtcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG4gIGxldCBuYW1lID0gY2FtZWxpemUocmF3TmFtZSk7XG4gIGlmIChuYW1lICE9PSBcImZpbHRlclwiICYmIG5hbWUgaW4gc3R5bGUpIHtcbiAgICByZXR1cm4gcHJlZml4Q2FjaGVbcmF3TmFtZV0gPSBuYW1lO1xuICB9XG4gIG5hbWUgPSBjYXBpdGFsaXplKG5hbWUpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcHJlZml4ZWQgPSBwcmVmaXhlc1tpXSArIG5hbWU7XG4gICAgaWYgKHByZWZpeGVkIGluIHN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJlZml4Q2FjaGVbcmF3TmFtZV0gPSBwcmVmaXhlZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJhd05hbWU7XG59XG5cbmNvbnN0IHhsaW5rTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIjtcbmZ1bmN0aW9uIHBhdGNoQXR0cihlbCwga2V5LCB2YWx1ZSwgaXNTVkcsIGluc3RhbmNlLCBpc0Jvb2xlYW4gPSBpc1NwZWNpYWxCb29sZWFuQXR0cihrZXkpKSB7XG4gIGlmIChpc1NWRyAmJiBrZXkuc3RhcnRzV2l0aChcInhsaW5rOlwiKSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXkuc2xpY2UoNiwga2V5Lmxlbmd0aCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgaXNCb29sZWFuICYmICFpbmNsdWRlQm9vbGVhbkF0dHIodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFxuICAgICAgICBrZXksXG4gICAgICAgIGlzQm9vbGVhbiA/IFwiXCIgOiBpc1N5bWJvbCh2YWx1ZSkgPyBTdHJpbmcodmFsdWUpIDogdmFsdWVcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhdGNoRE9NUHJvcChlbCwga2V5LCB2YWx1ZSwgcGFyZW50Q29tcG9uZW50LCBhdHRyTmFtZSkge1xuICBpZiAoa2V5ID09PSBcImlubmVySFRNTFwiIHx8IGtleSA9PT0gXCJ0ZXh0Q29udGVudFwiKSB7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGVsW2tleV0gPSBrZXkgPT09IFwiaW5uZXJIVE1MXCIgPyB1bnNhZmVUb1RydXN0ZWRIVE1MKHZhbHVlKSA6IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdGFnID0gZWwudGFnTmFtZTtcbiAgaWYgKGtleSA9PT0gXCJ2YWx1ZVwiICYmIHRhZyAhPT0gXCJQUk9HUkVTU1wiICYmIC8vIGN1c3RvbSBlbGVtZW50cyBtYXkgdXNlIF92YWx1ZSBpbnRlcm5hbGx5XG4gICF0YWcuaW5jbHVkZXMoXCItXCIpKSB7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0YWcgPT09IFwiT1BUSU9OXCIgPyBlbC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSB8fCBcIlwiIDogZWwudmFsdWU7XG4gICAgY29uc3QgbmV3VmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gKFxuICAgICAgLy8gIzExNjQ3OiB2YWx1ZSBzaG91bGQgYmUgc2V0IGFzIGVtcHR5IHN0cmluZyBmb3IgbnVsbCBhbmQgdW5kZWZpbmVkLFxuICAgICAgLy8gYnV0IDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIj4gc2hvdWxkIGJlIHNldCBhcyAnb24nLlxuICAgICAgZWwudHlwZSA9PT0gXCJjaGVja2JveFwiID8gXCJvblwiIDogXCJcIlxuICAgICkgOiBTdHJpbmcodmFsdWUpO1xuICAgIGlmIChvbGRWYWx1ZSAhPT0gbmV3VmFsdWUgfHwgIShcIl92YWx1ZVwiIGluIGVsKSkge1xuICAgICAgZWwudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH1cbiAgICBlbC5fdmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IG5lZWRSZW1vdmUgPSBmYWxzZTtcbiAgaWYgKHZhbHVlID09PSBcIlwiIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIGVsW2tleV07XG4gICAgaWYgKHR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICB2YWx1ZSA9IGluY2x1ZGVCb29sZWFuQXR0cih2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBudWxsICYmIHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgIG5lZWRSZW1vdmUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgdmFsdWUgPSAwO1xuICAgICAgbmVlZFJlbW92ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHRyeSB7XG4gICAgZWxba2V5XSA9IHZhbHVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIW5lZWRSZW1vdmUpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBGYWlsZWQgc2V0dGluZyBwcm9wIFwiJHtrZXl9XCIgb24gPCR7dGFnLnRvTG93ZXJDYXNlKCl9PjogdmFsdWUgJHt2YWx1ZX0gaXMgaW52YWxpZC5gLFxuICAgICAgICBlXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBuZWVkUmVtb3ZlICYmIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSB8fCBrZXkpO1xufVxuXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGVsLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuY29uc3QgdmVpS2V5ID0gU3ltYm9sKFwiX3ZlaVwiKTtcbmZ1bmN0aW9uIHBhdGNoRXZlbnQoZWwsIHJhd05hbWUsIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBpbnN0YW5jZSA9IG51bGwpIHtcbiAgY29uc3QgaW52b2tlcnMgPSBlbFt2ZWlLZXldIHx8IChlbFt2ZWlLZXldID0ge30pO1xuICBjb25zdCBleGlzdGluZ0ludm9rZXIgPSBpbnZva2Vyc1tyYXdOYW1lXTtcbiAgaWYgKG5leHRWYWx1ZSAmJiBleGlzdGluZ0ludm9rZXIpIHtcbiAgICBleGlzdGluZ0ludm9rZXIudmFsdWUgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2FuaXRpemVFdmVudFZhbHVlKG5leHRWYWx1ZSwgcmF3TmFtZSkgOiBuZXh0VmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgW25hbWUsIG9wdGlvbnNdID0gcGFyc2VOYW1lKHJhd05hbWUpO1xuICAgIGlmIChuZXh0VmFsdWUpIHtcbiAgICAgIGNvbnN0IGludm9rZXIgPSBpbnZva2Vyc1tyYXdOYW1lXSA9IGNyZWF0ZUludm9rZXIoXG4gICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzYW5pdGl6ZUV2ZW50VmFsdWUobmV4dFZhbHVlLCByYXdOYW1lKSA6IG5leHRWYWx1ZSxcbiAgICAgICAgaW5zdGFuY2VcbiAgICAgICk7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBpbnZva2VyLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKGV4aXN0aW5nSW52b2tlcikge1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgZXhpc3RpbmdJbnZva2VyLCBvcHRpb25zKTtcbiAgICAgIGludm9rZXJzW3Jhd05hbWVdID0gdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuY29uc3Qgb3B0aW9uc01vZGlmaWVyUkUgPSAvKD86T25jZXxQYXNzaXZlfENhcHR1cmUpJC87XG5mdW5jdGlvbiBwYXJzZU5hbWUobmFtZSkge1xuICBsZXQgb3B0aW9ucztcbiAgaWYgKG9wdGlvbnNNb2RpZmllclJFLnRlc3QobmFtZSkpIHtcbiAgICBvcHRpb25zID0ge307XG4gICAgbGV0IG07XG4gICAgd2hpbGUgKG0gPSBuYW1lLm1hdGNoKG9wdGlvbnNNb2RpZmllclJFKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgbmFtZS5sZW5ndGggLSBtWzBdLmxlbmd0aCk7XG4gICAgICBvcHRpb25zW21bMF0udG9Mb3dlckNhc2UoKV0gPSB0cnVlO1xuICAgIH1cbiAgfVxuICBjb25zdCBldmVudCA9IG5hbWVbMl0gPT09IFwiOlwiID8gbmFtZS5zbGljZSgzKSA6IGh5cGhlbmF0ZShuYW1lLnNsaWNlKDIpKTtcbiAgcmV0dXJuIFtldmVudCwgb3B0aW9uc107XG59XG5sZXQgY2FjaGVkTm93ID0gMDtcbmNvbnN0IHAgPSAvKiBAX19QVVJFX18gKi8gUHJvbWlzZS5yZXNvbHZlKCk7XG5jb25zdCBnZXROb3cgPSAoKSA9PiBjYWNoZWROb3cgfHwgKHAudGhlbigoKSA9PiBjYWNoZWROb3cgPSAwKSwgY2FjaGVkTm93ID0gRGF0ZS5ub3coKSk7XG5mdW5jdGlvbiBjcmVhdGVJbnZva2VyKGluaXRpYWxWYWx1ZSwgaW5zdGFuY2UpIHtcbiAgY29uc3QgaW52b2tlciA9IChlKSA9PiB7XG4gICAgaWYgKCFlLl92dHMpIHtcbiAgICAgIGUuX3Z0cyA9IERhdGUubm93KCk7XG4gICAgfSBlbHNlIGlmIChlLl92dHMgPD0gaW52b2tlci5hdHRhY2hlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICAgIHBhdGNoU3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGUsIGludm9rZXIudmFsdWUpLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICA1LFxuICAgICAgW2VdXG4gICAgKTtcbiAgfTtcbiAgaW52b2tlci52YWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgaW52b2tlci5hdHRhY2hlZCA9IGdldE5vdygpO1xuICByZXR1cm4gaW52b2tlcjtcbn1cbmZ1bmN0aW9uIHNhbml0aXplRXZlbnRWYWx1ZSh2YWx1ZSwgcHJvcE5hbWUpIHtcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpIHx8IGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHdhcm4oXG4gICAgYFdyb25nIHR5cGUgcGFzc2VkIGFzIGV2ZW50IGhhbmRsZXIgdG8gJHtwcm9wTmFtZX0gLSBkaWQgeW91IGZvcmdldCBAIG9yIDogaW4gZnJvbnQgb2YgeW91ciBwcm9wP1xuRXhwZWN0ZWQgZnVuY3Rpb24gb3IgYXJyYXkgb2YgZnVuY3Rpb25zLCByZWNlaXZlZCB0eXBlICR7dHlwZW9mIHZhbHVlfS5gXG4gICk7XG4gIHJldHVybiBOT09QO1xufVxuZnVuY3Rpb24gcGF0Y2hTdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oZSwgdmFsdWUpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxTdG9wID0gZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb247XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPSAoKSA9PiB7XG4gICAgICBvcmlnaW5hbFN0b3AuY2FsbChlKTtcbiAgICAgIGUuX3N0b3BwZWQgPSB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIHZhbHVlLm1hcChcbiAgICAgIChmbikgPT4gKGUyKSA9PiAhZTIuX3N0b3BwZWQgJiYgZm4gJiYgZm4oZTIpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuY29uc3QgaXNOYXRpdmVPbiA9IChrZXkpID0+IGtleS5jaGFyQ29kZUF0KDApID09PSAxMTEgJiYga2V5LmNoYXJDb2RlQXQoMSkgPT09IDExMCAmJiAvLyBsb3dlcmNhc2UgbGV0dGVyXG5rZXkuY2hhckNvZGVBdCgyKSA+IDk2ICYmIGtleS5jaGFyQ29kZUF0KDIpIDwgMTIzO1xuY29uc3QgcGF0Y2hQcm9wID0gKGVsLCBrZXksIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBuYW1lc3BhY2UsIHBhcmVudENvbXBvbmVudCkgPT4ge1xuICBjb25zdCBpc1NWRyA9IG5hbWVzcGFjZSA9PT0gXCJzdmdcIjtcbiAgaWYgKGtleSA9PT0gXCJjbGFzc1wiKSB7XG4gICAgcGF0Y2hDbGFzcyhlbCwgbmV4dFZhbHVlLCBpc1NWRyk7XG4gIH0gZWxzZSBpZiAoa2V5ID09PSBcInN0eWxlXCIpIHtcbiAgICBwYXRjaFN0eWxlKGVsLCBwcmV2VmFsdWUsIG5leHRWYWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNPbihrZXkpKSB7XG4gICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSkge1xuICAgICAgcGF0Y2hFdmVudChlbCwga2V5LCBwcmV2VmFsdWUsIG5leHRWYWx1ZSwgcGFyZW50Q29tcG9uZW50KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoa2V5WzBdID09PSBcIi5cIiA/IChrZXkgPSBrZXkuc2xpY2UoMSksIHRydWUpIDoga2V5WzBdID09PSBcIl5cIiA/IChrZXkgPSBrZXkuc2xpY2UoMSksIGZhbHNlKSA6IHNob3VsZFNldEFzUHJvcChlbCwga2V5LCBuZXh0VmFsdWUsIGlzU1ZHKSkge1xuICAgIHBhdGNoRE9NUHJvcChlbCwga2V5LCBuZXh0VmFsdWUpO1xuICAgIGlmICghZWwudGFnTmFtZS5pbmNsdWRlcyhcIi1cIikgJiYgKGtleSA9PT0gXCJ2YWx1ZVwiIHx8IGtleSA9PT0gXCJjaGVja2VkXCIgfHwga2V5ID09PSBcInNlbGVjdGVkXCIpKSB7XG4gICAgICBwYXRjaEF0dHIoZWwsIGtleSwgbmV4dFZhbHVlLCBpc1NWRywgcGFyZW50Q29tcG9uZW50LCBrZXkgIT09IFwidmFsdWVcIik7XG4gICAgfVxuICB9IGVsc2UgaWYgKFxuICAgIC8vICMxMTA4MSBmb3JjZSBzZXQgcHJvcHMgZm9yIHBvc3NpYmxlIGFzeW5jIGN1c3RvbSBlbGVtZW50XG4gICAgZWwuX2lzVnVlQ0UgJiYgKC9bQS1aXS8udGVzdChrZXkpIHx8ICFpc1N0cmluZyhuZXh0VmFsdWUpKVxuICApIHtcbiAgICBwYXRjaERPTVByb3AoZWwsIGNhbWVsaXplJDEoa2V5KSwgbmV4dFZhbHVlLCBwYXJlbnRDb21wb25lbnQsIGtleSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGtleSA9PT0gXCJ0cnVlLXZhbHVlXCIpIHtcbiAgICAgIGVsLl90cnVlVmFsdWUgPSBuZXh0VmFsdWU7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiZmFsc2UtdmFsdWVcIikge1xuICAgICAgZWwuX2ZhbHNlVmFsdWUgPSBuZXh0VmFsdWU7XG4gICAgfVxuICAgIHBhdGNoQXR0cihlbCwga2V5LCBuZXh0VmFsdWUsIGlzU1ZHKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNob3VsZFNldEFzUHJvcChlbCwga2V5LCB2YWx1ZSwgaXNTVkcpIHtcbiAgaWYgKGlzU1ZHKSB7XG4gICAgaWYgKGtleSA9PT0gXCJpbm5lckhUTUxcIiB8fCBrZXkgPT09IFwidGV4dENvbnRlbnRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChrZXkgaW4gZWwgJiYgaXNOYXRpdmVPbihrZXkpICYmIGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChrZXkgPT09IFwic3BlbGxjaGVja1wiIHx8IGtleSA9PT0gXCJkcmFnZ2FibGVcIiB8fCBrZXkgPT09IFwidHJhbnNsYXRlXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJmb3JtXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJsaXN0XCIgJiYgZWwudGFnTmFtZSA9PT0gXCJJTlBVVFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChrZXkgPT09IFwidHlwZVwiICYmIGVsLnRhZ05hbWUgPT09IFwiVEVYVEFSRUFcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoa2V5ID09PSBcIndpZHRoXCIgfHwga2V5ID09PSBcImhlaWdodFwiKSB7XG4gICAgY29uc3QgdGFnID0gZWwudGFnTmFtZTtcbiAgICBpZiAodGFnID09PSBcIklNR1wiIHx8IHRhZyA9PT0gXCJWSURFT1wiIHx8IHRhZyA9PT0gXCJDQU5WQVNcIiB8fCB0YWcgPT09IFwiU09VUkNFXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzTmF0aXZlT24oa2V5KSAmJiBpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGtleSBpbiBlbDtcbn1cblxuY29uc3QgUkVNT1ZBTCA9IHt9O1xuLyohICNfX05PX1NJREVfRUZGRUNUU19fICovXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRWxlbWVudChvcHRpb25zLCBleHRyYU9wdGlvbnMsIF9jcmVhdGVBcHApIHtcbiAgY29uc3QgQ29tcCA9IGRlZmluZUNvbXBvbmVudChvcHRpb25zLCBleHRyYU9wdGlvbnMpO1xuICBpZiAoaXNQbGFpbk9iamVjdChDb21wKSkgZXh0ZW5kKENvbXAsIGV4dHJhT3B0aW9ucyk7XG4gIGNsYXNzIFZ1ZUN1c3RvbUVsZW1lbnQgZXh0ZW5kcyBWdWVFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihpbml0aWFsUHJvcHMpIHtcbiAgICAgIHN1cGVyKENvbXAsIGluaXRpYWxQcm9wcywgX2NyZWF0ZUFwcCk7XG4gICAgfVxuICB9XG4gIFZ1ZUN1c3RvbUVsZW1lbnQuZGVmID0gQ29tcDtcbiAgcmV0dXJuIFZ1ZUN1c3RvbUVsZW1lbnQ7XG59XG4vKiEgI19fTk9fU0lERV9FRkZFQ1RTX18gKi9cbmNvbnN0IGRlZmluZVNTUkN1c3RvbUVsZW1lbnQgPSAvKiBAX19OT19TSURFX0VGRkVDVFNfXyAqLyAob3B0aW9ucywgZXh0cmFPcHRpb25zKSA9PiB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gZGVmaW5lQ3VzdG9tRWxlbWVudChvcHRpb25zLCBleHRyYU9wdGlvbnMsIGNyZWF0ZVNTUkFwcCk7XG59O1xuY29uc3QgQmFzZUNsYXNzID0gdHlwZW9mIEhUTUxFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gSFRNTEVsZW1lbnQgOiBjbGFzcyB7XG59O1xuY2xhc3MgVnVlRWxlbWVudCBleHRlbmRzIEJhc2VDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKF9kZWYsIF9wcm9wcyA9IHt9LCBfY3JlYXRlQXBwID0gY3JlYXRlQXBwKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9kZWYgPSBfZGVmO1xuICAgIHRoaXMuX3Byb3BzID0gX3Byb3BzO1xuICAgIHRoaXMuX2NyZWF0ZUFwcCA9IF9jcmVhdGVBcHA7XG4gICAgdGhpcy5faXNWdWVDRSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX2FwcCA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fbm9uY2UgPSB0aGlzLl9kZWYubm9uY2U7XG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9udW1iZXJQcm9wcyA9IG51bGw7XG4gICAgdGhpcy5fc3R5bGVDaGlsZHJlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICAgIHRoaXMuX29iID0gbnVsbDtcbiAgICBpZiAodGhpcy5zaGFkb3dSb290ICYmIF9jcmVhdGVBcHAgIT09IGNyZWF0ZUFwcCkge1xuICAgICAgdGhpcy5fcm9vdCA9IHRoaXMuc2hhZG93Um9vdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdGhpcy5zaGFkb3dSb290KSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYEN1c3RvbSBlbGVtZW50IGhhcyBwcmUtcmVuZGVyZWQgZGVjbGFyYXRpdmUgc2hhZG93IHJvb3QgYnV0IGlzIG5vdCBkZWZpbmVkIGFzIGh5ZHJhdGFibGUuIFVzZSBcXGBkZWZpbmVTU1JDdXN0b21FbGVtZW50XFxgLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChfZGVmLnNoYWRvd1Jvb3QgIT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogXCJvcGVuXCIgfSk7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSB0aGlzLnNoYWRvd1Jvb3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yb290ID0gdGhpcztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLl9kZWYuX19hc3luY0xvYWRlcikge1xuICAgICAgdGhpcy5fcmVzb2x2ZVByb3BzKHRoaXMuX2RlZik7XG4gICAgfVxuICB9XG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCkgcmV0dXJuO1xuICAgIGlmICghdGhpcy5zaGFkb3dSb290KSB7XG4gICAgICB0aGlzLl9wYXJzZVNsb3RzKCk7XG4gICAgfVxuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgbGV0IHBhcmVudCA9IHRoaXM7XG4gICAgd2hpbGUgKHBhcmVudCA9IHBhcmVudCAmJiAocGFyZW50LnBhcmVudE5vZGUgfHwgcGFyZW50Lmhvc3QpKSB7XG4gICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgVnVlRWxlbWVudCkge1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuX2luc3RhbmNlKSB7XG4gICAgICBpZiAodGhpcy5fcmVzb2x2ZWQpIHtcbiAgICAgICAgdGhpcy5fc2V0UGFyZW50KCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmdSZXNvbHZlKSB7XG4gICAgICAgICAgdGhpcy5fcGVuZGluZ1Jlc29sdmUgPSBwYXJlbnQuX3BlbmRpbmdSZXNvbHZlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1Jlc29sdmUgPSB2b2lkIDA7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlRGVmKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcmVzb2x2ZURlZigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9zZXRQYXJlbnQocGFyZW50ID0gdGhpcy5fcGFyZW50KSB7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgdGhpcy5faW5zdGFuY2UucGFyZW50ID0gcGFyZW50Ll9pbnN0YW5jZTtcbiAgICAgIHRoaXMuX2luc3RhbmNlLnByb3ZpZGVzID0gcGFyZW50Ll9pbnN0YW5jZS5wcm92aWRlcztcbiAgICB9XG4gIH1cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgbmV4dFRpY2soKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuX29iKSB7XG4gICAgICAgICAgdGhpcy5fb2IuZGlzY29ubmVjdCgpO1xuICAgICAgICAgIHRoaXMuX29iID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hcHAgJiYgdGhpcy5fYXBwLnVubW91bnQoKTtcbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlKSB0aGlzLl9pbnN0YW5jZS5jZSA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5fYXBwID0gdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiByZXNvbHZlIGlubmVyIGNvbXBvbmVudCBkZWZpbml0aW9uIChoYW5kbGUgcG9zc2libGUgYXN5bmMgY29tcG9uZW50KVxuICAgKi9cbiAgX3Jlc29sdmVEZWYoKSB7XG4gICAgaWYgKHRoaXMuX3BlbmRpbmdSZXNvbHZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9zZXRBdHRyKHRoaXMuYXR0cmlidXRlc1tpXS5uYW1lKTtcbiAgICB9XG4gICAgdGhpcy5fb2IgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IG0gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgIHRoaXMuX3NldEF0dHIobS5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLl9vYi5vYnNlcnZlKHRoaXMsIHsgYXR0cmlidXRlczogdHJ1ZSB9KTtcbiAgICBjb25zdCByZXNvbHZlID0gKGRlZiwgaXNBc3luYyA9IGZhbHNlKSA9PiB7XG4gICAgICB0aGlzLl9yZXNvbHZlZCA9IHRydWU7XG4gICAgICB0aGlzLl9wZW5kaW5nUmVzb2x2ZSA9IHZvaWQgMDtcbiAgICAgIGNvbnN0IHsgcHJvcHMsIHN0eWxlcyB9ID0gZGVmO1xuICAgICAgbGV0IG51bWJlclByb3BzO1xuICAgICAgaWYgKHByb3BzICYmICFpc0FycmF5KHByb3BzKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgICAgIGNvbnN0IG9wdCA9IHByb3BzW2tleV07XG4gICAgICAgICAgaWYgKG9wdCA9PT0gTnVtYmVyIHx8IG9wdCAmJiBvcHQudHlwZSA9PT0gTnVtYmVyKSB7XG4gICAgICAgICAgICBpZiAoa2V5IGluIHRoaXMuX3Byb3BzKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Byb3BzW2tleV0gPSB0b051bWJlcih0aGlzLl9wcm9wc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChudW1iZXJQcm9wcyB8fCAobnVtYmVyUHJvcHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSkpW2NhbWVsaXplJDEoa2V5KV0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fbnVtYmVyUHJvcHMgPSBudW1iZXJQcm9wcztcbiAgICAgIGlmIChpc0FzeW5jKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVQcm9wcyhkZWYpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgICB0aGlzLl9hcHBseVN0eWxlcyhzdHlsZXMpO1xuICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHN0eWxlcykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiQ3VzdG9tIGVsZW1lbnQgc3R5bGUgaW5qZWN0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgd2hlbiB1c2luZyBzaGFkb3dSb290OiBmYWxzZVwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLl9tb3VudChkZWYpO1xuICAgIH07XG4gICAgY29uc3QgYXN5bmNEZWYgPSB0aGlzLl9kZWYuX19hc3luY0xvYWRlcjtcbiAgICBpZiAoYXN5bmNEZWYpIHtcbiAgICAgIHRoaXMuX3BlbmRpbmdSZXNvbHZlID0gYXN5bmNEZWYoKS50aGVuKFxuICAgICAgICAoZGVmKSA9PiByZXNvbHZlKHRoaXMuX2RlZiA9IGRlZiwgdHJ1ZSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmUodGhpcy5fZGVmKTtcbiAgICB9XG4gIH1cbiAgX21vdW50KGRlZikge1xuICAgIGlmICgoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pICYmICFkZWYubmFtZSkge1xuICAgICAgZGVmLm5hbWUgPSBcIlZ1ZUVsZW1lbnRcIjtcbiAgICB9XG4gICAgdGhpcy5fYXBwID0gdGhpcy5fY3JlYXRlQXBwKGRlZik7XG4gICAgaWYgKGRlZi5jb25maWd1cmVBcHApIHtcbiAgICAgIGRlZi5jb25maWd1cmVBcHAodGhpcy5fYXBwKTtcbiAgICB9XG4gICAgdGhpcy5fYXBwLl9jZVZOb2RlID0gdGhpcy5fY3JlYXRlVk5vZGUoKTtcbiAgICB0aGlzLl9hcHAubW91bnQodGhpcy5fcm9vdCk7XG4gICAgY29uc3QgZXhwb3NlZCA9IHRoaXMuX2luc3RhbmNlICYmIHRoaXMuX2luc3RhbmNlLmV4cG9zZWQ7XG4gICAgaWYgKCFleHBvc2VkKSByZXR1cm47XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZXhwb3NlZCkge1xuICAgICAgaWYgKCFoYXNPd24odGhpcywga2V5KSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgICAgLy8gdW53cmFwIHJlZiB0byBiZSBjb25zaXN0ZW50IHdpdGggcHVibGljIGluc3RhbmNlIGJlaGF2aW9yXG4gICAgICAgICAgZ2V0OiAoKSA9PiB1bnJlZihleHBvc2VkW2tleV0pXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIHdhcm4oYEV4cG9zZWQgcHJvcGVydHkgXCIke2tleX1cIiBhbHJlYWR5IGV4aXN0cyBvbiBjdXN0b20gZWxlbWVudC5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3Jlc29sdmVQcm9wcyhkZWYpIHtcbiAgICBjb25zdCB7IHByb3BzIH0gPSBkZWY7XG4gICAgY29uc3QgZGVjbGFyZWRQcm9wS2V5cyA9IGlzQXJyYXkocHJvcHMpID8gcHJvcHMgOiBPYmplY3Qua2V5cyhwcm9wcyB8fCB7fSk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcykpIHtcbiAgICAgIGlmIChrZXlbMF0gIT09IFwiX1wiICYmIGRlY2xhcmVkUHJvcEtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICB0aGlzLl9zZXRQcm9wKGtleSwgdGhpc1trZXldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgZGVjbGFyZWRQcm9wS2V5cy5tYXAoY2FtZWxpemUkMSkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRQcm9wKGtleSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWwpIHtcbiAgICAgICAgICB0aGlzLl9zZXRQcm9wKGtleSwgdmFsLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIF9zZXRBdHRyKGtleSkge1xuICAgIGlmIChrZXkuc3RhcnRzV2l0aChcImRhdGEtdi1cIikpIHJldHVybjtcbiAgICBjb25zdCBoYXMgPSB0aGlzLmhhc0F0dHJpYnV0ZShrZXkpO1xuICAgIGxldCB2YWx1ZSA9IGhhcyA/IHRoaXMuZ2V0QXR0cmlidXRlKGtleSkgOiBSRU1PVkFMO1xuICAgIGNvbnN0IGNhbWVsS2V5ID0gY2FtZWxpemUkMShrZXkpO1xuICAgIGlmIChoYXMgJiYgdGhpcy5fbnVtYmVyUHJvcHMgJiYgdGhpcy5fbnVtYmVyUHJvcHNbY2FtZWxLZXldKSB7XG4gICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICB9XG4gICAgdGhpcy5fc2V0UHJvcChjYW1lbEtleSwgdmFsdWUsIGZhbHNlLCB0cnVlKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfZ2V0UHJvcChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvcHNba2V5XTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfc2V0UHJvcChrZXksIHZhbCwgc2hvdWxkUmVmbGVjdCA9IHRydWUsIHNob3VsZFVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgaWYgKHZhbCAhPT0gdGhpcy5fcHJvcHNba2V5XSkge1xuICAgICAgaWYgKHZhbCA9PT0gUkVNT1ZBTCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fcHJvcHNba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Byb3BzW2tleV0gPSB2YWw7XG4gICAgICAgIGlmIChrZXkgPT09IFwia2V5XCIgJiYgdGhpcy5fYXBwKSB7XG4gICAgICAgICAgdGhpcy5fYXBwLl9jZVZOb2RlLmtleSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFVwZGF0ZSAmJiB0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRSZWZsZWN0KSB7XG4gICAgICAgIGNvbnN0IG9iID0gdGhpcy5fb2I7XG4gICAgICAgIG9iICYmIG9iLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgaWYgKHZhbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGh5cGhlbmF0ZShrZXkpLCBcIlwiKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShoeXBoZW5hdGUoa2V5KSwgdmFsICsgXCJcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoIXZhbCkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKGh5cGhlbmF0ZShrZXkpKTtcbiAgICAgICAgfVxuICAgICAgICBvYiAmJiBvYi5vYnNlcnZlKHRoaXMsIHsgYXR0cmlidXRlczogdHJ1ZSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3VwZGF0ZSgpIHtcbiAgICByZW5kZXIodGhpcy5fY3JlYXRlVk5vZGUoKSwgdGhpcy5fcm9vdCk7XG4gIH1cbiAgX2NyZWF0ZVZOb2RlKCkge1xuICAgIGNvbnN0IGJhc2VQcm9wcyA9IHt9O1xuICAgIGlmICghdGhpcy5zaGFkb3dSb290KSB7XG4gICAgICBiYXNlUHJvcHMub25Wbm9kZU1vdW50ZWQgPSBiYXNlUHJvcHMub25Wbm9kZVVwZGF0ZWQgPSB0aGlzLl9yZW5kZXJTbG90cy5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKHRoaXMuX2RlZiwgZXh0ZW5kKGJhc2VQcm9wcywgdGhpcy5fcHJvcHMpKTtcbiAgICBpZiAoIXRoaXMuX2luc3RhbmNlKSB7XG4gICAgICB2bm9kZS5jZSA9IChpbnN0YW5jZSkgPT4ge1xuICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICBpbnN0YW5jZS5jZSA9IHRoaXM7XG4gICAgICAgIGluc3RhbmNlLmlzQ0UgPSB0cnVlO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGluc3RhbmNlLmNlUmVsb2FkID0gKG5ld1N0eWxlcykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0eWxlcykge1xuICAgICAgICAgICAgICB0aGlzLl9zdHlsZXMuZm9yRWFjaCgocykgPT4gdGhpcy5fcm9vdC5yZW1vdmVDaGlsZChzKSk7XG4gICAgICAgICAgICAgIHRoaXMuX3N0eWxlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYXBwbHlTdHlsZXMobmV3U3R5bGVzKTtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlzcGF0Y2ggPSAoZXZlbnQsIGFyZ3MpID0+IHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQoXG4gICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICBpc1BsYWluT2JqZWN0KGFyZ3NbMF0pID8gZXh0ZW5kKHsgZGV0YWlsOiBhcmdzIH0sIGFyZ3NbMF0pIDogeyBkZXRhaWw6IGFyZ3MgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgICAgIGluc3RhbmNlLmVtaXQgPSAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICBkaXNwYXRjaChldmVudCwgYXJncyk7XG4gICAgICAgICAgaWYgKGh5cGhlbmF0ZShldmVudCkgIT09IGV2ZW50KSB7XG4gICAgICAgICAgICBkaXNwYXRjaChoeXBoZW5hdGUoZXZlbnQpLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NldFBhcmVudCgpO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlO1xuICB9XG4gIF9hcHBseVN0eWxlcyhzdHlsZXMsIG93bmVyKSB7XG4gICAgaWYgKCFzdHlsZXMpIHJldHVybjtcbiAgICBpZiAob3duZXIpIHtcbiAgICAgIGlmIChvd25lciA9PT0gdGhpcy5fZGVmIHx8IHRoaXMuX3N0eWxlQ2hpbGRyZW4uaGFzKG93bmVyKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9zdHlsZUNoaWxkcmVuLmFkZChvd25lcik7XG4gICAgfVxuICAgIGNvbnN0IG5vbmNlID0gdGhpcy5fbm9uY2U7XG4gICAgZm9yIChsZXQgaSA9IHN0eWxlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgIGlmIChub25jZSkgcy5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBub25jZSk7XG4gICAgICBzLnRleHRDb250ZW50ID0gc3R5bGVzW2ldO1xuICAgICAgdGhpcy5zaGFkb3dSb290LnByZXBlbmQocyk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBpZiAob3duZXIpIHtcbiAgICAgICAgICBpZiAob3duZXIuX19obXJJZCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jaGlsZFN0eWxlcykgdGhpcy5fY2hpbGRTdHlsZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICAgICAgbGV0IGVudHJ5ID0gdGhpcy5fY2hpbGRTdHlsZXMuZ2V0KG93bmVyLl9faG1ySWQpO1xuICAgICAgICAgICAgaWYgKCFlbnRyeSkge1xuICAgICAgICAgICAgICB0aGlzLl9jaGlsZFN0eWxlcy5zZXQob3duZXIuX19obXJJZCwgZW50cnkgPSBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnRyeS5wdXNoKHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAodGhpcy5fc3R5bGVzIHx8ICh0aGlzLl9zdHlsZXMgPSBbXSkpLnB1c2gocyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE9ubHkgY2FsbGVkIHdoZW4gc2hhZG93Um9vdCBpcyBmYWxzZVxuICAgKi9cbiAgX3BhcnNlU2xvdHMoKSB7XG4gICAgY29uc3Qgc2xvdHMgPSB0aGlzLl9zbG90cyA9IHt9O1xuICAgIGxldCBuO1xuICAgIHdoaWxlIChuID0gdGhpcy5maXJzdENoaWxkKSB7XG4gICAgICBjb25zdCBzbG90TmFtZSA9IG4ubm9kZVR5cGUgPT09IDEgJiYgbi5nZXRBdHRyaWJ1dGUoXCJzbG90XCIpIHx8IFwiZGVmYXVsdFwiO1xuICAgICAgKHNsb3RzW3Nsb3ROYW1lXSB8fCAoc2xvdHNbc2xvdE5hbWVdID0gW10pKS5wdXNoKG4pO1xuICAgICAgdGhpcy5yZW1vdmVDaGlsZChuKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE9ubHkgY2FsbGVkIHdoZW4gc2hhZG93Um9vdCBpcyBmYWxzZVxuICAgKi9cbiAgX3JlbmRlclNsb3RzKCkge1xuICAgIGNvbnN0IG91dGxldHMgPSAodGhpcy5fdGVsZXBvcnRUYXJnZXQgfHwgdGhpcykucXVlcnlTZWxlY3RvckFsbChcInNsb3RcIik7XG4gICAgY29uc3Qgc2NvcGVJZCA9IHRoaXMuX2luc3RhbmNlLnR5cGUuX19zY29wZUlkO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0bGV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbyA9IG91dGxldHNbaV07XG4gICAgICBjb25zdCBzbG90TmFtZSA9IG8uZ2V0QXR0cmlidXRlKFwibmFtZVwiKSB8fCBcImRlZmF1bHRcIjtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLl9zbG90c1tzbG90TmFtZV07XG4gICAgICBjb25zdCBwYXJlbnQgPSBvLnBhcmVudE5vZGU7XG4gICAgICBpZiAoY29udGVudCkge1xuICAgICAgICBmb3IgKGNvbnN0IG4gb2YgY29udGVudCkge1xuICAgICAgICAgIGlmIChzY29wZUlkICYmIG4ubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gc2NvcGVJZCArIFwiLXNcIjtcbiAgICAgICAgICAgIGNvbnN0IHdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIobiwgMSk7XG4gICAgICAgICAgICBuLnNldEF0dHJpYnV0ZShpZCwgXCJcIik7XG4gICAgICAgICAgICBsZXQgY2hpbGQ7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGQgPSB3YWxrZXIubmV4dE5vZGUoKSkge1xuICAgICAgICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoaWQsIFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG4sIG8pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aGlsZSAoby5maXJzdENoaWxkKSBwYXJlbnQuaW5zZXJ0QmVmb3JlKG8uZmlyc3RDaGlsZCwgbyk7XG4gICAgICB9XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQobyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9pbmplY3RDaGlsZFN0eWxlKGNvbXApIHtcbiAgICB0aGlzLl9hcHBseVN0eWxlcyhjb21wLnN0eWxlcywgY29tcCk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3JlbW92ZUNoaWxkU3R5bGUoY29tcCkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB0aGlzLl9zdHlsZUNoaWxkcmVuLmRlbGV0ZShjb21wKTtcbiAgICAgIGlmICh0aGlzLl9jaGlsZFN0eWxlcyAmJiBjb21wLl9faG1ySWQpIHtcbiAgICAgICAgY29uc3Qgb2xkU3R5bGVzID0gdGhpcy5fY2hpbGRTdHlsZXMuZ2V0KGNvbXAuX19obXJJZCk7XG4gICAgICAgIGlmIChvbGRTdHlsZXMpIHtcbiAgICAgICAgICBvbGRTdHlsZXMuZm9yRWFjaCgocykgPT4gdGhpcy5fcm9vdC5yZW1vdmVDaGlsZChzKSk7XG4gICAgICAgICAgb2xkU3R5bGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHVzZUhvc3QoY2FsbGVyKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGNvbnN0IGVsID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuY2U7XG4gIGlmIChlbCkge1xuICAgIHJldHVybiBlbDtcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgd2FybihcbiAgICAgICAgYCR7Y2FsbGVyIHx8IFwidXNlSG9zdFwifSBjYWxsZWQgd2l0aG91dCBhbiBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlLmBcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGAke2NhbGxlciB8fCBcInVzZUhvc3RcIn0gY2FuIG9ubHkgYmUgdXNlZCBpbiBjb21wb25lbnRzIGRlZmluZWQgdmlhIGRlZmluZUN1c3RvbUVsZW1lbnQuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB1c2VTaGFkb3dSb290KCkge1xuICBjb25zdCBlbCA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyB1c2VIb3N0KFwidXNlU2hhZG93Um9vdFwiKSA6IHVzZUhvc3QoKTtcbiAgcmV0dXJuIGVsICYmIGVsLnNoYWRvd1Jvb3Q7XG59XG5cbmZ1bmN0aW9uIHVzZUNzc01vZHVsZShuYW1lID0gXCIkc3R5bGVcIikge1xuICB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYHVzZUNzc01vZHVsZSBtdXN0IGJlIGNhbGxlZCBpbnNpZGUgc2V0dXAoKWApO1xuICAgICAgcmV0dXJuIEVNUFRZX09CSjtcbiAgICB9XG4gICAgY29uc3QgbW9kdWxlcyA9IGluc3RhbmNlLnR5cGUuX19jc3NNb2R1bGVzO1xuICAgIGlmICghbW9kdWxlcykge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGBDdXJyZW50IGluc3RhbmNlIGRvZXMgbm90IGhhdmUgQ1NTIG1vZHVsZXMgaW5qZWN0ZWQuYCk7XG4gICAgICByZXR1cm4gRU1QVFlfT0JKO1xuICAgIH1cbiAgICBjb25zdCBtb2QgPSBtb2R1bGVzW25hbWVdO1xuICAgIGlmICghbW9kKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYEN1cnJlbnQgaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBDU1MgbW9kdWxlIG5hbWVkIFwiJHtuYW1lfVwiLmApO1xuICAgICAgcmV0dXJuIEVNUFRZX09CSjtcbiAgICB9XG4gICAgcmV0dXJuIG1vZDtcbiAgfVxufVxuXG5jb25zdCBwb3NpdGlvbk1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgbmV3UG9zaXRpb25NYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IG1vdmVDYktleSA9IFN5bWJvbChcIl9tb3ZlQ2JcIik7XG5jb25zdCBlbnRlckNiS2V5ID0gU3ltYm9sKFwiX2VudGVyQ2JcIik7XG5jb25zdCBkZWNvcmF0ZSA9ICh0KSA9PiB7XG4gIGRlbGV0ZSB0LnByb3BzLm1vZGU7XG4gIHJldHVybiB0O1xufTtcbmNvbnN0IFRyYW5zaXRpb25Hcm91cEltcGwgPSAvKiBAX19QVVJFX18gKi8gZGVjb3JhdGUoe1xuICBuYW1lOiBcIlRyYW5zaXRpb25Hcm91cFwiLFxuICBwcm9wczogLyogQF9fUFVSRV9fICovIGV4dGVuZCh7fSwgVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycywge1xuICAgIHRhZzogU3RyaW5nLFxuICAgIG1vdmVDbGFzczogU3RyaW5nXG4gIH0pLFxuICBzZXR1cChwcm9wcywgeyBzbG90cyB9KSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICBjb25zdCBzdGF0ZSA9IHVzZVRyYW5zaXRpb25TdGF0ZSgpO1xuICAgIGxldCBwcmV2Q2hpbGRyZW47XG4gICAgbGV0IGNoaWxkcmVuO1xuICAgIG9uVXBkYXRlZCgoKSA9PiB7XG4gICAgICBpZiAoIXByZXZDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbW92ZUNsYXNzID0gcHJvcHMubW92ZUNsYXNzIHx8IGAke3Byb3BzLm5hbWUgfHwgXCJ2XCJ9LW1vdmVgO1xuICAgICAgaWYgKCFoYXNDU1NUcmFuc2Zvcm0oXG4gICAgICAgIHByZXZDaGlsZHJlblswXS5lbCxcbiAgICAgICAgaW5zdGFuY2Uudm5vZGUuZWwsXG4gICAgICAgIG1vdmVDbGFzc1xuICAgICAgKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwcmV2Q2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XG4gICAgICBwcmV2Q2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgICBjb25zdCBtb3ZlZENoaWxkcmVuID0gcHJldkNoaWxkcmVuLmZpbHRlcihhcHBseVRyYW5zbGF0aW9uKTtcbiAgICAgIGZvcmNlUmVmbG93KCk7XG4gICAgICBtb3ZlZENoaWxkcmVuLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgY29uc3QgZWwgPSBjLmVsO1xuICAgICAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IHN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IFwiXCI7XG4gICAgICAgIGNvbnN0IGNiID0gZWxbbW92ZUNiS2V5XSA9IChlKSA9PiB7XG4gICAgICAgICAgaWYgKGUgJiYgZS50YXJnZXQgIT09IGVsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIGNiKTtcbiAgICAgICAgICAgIGVsW21vdmVDYktleV0gPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIiwgY2IpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IHJhd1Byb3BzID0gdG9SYXcocHJvcHMpO1xuICAgICAgY29uc3QgY3NzVHJhbnNpdGlvblByb3BzID0gcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhyYXdQcm9wcyk7XG4gICAgICBsZXQgdGFnID0gcmF3UHJvcHMudGFnIHx8IEZyYWdtZW50O1xuICAgICAgcHJldkNoaWxkcmVuID0gW107XG4gICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgaWYgKGNoaWxkLmVsICYmIGNoaWxkLmVsIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgcHJldkNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKFxuICAgICAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICAgICAgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhcbiAgICAgICAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICAgICAgICBjc3NUcmFuc2l0aW9uUHJvcHMsXG4gICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChcbiAgICAgICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgICAgIGNoaWxkLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0ID8gZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKHNsb3RzLmRlZmF1bHQoKSkgOiBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKGNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKFxuICAgICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgICByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKGNoaWxkLCBjc3NUcmFuc2l0aW9uUHJvcHMsIHN0YXRlLCBpbnN0YW5jZSlcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY2hpbGQudHlwZSAhPT0gVGV4dCkge1xuICAgICAgICAgIHdhcm4oYDxUcmFuc2l0aW9uR3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQuYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0YWcsIG51bGwsIGNoaWxkcmVuKTtcbiAgICB9O1xuICB9XG59KTtcbmNvbnN0IFRyYW5zaXRpb25Hcm91cCA9IFRyYW5zaXRpb25Hcm91cEltcGw7XG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyhjKSB7XG4gIGNvbnN0IGVsID0gYy5lbDtcbiAgaWYgKGVsW21vdmVDYktleV0pIHtcbiAgICBlbFttb3ZlQ2JLZXldKCk7XG4gIH1cbiAgaWYgKGVsW2VudGVyQ2JLZXldKSB7XG4gICAgZWxbZW50ZXJDYktleV0oKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24oYykge1xuICBuZXdQb3NpdGlvbk1hcC5zZXQoYywgYy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG59XG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uKGMpIHtcbiAgY29uc3Qgb2xkUG9zID0gcG9zaXRpb25NYXAuZ2V0KGMpO1xuICBjb25zdCBuZXdQb3MgPSBuZXdQb3NpdGlvbk1hcC5nZXQoYyk7XG4gIGNvbnN0IGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgY29uc3QgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgaWYgKGR4IHx8IGR5KSB7XG4gICAgY29uc3QgcyA9IGMuZWwuc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLndlYmtpdFRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtkeH1weCwke2R5fXB4KWA7XG4gICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSBcIjBzXCI7XG4gICAgcmV0dXJuIGM7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhc0NTU1RyYW5zZm9ybShlbCwgcm9vdCwgbW92ZUNsYXNzKSB7XG4gIGNvbnN0IGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gIGNvbnN0IF92dGMgPSBlbFt2dGNLZXldO1xuICBpZiAoX3Z0Yykge1xuICAgIF92dGMuZm9yRWFjaCgoY2xzKSA9PiB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKChjKSA9PiBjICYmIGNsb25lLmNsYXNzTGlzdC5yZW1vdmUoYykpO1xuICAgIH0pO1xuICB9XG4gIG1vdmVDbGFzcy5zcGxpdCgvXFxzKy8pLmZvckVhY2goKGMpID0+IGMgJiYgY2xvbmUuY2xhc3NMaXN0LmFkZChjKSk7XG4gIGNsb25lLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgY29uc3QgY29udGFpbmVyID0gcm9vdC5ub2RlVHlwZSA9PT0gMSA/IHJvb3QgOiByb290LnBhcmVudE5vZGU7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjbG9uZSk7XG4gIGNvbnN0IHsgaGFzVHJhbnNmb3JtIH0gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XG4gIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjbG9uZSk7XG4gIHJldHVybiBoYXNUcmFuc2Zvcm07XG59XG5cbmNvbnN0IGdldE1vZGVsQXNzaWduZXIgPSAodm5vZGUpID0+IHtcbiAgY29uc3QgZm4gPSB2bm9kZS5wcm9wc1tcIm9uVXBkYXRlOm1vZGVsVmFsdWVcIl0gfHwgZmFsc2U7XG4gIHJldHVybiBpc0FycmF5KGZuKSA/ICh2YWx1ZSkgPT4gaW52b2tlQXJyYXlGbnMoZm4sIHZhbHVlKSA6IGZuO1xufTtcbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kKGUpIHtcbiAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gIGlmICh0YXJnZXQuY29tcG9zaW5nKSB7XG4gICAgdGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImlucHV0XCIpKTtcbiAgfVxufVxuY29uc3QgYXNzaWduS2V5ID0gU3ltYm9sKFwiX2Fzc2lnblwiKTtcbmNvbnN0IHZNb2RlbFRleHQgPSB7XG4gIGNyZWF0ZWQoZWwsIHsgbW9kaWZpZXJzOiB7IGxhenksIHRyaW0sIG51bWJlciB9IH0sIHZub2RlKSB7XG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIGNvbnN0IGNhc3RUb051bWJlciA9IG51bWJlciB8fCB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy50eXBlID09PSBcIm51bWJlclwiO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIGxhenkgPyBcImNoYW5nZVwiIDogXCJpbnB1dFwiLCAoZSkgPT4ge1xuICAgICAgaWYgKGUudGFyZ2V0LmNvbXBvc2luZykgcmV0dXJuO1xuICAgICAgbGV0IGRvbVZhbHVlID0gZWwudmFsdWU7XG4gICAgICBpZiAodHJpbSkge1xuICAgICAgICBkb21WYWx1ZSA9IGRvbVZhbHVlLnRyaW0oKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYXN0VG9OdW1iZXIpIHtcbiAgICAgICAgZG9tVmFsdWUgPSBsb29zZVRvTnVtYmVyKGRvbVZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsW2Fzc2lnbktleV0oZG9tVmFsdWUpO1xuICAgIH0pO1xuICAgIGlmICh0cmltKSB7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICAgIGVsLnZhbHVlID0gZWwudmFsdWUudHJpbSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghbGF6eSkge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjb21wb3NpdGlvbnN0YXJ0XCIsIG9uQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNvbXBvc2l0aW9uZW5kXCIsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjaGFuZ2VcIiwgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgfVxuICB9LFxuICAvLyBzZXQgdmFsdWUgb24gbW91bnRlZCBzbyBpdCdzIGFmdGVyIG1pbi9tYXggZm9yIHR5cGU9XCJyYW5nZVwiXG4gIG1vdW50ZWQoZWwsIHsgdmFsdWUgfSkge1xuICAgIGVsLnZhbHVlID0gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZTtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSwgbW9kaWZpZXJzOiB7IGxhenksIHRyaW0sIG51bWJlciB9IH0sIHZub2RlKSB7XG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIGlmIChlbC5jb21wb3NpbmcpIHJldHVybjtcbiAgICBjb25zdCBlbFZhbHVlID0gKG51bWJlciB8fCBlbC50eXBlID09PSBcIm51bWJlclwiKSAmJiAhL14wXFxkLy50ZXN0KGVsLnZhbHVlKSA/IGxvb3NlVG9OdW1iZXIoZWwudmFsdWUpIDogZWwudmFsdWU7XG4gICAgY29uc3QgbmV3VmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlO1xuICAgIGlmIChlbFZhbHVlID09PSBuZXdWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZWwgJiYgZWwudHlwZSAhPT0gXCJyYW5nZVwiKSB7XG4gICAgICBpZiAobGF6eSAmJiB2YWx1ZSA9PT0gb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRyaW0gJiYgZWwudmFsdWUudHJpbSgpID09PSBuZXdWYWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGVsLnZhbHVlID0gbmV3VmFsdWU7XG4gIH1cbn07XG5jb25zdCB2TW9kZWxDaGVja2JveCA9IHtcbiAgLy8gIzQwOTYgYXJyYXkgY2hlY2tib3hlcyBuZWVkIHRvIGJlIGRlZXAgdHJhdmVyc2VkXG4gIGRlZXA6IHRydWUsXG4gIGNyZWF0ZWQoZWwsIF8sIHZub2RlKSB7XG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IG1vZGVsVmFsdWUgPSBlbC5fbW9kZWxWYWx1ZTtcbiAgICAgIGNvbnN0IGVsZW1lbnRWYWx1ZSA9IGdldFZhbHVlKGVsKTtcbiAgICAgIGNvbnN0IGNoZWNrZWQgPSBlbC5jaGVja2VkO1xuICAgICAgY29uc3QgYXNzaWduID0gZWxbYXNzaWduS2V5XTtcbiAgICAgIGlmIChpc0FycmF5KG1vZGVsVmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbG9vc2VJbmRleE9mKG1vZGVsVmFsdWUsIGVsZW1lbnRWYWx1ZSk7XG4gICAgICAgIGNvbnN0IGZvdW5kID0gaW5kZXggIT09IC0xO1xuICAgICAgICBpZiAoY2hlY2tlZCAmJiAhZm91bmQpIHtcbiAgICAgICAgICBhc3NpZ24obW9kZWxWYWx1ZS5jb25jYXQoZWxlbWVudFZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWNoZWNrZWQgJiYgZm91bmQpIHtcbiAgICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IFsuLi5tb2RlbFZhbHVlXTtcbiAgICAgICAgICBmaWx0ZXJlZC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIGFzc2lnbihmaWx0ZXJlZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNTZXQobW9kZWxWYWx1ZSkpIHtcbiAgICAgICAgY29uc3QgY2xvbmVkID0gbmV3IFNldChtb2RlbFZhbHVlKTtcbiAgICAgICAgaWYgKGNoZWNrZWQpIHtcbiAgICAgICAgICBjbG9uZWQuYWRkKGVsZW1lbnRWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xvbmVkLmRlbGV0ZShlbGVtZW50VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2lnbihjbG9uZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzaWduKGdldENoZWNrYm94VmFsdWUoZWwsIGNoZWNrZWQpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgLy8gc2V0IGluaXRpYWwgY2hlY2tlZCBvbiBtb3VudCB0byB3YWl0IGZvciB0cnVlLXZhbHVlL2ZhbHNlLXZhbHVlXG4gIG1vdW50ZWQ6IHNldENoZWNrZWQsXG4gIGJlZm9yZVVwZGF0ZShlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBlbFthc3NpZ25LZXldID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgc2V0Q2hlY2tlZChlbCwgYmluZGluZywgdm5vZGUpO1xuICB9XG59O1xuZnVuY3Rpb24gc2V0Q2hlY2tlZChlbCwgeyB2YWx1ZSwgb2xkVmFsdWUgfSwgdm5vZGUpIHtcbiAgZWwuX21vZGVsVmFsdWUgPSB2YWx1ZTtcbiAgbGV0IGNoZWNrZWQ7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGNoZWNrZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKSA+IC0xO1xuICB9IGVsc2UgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgIGNoZWNrZWQgPSB2YWx1ZS5oYXModm5vZGUucHJvcHMudmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGlmICh2YWx1ZSA9PT0gb2xkVmFsdWUpIHJldHVybjtcbiAgICBjaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgZ2V0Q2hlY2tib3hWYWx1ZShlbCwgdHJ1ZSkpO1xuICB9XG4gIGlmIChlbC5jaGVja2VkICE9PSBjaGVja2VkKSB7XG4gICAgZWwuY2hlY2tlZCA9IGNoZWNrZWQ7XG4gIH1cbn1cbmNvbnN0IHZNb2RlbFJhZGlvID0ge1xuICBjcmVhdGVkKGVsLCB7IHZhbHVlIH0sIHZub2RlKSB7XG4gICAgZWwuY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKTtcbiAgICBlbFthc3NpZ25LZXldID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgZWxbYXNzaWduS2V5XShnZXRWYWx1ZShlbCkpO1xuICAgIH0pO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHZub2RlKSB7XG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIGlmICh2YWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSk7XG4gICAgfVxuICB9XG59O1xuY29uc3Qgdk1vZGVsU2VsZWN0ID0ge1xuICAvLyA8c2VsZWN0IG11bHRpcGxlPiB2YWx1ZSBuZWVkIHRvIGJlIGRlZXAgdHJhdmVyc2VkXG4gIGRlZXA6IHRydWUsXG4gIGNyZWF0ZWQoZWwsIHsgdmFsdWUsIG1vZGlmaWVyczogeyBudW1iZXIgfSB9LCB2bm9kZSkge1xuICAgIGNvbnN0IGlzU2V0TW9kZWwgPSBpc1NldCh2YWx1ZSk7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0ZWRWYWwgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoZWwub3B0aW9ucywgKG8pID0+IG8uc2VsZWN0ZWQpLm1hcChcbiAgICAgICAgKG8pID0+IG51bWJlciA/IGxvb3NlVG9OdW1iZXIoZ2V0VmFsdWUobykpIDogZ2V0VmFsdWUobylcbiAgICAgICk7XG4gICAgICBlbFthc3NpZ25LZXldKFxuICAgICAgICBlbC5tdWx0aXBsZSA/IGlzU2V0TW9kZWwgPyBuZXcgU2V0KHNlbGVjdGVkVmFsKSA6IHNlbGVjdGVkVmFsIDogc2VsZWN0ZWRWYWxbMF1cbiAgICAgICk7XG4gICAgICBlbC5fYXNzaWduaW5nID0gdHJ1ZTtcbiAgICAgIG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgZWwuX2Fzc2lnbmluZyA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICB9LFxuICAvLyBzZXQgdmFsdWUgaW4gbW91bnRlZCAmIHVwZGF0ZWQgYmVjYXVzZSA8c2VsZWN0PiByZWxpZXMgb24gaXRzIGNoaWxkcmVuXG4gIC8vIDxvcHRpb24+cy5cbiAgbW91bnRlZChlbCwgeyB2YWx1ZSB9KSB7XG4gICAgc2V0U2VsZWN0ZWQoZWwsIHZhbHVlKTtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGVsLCBfYmluZGluZywgdm5vZGUpIHtcbiAgICBlbFthc3NpZ25LZXldID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gIH0sXG4gIHVwZGF0ZWQoZWwsIHsgdmFsdWUgfSkge1xuICAgIGlmICghZWwuX2Fzc2lnbmluZykge1xuICAgICAgc2V0U2VsZWN0ZWQoZWwsIHZhbHVlKTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBzZXRTZWxlY3RlZChlbCwgdmFsdWUpIHtcbiAgY29uc3QgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBjb25zdCBpc0FycmF5VmFsdWUgPSBpc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlzTXVsdGlwbGUgJiYgIWlzQXJyYXlWYWx1ZSAmJiAhaXNTZXQodmFsdWUpKSB7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKFxuICAgICAgYDxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD4gZXhwZWN0cyBhbiBBcnJheSBvciBTZXQgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290ICR7T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSl9LmBcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKGxldCBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3Qgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICBjb25zdCBvcHRpb25WYWx1ZSA9IGdldFZhbHVlKG9wdGlvbik7XG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgIGlmIChpc0FycmF5VmFsdWUpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uVHlwZSA9IHR5cGVvZiBvcHRpb25WYWx1ZTtcbiAgICAgICAgaWYgKG9wdGlvblR5cGUgPT09IFwic3RyaW5nXCIgfHwgb3B0aW9uVHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlLnNvbWUoKHYpID0+IFN0cmluZyh2KSA9PT0gU3RyaW5nKG9wdGlvblZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBvcHRpb25WYWx1ZSkgPiAtMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdmFsdWUuaGFzKG9wdGlvblZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGlmICghaXNNdWx0aXBsZSAmJiBlbC5zZWxlY3RlZEluZGV4ICE9PSAtMSkge1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VmFsdWUoZWwpIHtcbiAgcmV0dXJuIFwiX3ZhbHVlXCIgaW4gZWwgPyBlbC5fdmFsdWUgOiBlbC52YWx1ZTtcbn1cbmZ1bmN0aW9uIGdldENoZWNrYm94VmFsdWUoZWwsIGNoZWNrZWQpIHtcbiAgY29uc3Qga2V5ID0gY2hlY2tlZCA/IFwiX3RydWVWYWx1ZVwiIDogXCJfZmFsc2VWYWx1ZVwiO1xuICByZXR1cm4ga2V5IGluIGVsID8gZWxba2V5XSA6IGNoZWNrZWQ7XG59XG5jb25zdCB2TW9kZWxEeW5hbWljID0ge1xuICBjcmVhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBudWxsLCBcImNyZWF0ZWRcIik7XG4gIH0sXG4gIG1vdW50ZWQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIG51bGwsIFwibW91bnRlZFwiKTtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKSB7XG4gICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgXCJiZWZvcmVVcGRhdGVcIik7XG4gIH0sXG4gIHVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUpIHtcbiAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCBcInVwZGF0ZWRcIik7XG4gIH1cbn07XG5mdW5jdGlvbiByZXNvbHZlRHluYW1pY01vZGVsKHRhZ05hbWUsIHR5cGUpIHtcbiAgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgY2FzZSBcIlNFTEVDVFwiOlxuICAgICAgcmV0dXJuIHZNb2RlbFNlbGVjdDtcbiAgICBjYXNlIFwiVEVYVEFSRUFcIjpcbiAgICAgIHJldHVybiB2TW9kZWxUZXh0O1xuICAgIGRlZmF1bHQ6XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImNoZWNrYm94XCI6XG4gICAgICAgICAgcmV0dXJuIHZNb2RlbENoZWNrYm94O1xuICAgICAgICBjYXNlIFwicmFkaW9cIjpcbiAgICAgICAgICByZXR1cm4gdk1vZGVsUmFkaW87XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHZNb2RlbFRleHQ7XG4gICAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUsIGhvb2spIHtcbiAgY29uc3QgbW9kZWxUb1VzZSA9IHJlc29sdmVEeW5hbWljTW9kZWwoXG4gICAgZWwudGFnTmFtZSxcbiAgICB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy50eXBlXG4gICk7XG4gIGNvbnN0IGZuID0gbW9kZWxUb1VzZVtob29rXTtcbiAgZm4gJiYgZm4oZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUpO1xufVxuZnVuY3Rpb24gaW5pdFZNb2RlbEZvclNTUigpIHtcbiAgdk1vZGVsVGV4dC5nZXRTU1JQcm9wcyA9ICh7IHZhbHVlIH0pID0+ICh7IHZhbHVlIH0pO1xuICB2TW9kZWxSYWRpby5nZXRTU1JQcm9wcyA9ICh7IHZhbHVlIH0sIHZub2RlKSA9PiB7XG4gICAgaWYgKHZub2RlLnByb3BzICYmIGxvb3NlRXF1YWwodm5vZGUucHJvcHMudmFsdWUsIHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xuICAgIH1cbiAgfTtcbiAgdk1vZGVsQ2hlY2tib3guZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9LCB2bm9kZSkgPT4ge1xuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgaWYgKHZub2RlLnByb3BzICYmIGxvb3NlSW5kZXhPZih2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgICBpZiAodm5vZGUucHJvcHMgJiYgdmFsdWUuaGFzKHZub2RlLnByb3BzLnZhbHVlKSkge1xuICAgICAgICByZXR1cm4geyBjaGVja2VkOiB0cnVlIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xuICAgIH1cbiAgfTtcbiAgdk1vZGVsRHluYW1pYy5nZXRTU1JQcm9wcyA9IChiaW5kaW5nLCB2bm9kZSkgPT4ge1xuICAgIGlmICh0eXBlb2Ygdm5vZGUudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtb2RlbFRvVXNlID0gcmVzb2x2ZUR5bmFtaWNNb2RlbChcbiAgICAgIC8vIHJlc29sdmVEeW5hbWljTW9kZWwgZXhwZWN0cyBhbiB1cHBlcmNhc2UgdGFnIG5hbWUsIGJ1dCB2bm9kZS50eXBlIGlzIGxvd2VyY2FzZVxuICAgICAgdm5vZGUudHlwZS50b1VwcGVyQ2FzZSgpLFxuICAgICAgdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudHlwZVxuICAgICk7XG4gICAgaWYgKG1vZGVsVG9Vc2UuZ2V0U1NSUHJvcHMpIHtcbiAgICAgIHJldHVybiBtb2RlbFRvVXNlLmdldFNTUlByb3BzKGJpbmRpbmcsIHZub2RlKTtcbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IHN5c3RlbU1vZGlmaWVycyA9IFtcImN0cmxcIiwgXCJzaGlmdFwiLCBcImFsdFwiLCBcIm1ldGFcIl07XG5jb25zdCBtb2RpZmllckd1YXJkcyA9IHtcbiAgc3RvcDogKGUpID0+IGUuc3RvcFByb3BhZ2F0aW9uKCksXG4gIHByZXZlbnQ6IChlKSA9PiBlLnByZXZlbnREZWZhdWx0KCksXG4gIHNlbGY6IChlKSA9PiBlLnRhcmdldCAhPT0gZS5jdXJyZW50VGFyZ2V0LFxuICBjdHJsOiAoZSkgPT4gIWUuY3RybEtleSxcbiAgc2hpZnQ6IChlKSA9PiAhZS5zaGlmdEtleSxcbiAgYWx0OiAoZSkgPT4gIWUuYWx0S2V5LFxuICBtZXRhOiAoZSkgPT4gIWUubWV0YUtleSxcbiAgbGVmdDogKGUpID0+IFwiYnV0dG9uXCIgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMCxcbiAgbWlkZGxlOiAoZSkgPT4gXCJidXR0b25cIiBpbiBlICYmIGUuYnV0dG9uICE9PSAxLFxuICByaWdodDogKGUpID0+IFwiYnV0dG9uXCIgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMixcbiAgZXhhY3Q6IChlLCBtb2RpZmllcnMpID0+IHN5c3RlbU1vZGlmaWVycy5zb21lKChtKSA9PiBlW2Ake219S2V5YF0gJiYgIW1vZGlmaWVycy5pbmNsdWRlcyhtKSlcbn07XG5jb25zdCB3aXRoTW9kaWZpZXJzID0gKGZuLCBtb2RpZmllcnMpID0+IHtcbiAgY29uc3QgY2FjaGUgPSBmbi5fd2l0aE1vZHMgfHwgKGZuLl93aXRoTW9kcyA9IHt9KTtcbiAgY29uc3QgY2FjaGVLZXkgPSBtb2RpZmllcnMuam9pbihcIi5cIik7XG4gIHJldHVybiBjYWNoZVtjYWNoZUtleV0gfHwgKGNhY2hlW2NhY2hlS2V5XSA9IChldmVudCwgLi4uYXJncykgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kaWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBndWFyZCA9IG1vZGlmaWVyR3VhcmRzW21vZGlmaWVyc1tpXV07XG4gICAgICBpZiAoZ3VhcmQgJiYgZ3VhcmQoZXZlbnQsIG1vZGlmaWVycykpIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGZuKGV2ZW50LCAuLi5hcmdzKTtcbiAgfSk7XG59O1xuY29uc3Qga2V5TmFtZXMgPSB7XG4gIGVzYzogXCJlc2NhcGVcIixcbiAgc3BhY2U6IFwiIFwiLFxuICB1cDogXCJhcnJvdy11cFwiLFxuICBsZWZ0OiBcImFycm93LWxlZnRcIixcbiAgcmlnaHQ6IFwiYXJyb3ctcmlnaHRcIixcbiAgZG93bjogXCJhcnJvdy1kb3duXCIsXG4gIGRlbGV0ZTogXCJiYWNrc3BhY2VcIlxufTtcbmNvbnN0IHdpdGhLZXlzID0gKGZuLCBtb2RpZmllcnMpID0+IHtcbiAgY29uc3QgY2FjaGUgPSBmbi5fd2l0aEtleXMgfHwgKGZuLl93aXRoS2V5cyA9IHt9KTtcbiAgY29uc3QgY2FjaGVLZXkgPSBtb2RpZmllcnMuam9pbihcIi5cIik7XG4gIHJldHVybiBjYWNoZVtjYWNoZUtleV0gfHwgKGNhY2hlW2NhY2hlS2V5XSA9IChldmVudCkgPT4ge1xuICAgIGlmICghKFwia2V5XCIgaW4gZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50S2V5ID0gaHlwaGVuYXRlKGV2ZW50LmtleSk7XG4gICAgaWYgKG1vZGlmaWVycy5zb21lKFxuICAgICAgKGspID0+IGsgPT09IGV2ZW50S2V5IHx8IGtleU5hbWVzW2tdID09PSBldmVudEtleVxuICAgICkpIHtcbiAgICAgIHJldHVybiBmbihldmVudCk7XG4gICAgfVxuICB9KTtcbn07XG5cbmNvbnN0IHJlbmRlcmVyT3B0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBleHRlbmQoeyBwYXRjaFByb3AgfSwgbm9kZU9wcyk7XG5sZXQgcmVuZGVyZXI7XG5sZXQgZW5hYmxlZEh5ZHJhdGlvbiA9IGZhbHNlO1xuZnVuY3Rpb24gZW5zdXJlUmVuZGVyZXIoKSB7XG4gIHJldHVybiByZW5kZXJlciB8fCAocmVuZGVyZXIgPSBjcmVhdGVSZW5kZXJlcihyZW5kZXJlck9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkge1xuICByZW5kZXJlciA9IGVuYWJsZWRIeWRyYXRpb24gPyByZW5kZXJlciA6IGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyKHJlbmRlcmVyT3B0aW9ucyk7XG4gIGVuYWJsZWRIeWRyYXRpb24gPSB0cnVlO1xuICByZXR1cm4gcmVuZGVyZXI7XG59XG5jb25zdCByZW5kZXIgPSAoLi4uYXJncykgPT4ge1xuICBlbnN1cmVSZW5kZXJlcigpLnJlbmRlciguLi5hcmdzKTtcbn07XG5jb25zdCBoeWRyYXRlID0gKC4uLmFyZ3MpID0+IHtcbiAgZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIoKS5oeWRyYXRlKC4uLmFyZ3MpO1xufTtcbmNvbnN0IGNyZWF0ZUFwcCA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IGFwcCA9IGVuc3VyZVJlbmRlcmVyKCkuY3JlYXRlQXBwKC4uLmFyZ3MpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCk7XG4gICAgaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKTtcbiAgfVxuICBjb25zdCB7IG1vdW50IH0gPSBhcHA7XG4gIGFwcC5tb3VudCA9IChjb250YWluZXJPclNlbGVjdG9yKSA9PiB7XG4gICAgY29uc3QgY29udGFpbmVyID0gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lck9yU2VsZWN0b3IpO1xuICAgIGlmICghY29udGFpbmVyKSByZXR1cm47XG4gICAgY29uc3QgY29tcG9uZW50ID0gYXBwLl9jb21wb25lbnQ7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKGNvbXBvbmVudCkgJiYgIWNvbXBvbmVudC5yZW5kZXIgJiYgIWNvbXBvbmVudC50ZW1wbGF0ZSkge1xuICAgICAgY29tcG9uZW50LnRlbXBsYXRlID0gY29udGFpbmVyLmlubmVySFRNTDtcbiAgICB9XG4gICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgY29udGFpbmVyLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICB9XG4gICAgY29uc3QgcHJveHkgPSBtb3VudChjb250YWluZXIsIGZhbHNlLCByZXNvbHZlUm9vdE5hbWVzcGFjZShjb250YWluZXIpKTtcbiAgICBpZiAoY29udGFpbmVyIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgY29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZShcInYtY2xvYWtcIik7XG4gICAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwiZGF0YS12LWFwcFwiLCBcIlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3h5O1xuICB9O1xuICByZXR1cm4gYXBwO1xufTtcbmNvbnN0IGNyZWF0ZVNTUkFwcCA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IGFwcCA9IGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkuY3JlYXRlQXBwKC4uLmFyZ3MpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCk7XG4gICAgaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKTtcbiAgfVxuICBjb25zdCB7IG1vdW50IH0gPSBhcHA7XG4gIGFwcC5tb3VudCA9IChjb250YWluZXJPclNlbGVjdG9yKSA9PiB7XG4gICAgY29uc3QgY29udGFpbmVyID0gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lck9yU2VsZWN0b3IpO1xuICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgIHJldHVybiBtb3VudChjb250YWluZXIsIHRydWUsIHJlc29sdmVSb290TmFtZXNwYWNlKGNvbnRhaW5lcikpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGFwcDtcbn07XG5mdW5jdGlvbiByZXNvbHZlUm9vdE5hbWVzcGFjZShjb250YWluZXIpIHtcbiAgaWYgKGNvbnRhaW5lciBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpIHtcbiAgICByZXR1cm4gXCJzdmdcIjtcbiAgfVxuICBpZiAodHlwZW9mIE1hdGhNTEVsZW1lbnQgPT09IFwiZnVuY3Rpb25cIiAmJiBjb250YWluZXIgaW5zdGFuY2VvZiBNYXRoTUxFbGVtZW50KSB7XG4gICAgcmV0dXJuIFwibWF0aG1sXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZywgXCJpc05hdGl2ZVRhZ1wiLCB7XG4gICAgdmFsdWU6ICh0YWcpID0+IGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHVGFnKHRhZykgfHwgaXNNYXRoTUxUYWcodGFnKSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG59XG5mdW5jdGlvbiBpbmplY3RDb21waWxlck9wdGlvbnNDaGVjayhhcHApIHtcbiAgaWYgKGlzUnVudGltZU9ubHkoKSkge1xuICAgIGNvbnN0IGlzQ3VzdG9tRWxlbWVudCA9IGFwcC5jb25maWcuaXNDdXN0b21FbGVtZW50O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLCBcImlzQ3VzdG9tRWxlbWVudFwiLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBpc0N1c3RvbUVsZW1lbnQ7XG4gICAgICB9LFxuICAgICAgc2V0KCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBUaGUgXFxgaXNDdXN0b21FbGVtZW50XFxgIGNvbmZpZyBvcHRpb24gaXMgZGVwcmVjYXRlZC4gVXNlIFxcYGNvbXBpbGVyT3B0aW9ucy5pc0N1c3RvbUVsZW1lbnRcXGAgaW5zdGVhZC5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgY29tcGlsZXJPcHRpb25zID0gYXBwLmNvbmZpZy5jb21waWxlck9wdGlvbnM7XG4gICAgY29uc3QgbXNnID0gYFRoZSBcXGBjb21waWxlck9wdGlvbnNcXGAgY29uZmlnIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIGEgYnVpbGQgb2YgVnVlLmpzIHRoYXQgaW5jbHVkZXMgdGhlIHJ1bnRpbWUgY29tcGlsZXIgKGFrYSBcImZ1bGwgYnVpbGRcIikuIFNpbmNlIHlvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCwgXFxgY29tcGlsZXJPcHRpb25zXFxgIG11c3QgYmUgcGFzc2VkIHRvIFxcYEB2dWUvY29tcGlsZXItZG9tXFxgIGluIHRoZSBidWlsZCBzZXR1cCBpbnN0ZWFkLlxuLSBGb3IgdnVlLWxvYWRlcjogcGFzcyBpdCB2aWEgdnVlLWxvYWRlcidzIFxcYGNvbXBpbGVyT3B0aW9uc1xcYCBsb2FkZXIgb3B0aW9uLlxuLSBGb3IgdnVlLWNsaTogc2VlIGh0dHBzOi8vY2xpLnZ1ZWpzLm9yZy9ndWlkZS93ZWJwYWNrLmh0bWwjbW9kaWZ5aW5nLW9wdGlvbnMtb2YtYS1sb2FkZXJcbi0gRm9yIHZpdGU6IHBhc3MgaXQgdmlhIEB2aXRlanMvcGx1Z2luLXZ1ZSBvcHRpb25zLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZpdGVqcy92aXRlLXBsdWdpbi12dWUvdHJlZS9tYWluL3BhY2thZ2VzL3BsdWdpbi12dWUjZXhhbXBsZS1mb3ItcGFzc2luZy1vcHRpb25zLXRvLXZ1ZWNvbXBpbGVyLXNmY2A7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsIFwiY29tcGlsZXJPcHRpb25zXCIsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICByZXR1cm4gY29tcGlsZXJPcHRpb25zO1xuICAgICAgfSxcbiAgICAgIHNldCgpIHtcbiAgICAgICAgd2Fybihtc2cpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVDb250YWluZXIoY29udGFpbmVyKSB7XG4gIGlmIChpc1N0cmluZyhjb250YWluZXIpKSB7XG4gICAgY29uc3QgcmVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihjb250YWluZXIpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFyZXMpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBGYWlsZWQgdG8gbW91bnQgYXBwOiBtb3VudCB0YXJnZXQgc2VsZWN0b3IgXCIke2NvbnRhaW5lcn1cIiByZXR1cm5lZCBudWxsLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2luZG93LlNoYWRvd1Jvb3QgJiYgY29udGFpbmVyIGluc3RhbmNlb2Ygd2luZG93LlNoYWRvd1Jvb3QgJiYgY29udGFpbmVyLm1vZGUgPT09IFwiY2xvc2VkXCIpIHtcbiAgICB3YXJuKFxuICAgICAgYG1vdW50aW5nIG9uIGEgU2hhZG93Um9vdCB3aXRoIFxcYHttb2RlOiBcImNsb3NlZFwifVxcYCBtYXkgbGVhZCB0byB1bnByZWRpY3RhYmxlIGJ1Z3NgXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY29udGFpbmVyO1xufVxubGV0IHNzckRpcmVjdGl2ZUluaXRpYWxpemVkID0gZmFsc2U7XG5jb25zdCBpbml0RGlyZWN0aXZlc0ZvclNTUiA9ICgpID0+IHtcbiAgaWYgKCFzc3JEaXJlY3RpdmVJbml0aWFsaXplZCkge1xuICAgIHNzckRpcmVjdGl2ZUluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICBpbml0Vk1vZGVsRm9yU1NSKCk7XG4gICAgaW5pdFZTaG93Rm9yU1NSKCk7XG4gIH1cbn0gO1xuXG5leHBvcnQgeyBUcmFuc2l0aW9uLCBUcmFuc2l0aW9uR3JvdXAsIFZ1ZUVsZW1lbnQsIGNyZWF0ZUFwcCwgY3JlYXRlU1NSQXBwLCBkZWZpbmVDdXN0b21FbGVtZW50LCBkZWZpbmVTU1JDdXN0b21FbGVtZW50LCBoeWRyYXRlLCBpbml0RGlyZWN0aXZlc0ZvclNTUiwgcmVuZGVyLCB1c2VDc3NNb2R1bGUsIHVzZUNzc1ZhcnMsIHVzZUhvc3QsIHVzZVNoYWRvd1Jvb3QsIHZNb2RlbENoZWNrYm94LCB2TW9kZWxEeW5hbWljLCB2TW9kZWxSYWRpbywgdk1vZGVsU2VsZWN0LCB2TW9kZWxUZXh0LCB2U2hvdywgd2l0aEtleXMsIHdpdGhNb2RpZmllcnMgfTtcbiIsIi8qKlxuKiB2dWUgdjMuNS4xM1xuKiAoYykgMjAxOC1wcmVzZW50IFl1eGkgKEV2YW4pIFlvdSBhbmQgVnVlIGNvbnRyaWJ1dG9yc1xuKiBAbGljZW5zZSBNSVRcbioqL1xuaW1wb3J0IHsgaW5pdEN1c3RvbUZvcm1hdHRlciwgd2FybiB9IGZyb20gJ0B2dWUvcnVudGltZS1kb20nO1xuZXhwb3J0ICogZnJvbSAnQHZ1ZS9ydW50aW1lLWRvbSc7XG5cbmZ1bmN0aW9uIGluaXREZXYoKSB7XG4gIHtcbiAgICBpbml0Q3VzdG9tRm9ybWF0dGVyKCk7XG4gIH1cbn1cblxuaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgaW5pdERldigpO1xufVxuY29uc3QgY29tcGlsZSA9ICgpID0+IHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuKFxuICAgICAgYFJ1bnRpbWUgY29tcGlsYXRpb24gaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJ1aWxkIG9mIFZ1ZS5gICsgKGAgQ29uZmlndXJlIHlvdXIgYnVuZGxlciB0byBhbGlhcyBcInZ1ZVwiIHRvIFwidnVlL2Rpc3QvdnVlLmVzbS1idW5kbGVyLmpzXCIuYCApXG4gICAgKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgY29tcGlsZSB9O1xuIiwiZnVuY3Rpb24gYXQoYXJyLCBpbmRpY2VzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KGluZGljZXMubGVuZ3RoKTtcbiAgICBjb25zdCBsZW5ndGggPSBhcnIubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgaW5kZXggPSBpbmRpY2VzW2ldO1xuICAgICAgICBpbmRleCA9IE51bWJlci5pc0ludGVnZXIoaW5kZXgpID8gaW5kZXggOiBNYXRoLnRydW5jKGluZGV4KSB8fCAwO1xuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICBpbmRleCArPSBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2ldID0gYXJyW2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IHsgYXQgfTtcbiIsImZ1bmN0aW9uIGNodW5rKGFyciwgc2l6ZSkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihzaXplKSB8fCBzaXplIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaXplIG11c3QgYmUgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gemVyby4nKTtcbiAgICB9XG4gICAgY29uc3QgY2h1bmtMZW5ndGggPSBNYXRoLmNlaWwoYXJyLmxlbmd0aCAvIHNpemUpO1xuICAgIGNvbnN0IHJlc3VsdCA9IEFycmF5KGNodW5rTGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgY2h1bmtMZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBpbmRleCAqIHNpemU7XG4gICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgc2l6ZTtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGFyci5zbGljZShzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IHsgY2h1bmsgfTtcbiIsImZ1bmN0aW9uIGNvbXBhY3QoYXJyKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGFycltpXTtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCB7IGNvbXBhY3QgfTtcbiIsImZ1bmN0aW9uIGNvdW50QnkoYXJyLCBtYXBwZXIpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBpdGVtID0gYXJyW2ldO1xuICAgICAgICBjb25zdCBrZXkgPSBtYXBwZXIoaXRlbSk7XG4gICAgICAgIHJlc3VsdFtrZXldID0gKHJlc3VsdFtrZXldID8/IDApICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IHsgY291bnRCeSB9O1xuIiwiZnVuY3Rpb24gZGlmZmVyZW5jZShmaXJzdEFyciwgc2Vjb25kQXJyKSB7XG4gICAgY29uc3Qgc2Vjb25kU2V0ID0gbmV3IFNldChzZWNvbmRBcnIpO1xuICAgIHJldHVybiBmaXJzdEFyci5maWx0ZXIoaXRlbSA9PiAhc2Vjb25kU2V0LmhhcyhpdGVtKSk7XG59XG5cbmV4cG9ydCB7IGRpZmZlcmVuY2UgfTtcbiIsImZ1bmN0aW9uIGRpZmZlcmVuY2VCeShmaXJzdEFyciwgc2Vjb25kQXJyLCBtYXBwZXIpIHtcbiAgICBjb25zdCBtYXBwZWRTZWNvbmRTZXQgPSBuZXcgU2V0KHNlY29uZEFyci5tYXAoaXRlbSA9PiBtYXBwZXIoaXRlbSkpKTtcbiAgICByZXR1cm4gZmlyc3RBcnIuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgICByZXR1cm4gIW1hcHBlZFNlY29uZFNldC5oYXMobWFwcGVyKGl0ZW0pKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgZGlmZmVyZW5jZUJ5IH07XG4iLCJmdW5jdGlvbiBkaWZmZXJlbmNlV2l0aChmaXJzdEFyciwgc2Vjb25kQXJyLCBhcmVJdGVtc0VxdWFsKSB7XG4gICAgcmV0dXJuIGZpcnN0QXJyLmZpbHRlcihmaXJzdEl0ZW0gPT4ge1xuICAgICAgICByZXR1cm4gc2Vjb25kQXJyLmV2ZXJ5KHNlY29uZEl0ZW0gPT4ge1xuICAgICAgICAgICAgcmV0dXJuICFhcmVJdGVtc0VxdWFsKGZpcnN0SXRlbSwgc2Vjb25kSXRlbSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5leHBvcnQgeyBkaWZmZXJlbmNlV2l0aCB9O1xuIiwiZnVuY3Rpb24gZHJvcChhcnIsIGl0ZW1zQ291bnQpIHtcbiAgICBpdGVtc0NvdW50ID0gTWF0aC5tYXgoaXRlbXNDb3VudCwgMCk7XG4gICAgcmV0dXJuIGFyci5zbGljZShpdGVtc0NvdW50KTtcbn1cblxuZXhwb3J0IHsgZHJvcCB9O1xuIiwiZnVuY3Rpb24gZHJvcFJpZ2h0KGFyciwgaXRlbXNDb3VudCkge1xuICAgIGl0ZW1zQ291bnQgPSBNYXRoLm1pbigtaXRlbXNDb3VudCwgMCk7XG4gICAgaWYgKGl0ZW1zQ291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGFyci5zbGljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyLnNsaWNlKDAsIGl0ZW1zQ291bnQpO1xufVxuXG5leHBvcnQgeyBkcm9wUmlnaHQgfTtcbiIsImZ1bmN0aW9uIGRyb3BSaWdodFdoaWxlKGFyciwgY2FuQ29udGludWVEcm9wcGluZykge1xuICAgIGZvciAobGV0IGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKCFjYW5Db250aW51ZURyb3BwaW5nKGFycltpXSwgaSwgYXJyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5zbGljZSgwLCBpICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuXG5leHBvcnQgeyBkcm9wUmlnaHRXaGlsZSB9O1xuIiwiZnVuY3Rpb24gZHJvcFdoaWxlKGFyciwgY2FuQ29udGludWVEcm9wcGluZykge1xuICAgIGNvbnN0IGRyb3BFbmRJbmRleCA9IGFyci5maW5kSW5kZXgoKGl0ZW0sIGluZGV4LCBhcnIpID0+ICFjYW5Db250aW51ZURyb3BwaW5nKGl0ZW0sIGluZGV4LCBhcnIpKTtcbiAgICBpZiAoZHJvcEVuZEluZGV4ID09PSAtMSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBhcnIuc2xpY2UoZHJvcEVuZEluZGV4KTtcbn1cblxuZXhwb3J0IHsgZHJvcFdoaWxlIH07XG4iLCJmdW5jdGlvbiBmaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQgPSAwLCBlbmQgPSBhcnJheS5sZW5ndGgpIHtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgY29uc3QgZmluYWxTdGFydCA9IE1hdGgubWF4KHN0YXJ0ID49IDAgPyBzdGFydCA6IGxlbmd0aCArIHN0YXJ0LCAwKTtcbiAgICBjb25zdCBmaW5hbEVuZCA9IE1hdGgubWluKGVuZCA+PSAwID8gZW5kIDogbGVuZ3RoICsgZW5kLCBsZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSBmaW5hbFN0YXJ0OyBpIDwgZmluYWxFbmQ7IGkrKykge1xuICAgICAgICBhcnJheVtpXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCB7IGZpbGwgfTtcbiIsImZ1bmN0aW9uIGZsYXR0ZW4oYXJyLCBkZXB0aCA9IDEpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBmbG9vcmVkRGVwdGggPSBNYXRoLmZsb29yKGRlcHRoKTtcbiAgICBjb25zdCByZWN1cnNpdmUgPSAoYXJyLCBjdXJyZW50RGVwdGgpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBhcnJbaV07XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSAmJiBjdXJyZW50RGVwdGggPCBmbG9vcmVkRGVwdGgpIHtcbiAgICAgICAgICAgICAgICByZWN1cnNpdmUoaXRlbSwgY3VycmVudERlcHRoICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmVjdXJzaXZlKGFyciwgMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IHsgZmxhdHRlbiB9O1xuIiwiaW1wb3J0IHsgZmxhdHRlbiB9IGZyb20gJy4vZmxhdHRlbi5tanMnO1xuXG5mdW5jdGlvbiBmbGF0TWFwKGFyciwgaXRlcmF0ZWUsIGRlcHRoID0gMSkge1xuICAgIHJldHVybiBmbGF0dGVuKGFyci5tYXAoaXRlbSA9PiBpdGVyYXRlZShpdGVtKSksIGRlcHRoKTtcbn1cblxuZXhwb3J0IHsgZmxhdE1hcCB9O1xuIiwiaW1wb3J0IHsgZmxhdHRlbiB9IGZyb20gJy4vZmxhdHRlbi5tanMnO1xuXG5mdW5jdGlvbiBmbGF0dGVuRGVlcChhcnIpIHtcbiAgICByZXR1cm4gZmxhdHRlbihhcnIsIEluZmluaXR5KTtcbn1cblxuZXhwb3J0IHsgZmxhdHRlbkRlZXAgfTtcbiIsImltcG9ydCB7IGZsYXR0ZW5EZWVwIH0gZnJvbSAnLi9mbGF0dGVuRGVlcC5tanMnO1xuXG5mdW5jdGlvbiBmbGF0TWFwRGVlcChhcnIsIGl0ZXJhdGVlKSB7XG4gICAgcmV0dXJuIGZsYXR0ZW5EZWVwKGFyci5tYXAoKGl0ZW0pID0+IGl0ZXJhdGVlKGl0ZW0pKSk7XG59XG5cbmV4cG9ydCB7IGZsYXRNYXBEZWVwIH07XG4iLCJmdW5jdGlvbiBmb3JFYWNoUmlnaHQoYXJyLCBjYWxsYmFjaykge1xuICAgIGZvciAobGV0IGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGFycltpXTtcbiAgICAgICAgY2FsbGJhY2soZWxlbWVudCwgaSwgYXJyKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGZvckVhY2hSaWdodCB9O1xuIiwiZnVuY3Rpb24gZ3JvdXBCeShhcnIsIGdldEtleUZyb21JdGVtKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGFycltpXTtcbiAgICAgICAgY29uc3Qga2V5ID0gZ2V0S2V5RnJvbUl0ZW0oaXRlbSk7XG4gICAgICAgIGlmICghT2JqZWN0Lmhhc093bihyZXN1bHQsIGtleSkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2tleV0ucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IHsgZ3JvdXBCeSB9O1xuIiwiZnVuY3Rpb24gaGVhZChhcnIpIHtcbiAgICByZXR1cm4gYXJyWzBdO1xufVxuXG5leHBvcnQgeyBoZWFkIH07XG4iLCJmdW5jdGlvbiBpbml0aWFsKGFycikge1xuICAgIHJldHVybiBhcnIuc2xpY2UoMCwgLTEpO1xufVxuXG5leHBvcnQgeyBpbml0aWFsIH07XG4iLCJmdW5jdGlvbiBpbnRlcnNlY3Rpb24oZmlyc3RBcnIsIHNlY29uZEFycikge1xuICAgIGNvbnN0IHNlY29uZFNldCA9IG5ldyBTZXQoc2Vjb25kQXJyKTtcbiAgICByZXR1cm4gZmlyc3RBcnIuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgICByZXR1cm4gc2Vjb25kU2V0LmhhcyhpdGVtKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgaW50ZXJzZWN0aW9uIH07XG4iLCJmdW5jdGlvbiBpbnRlcnNlY3Rpb25CeShmaXJzdEFyciwgc2Vjb25kQXJyLCBtYXBwZXIpIHtcbiAgICBjb25zdCBtYXBwZWRTZWNvbmRTZXQgPSBuZXcgU2V0KHNlY29uZEFyci5tYXAobWFwcGVyKSk7XG4gICAgcmV0dXJuIGZpcnN0QXJyLmZpbHRlcihpdGVtID0+IG1hcHBlZFNlY29uZFNldC5oYXMobWFwcGVyKGl0ZW0pKSk7XG59XG5cbmV4cG9ydCB7IGludGVyc2VjdGlvbkJ5IH07XG4iLCJmdW5jdGlvbiBpbnRlcnNlY3Rpb25XaXRoKGZpcnN0QXJyLCBzZWNvbmRBcnIsIGFyZUl0ZW1zRXF1YWwpIHtcbiAgICByZXR1cm4gZmlyc3RBcnIuZmlsdGVyKGZpcnN0SXRlbSA9PiB7XG4gICAgICAgIHJldHVybiBzZWNvbmRBcnIuc29tZShzZWNvbmRJdGVtID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhcmVJdGVtc0VxdWFsKGZpcnN0SXRlbSwgc2Vjb25kSXRlbSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5leHBvcnQgeyBpbnRlcnNlY3Rpb25XaXRoIH07XG4iLCJpbXBvcnQgeyBkaWZmZXJlbmNlIH0gZnJvbSAnLi9kaWZmZXJlbmNlLm1qcyc7XG5cbmZ1bmN0aW9uIGlzU3Vic2V0KHN1cGVyc2V0LCBzdWJzZXQpIHtcbiAgICByZXR1cm4gZGlmZmVyZW5jZShzdWJzZXQsIHN1cGVyc2V0KS5sZW5ndGggPT09IDA7XG59XG5cbmV4cG9ydCB7IGlzU3Vic2V0IH07XG4iLCJpbXBvcnQgeyBkaWZmZXJlbmNlV2l0aCB9IGZyb20gJy4vZGlmZmVyZW5jZVdpdGgubWpzJztcblxuZnVuY3Rpb24gaXNTdWJzZXRXaXRoKHN1cGVyc2V0LCBzdWJzZXQsIGFyZUl0ZW1zRXF1YWwpIHtcbiAgICByZXR1cm4gZGlmZmVyZW5jZVdpdGgoc3Vic2V0LCBzdXBlcnNldCwgYXJlSXRlbXNFcXVhbCkubGVuZ3RoID09PSAwO1xufVxuXG5leHBvcnQgeyBpc1N1YnNldFdpdGggfTtcbiIsImZ1bmN0aW9uIGtleUJ5KGFyciwgZ2V0S2V5RnJvbUl0ZW0pIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBpdGVtID0gYXJyW2ldO1xuICAgICAgICBjb25zdCBrZXkgPSBnZXRLZXlGcm9tSXRlbShpdGVtKTtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBpdGVtO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgeyBrZXlCeSB9O1xuIiwiZnVuY3Rpb24gbGFzdChhcnIpIHtcbiAgICByZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAxXTtcbn1cblxuZXhwb3J0IHsgbGFzdCB9O1xuIiwiZnVuY3Rpb24gbWF4QnkoaXRlbXMsIGdldFZhbHVlKSB7XG4gICAgbGV0IG1heEVsZW1lbnQgPSBpdGVtc1swXTtcbiAgICBsZXQgbWF4ID0gLUluZmluaXR5O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGl0ZW1zW2ldO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGdldFZhbHVlKGVsZW1lbnQpO1xuICAgICAgICBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICAgICAgbWF4RWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heEVsZW1lbnQ7XG59XG5cbmV4cG9ydCB7IG1heEJ5IH07XG4iLCJmdW5jdGlvbiBtaW5CeShpdGVtcywgZ2V0VmFsdWUpIHtcbiAgICBsZXQgbWluRWxlbWVudCA9IGl0ZW1zWzBdO1xuICAgIGxldCBtaW4gPSBJbmZpbml0eTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBpdGVtc1tpXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRWYWx1ZShlbGVtZW50KTtcbiAgICAgICAgaWYgKHZhbHVlIDwgbWluKSB7XG4gICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICAgIG1pbkVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtaW5FbGVtZW50O1xufVxuXG5leHBvcnQgeyBtaW5CeSB9O1xuIiwiZnVuY3Rpb24gY29tcGFyZVZhbHVlcyhhLCBiLCBvcmRlcikge1xuICAgIGlmIChhIDwgYikge1xuICAgICAgICByZXR1cm4gb3JkZXIgPT09ICdhc2MnID8gLTEgOiAxO1xuICAgIH1cbiAgICBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmV0dXJuIG9yZGVyID09PSAnYXNjJyA/IDEgOiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5cbmV4cG9ydCB7IGNvbXBhcmVWYWx1ZXMgfTtcbiIsImltcG9ydCB7IGNvbXBhcmVWYWx1ZXMgfSBmcm9tICcuLi9faW50ZXJuYWwvY29tcGFyZVZhbHVlcy5tanMnO1xuXG5mdW5jdGlvbiBvcmRlckJ5KGFyciwgY3JpdGVyaWEsIG9yZGVycykge1xuICAgIHJldHVybiBhcnIuc2xpY2UoKS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIGNvbnN0IG9yZGVyc0xlbmd0aCA9IG9yZGVycy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3JpdGVyaWEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG9yZGVyID0gb3JkZXJzTGVuZ3RoID4gaSA/IG9yZGVyc1tpXSA6IG9yZGVyc1tvcmRlcnNMZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IGNyaXRlcmlvbiA9IGNyaXRlcmlhW2ldO1xuICAgICAgICAgICAgY29uc3QgY3JpdGVyaW9uSXNGdW5jdGlvbiA9IHR5cGVvZiBjcml0ZXJpb24gPT09ICdmdW5jdGlvbic7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZUEgPSBjcml0ZXJpb25Jc0Z1bmN0aW9uID8gY3JpdGVyaW9uKGEpIDogYVtjcml0ZXJpb25dO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVCID0gY3JpdGVyaW9uSXNGdW5jdGlvbiA/IGNyaXRlcmlvbihiKSA6IGJbY3JpdGVyaW9uXTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbXBhcmVWYWx1ZXModmFsdWVBLCB2YWx1ZUIsIG9yZGVyKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0pO1xufVxuXG5leHBvcnQgeyBvcmRlckJ5IH07XG4iLCJmdW5jdGlvbiBwYXJ0aXRpb24oYXJyLCBpc0luVHJ1dGh5KSB7XG4gICAgY29uc3QgdHJ1dGh5ID0gW107XG4gICAgY29uc3QgZmFsc3kgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBpdGVtID0gYXJyW2ldO1xuICAgICAgICBpZiAoaXNJblRydXRoeShpdGVtKSkge1xuICAgICAgICAgICAgdHJ1dGh5LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmYWxzeS5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbdHJ1dGh5LCBmYWxzeV07XG59XG5cbmV4cG9ydCB7IHBhcnRpdGlvbiB9O1xuIiwiZnVuY3Rpb24gcHVsbChhcnIsIHZhbHVlc1RvUmVtb3ZlKSB7XG4gICAgY29uc3QgdmFsdWVzU2V0ID0gbmV3IFNldCh2YWx1ZXNUb1JlbW92ZSk7XG4gICAgbGV0IHJlc3VsdEluZGV4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodmFsdWVzU2V0LmhhcyhhcnJbaV0pKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU9iamVjdC5oYXNPd24oYXJyLCBpKSkge1xuICAgICAgICAgICAgZGVsZXRlIGFycltyZXN1bHRJbmRleCsrXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGFycltyZXN1bHRJbmRleCsrXSA9IGFycltpXTtcbiAgICB9XG4gICAgYXJyLmxlbmd0aCA9IHJlc3VsdEluZGV4O1xuICAgIHJldHVybiBhcnI7XG59XG5cbmV4cG9ydCB7IHB1bGwgfTtcbiIsImltcG9ydCB7IGF0IH0gZnJvbSAnLi9hdC5tanMnO1xuXG5mdW5jdGlvbiBwdWxsQXQoYXJyLCBpbmRpY2VzVG9SZW1vdmUpIHtcbiAgICBjb25zdCByZW1vdmVkID0gYXQoYXJyLCBpbmRpY2VzVG9SZW1vdmUpO1xuICAgIGNvbnN0IGluZGljZXMgPSBuZXcgU2V0KGluZGljZXNUb1JlbW92ZS5zbGljZSgpLnNvcnQoKHgsIHkpID0+IHkgLSB4KSk7XG4gICAgZm9yIChjb25zdCBpbmRleCBvZiBpbmRpY2VzKSB7XG4gICAgICAgIGFyci5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gcmVtb3ZlZDtcbn1cblxuZXhwb3J0IHsgcHVsbEF0IH07XG4iLCJmdW5jdGlvbiByZW1vdmUoYXJyLCBzaG91bGRSZW1vdmVFbGVtZW50KSB7XG4gICAgY29uc3Qgb3JpZ2luYWxBcnIgPSBhcnIuc2xpY2UoKTtcbiAgICBjb25zdCByZW1vdmVkID0gW107XG4gICAgbGV0IHJlc3VsdEluZGV4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlRWxlbWVudChhcnJbaV0sIGksIG9yaWdpbmFsQXJyKSkge1xuICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKGFycltpXSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU9iamVjdC5oYXNPd24oYXJyLCBpKSkge1xuICAgICAgICAgICAgZGVsZXRlIGFycltyZXN1bHRJbmRleCsrXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGFycltyZXN1bHRJbmRleCsrXSA9IGFycltpXTtcbiAgICB9XG4gICAgYXJyLmxlbmd0aCA9IHJlc3VsdEluZGV4O1xuICAgIHJldHVybiByZW1vdmVkO1xufVxuXG5leHBvcnQgeyByZW1vdmUgfTtcbiIsImZ1bmN0aW9uIHNhbXBsZShhcnIpIHtcbiAgICBjb25zdCByYW5kb21JbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGFyci5sZW5ndGgpO1xuICAgIHJldHVybiBhcnJbcmFuZG9tSW5kZXhdO1xufVxuXG5leHBvcnQgeyBzYW1wbGUgfTtcbiIsImZ1bmN0aW9uIHJhbmRvbShtaW5pbXVtLCBtYXhpbXVtKSB7XG4gICAgaWYgKG1heGltdW0gPT0gbnVsbCkge1xuICAgICAgICBtYXhpbXVtID0gbWluaW11bTtcbiAgICAgICAgbWluaW11bSA9IDA7XG4gICAgfVxuICAgIGlmIChtaW5pbXVtID49IG1heGltdW0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0OiBUaGUgbWF4aW11bSB2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB0aGUgbWluaW11bSB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAobWF4aW11bSAtIG1pbmltdW0pICsgbWluaW11bTtcbn1cblxuZXhwb3J0IHsgcmFuZG9tIH07XG4iLCJpbXBvcnQgeyByYW5kb20gfSBmcm9tICcuL3JhbmRvbS5tanMnO1xuXG5mdW5jdGlvbiByYW5kb21JbnQobWluaW11bSwgbWF4aW11bSkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKHJhbmRvbShtaW5pbXVtLCBtYXhpbXVtKSk7XG59XG5cbmV4cG9ydCB7IHJhbmRvbUludCB9O1xuIiwiaW1wb3J0IHsgcmFuZG9tSW50IH0gZnJvbSAnLi4vbWF0aC9yYW5kb21JbnQubWpzJztcblxuZnVuY3Rpb24gc2FtcGxlU2l6ZShhcnJheSwgc2l6ZSkge1xuICAgIGlmIChzaXplID4gYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2l6ZSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgbGVuZ3RoIG9mIGFycmF5LicpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChsZXQgc3RlcCA9IGFycmF5Lmxlbmd0aCAtIHNpemUsIHJlc3VsdEluZGV4ID0gMDsgc3RlcCA8IGFycmF5Lmxlbmd0aDsgc3RlcCsrLCByZXN1bHRJbmRleCsrKSB7XG4gICAgICAgIGxldCBpbmRleCA9IHJhbmRvbUludCgwLCBzdGVwICsgMSk7XG4gICAgICAgIGlmIChzZWxlY3RlZC5oYXMoaW5kZXgpKSB7XG4gICAgICAgICAgICBpbmRleCA9IHN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0ZWQuYWRkKGluZGV4KTtcbiAgICAgICAgcmVzdWx0W3Jlc3VsdEluZGV4XSA9IGFycmF5W2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IHsgc2FtcGxlU2l6ZSB9O1xuIiwiZnVuY3Rpb24gc2h1ZmZsZShhcnIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhcnIuc2xpY2UoKTtcbiAgICBmb3IgKGxldCBpID0gcmVzdWx0Lmxlbmd0aCAtIDE7IGkgPj0gMTsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaSArIDEpKTtcbiAgICAgICAgW3Jlc3VsdFtpXSwgcmVzdWx0W2pdXSA9IFtyZXN1bHRbal0sIHJlc3VsdFtpXV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCB7IHNodWZmbGUgfTtcbiIsImltcG9ydCB7IG9yZGVyQnkgfSBmcm9tICcuL29yZGVyQnkubWpzJztcblxuZnVuY3Rpb24gc29ydEJ5KGFyciwgY3JpdGVyaWEpIHtcbiAgICByZXR1cm4gb3JkZXJCeShhcnIsIGNyaXRlcmlhLCBbJ2FzYyddKTtcbn1cblxuZXhwb3J0IHsgc29ydEJ5IH07XG4iLCJmdW5jdGlvbiB0YWlsKGFycikge1xuICAgIHJldHVybiBhcnIuc2xpY2UoMSk7XG59XG5cbmV4cG9ydCB7IHRhaWwgfTtcbiIsImZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgfHwgdmFsdWUgaW5zdGFuY2VvZiBTeW1ib2w7XG59XG5cbmV4cG9ydCB7IGlzU3ltYm9sIH07XG4iLCJpbXBvcnQgeyBpc1N5bWJvbCB9IGZyb20gJy4uL3ByZWRpY2F0ZS9pc1N5bWJvbC5tanMnO1xuXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICAgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG59XG5cbmV4cG9ydCB7IHRvTnVtYmVyIH07XG4iLCJpbXBvcnQgeyB0b051bWJlciB9IGZyb20gJy4vdG9OdW1iZXIubWpzJztcblxuZnVuY3Rpb24gdG9GaW5pdGUodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMDtcbiAgICB9XG4gICAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gICAgaWYgKHZhbHVlID09PSBJbmZpbml0eSB8fCB2YWx1ZSA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgIGNvbnN0IHNpZ24gPSB2YWx1ZSA8IDAgPyAtMSA6IDE7XG4gICAgICAgIHJldHVybiBzaWduICogTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbn1cblxuZXhwb3J0IHsgdG9GaW5pdGUgfTtcbiIsImltcG9ydCB7IHRvRmluaXRlIH0gZnJvbSAnLi90b0Zpbml0ZS5tanMnO1xuXG5mdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcbiAgICBjb25zdCBmaW5pdGUgPSB0b0Zpbml0ZSh2YWx1ZSk7XG4gICAgY29uc3QgcmVtYWluZGVyID0gZmluaXRlICUgMTtcbiAgICByZXR1cm4gcmVtYWluZGVyID8gZmluaXRlIC0gcmVtYWluZGVyIDogZmluaXRlO1xufVxuXG5leHBvcnQgeyB0b0ludGVnZXIgfTtcbiIsImltcG9ydCB7IHRvSW50ZWdlciB9IGZyb20gJy4uL2NvbXBhdC91dGlsL3RvSW50ZWdlci5tanMnO1xuXG5mdW5jdGlvbiB0YWtlKGFyciwgY291bnQsIGd1YXJkKSB7XG4gICAgY291bnQgPSBndWFyZCB8fCBjb3VudCA9PT0gdW5kZWZpbmVkID8gMSA6IHRvSW50ZWdlcihjb3VudCk7XG4gICAgcmV0dXJuIGFyci5zbGljZSgwLCBjb3VudCk7XG59XG5cbmV4cG9ydCB7IHRha2UgfTtcbiIsImltcG9ydCB7IHRvSW50ZWdlciB9IGZyb20gJy4uL2NvbXBhdC91dGlsL3RvSW50ZWdlci5tanMnO1xuXG5mdW5jdGlvbiB0YWtlUmlnaHQoYXJyLCBjb3VudCA9IDEsIGd1YXJkKSB7XG4gICAgY291bnQgPSBndWFyZCB8fCBjb3VudCA9PT0gdW5kZWZpbmVkID8gMSA6IHRvSW50ZWdlcihjb3VudCk7XG4gICAgaWYgKGNvdW50IDw9IDAgfHwgYXJyID09IG51bGwgfHwgYXJyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBhcnIuc2xpY2UoLWNvdW50KTtcbn1cblxuZXhwb3J0IHsgdGFrZVJpZ2h0IH07XG4iLCJmdW5jdGlvbiB0YWtlUmlnaHRXaGlsZShhcnIsIHNob3VsZENvbnRpbnVlVGFraW5nKSB7XG4gICAgZm9yIChsZXQgaSA9IGFyci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoIXNob3VsZENvbnRpbnVlVGFraW5nKGFycltpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIuc2xpY2UoaSArIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnIuc2xpY2UoKTtcbn1cblxuZXhwb3J0IHsgdGFrZVJpZ2h0V2hpbGUgfTtcbiIsImZ1bmN0aW9uIHRha2VXaGlsZShhcnIsIHNob3VsZENvbnRpbnVlVGFraW5nKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGFycltpXTtcbiAgICAgICAgaWYgKCFzaG91bGRDb250aW51ZVRha2luZyhpdGVtKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCB7IHRha2VXaGlsZSB9O1xuIiwiZnVuY3Rpb24gdG9GaWxsZWQoYXJyLCB2YWx1ZSwgc3RhcnQgPSAwLCBlbmQgPSBhcnIubGVuZ3RoKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgICBjb25zdCBmaW5hbFN0YXJ0ID0gTWF0aC5tYXgoc3RhcnQgPj0gMCA/IHN0YXJ0IDogbGVuZ3RoICsgc3RhcnQsIDApO1xuICAgIGNvbnN0IGZpbmFsRW5kID0gTWF0aC5taW4oZW5kID49IDAgPyBlbmQgOiBsZW5ndGggKyBlbmQsIGxlbmd0aCk7XG4gICAgY29uc3QgbmV3QXJyID0gYXJyLnNsaWNlKCk7XG4gICAgZm9yIChsZXQgaSA9IGZpbmFsU3RhcnQ7IGkgPCBmaW5hbEVuZDsgaSsrKSB7XG4gICAgICAgIG5ld0FycltpXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3QXJyO1xufVxuXG5leHBvcnQgeyB0b0ZpbGxlZCB9O1xuIiwiZnVuY3Rpb24gdW5pcShhcnIpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KGFycikpO1xufVxuXG5leHBvcnQgeyB1bmlxIH07XG4iLCJpbXBvcnQgeyB1bmlxIH0gZnJvbSAnLi91bmlxLm1qcyc7XG5cbmZ1bmN0aW9uIHVuaW9uKGFycjEsIGFycjIpIHtcbiAgICByZXR1cm4gdW5pcShhcnIxLmNvbmNhdChhcnIyKSk7XG59XG5cbmV4cG9ydCB7IHVuaW9uIH07XG4iLCJmdW5jdGlvbiB1bmlxQnkoYXJyLCBtYXBwZXIpIHtcbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGFycltpXTtcbiAgICAgICAgY29uc3Qga2V5ID0gbWFwcGVyKGl0ZW0pO1xuICAgICAgICBpZiAoIW1hcC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgbWFwLnNldChrZXksIGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKG1hcC52YWx1ZXMoKSk7XG59XG5cbmV4cG9ydCB7IHVuaXFCeSB9O1xuIiwiaW1wb3J0IHsgdW5pcUJ5IH0gZnJvbSAnLi91bmlxQnkubWpzJztcblxuZnVuY3Rpb24gdW5pb25CeShhcnIxLCBhcnIyLCBtYXBwZXIpIHtcbiAgICByZXR1cm4gdW5pcUJ5KGFycjEuY29uY2F0KGFycjIpLCBtYXBwZXIpO1xufVxuXG5leHBvcnQgeyB1bmlvbkJ5IH07XG4iLCJmdW5jdGlvbiB1bmlxV2l0aChhcnIsIGFyZUl0ZW1zRXF1YWwpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBpdGVtID0gYXJyW2ldO1xuICAgICAgICBjb25zdCBpc1VuaXEgPSByZXN1bHQuZXZlcnkodiA9PiAhYXJlSXRlbXNFcXVhbCh2LCBpdGVtKSk7XG4gICAgICAgIGlmIChpc1VuaXEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCB7IHVuaXFXaXRoIH07XG4iLCJpbXBvcnQgeyB1bmlxV2l0aCB9IGZyb20gJy4vdW5pcVdpdGgubWpzJztcblxuZnVuY3Rpb24gdW5pb25XaXRoKGFycjEsIGFycjIsIGFyZUl0ZW1zRXF1YWwpIHtcbiAgICByZXR1cm4gdW5pcVdpdGgoYXJyMS5jb25jYXQoYXJyMiksIGFyZUl0ZW1zRXF1YWwpO1xufVxuXG5leHBvcnQgeyB1bmlvbldpdGggfTtcbiIsImZ1bmN0aW9uIHVuemlwKHppcHBlZCkge1xuICAgIGxldCBtYXhMZW4gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemlwcGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh6aXBwZWRbaV0ubGVuZ3RoID4gbWF4TGVuKSB7XG4gICAgICAgICAgICBtYXhMZW4gPSB6aXBwZWRbaV0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShtYXhMZW4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4TGVuOyBpKyspIHtcbiAgICAgICAgcmVzdWx0W2ldID0gbmV3IEFycmF5KHppcHBlZC5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHppcHBlZC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgcmVzdWx0W2ldW2pdID0gemlwcGVkW2pdW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCB7IHVuemlwIH07XG4iLCJmdW5jdGlvbiB1bnppcFdpdGgodGFyZ2V0LCBpdGVyYXRlZSkge1xuICAgIGNvbnN0IG1heExlbmd0aCA9IE1hdGgubWF4KC4uLnRhcmdldC5tYXAoaW5uZXJBcnJheSA9PiBpbm5lckFycmF5Lmxlbmd0aCkpO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShtYXhMZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZ3JvdXAgPSBuZXcgQXJyYXkodGFyZ2V0Lmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGFyZ2V0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBncm91cFtqXSA9IHRhcmdldFtqXVtpXTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbaV0gPSBpdGVyYXRlZSguLi5ncm91cCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCB7IHVuemlwV2l0aCB9O1xuIiwiZnVuY3Rpb24gd2luZG93ZWQoYXJyLCBzaXplLCBzdGVwID0gMSwgeyBwYXJ0aWFsV2luZG93cyA9IGZhbHNlIH0gPSB7fSkge1xuICAgIGlmIChzaXplIDw9IDAgfHwgIU51bWJlci5pc0ludGVnZXIoc2l6ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaXplIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLicpO1xuICAgIH1cbiAgICBpZiAoc3RlcCA8PSAwIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKHN0ZXApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU3RlcCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci4nKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgZW5kID0gcGFydGlhbFdpbmRvd3MgPyBhcnIubGVuZ3RoIDogYXJyLmxlbmd0aCAtIHNpemUgKyAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW5kOyBpICs9IHN0ZXApIHtcbiAgICAgICAgcmVzdWx0LnB1c2goYXJyLnNsaWNlKGksIGkgKyBzaXplKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCB7IHdpbmRvd2VkIH07XG4iLCJpbXBvcnQgeyBkaWZmZXJlbmNlIH0gZnJvbSAnLi9kaWZmZXJlbmNlLm1qcyc7XG5cbmZ1bmN0aW9uIHdpdGhvdXQoYXJyYXksIC4uLnZhbHVlcykge1xuICAgIHJldHVybiBkaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMpO1xufVxuXG5leHBvcnQgeyB3aXRob3V0IH07XG4iLCJpbXBvcnQgeyBkaWZmZXJlbmNlIH0gZnJvbSAnLi9kaWZmZXJlbmNlLm1qcyc7XG5pbXBvcnQgeyBpbnRlcnNlY3Rpb24gfSBmcm9tICcuL2ludGVyc2VjdGlvbi5tanMnO1xuaW1wb3J0IHsgdW5pb24gfSBmcm9tICcuL3VuaW9uLm1qcyc7XG5cbmZ1bmN0aW9uIHhvcihhcnIxLCBhcnIyKSB7XG4gICAgcmV0dXJuIGRpZmZlcmVuY2UodW5pb24oYXJyMSwgYXJyMiksIGludGVyc2VjdGlvbihhcnIxLCBhcnIyKSk7XG59XG5cbmV4cG9ydCB7IHhvciB9O1xuIiwiaW1wb3J0IHsgZGlmZmVyZW5jZUJ5IH0gZnJvbSAnLi9kaWZmZXJlbmNlQnkubWpzJztcbmltcG9ydCB7IGludGVyc2VjdGlvbkJ5IH0gZnJvbSAnLi9pbnRlcnNlY3Rpb25CeS5tanMnO1xuaW1wb3J0IHsgdW5pb25CeSB9IGZyb20gJy4vdW5pb25CeS5tanMnO1xuXG5mdW5jdGlvbiB4b3JCeShhcnIxLCBhcnIyLCBtYXBwZXIpIHtcbiAgICBjb25zdCB1bmlvbiA9IHVuaW9uQnkoYXJyMSwgYXJyMiwgbWFwcGVyKTtcbiAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb25CeShhcnIxLCBhcnIyLCBtYXBwZXIpO1xuICAgIHJldHVybiBkaWZmZXJlbmNlQnkodW5pb24sIGludGVyc2VjdGlvbiwgbWFwcGVyKTtcbn1cblxuZXhwb3J0IHsgeG9yQnkgfTtcbiIsImltcG9ydCB7IGRpZmZlcmVuY2VXaXRoIH0gZnJvbSAnLi9kaWZmZXJlbmNlV2l0aC5tanMnO1xuaW1wb3J0IHsgaW50ZXJzZWN0aW9uV2l0aCB9IGZyb20gJy4vaW50ZXJzZWN0aW9uV2l0aC5tanMnO1xuaW1wb3J0IHsgdW5pb25XaXRoIH0gZnJvbSAnLi91bmlvbldpdGgubWpzJztcblxuZnVuY3Rpb24geG9yV2l0aChhcnIxLCBhcnIyLCBhcmVFbGVtZW50c0VxdWFsKSB7XG4gICAgY29uc3QgdW5pb24gPSB1bmlvbldpdGgoYXJyMSwgYXJyMiwgYXJlRWxlbWVudHNFcXVhbCk7XG4gICAgY29uc3QgaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uV2l0aChhcnIxLCBhcnIyLCBhcmVFbGVtZW50c0VxdWFsKTtcbiAgICByZXR1cm4gZGlmZmVyZW5jZVdpdGgodW5pb24sIGludGVyc2VjdGlvbiwgYXJlRWxlbWVudHNFcXVhbCk7XG59XG5cbmV4cG9ydCB7IHhvcldpdGggfTtcbiIsImZ1bmN0aW9uIHppcCguLi5hcnJzKSB7XG4gICAgbGV0IHJvd0NvdW50ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFycnNbaV0ubGVuZ3RoID4gcm93Q291bnQpIHtcbiAgICAgICAgICAgIHJvd0NvdW50ID0gYXJyc1tpXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY29sdW1uQ291bnQgPSBhcnJzLmxlbmd0aDtcbiAgICBjb25zdCByZXN1bHQgPSBBcnJheShyb3dDb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dDb3VudDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHJvdyA9IEFycmF5KGNvbHVtbkNvdW50KTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2x1bW5Db3VudDsgKytqKSB7XG4gICAgICAgICAgICByb3dbal0gPSBhcnJzW2pdW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtpXSA9IHJvdztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IHsgemlwIH07XG4iLCJmdW5jdGlvbiB6aXBPYmplY3Qoa2V5cywgdmFsdWVzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdFtrZXlzW2ldXSA9IHZhbHVlc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IHsgemlwT2JqZWN0IH07XG4iLCJmdW5jdGlvbiB6aXBXaXRoKGFycjEsIC4uLnJlc3QpIHtcbiAgICBjb25zdCBhcnJzID0gW2FycjEsIC4uLnJlc3Quc2xpY2UoMCwgLTEpXTtcbiAgICBjb25zdCBjb21iaW5lID0gcmVzdFtyZXN0Lmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IG1heEluZGV4ID0gTWF0aC5tYXgoLi4uYXJycy5tYXAoYXJyID0+IGFyci5sZW5ndGgpKTtcbiAgICBjb25zdCByZXN1bHQgPSBBcnJheShtYXhJbmRleCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhJbmRleDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gYXJycy5tYXAoYXJyID0+IGFycltpXSk7XG4gICAgICAgIHJlc3VsdFtpXSA9IGNvbWJpbmUoLi4uZWxlbWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgeyB6aXBXaXRoIH07XG4iLCJjbGFzcyBBYm9ydEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UgPSAnVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZCcpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdBYm9ydEVycm9yJztcbiAgICB9XG59XG5cbmV4cG9ydCB7IEFib3J0RXJyb3IgfTtcbiIsImNsYXNzIFRpbWVvdXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gJ1RoZSBvcGVyYXRpb24gd2FzIHRpbWVkIG91dCcpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdUaW1lb3V0RXJyb3InO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgVGltZW91dEVycm9yIH07XG4iLCJmdW5jdGlvbiBhZnRlcihuLCBmdW5jKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG4pIHx8IG4gPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbiBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIuYCk7XG4gICAgfVxuICAgIGxldCBjb3VudGVyID0gMDtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKCsrY291bnRlciA+PSBuKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYyguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG59XG5cbmV4cG9ydCB7IGFmdGVyIH07XG4iLCJmdW5jdGlvbiBhcnkoZnVuYywgbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzLnNsaWNlKDAsIG4pKTtcbiAgICB9O1xufVxuXG5leHBvcnQgeyBhcnkgfTtcbiIsImFzeW5jIGZ1bmN0aW9uIGFzeW5jTm9vcCgpIHsgfVxuXG5leHBvcnQgeyBhc3luY05vb3AgfTtcbiIsImZ1bmN0aW9uIGJlZm9yZShuLCBmdW5jKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG4pIHx8IG4gPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbiBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIuJyk7XG4gICAgfVxuICAgIGxldCBjb3VudGVyID0gMDtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKCsrY291bnRlciA8IG4pIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbn1cblxuZXhwb3J0IHsgYmVmb3JlIH07XG4iLCJmdW5jdGlvbiBjdXJyeShmdW5jKSB7XG4gICAgaWYgKGZ1bmMubGVuZ3RoID09PSAwIHx8IGZ1bmMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgICAgICByZXR1cm4gbWFrZUN1cnJ5KGZ1bmMsIGZ1bmMubGVuZ3RoLCBbYXJnXSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1ha2VDdXJyeShvcmlnaW4sIGFyZ3NMZW5ndGgsIGFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbiguLi5hcmdzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG5leHQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZUN1cnJ5KG9yaWdpbiwgYXJnc0xlbmd0aCwgWy4uLmFyZ3MsIGFyZ10pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGN1cnJ5IH07XG4iLCJmdW5jdGlvbiBjdXJyeVJpZ2h0KGZ1bmMpIHtcbiAgICBpZiAoZnVuYy5sZW5ndGggPT09IDAgfHwgZnVuYy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiBtYWtlQ3VycnlSaWdodChmdW5jLCBmdW5jLmxlbmd0aCwgW2FyZ10pO1xuICAgIH07XG59XG5mdW5jdGlvbiBtYWtlQ3VycnlSaWdodChvcmlnaW4sIGFyZ3NMZW5ndGgsIGFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbiguLi5hcmdzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG5leHQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZUN1cnJ5UmlnaHQob3JpZ2luLCBhcmdzTGVuZ3RoLCBbYXJnLCAuLi5hcmdzXSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cbn1cblxuZXhwb3J0IHsgY3VycnlSaWdodCB9O1xuIiwiZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgZGVib3VuY2VNcywgeyBzaWduYWwsIGVkZ2VzIH0gPSB7fSkge1xuICAgIGxldCBwZW5kaW5nVGhpcyA9IHVuZGVmaW5lZDtcbiAgICBsZXQgcGVuZGluZ0FyZ3MgPSBudWxsO1xuICAgIGNvbnN0IGxlYWRpbmcgPSBlZGdlcyAhPSBudWxsICYmIGVkZ2VzLmluY2x1ZGVzKCdsZWFkaW5nJyk7XG4gICAgY29uc3QgdHJhaWxpbmcgPSBlZGdlcyA9PSBudWxsIHx8IGVkZ2VzLmluY2x1ZGVzKCd0cmFpbGluZycpO1xuICAgIGNvbnN0IGludm9rZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKHBlbmRpbmdBcmdzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmdW5jLmFwcGx5KHBlbmRpbmdUaGlzLCBwZW5kaW5nQXJncyk7XG4gICAgICAgICAgICBwZW5kaW5nVGhpcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHBlbmRpbmdBcmdzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25UaW1lckVuZCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRyYWlsaW5nKSB7XG4gICAgICAgICAgICBpbnZva2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjYW5jZWwoKTtcbiAgICB9O1xuICAgIGxldCB0aW1lb3V0SWQgPSBudWxsO1xuICAgIGNvbnN0IHNjaGVkdWxlID0gKCkgPT4ge1xuICAgICAgICBpZiAodGltZW91dElkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGltZW91dElkID0gbnVsbDtcbiAgICAgICAgICAgIG9uVGltZXJFbmQoKTtcbiAgICAgICAgfSwgZGVib3VuY2VNcyk7XG4gICAgfTtcbiAgICBjb25zdCBjYW5jZWxUaW1lciA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRpbWVvdXRJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICB0aW1lb3V0SWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgICAgIGNhbmNlbFRpbWVyKCk7XG4gICAgICAgIHBlbmRpbmdUaGlzID0gdW5kZWZpbmVkO1xuICAgICAgICBwZW5kaW5nQXJncyA9IG51bGw7XG4gICAgfTtcbiAgICBjb25zdCBmbHVzaCA9ICgpID0+IHtcbiAgICAgICAgY2FuY2VsVGltZXIoKTtcbiAgICAgICAgaW52b2tlKCk7XG4gICAgfTtcbiAgICBjb25zdCBkZWJvdW5jZWQgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBpZiAoc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGVuZGluZ1RoaXMgPSB0aGlzO1xuICAgICAgICBwZW5kaW5nQXJncyA9IGFyZ3M7XG4gICAgICAgIGNvbnN0IGlzRmlyc3RDYWxsID0gdGltZW91dElkID09IG51bGw7XG4gICAgICAgIHNjaGVkdWxlKCk7XG4gICAgICAgIGlmIChsZWFkaW5nICYmIGlzRmlyc3RDYWxsKSB7XG4gICAgICAgICAgICBpbnZva2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZGVib3VuY2VkLnNjaGVkdWxlID0gc2NoZWR1bGU7XG4gICAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgICBzaWduYWw/LmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgY2FuY2VsLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxuZXhwb3J0IHsgZGVib3VuY2UgfTtcbiIsImZ1bmN0aW9uIGZsb3coLi4uZnVuY3MpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGZ1bmNzLmxlbmd0aCA/IGZ1bmNzWzBdLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBmdW5jcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuY3NbaV0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cblxuZXhwb3J0IHsgZmxvdyB9O1xuIiwiaW1wb3J0IHsgZmxvdyB9IGZyb20gJy4vZmxvdy5tanMnO1xuXG5mdW5jdGlvbiBmbG93UmlnaHQoLi4uZnVuY3MpIHtcbiAgICByZXR1cm4gZmxvdyguLi5mdW5jcy5yZXZlcnNlKCkpO1xufVxuXG5leHBvcnQgeyBmbG93UmlnaHQgfTtcbiIsImZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgICByZXR1cm4geDtcbn1cblxuZXhwb3J0IHsgaWRlbnRpdHkgfTtcbiIsImZ1bmN0aW9uIG1lbW9pemUoZm4sIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgY2FjaGUgPSBuZXcgTWFwKCksIGdldENhY2hlS2V5IH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IG1lbW9pemVkRm4gPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGdldENhY2hlS2V5ID8gZ2V0Q2FjaGVLZXkoYXJnKSA6IGFyZztcbiAgICAgICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZm4uY2FsbCh0aGlzLCBhcmcpO1xuICAgICAgICBjYWNoZS5zZXQoa2V5LCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgbWVtb2l6ZWRGbi5jYWNoZSA9IGNhY2hlO1xuICAgIHJldHVybiBtZW1vaXplZEZuO1xufVxuXG5leHBvcnQgeyBtZW1vaXplIH07XG4iLCJmdW5jdGlvbiBuZWdhdGUoZnVuYykge1xuICAgIHJldHVybiAoKC4uLmFyZ3MpID0+ICFmdW5jKC4uLmFyZ3MpKTtcbn1cblxuZXhwb3J0IHsgbmVnYXRlIH07XG4iLCJmdW5jdGlvbiBub29wKCkgeyB9XG5cbmV4cG9ydCB7IG5vb3AgfTtcbiIsImZ1bmN0aW9uIG9uY2UoZnVuYykge1xuICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICBsZXQgY2FjaGU7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgY2FjaGUgPSBmdW5jKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWNoZTtcbiAgICB9O1xufVxuXG5leHBvcnQgeyBvbmNlIH07XG4iLCJmdW5jdGlvbiBwYXJ0aWFsKGZ1bmMsIC4uLnBhcnRpYWxBcmdzKSB7XG4gICAgcmV0dXJuIHBhcnRpYWxJbXBsKGZ1bmMsIHBsYWNlaG9sZGVyU3ltYm9sLCAuLi5wYXJ0aWFsQXJncyk7XG59XG5mdW5jdGlvbiBwYXJ0aWFsSW1wbChmdW5jLCBwbGFjZWhvbGRlciwgLi4ucGFydGlhbEFyZ3MpIHtcbiAgICBjb25zdCBwYXJ0aWFsZWQgPSBmdW5jdGlvbiAoLi4ucHJvdmlkZWRBcmdzKSB7XG4gICAgICAgIGxldCBwcm92aWRlZEFyZ3NJbmRleCA9IDA7XG4gICAgICAgIGNvbnN0IHN1YnN0aXR1dGVkQXJncyA9IHBhcnRpYWxBcmdzXG4gICAgICAgICAgICAuc2xpY2UoKVxuICAgICAgICAgICAgLm1hcChhcmcgPT4gKGFyZyA9PT0gcGxhY2Vob2xkZXIgPyBwcm92aWRlZEFyZ3NbcHJvdmlkZWRBcmdzSW5kZXgrK10gOiBhcmcpKTtcbiAgICAgICAgY29uc3QgcmVtYWluaW5nQXJncyA9IHByb3ZpZGVkQXJncy5zbGljZShwcm92aWRlZEFyZ3NJbmRleCk7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIHN1YnN0aXR1dGVkQXJncy5jb25jYXQocmVtYWluaW5nQXJncykpO1xuICAgIH07XG4gICAgaWYgKGZ1bmMucHJvdG90eXBlKSB7XG4gICAgICAgIHBhcnRpYWxlZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGZ1bmMucHJvdG90eXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRpYWxlZDtcbn1cbmNvbnN0IHBsYWNlaG9sZGVyU3ltYm9sID0gU3ltYm9sKCdwYXJ0aWFsLnBsYWNlaG9sZGVyJyk7XG5wYXJ0aWFsLnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXJTeW1ib2w7XG5cbmV4cG9ydCB7IHBhcnRpYWwsIHBhcnRpYWxJbXBsIH07XG4iLCJmdW5jdGlvbiBwYXJ0aWFsUmlnaHQoZnVuYywgLi4ucGFydGlhbEFyZ3MpIHtcbiAgICByZXR1cm4gcGFydGlhbFJpZ2h0SW1wbChmdW5jLCBwbGFjZWhvbGRlclN5bWJvbCwgLi4ucGFydGlhbEFyZ3MpO1xufVxuZnVuY3Rpb24gcGFydGlhbFJpZ2h0SW1wbChmdW5jLCBwbGFjZWhvbGRlciwgLi4ucGFydGlhbEFyZ3MpIHtcbiAgICBjb25zdCBwYXJ0aWFsZWRSaWdodCA9IGZ1bmN0aW9uICguLi5wcm92aWRlZEFyZ3MpIHtcbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXJMZW5ndGggPSBwYXJ0aWFsQXJncy5maWx0ZXIoYXJnID0+IGFyZyA9PT0gcGxhY2Vob2xkZXIpLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcmFuZ2VMZW5ndGggPSBNYXRoLm1heChwcm92aWRlZEFyZ3MubGVuZ3RoIC0gcGxhY2Vob2xkZXJMZW5ndGgsIDApO1xuICAgICAgICBjb25zdCByZW1haW5pbmdBcmdzID0gcHJvdmlkZWRBcmdzLnNsaWNlKDAsIHJhbmdlTGVuZ3RoKTtcbiAgICAgICAgbGV0IHByb3ZpZGVkQXJnc0luZGV4ID0gcmFuZ2VMZW5ndGg7XG4gICAgICAgIGNvbnN0IHN1YnN0aXR1dGVkQXJncyA9IHBhcnRpYWxBcmdzXG4gICAgICAgICAgICAuc2xpY2UoKVxuICAgICAgICAgICAgLm1hcChhcmcgPT4gKGFyZyA9PT0gcGxhY2Vob2xkZXIgPyBwcm92aWRlZEFyZ3NbcHJvdmlkZWRBcmdzSW5kZXgrK10gOiBhcmcpKTtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgcmVtYWluaW5nQXJncy5jb25jYXQoc3Vic3RpdHV0ZWRBcmdzKSk7XG4gICAgfTtcbiAgICBpZiAoZnVuYy5wcm90b3R5cGUpIHtcbiAgICAgICAgcGFydGlhbGVkUmlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShmdW5jLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0aWFsZWRSaWdodDtcbn1cbmNvbnN0IHBsYWNlaG9sZGVyU3ltYm9sID0gU3ltYm9sKCdwYXJ0aWFsUmlnaHQucGxhY2Vob2xkZXInKTtcbnBhcnRpYWxSaWdodC5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyU3ltYm9sO1xuXG5leHBvcnQgeyBwYXJ0aWFsUmlnaHQsIHBhcnRpYWxSaWdodEltcGwgfTtcbiIsImZ1bmN0aW9uIHJlc3QoZnVuYywgc3RhcnRJbmRleCA9IGZ1bmMubGVuZ3RoIC0gMSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCByZXN0ID0gYXJncy5zbGljZShzdGFydEluZGV4KTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gYXJncy5zbGljZSgwLCBzdGFydEluZGV4KTtcbiAgICAgICAgd2hpbGUgKHBhcmFtcy5sZW5ndGggPCBzdGFydEluZGV4KSB7XG4gICAgICAgICAgICBwYXJhbXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIFsuLi5wYXJhbXMsIHJlc3RdKTtcbiAgICB9O1xufVxuXG5leHBvcnQgeyByZXN0IH07XG4iLCJpbXBvcnQgeyBBYm9ydEVycm9yIH0gZnJvbSAnLi4vZXJyb3IvQWJvcnRFcnJvci5tanMnO1xuXG5mdW5jdGlvbiBkZWxheShtcywgeyBzaWduYWwgfSA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgYWJvcnRFcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgQWJvcnRFcnJvcigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYWJvcnRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICBhYm9ydEVycm9yKCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBhYm9ydEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBzaWduYWw/LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSwgbXMpO1xuICAgICAgICBzaWduYWw/LmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IGRlbGF5IH07XG4iLCJpbXBvcnQgeyBkZWxheSB9IGZyb20gJy4uL3Byb21pc2UvZGVsYXkubWpzJztcblxuY29uc3QgREVGQVVMVF9ERUxBWSA9IDA7XG5jb25zdCBERUZBVUxUX1JFVFJJRVMgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5hc3luYyBmdW5jdGlvbiByZXRyeShmdW5jLCBfb3B0aW9ucykge1xuICAgIGxldCBkZWxheSQxO1xuICAgIGxldCByZXRyaWVzO1xuICAgIGxldCBzaWduYWw7XG4gICAgaWYgKHR5cGVvZiBfb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgZGVsYXkkMSA9IERFRkFVTFRfREVMQVk7XG4gICAgICAgIHJldHJpZXMgPSBfb3B0aW9ucztcbiAgICAgICAgc2lnbmFsID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGVsYXkkMSA9IF9vcHRpb25zPy5kZWxheSA/PyBERUZBVUxUX0RFTEFZO1xuICAgICAgICByZXRyaWVzID0gX29wdGlvbnM/LnJldHJpZXMgPz8gREVGQVVMVF9SRVRSSUVTO1xuICAgICAgICBzaWduYWwgPSBfb3B0aW9ucz8uc2lnbmFsO1xuICAgIH1cbiAgICBsZXQgZXJyb3I7XG4gICAgZm9yIChsZXQgYXR0ZW1wdHMgPSAwOyBhdHRlbXB0cyA8IHJldHJpZXM7IGF0dGVtcHRzKyspIHtcbiAgICAgICAgaWYgKHNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3IgPz8gbmV3IEVycm9yKGBUaGUgcmV0cnkgb3BlcmF0aW9uIHdhcyBhYm9ydGVkIGR1ZSB0byBhbiBhYm9ydCBzaWduYWwuYCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBmdW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50RGVsYXkgPSB0eXBlb2YgZGVsYXkkMSA9PT0gJ2Z1bmN0aW9uJyA/IGRlbGF5JDEoYXR0ZW1wdHMpIDogZGVsYXkkMTtcbiAgICAgICAgICAgIGF3YWl0IGRlbGF5KGN1cnJlbnREZWxheSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG59XG5cbmV4cG9ydCB7IHJldHJ5IH07XG4iLCJmdW5jdGlvbiBzcHJlYWQoZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnc0Fycikge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzQXJyKTtcbiAgICB9O1xufVxuXG5leHBvcnQgeyBzcHJlYWQgfTtcbiIsImltcG9ydCB7IGRlYm91bmNlIH0gZnJvbSAnLi9kZWJvdW5jZS5tanMnO1xuXG5mdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB0aHJvdHRsZU1zLCB7IHNpZ25hbCwgZWRnZXMgPSBbJ2xlYWRpbmcnLCAndHJhaWxpbmcnXSB9ID0ge30pIHtcbiAgICBsZXQgcGVuZGluZ0F0ID0gbnVsbDtcbiAgICBjb25zdCBkZWJvdW5jZWQgPSBkZWJvdW5jZShmdW5jLCB0aHJvdHRsZU1zLCB7IHNpZ25hbCwgZWRnZXMgfSk7XG4gICAgY29uc3QgdGhyb3R0bGVkID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHBlbmRpbmdBdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwZW5kaW5nQXQgPSBEYXRlLm5vdygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKERhdGUubm93KCkgLSBwZW5kaW5nQXQgPj0gdGhyb3R0bGVNcykge1xuICAgICAgICAgICAgICAgIHBlbmRpbmdBdCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgZGVib3VuY2VkLmNhbmNlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlYm91bmNlZCguLi5hcmdzKTtcbiAgICB9O1xuICAgIHRocm90dGxlZC5jYW5jZWwgPSBkZWJvdW5jZWQuY2FuY2VsO1xuICAgIHRocm90dGxlZC5mbHVzaCA9IGRlYm91bmNlZC5mbHVzaDtcbiAgICByZXR1cm4gdGhyb3R0bGVkO1xufVxuXG5leHBvcnQgeyB0aHJvdHRsZSB9O1xuIiwiaW1wb3J0IHsgYXJ5IH0gZnJvbSAnLi9hcnkubWpzJztcblxuZnVuY3Rpb24gdW5hcnkoZnVuYykge1xuICAgIHJldHVybiBhcnkoZnVuYywgMSk7XG59XG5cbmV4cG9ydCB7IHVuYXJ5IH07XG4iLCJmdW5jdGlvbiBjbGFtcCh2YWx1ZSwgYm91bmQxLCBib3VuZDIpIHtcbiAgICBpZiAoYm91bmQyID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKHZhbHVlLCBib3VuZDEpO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIGJvdW5kMSksIGJvdW5kMik7XG59XG5cbmV4cG9ydCB7IGNsYW1wIH07XG4iLCJmdW5jdGlvbiBpblJhbmdlKHZhbHVlLCBtaW5pbXVtLCBtYXhpbXVtKSB7XG4gICAgaWYgKG1heGltdW0gPT0gbnVsbCkge1xuICAgICAgICBtYXhpbXVtID0gbWluaW11bTtcbiAgICAgICAgbWluaW11bSA9IDA7XG4gICAgfVxuICAgIGlmIChtaW5pbXVtID49IG1heGltdW0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgbWF4aW11bSB2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB0aGUgbWluaW11bSB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIG1pbmltdW0gPD0gdmFsdWUgJiYgdmFsdWUgPCBtYXhpbXVtO1xufVxuXG5leHBvcnQgeyBpblJhbmdlIH07XG4iLCJmdW5jdGlvbiBzdW0obnVtcykge1xuICAgIGxldCByZXN1bHQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gbnVtc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IHsgc3VtIH07XG4iLCJpbXBvcnQgeyBzdW0gfSBmcm9tICcuL3N1bS5tanMnO1xuXG5mdW5jdGlvbiBtZWFuKG51bXMpIHtcbiAgICByZXR1cm4gc3VtKG51bXMpIC8gbnVtcy5sZW5ndGg7XG59XG5cbmV4cG9ydCB7IG1lYW4gfTtcbiIsImltcG9ydCB7IG1lYW4gfSBmcm9tICcuL21lYW4ubWpzJztcblxuZnVuY3Rpb24gbWVhbkJ5KGl0ZW1zLCBnZXRWYWx1ZSkge1xuICAgIGNvbnN0IG51bXMgPSBpdGVtcy5tYXAoeCA9PiBnZXRWYWx1ZSh4KSk7XG4gICAgcmV0dXJuIG1lYW4obnVtcyk7XG59XG5cbmV4cG9ydCB7IG1lYW5CeSB9O1xuIiwiZnVuY3Rpb24gbWVkaWFuKG51bXMpIHtcbiAgICBpZiAobnVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgY29uc3Qgc29ydGVkID0gbnVtcy5zbGljZSgpLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICBjb25zdCBtaWRkbGVJbmRleCA9IE1hdGguZmxvb3Ioc29ydGVkLmxlbmd0aCAvIDIpO1xuICAgIGlmIChzb3J0ZWQubGVuZ3RoICUgMiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gKHNvcnRlZFttaWRkbGVJbmRleCAtIDFdICsgc29ydGVkW21pZGRsZUluZGV4XSkgLyAyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNvcnRlZFttaWRkbGVJbmRleF07XG4gICAgfVxufVxuXG5leHBvcnQgeyBtZWRpYW4gfTtcbiIsImltcG9ydCB7IG1lZGlhbiB9IGZyb20gJy4vbWVkaWFuLm1qcyc7XG5cbmZ1bmN0aW9uIG1lZGlhbkJ5KGl0ZW1zLCBnZXRWYWx1ZSkge1xuICAgIGNvbnN0IG51bXMgPSBpdGVtcy5tYXAoeCA9PiBnZXRWYWx1ZSh4KSk7XG4gICAgcmV0dXJuIG1lZGlhbihudW1zKTtcbn1cblxuZXhwb3J0IHsgbWVkaWFuQnkgfTtcbiIsImZ1bmN0aW9uIHJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAgPSAxKSB7XG4gICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihzdGVwKSB8fCBzdGVwID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHN0ZXAgdmFsdWUgbXVzdCBiZSBhIG5vbi16ZXJvIGludGVnZXIuYCk7XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KE1hdGguY2VpbCgoZW5kIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0W2ldID0gc3RhcnQgKyBpICogc3RlcDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IHsgcmFuZ2UgfTtcbiIsImZ1bmN0aW9uIHJhbmdlUmlnaHQoc3RhcnQsIGVuZCwgc3RlcCA9IDEpIHtcbiAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHN0ZXApIHx8IHN0ZXAgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgc3RlcCB2YWx1ZSBtdXN0IGJlIGEgbm9uLXplcm8gaW50ZWdlci5gKTtcbiAgICB9XG4gICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChlbmQgLSBzdGFydCkgLyBzdGVwKSwgMCk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRbaV0gPSBzdGFydCArIChsZW5ndGggLSBpIC0gMSkgKiBzdGVwO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgeyByYW5nZVJpZ2h0IH07XG4iLCJmdW5jdGlvbiByb3VuZCh2YWx1ZSwgcHJlY2lzaW9uID0gMCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihwcmVjaXNpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJlY2lzaW9uIG11c3QgYmUgYW4gaW50ZWdlci4nKTtcbiAgICB9XG4gICAgY29uc3QgbXVsdGlwbGllciA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogbXVsdGlwbGllcikgLyBtdWx0aXBsaWVyO1xufVxuXG5leHBvcnQgeyByb3VuZCB9O1xuIiwiZnVuY3Rpb24gc3VtQnkoaXRlbXMsIGdldFZhbHVlKSB7XG4gICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gZ2V0VmFsdWUoaXRlbXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgeyBzdW1CeSB9O1xuIiwiZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpO1xufVxuXG5leHBvcnQgeyBpc1ByaW1pdGl2ZSB9O1xuIiwiZnVuY3Rpb24gaXNUeXBlZEFycmF5KHgpIHtcbiAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KHgpICYmICEoeCBpbnN0YW5jZW9mIERhdGFWaWV3KTtcbn1cblxuZXhwb3J0IHsgaXNUeXBlZEFycmF5IH07XG4iLCJpbXBvcnQgeyBpc1ByaW1pdGl2ZSB9IGZyb20gJy4uL3ByZWRpY2F0ZS9pc1ByaW1pdGl2ZS5tanMnO1xuaW1wb3J0IHsgaXNUeXBlZEFycmF5IH0gZnJvbSAnLi4vcHJlZGljYXRlL2lzVHlwZWRBcnJheS5tanMnO1xuXG5mdW5jdGlvbiBjbG9uZShvYmopIHtcbiAgICBpZiAoaXNQcmltaXRpdmUob2JqKSkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopIHx8XG4gICAgICAgIGlzVHlwZWRBcnJheShvYmopIHx8XG4gICAgICAgIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICAgICAgICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIG9iaiBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKSkge1xuICAgICAgICByZXR1cm4gb2JqLnNsaWNlKDApO1xuICAgIH1cbiAgICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgICBjb25zdCBDb25zdHJ1Y3RvciA9IHByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgRGF0ZSB8fCBvYmogaW5zdGFuY2VvZiBNYXAgfHwgb2JqIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3Iob2JqKTtcbiAgICB9XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICBjb25zdCBuZXdSZWdFeHAgPSBuZXcgQ29uc3RydWN0b3Iob2JqKTtcbiAgICAgICAgbmV3UmVnRXhwLmxhc3RJbmRleCA9IG9iai5sYXN0SW5kZXg7XG4gICAgICAgIHJldHVybiBuZXdSZWdFeHA7XG4gICAgfVxuICAgIGlmIChvYmogaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKG9iai5idWZmZXIuc2xpY2UoMCkpO1xuICAgIH1cbiAgICBpZiAob2JqIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgY29uc3QgbmV3RXJyb3IgPSBuZXcgQ29uc3RydWN0b3Iob2JqLm1lc3NhZ2UpO1xuICAgICAgICBuZXdFcnJvci5zdGFjayA9IG9iai5zdGFjaztcbiAgICAgICAgbmV3RXJyb3IubmFtZSA9IG9iai5uYW1lO1xuICAgICAgICBuZXdFcnJvci5jYXVzZSA9IG9iai5jYXVzZTtcbiAgICAgICAgcmV0dXJuIG5ld0Vycm9yO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIEZpbGUgIT09ICd1bmRlZmluZWQnICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgY29uc3QgbmV3RmlsZSA9IG5ldyBDb25zdHJ1Y3Rvcihbb2JqXSwgb2JqLm5hbWUsIHsgdHlwZTogb2JqLnR5cGUsIGxhc3RNb2RpZmllZDogb2JqLmxhc3RNb2RpZmllZCB9KTtcbiAgICAgICAgcmV0dXJuIG5ld0ZpbGU7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCBuZXdPYmplY3QgPSBPYmplY3QuY3JlYXRlKHByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ld09iamVjdCwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZXhwb3J0IHsgY2xvbmUgfTtcbiIsImZ1bmN0aW9uIGdldFN5bWJvbHMob2JqZWN0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KS5maWx0ZXIoc3ltYm9sID0+IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCkpO1xufVxuXG5leHBvcnQgeyBnZXRTeW1ib2xzIH07XG4iLCJmdW5jdGlvbiBnZXRUYWcodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/ICdbb2JqZWN0IFVuZGVmaW5lZF0nIDogJ1tvYmplY3QgTnVsbF0nO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuZXhwb3J0IHsgZ2V0VGFnIH07XG4iLCJjb25zdCByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJztcbmNvbnN0IHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nO1xuY29uc3QgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXSc7XG5jb25zdCBib29sZWFuVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuY29uc3QgYXJndW1lbnRzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5jb25zdCBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcbmNvbnN0IGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXSc7XG5jb25zdCBtYXBUYWcgPSAnW29iamVjdCBNYXBdJztcbmNvbnN0IHNldFRhZyA9ICdbb2JqZWN0IFNldF0nO1xuY29uc3QgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nO1xuY29uc3QgZnVuY3Rpb25UYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuY29uc3QgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xuY29uc3Qgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5jb25zdCBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXSc7XG5jb25zdCBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5jb25zdCB1aW50OEFycmF5VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nO1xuY29uc3QgdWludDhDbGFtcGVkQXJyYXlUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nO1xuY29uc3QgdWludDE2QXJyYXlUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nO1xuY29uc3QgdWludDMyQXJyYXlUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuY29uc3QgYmlnVWludDY0QXJyYXlUYWcgPSAnW29iamVjdCBCaWdVaW50NjRBcnJheV0nO1xuY29uc3QgaW50OEFycmF5VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XSc7XG5jb25zdCBpbnQxNkFycmF5VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nO1xuY29uc3QgaW50MzJBcnJheVRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJztcbmNvbnN0IGJpZ0ludDY0QXJyYXlUYWcgPSAnW29iamVjdCBCaWdJbnQ2NEFycmF5XSc7XG5jb25zdCBmbG9hdDMyQXJyYXlUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJztcbmNvbnN0IGZsb2F0NjRBcnJheVRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nO1xuXG5leHBvcnQgeyBhcmd1bWVudHNUYWcsIGFycmF5QnVmZmVyVGFnLCBhcnJheVRhZywgYmlnSW50NjRBcnJheVRhZywgYmlnVWludDY0QXJyYXlUYWcsIGJvb2xlYW5UYWcsIGRhdGFWaWV3VGFnLCBkYXRlVGFnLCBlcnJvclRhZywgZmxvYXQzMkFycmF5VGFnLCBmbG9hdDY0QXJyYXlUYWcsIGZ1bmN0aW9uVGFnLCBpbnQxNkFycmF5VGFnLCBpbnQzMkFycmF5VGFnLCBpbnQ4QXJyYXlUYWcsIG1hcFRhZywgbnVtYmVyVGFnLCBvYmplY3RUYWcsIHJlZ2V4cFRhZywgc2V0VGFnLCBzdHJpbmdUYWcsIHN5bWJvbFRhZywgdWludDE2QXJyYXlUYWcsIHVpbnQzMkFycmF5VGFnLCB1aW50OEFycmF5VGFnLCB1aW50OENsYW1wZWRBcnJheVRhZyB9O1xuIiwiaW1wb3J0IHsgZ2V0U3ltYm9scyB9IGZyb20gJy4uL2NvbXBhdC9faW50ZXJuYWwvZ2V0U3ltYm9scy5tanMnO1xuaW1wb3J0IHsgZ2V0VGFnIH0gZnJvbSAnLi4vY29tcGF0L19pbnRlcm5hbC9nZXRUYWcubWpzJztcbmltcG9ydCB7IHVpbnQzMkFycmF5VGFnLCB1aW50MTZBcnJheVRhZywgdWludDhDbGFtcGVkQXJyYXlUYWcsIHVpbnQ4QXJyYXlUYWcsIHN5bWJvbFRhZywgc3RyaW5nVGFnLCBzZXRUYWcsIHJlZ2V4cFRhZywgb2JqZWN0VGFnLCBudW1iZXJUYWcsIG1hcFRhZywgaW50MzJBcnJheVRhZywgaW50MTZBcnJheVRhZywgaW50OEFycmF5VGFnLCBmbG9hdDY0QXJyYXlUYWcsIGZsb2F0MzJBcnJheVRhZywgZGF0ZVRhZywgYm9vbGVhblRhZywgZGF0YVZpZXdUYWcsIGFycmF5QnVmZmVyVGFnLCBhcnJheVRhZywgYXJndW1lbnRzVGFnIH0gZnJvbSAnLi4vY29tcGF0L19pbnRlcm5hbC90YWdzLm1qcyc7XG5pbXBvcnQgeyBpc1ByaW1pdGl2ZSB9IGZyb20gJy4uL3ByZWRpY2F0ZS9pc1ByaW1pdGl2ZS5tanMnO1xuaW1wb3J0IHsgaXNUeXBlZEFycmF5IH0gZnJvbSAnLi4vcHJlZGljYXRlL2lzVHlwZWRBcnJheS5tanMnO1xuXG5mdW5jdGlvbiBjbG9uZURlZXBXaXRoKG9iaiwgY2xvbmVWYWx1ZSkge1xuICAgIHJldHVybiBjbG9uZURlZXBXaXRoSW1wbChvYmosIHVuZGVmaW5lZCwgb2JqLCBuZXcgTWFwKCksIGNsb25lVmFsdWUpO1xufVxuZnVuY3Rpb24gY2xvbmVEZWVwV2l0aEltcGwodmFsdWVUb0Nsb25lLCBrZXlUb0Nsb25lLCBvYmplY3RUb0Nsb25lLCBzdGFjayA9IG5ldyBNYXAoKSwgY2xvbmVWYWx1ZSA9IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGNsb25lZCA9IGNsb25lVmFsdWU/Lih2YWx1ZVRvQ2xvbmUsIGtleVRvQ2xvbmUsIG9iamVjdFRvQ2xvbmUsIHN0YWNrKTtcbiAgICBpZiAoY2xvbmVkICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9XG4gICAgaWYgKGlzUHJpbWl0aXZlKHZhbHVlVG9DbG9uZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlVG9DbG9uZTtcbiAgICB9XG4gICAgaWYgKHN0YWNrLmhhcyh2YWx1ZVRvQ2xvbmUpKSB7XG4gICAgICAgIHJldHVybiBzdGFjay5nZXQodmFsdWVUb0Nsb25lKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVUb0Nsb25lKSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkodmFsdWVUb0Nsb25lLmxlbmd0aCk7XG4gICAgICAgIHN0YWNrLnNldCh2YWx1ZVRvQ2xvbmUsIHJlc3VsdCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVUb0Nsb25lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSBjbG9uZURlZXBXaXRoSW1wbCh2YWx1ZVRvQ2xvbmVbaV0sIGksIG9iamVjdFRvQ2xvbmUsIHN0YWNrLCBjbG9uZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0Lmhhc093bih2YWx1ZVRvQ2xvbmUsICdpbmRleCcpKSB7XG4gICAgICAgICAgICByZXN1bHQuaW5kZXggPSB2YWx1ZVRvQ2xvbmUuaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd24odmFsdWVUb0Nsb25lLCAnaW5wdXQnKSkge1xuICAgICAgICAgICAgcmVzdWx0LmlucHV0ID0gdmFsdWVUb0Nsb25lLmlucHV0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh2YWx1ZVRvQ2xvbmUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZVRvQ2xvbmUuZ2V0VGltZSgpKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlVG9DbG9uZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgUmVnRXhwKHZhbHVlVG9DbG9uZS5zb3VyY2UsIHZhbHVlVG9DbG9uZS5mbGFncyk7XG4gICAgICAgIHJlc3VsdC5sYXN0SW5kZXggPSB2YWx1ZVRvQ2xvbmUubGFzdEluZGV4O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodmFsdWVUb0Nsb25lIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgc3RhY2suc2V0KHZhbHVlVG9DbG9uZSwgcmVzdWx0KTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdmFsdWVUb0Nsb25lKSB7XG4gICAgICAgICAgICByZXN1bHQuc2V0KGtleSwgY2xvbmVEZWVwV2l0aEltcGwodmFsdWUsIGtleSwgb2JqZWN0VG9DbG9uZSwgc3RhY2ssIGNsb25lVmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodmFsdWVUb0Nsb25lIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQoKTtcbiAgICAgICAgc3RhY2suc2V0KHZhbHVlVG9DbG9uZSwgcmVzdWx0KTtcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZVRvQ2xvbmUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hZGQoY2xvbmVEZWVwV2l0aEltcGwodmFsdWUsIHVuZGVmaW5lZCwgb2JqZWN0VG9DbG9uZSwgc3RhY2ssIGNsb25lVmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgQnVmZmVyLmlzQnVmZmVyKHZhbHVlVG9DbG9uZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlVG9DbG9uZS5zdWJhcnJheSgpO1xuICAgIH1cbiAgICBpZiAoaXNUeXBlZEFycmF5KHZhbHVlVG9DbG9uZSkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IChPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWVUb0Nsb25lKS5jb25zdHJ1Y3RvcikodmFsdWVUb0Nsb25lLmxlbmd0aCk7XG4gICAgICAgIHN0YWNrLnNldCh2YWx1ZVRvQ2xvbmUsIHJlc3VsdCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVUb0Nsb25lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSBjbG9uZURlZXBXaXRoSW1wbCh2YWx1ZVRvQ2xvbmVbaV0sIGksIG9iamVjdFRvQ2xvbmUsIHN0YWNrLCBjbG9uZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodmFsdWVUb0Nsb25lIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHxcbiAgICAgICAgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWVUb0Nsb25lIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVRvQ2xvbmUuc2xpY2UoMCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZVRvQ2xvbmUgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgRGF0YVZpZXcodmFsdWVUb0Nsb25lLmJ1ZmZlci5zbGljZSgwKSwgdmFsdWVUb0Nsb25lLmJ5dGVPZmZzZXQsIHZhbHVlVG9DbG9uZS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgc3RhY2suc2V0KHZhbHVlVG9DbG9uZSwgcmVzdWx0KTtcbiAgICAgICAgY29weVByb3BlcnRpZXMocmVzdWx0LCB2YWx1ZVRvQ2xvbmUsIG9iamVjdFRvQ2xvbmUsIHN0YWNrLCBjbG9uZVZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBGaWxlICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZVRvQ2xvbmUgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBGaWxlKFt2YWx1ZVRvQ2xvbmVdLCB2YWx1ZVRvQ2xvbmUubmFtZSwge1xuICAgICAgICAgICAgdHlwZTogdmFsdWVUb0Nsb25lLnR5cGUsXG4gICAgICAgIH0pO1xuICAgICAgICBzdGFjay5zZXQodmFsdWVUb0Nsb25lLCByZXN1bHQpO1xuICAgICAgICBjb3B5UHJvcGVydGllcyhyZXN1bHQsIHZhbHVlVG9DbG9uZSwgb2JqZWN0VG9DbG9uZSwgc3RhY2ssIGNsb25lVmFsdWUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodmFsdWVUb0Nsb25lIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQmxvYihbdmFsdWVUb0Nsb25lXSwgeyB0eXBlOiB2YWx1ZVRvQ2xvbmUudHlwZSB9KTtcbiAgICAgICAgc3RhY2suc2V0KHZhbHVlVG9DbG9uZSwgcmVzdWx0KTtcbiAgICAgICAgY29weVByb3BlcnRpZXMocmVzdWx0LCB2YWx1ZVRvQ2xvbmUsIG9iamVjdFRvQ2xvbmUsIHN0YWNrLCBjbG9uZVZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHZhbHVlVG9DbG9uZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyB2YWx1ZVRvQ2xvbmUuY29uc3RydWN0b3IoKTtcbiAgICAgICAgc3RhY2suc2V0KHZhbHVlVG9DbG9uZSwgcmVzdWx0KTtcbiAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSB2YWx1ZVRvQ2xvbmUubWVzc2FnZTtcbiAgICAgICAgcmVzdWx0Lm5hbWUgPSB2YWx1ZVRvQ2xvbmUubmFtZTtcbiAgICAgICAgcmVzdWx0LnN0YWNrID0gdmFsdWVUb0Nsb25lLnN0YWNrO1xuICAgICAgICByZXN1bHQuY2F1c2UgPSB2YWx1ZVRvQ2xvbmUuY2F1c2U7XG4gICAgICAgIGNvcHlQcm9wZXJ0aWVzKHJlc3VsdCwgdmFsdWVUb0Nsb25lLCBvYmplY3RUb0Nsb25lLCBzdGFjaywgY2xvbmVWYWx1ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWVUb0Nsb25lID09PSAnb2JqZWN0JyAmJiBpc0Nsb25lYWJsZU9iamVjdCh2YWx1ZVRvQ2xvbmUpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlVG9DbG9uZSkpO1xuICAgICAgICBzdGFjay5zZXQodmFsdWVUb0Nsb25lLCByZXN1bHQpO1xuICAgICAgICBjb3B5UHJvcGVydGllcyhyZXN1bHQsIHZhbHVlVG9DbG9uZSwgb2JqZWN0VG9DbG9uZSwgc3RhY2ssIGNsb25lVmFsdWUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVUb0Nsb25lO1xufVxuZnVuY3Rpb24gY29weVByb3BlcnRpZXModGFyZ2V0LCBzb3VyY2UsIG9iamVjdFRvQ2xvbmUgPSB0YXJnZXQsIHN0YWNrLCBjbG9uZVZhbHVlKSB7XG4gICAgY29uc3Qga2V5cyA9IFsuLi5PYmplY3Qua2V5cyhzb3VyY2UpLCAuLi5nZXRTeW1ib2xzKHNvdXJjZSldO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yID09IG51bGwgfHwgZGVzY3JpcHRvci53cml0YWJsZSkge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBjbG9uZURlZXBXaXRoSW1wbChzb3VyY2Vba2V5XSwga2V5LCBvYmplY3RUb0Nsb25lLCBzdGFjaywgY2xvbmVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpc0Nsb25lYWJsZU9iamVjdChvYmplY3QpIHtcbiAgICBzd2l0Y2ggKGdldFRhZyhvYmplY3QpKSB7XG4gICAgICAgIGNhc2UgYXJndW1lbnRzVGFnOlxuICAgICAgICBjYXNlIGFycmF5VGFnOlxuICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgICBjYXNlIGJvb2xlYW5UYWc6XG4gICAgICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgICAgY2FzZSBmbG9hdDMyQXJyYXlUYWc6XG4gICAgICAgIGNhc2UgZmxvYXQ2NEFycmF5VGFnOlxuICAgICAgICBjYXNlIGludDhBcnJheVRhZzpcbiAgICAgICAgY2FzZSBpbnQxNkFycmF5VGFnOlxuICAgICAgICBjYXNlIGludDMyQXJyYXlUYWc6XG4gICAgICAgIGNhc2UgbWFwVGFnOlxuICAgICAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgICAgY2FzZSBvYmplY3RUYWc6XG4gICAgICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgICBjYXNlIHNldFRhZzpcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgICBjYXNlIHVpbnQ4QXJyYXlUYWc6XG4gICAgICAgIGNhc2UgdWludDhDbGFtcGVkQXJyYXlUYWc6XG4gICAgICAgIGNhc2UgdWludDE2QXJyYXlUYWc6XG4gICAgICAgIGNhc2UgdWludDMyQXJyYXlUYWc6IHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgY2xvbmVEZWVwV2l0aCwgY2xvbmVEZWVwV2l0aEltcGwsIGNvcHlQcm9wZXJ0aWVzIH07XG4iLCJpbXBvcnQgeyBjbG9uZURlZXBXaXRoSW1wbCB9IGZyb20gJy4vY2xvbmVEZWVwV2l0aC5tanMnO1xuXG5mdW5jdGlvbiBjbG9uZURlZXAob2JqKSB7XG4gICAgcmV0dXJuIGNsb25lRGVlcFdpdGhJbXBsKG9iaiwgdW5kZWZpbmVkLCBvYmosIG5ldyBNYXAoKSwgdW5kZWZpbmVkKTtcbn1cblxuZXhwb3J0IHsgY2xvbmVEZWVwIH07XG4iLCJmdW5jdGlvbiBmaW5kS2V5KG9iaiwgcHJlZGljYXRlKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgcmV0dXJuIGtleXMuZmluZChrZXkgPT4gcHJlZGljYXRlKG9ialtrZXldLCBrZXksIG9iaikpO1xufVxuXG5leHBvcnQgeyBmaW5kS2V5IH07XG4iLCJmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICAgIGNvbnN0IGhhc09iamVjdFByb3RvdHlwZSA9IHByb3RvID09PSBudWxsIHx8XG4gICAgICAgIHByb3RvID09PSBPYmplY3QucHJvdG90eXBlIHx8XG4gICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykgPT09IG51bGw7XG4gICAgaWYgKCFoYXNPYmplY3RQcm90b3R5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbmV4cG9ydCB7IGlzUGxhaW5PYmplY3QgfTtcbiIsImltcG9ydCB7IGlzUGxhaW5PYmplY3QgfSBmcm9tICcuLi9wcmVkaWNhdGUvaXNQbGFpbk9iamVjdC5tanMnO1xuXG5mdW5jdGlvbiBmbGF0dGVuT2JqZWN0KG9iamVjdCwgeyBkZWxpbWl0ZXIgPSAnLicgfSA9IHt9KSB7XG4gICAgcmV0dXJuIGZsYXR0ZW5PYmplY3RJbXBsKG9iamVjdCwgJycsIGRlbGltaXRlcik7XG59XG5mdW5jdGlvbiBmbGF0dGVuT2JqZWN0SW1wbChvYmplY3QsIHByZWZpeCA9ICcnLCBkZWxpbWl0ZXIgPSAnLicpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgY29uc3QgcHJlZml4ZWRLZXkgPSBwcmVmaXggPyBgJHtwcmVmaXh9JHtkZWxpbWl0ZXJ9JHtrZXl9YCA6IGtleTtcbiAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpICYmIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHJlc3VsdCwgZmxhdHRlbk9iamVjdEltcGwodmFsdWUsIHByZWZpeGVkS2V5LCBkZWxpbWl0ZXIpKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIGZsYXR0ZW5PYmplY3RJbXBsKHZhbHVlLCBwcmVmaXhlZEtleSwgZGVsaW1pdGVyKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbcHJlZml4ZWRLZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCB7IGZsYXR0ZW5PYmplY3QgfTtcbiIsImZ1bmN0aW9uIGludmVydChvYmopIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgICAgcmVzdWx0W3ZhbHVlXSA9IGtleTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IHsgaW52ZXJ0IH07XG4iLCJmdW5jdGlvbiBtYXBLZXlzKG9iamVjdCwgZ2V0TmV3S2V5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgIHJlc3VsdFtnZXROZXdLZXkodmFsdWUsIGtleSwgb2JqZWN0KV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IHsgbWFwS2V5cyB9O1xuIiwiZnVuY3Rpb24gbWFwVmFsdWVzKG9iamVjdCwgZ2V0TmV3VmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBnZXROZXdWYWx1ZSh2YWx1ZSwga2V5LCBvYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgeyBtYXBWYWx1ZXMgfTtcbiIsImltcG9ydCB7IGlzUGxhaW5PYmplY3QgfSBmcm9tICcuLi9wcmVkaWNhdGUvaXNQbGFpbk9iamVjdC5tanMnO1xuXG5mdW5jdGlvbiBtZXJnZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGNvbnN0IHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgICAgICBjb25zdCBzb3VyY2VWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICBjb25zdCB0YXJnZXRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2VWYWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRhcmdldFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gbWVyZ2UodGFyZ2V0VmFsdWUsIHNvdXJjZVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gbWVyZ2UoW10sIHNvdXJjZVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNvdXJjZVZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QodGFyZ2V0VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBtZXJnZSh0YXJnZXRWYWx1ZSwgc291cmNlVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBtZXJnZSh7fSwgc291cmNlVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRhcmdldFZhbHVlID09PSB1bmRlZmluZWQgfHwgc291cmNlVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2VWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5leHBvcnQgeyBtZXJnZSB9O1xuIiwiZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGw7XG59XG5cbmV4cG9ydCB7IGlzT2JqZWN0TGlrZSB9O1xuIiwiaW1wb3J0IHsgaXNPYmplY3RMaWtlIH0gZnJvbSAnLi4vY29tcGF0L3ByZWRpY2F0ZS9pc09iamVjdExpa2UubWpzJztcblxuZnVuY3Rpb24gbWVyZ2VXaXRoKHRhcmdldCwgc291cmNlLCBtZXJnZSkge1xuICAgIGNvbnN0IHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgICAgICBjb25zdCBzb3VyY2VWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICBjb25zdCB0YXJnZXRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICAgICAgICBjb25zdCBtZXJnZWQgPSBtZXJnZSh0YXJnZXRWYWx1ZSwgc291cmNlVmFsdWUsIGtleSwgdGFyZ2V0LCBzb3VyY2UpO1xuICAgICAgICBpZiAobWVyZ2VkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gbWVyZ2VkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlVmFsdWUpKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IG1lcmdlV2l0aCh0YXJnZXRWYWx1ZSA/PyBbXSwgc291cmNlVmFsdWUsIG1lcmdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc09iamVjdExpa2UodGFyZ2V0VmFsdWUpICYmIGlzT2JqZWN0TGlrZShzb3VyY2VWYWx1ZSkpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gbWVyZ2VXaXRoKHRhcmdldFZhbHVlID8/IHt9LCBzb3VyY2VWYWx1ZSwgbWVyZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRhcmdldFZhbHVlID09PSB1bmRlZmluZWQgfHwgc291cmNlVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2VWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5leHBvcnQgeyBtZXJnZVdpdGggfTtcbiIsImZ1bmN0aW9uIG9taXQob2JqLCBrZXlzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0geyAuLi5vYmogfTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgZGVsZXRlIHJlc3VsdFtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgeyBvbWl0IH07XG4iLCJmdW5jdGlvbiBvbWl0Qnkob2JqLCBzaG91bGRPbWl0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG4gICAgICAgIGlmICghc2hvdWxkT21pdCh2YWx1ZSwga2V5KSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgeyBvbWl0QnkgfTtcbiIsImZ1bmN0aW9uIHBpY2sob2JqLCBrZXlzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgeyBwaWNrIH07XG4iLCJmdW5jdGlvbiBwaWNrQnkob2JqLCBzaG91bGRQaWNrKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG4gICAgICAgIGlmIChzaG91bGRQaWNrKHZhbHVlLCBrZXkpKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCB7IHBpY2tCeSB9O1xuIiwiZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cblxuZXhwb3J0IHsgaXNBcnJheSB9O1xuIiwiZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHIpIHtcbiAgICByZXR1cm4gKHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKS50b0xvd2VyQ2FzZSgpKTtcbn1cblxuZXhwb3J0IHsgY2FwaXRhbGl6ZSB9O1xuIiwiY29uc3QgQ0FTRV9TUExJVF9QQVRURVJOID0gL1xccHtMdX0/XFxwe0xsfSt8WzAtOV0rfFxccHtMdX0rKD8hXFxwe0xsfSl8XFxwe0Vtb2ppX1ByZXNlbnRhdGlvbn18XFxwe0V4dGVuZGVkX1BpY3RvZ3JhcGhpY318XFxwe0x9Ky9ndTtcbmZ1bmN0aW9uIHdvcmRzKHN0cikge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHN0ci5tYXRjaChDQVNFX1NQTElUX1BBVFRFUk4pID8/IFtdKTtcbn1cblxuZXhwb3J0IHsgQ0FTRV9TUExJVF9QQVRURVJOLCB3b3JkcyB9O1xuIiwiaW1wb3J0IHsgY2FwaXRhbGl6ZSB9IGZyb20gJy4vY2FwaXRhbGl6ZS5tanMnO1xuaW1wb3J0IHsgd29yZHMgfSBmcm9tICcuL3dvcmRzLm1qcyc7XG5cbmZ1bmN0aW9uIGNhbWVsQ2FzZShzdHIpIHtcbiAgICBjb25zdCB3b3JkcyQxID0gd29yZHMoc3RyKTtcbiAgICBpZiAod29yZHMkMS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBjb25zdCBbZmlyc3QsIC4uLnJlc3RdID0gd29yZHMkMTtcbiAgICByZXR1cm4gYCR7Zmlyc3QudG9Mb3dlckNhc2UoKX0ke3Jlc3QubWFwKHdvcmQgPT4gY2FwaXRhbGl6ZSh3b3JkKSkuam9pbignJyl9YDtcbn1cblxuZXhwb3J0IHsgY2FtZWxDYXNlIH07XG4iLCJpbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnLi4vY29tcGF0L3ByZWRpY2F0ZS9pc0FycmF5Lm1qcyc7XG5pbXBvcnQgeyBpc1BsYWluT2JqZWN0IH0gZnJvbSAnLi4vcHJlZGljYXRlL2lzUGxhaW5PYmplY3QubWpzJztcbmltcG9ydCB7IGNhbWVsQ2FzZSB9IGZyb20gJy4uL3N0cmluZy9jYW1lbENhc2UubWpzJztcblxuZnVuY3Rpb24gdG9DYW1lbENhc2VLZXlzKG9iaikge1xuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG9iai5tYXAoaXRlbSA9PiB0b0NhbWVsQ2FzZUtleXMoaXRlbSkpO1xuICAgIH1cbiAgICBpZiAoaXNQbGFpbk9iamVjdChvYmopKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgY29uc3QgY2FtZWxLZXkgPSBjYW1lbENhc2Uoa2V5KTtcbiAgICAgICAgICAgIGNvbnN0IGNhbWVsQ2FzZUtleXMgPSB0b0NhbWVsQ2FzZUtleXMob2JqW2tleV0pO1xuICAgICAgICAgICAgcmVzdWx0W2NhbWVsS2V5XSA9IGNhbWVsQ2FzZUtleXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZXhwb3J0IHsgdG9DYW1lbENhc2VLZXlzIH07XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICcuL2Nsb25lRGVlcC5tanMnO1xuaW1wb3J0IHsgbWVyZ2UgfSBmcm9tICcuL21lcmdlLm1qcyc7XG5cbmZ1bmN0aW9uIHRvTWVyZ2VkKHRhcmdldCwgc291cmNlKSB7XG4gICAgcmV0dXJuIG1lcmdlKGNsb25lRGVlcCh0YXJnZXQpLCBzb3VyY2UpO1xufVxuXG5leHBvcnQgeyB0b01lcmdlZCB9O1xuIiwiZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmplY3QpIHtcbiAgICBpZiAodHlwZW9mIG9iamVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgY29uc3QgdGFnID0gb2JqZWN0W1N5bWJvbC50b1N0cmluZ1RhZ107XG4gICAgICAgIGlmICh0YWcgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzVGFnUmVhZG9ubHkgPSAhT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIFN5bWJvbC50b1N0cmluZ1RhZyk/LndyaXRhYmxlO1xuICAgICAgICBpZiAoaXNUYWdSZWFkb25seSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3QudG9TdHJpbmcoKSA9PT0gYFtvYmplY3QgJHt0YWd9XWA7XG4gICAgfVxuICAgIGxldCBwcm90byA9IG9iamVjdDtcbiAgICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSAhPT0gbnVsbCkge1xuICAgICAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KSA9PT0gcHJvdG87XG59XG5cbmV4cG9ydCB7IGlzUGxhaW5PYmplY3QgfTtcbiIsImltcG9ydCB7IHdvcmRzIH0gZnJvbSAnLi93b3Jkcy5tanMnO1xuXG5mdW5jdGlvbiBzbmFrZUNhc2Uoc3RyKSB7XG4gICAgY29uc3Qgd29yZHMkMSA9IHdvcmRzKHN0cik7XG4gICAgcmV0dXJuIHdvcmRzJDEubWFwKHdvcmQgPT4gd29yZC50b0xvd2VyQ2FzZSgpKS5qb2luKCdfJyk7XG59XG5cbmV4cG9ydCB7IHNuYWtlQ2FzZSB9O1xuIiwiaW1wb3J0IHsgaXNBcnJheSB9IGZyb20gJy4uL2NvbXBhdC9wcmVkaWNhdGUvaXNBcnJheS5tanMnO1xuaW1wb3J0IHsgaXNQbGFpbk9iamVjdCB9IGZyb20gJy4uL2NvbXBhdC9wcmVkaWNhdGUvaXNQbGFpbk9iamVjdC5tanMnO1xuaW1wb3J0IHsgc25ha2VDYXNlIH0gZnJvbSAnLi4vc3RyaW5nL3NuYWtlQ2FzZS5tanMnO1xuXG5mdW5jdGlvbiB0b1NuYWtlQ2FzZUtleXMob2JqKSB7XG4gICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICByZXR1cm4gb2JqLm1hcChpdGVtID0+IHRvU25ha2VDYXNlS2V5cyhpdGVtKSk7XG4gICAgfVxuICAgIGlmIChpc1BsYWluT2JqZWN0KG9iaikpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBjb25zdCBzbmFrZUtleSA9IHNuYWtlQ2FzZShrZXkpO1xuICAgICAgICAgICAgY29uc3Qgc25ha2VDYXNlS2V5cyA9IHRvU25ha2VDYXNlS2V5cyhvYmpba2V5XSk7XG4gICAgICAgICAgICByZXN1bHRbc25ha2VLZXldID0gc25ha2VDYXNlS2V5cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuXG5leHBvcnQgeyB0b1NuYWtlQ2FzZUtleXMgfTtcbiIsImZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbn1cblxuZXhwb3J0IHsgaXNBcnJheUJ1ZmZlciB9O1xuIiwiZnVuY3Rpb24gaXNCbG9iKHgpIHtcbiAgICBpZiAodHlwZW9mIEJsb2IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHggaW5zdGFuY2VvZiBCbG9iO1xufVxuXG5leHBvcnQgeyBpc0Jsb2IgfTtcbiIsImZ1bmN0aW9uIGlzQm9vbGVhbih4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnYm9vbGVhbic7XG59XG5cbmV4cG9ydCB7IGlzQm9vbGVhbiB9O1xuIiwiZnVuY3Rpb24gaXNCcm93c2VyKCkge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3c/LmRvY3VtZW50ICE9IG51bGw7XG59XG5cbmV4cG9ydCB7IGlzQnJvd3NlciB9O1xuIiwiZnVuY3Rpb24gaXNCdWZmZXIoeCkge1xuICAgIHJldHVybiB0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBCdWZmZXIuaXNCdWZmZXIoeCk7XG59XG5cbmV4cG9ydCB7IGlzQnVmZmVyIH07XG4iLCJmdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlO1xufVxuXG5leHBvcnQgeyBpc0RhdGUgfTtcbiIsImZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKE51bWJlci5pc05hTih2YWx1ZSkgJiYgTnVtYmVyLmlzTmFOKG90aGVyKSk7XG59XG5cbmV4cG9ydCB7IGVxIH07XG4iLCJpbXBvcnQgeyBpc1BsYWluT2JqZWN0IH0gZnJvbSAnLi9pc1BsYWluT2JqZWN0Lm1qcyc7XG5pbXBvcnQgeyBnZXRTeW1ib2xzIH0gZnJvbSAnLi4vY29tcGF0L19pbnRlcm5hbC9nZXRTeW1ib2xzLm1qcyc7XG5pbXBvcnQgeyBnZXRUYWcgfSBmcm9tICcuLi9jb21wYXQvX2ludGVybmFsL2dldFRhZy5tanMnO1xuaW1wb3J0IHsgZnVuY3Rpb25UYWcsIHJlZ2V4cFRhZywgc3ltYm9sVGFnLCBkYXRlVGFnLCBib29sZWFuVGFnLCBudW1iZXJUYWcsIHN0cmluZ1RhZywgb2JqZWN0VGFnLCBlcnJvclRhZywgZGF0YVZpZXdUYWcsIGFycmF5QnVmZmVyVGFnLCBmbG9hdDY0QXJyYXlUYWcsIGZsb2F0MzJBcnJheVRhZywgYmlnSW50NjRBcnJheVRhZywgaW50MzJBcnJheVRhZywgaW50MTZBcnJheVRhZywgaW50OEFycmF5VGFnLCBiaWdVaW50NjRBcnJheVRhZywgdWludDMyQXJyYXlUYWcsIHVpbnQxNkFycmF5VGFnLCB1aW50OENsYW1wZWRBcnJheVRhZywgdWludDhBcnJheVRhZywgYXJyYXlUYWcsIHNldFRhZywgbWFwVGFnLCBhcmd1bWVudHNUYWcgfSBmcm9tICcuLi9jb21wYXQvX2ludGVybmFsL3RhZ3MubWpzJztcbmltcG9ydCB7IGVxIH0gZnJvbSAnLi4vY29tcGF0L3V0aWwvZXEubWpzJztcblxuZnVuY3Rpb24gaXNFcXVhbFdpdGgoYSwgYiwgYXJlVmFsdWVzRXF1YWwpIHtcbiAgICByZXR1cm4gaXNFcXVhbFdpdGhJbXBsKGEsIGIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJlVmFsdWVzRXF1YWwpO1xufVxuZnVuY3Rpb24gaXNFcXVhbFdpdGhJbXBsKGEsIGIsIHByb3BlcnR5LCBhUGFyZW50LCBiUGFyZW50LCBzdGFjaywgYXJlVmFsdWVzRXF1YWwpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhcmVWYWx1ZXNFcXVhbChhLCBiLCBwcm9wZXJ0eSwgYVBhcmVudCwgYlBhcmVudCwgc3RhY2spO1xuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGEgPT09IHR5cGVvZiBiKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIGEpIHtcbiAgICAgICAgICAgIGNhc2UgJ2JpZ2ludCc6XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgICAgICAgY2FzZSAndW5kZWZpbmVkJzoge1xuICAgICAgICAgICAgICAgIHJldHVybiBhID09PSBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzoge1xuICAgICAgICAgICAgICAgIHJldHVybiBhID09PSBiIHx8IE9iamVjdC5pcyhhLCBiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzoge1xuICAgICAgICAgICAgICAgIHJldHVybiBhID09PSBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnb2JqZWN0Jzoge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmVPYmplY3RzRXF1YWwoYSwgYiwgc3RhY2ssIGFyZVZhbHVlc0VxdWFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJlT2JqZWN0c0VxdWFsKGEsIGIsIHN0YWNrLCBhcmVWYWx1ZXNFcXVhbCk7XG59XG5mdW5jdGlvbiBhcmVPYmplY3RzRXF1YWwoYSwgYiwgc3RhY2ssIGFyZVZhbHVlc0VxdWFsKSB7XG4gICAgaWYgKE9iamVjdC5pcyhhLCBiKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IGFUYWcgPSBnZXRUYWcoYSk7XG4gICAgbGV0IGJUYWcgPSBnZXRUYWcoYik7XG4gICAgaWYgKGFUYWcgPT09IGFyZ3VtZW50c1RhZykge1xuICAgICAgICBhVGFnID0gb2JqZWN0VGFnO1xuICAgIH1cbiAgICBpZiAoYlRhZyA9PT0gYXJndW1lbnRzVGFnKSB7XG4gICAgICAgIGJUYWcgPSBvYmplY3RUYWc7XG4gICAgfVxuICAgIGlmIChhVGFnICE9PSBiVGFnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3dpdGNoIChhVGFnKSB7XG4gICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAgICAgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuICAgICAgICBjYXNlIG51bWJlclRhZzoge1xuICAgICAgICAgICAgY29uc3QgeCA9IGEudmFsdWVPZigpO1xuICAgICAgICAgICAgY29uc3QgeSA9IGIudmFsdWVPZigpO1xuICAgICAgICAgICAgcmV0dXJuIGVxKHgsIHkpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgYm9vbGVhblRhZzpcbiAgICAgICAgY2FzZSBkYXRlVGFnOlxuICAgICAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuaXMoYS52YWx1ZU9mKCksIGIudmFsdWVPZigpKTtcbiAgICAgICAgY2FzZSByZWdleHBUYWc6IHtcbiAgICAgICAgICAgIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIGZ1bmN0aW9uVGFnOiB7XG4gICAgICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFjayA9IHN0YWNrID8/IG5ldyBNYXAoKTtcbiAgICBjb25zdCBhU3RhY2sgPSBzdGFjay5nZXQoYSk7XG4gICAgY29uc3QgYlN0YWNrID0gc3RhY2suZ2V0KGIpO1xuICAgIGlmIChhU3RhY2sgIT0gbnVsbCAmJiBiU3RhY2sgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYVN0YWNrID09PSBiO1xuICAgIH1cbiAgICBzdGFjay5zZXQoYSwgYik7XG4gICAgc3RhY2suc2V0KGIsIGEpO1xuICAgIHRyeSB7XG4gICAgICAgIHN3aXRjaCAoYVRhZykge1xuICAgICAgICAgICAgY2FzZSBtYXBUYWc6IHtcbiAgICAgICAgICAgICAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBhLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWIuaGFzKGtleSkgfHwgIWlzRXF1YWxXaXRoSW1wbCh2YWx1ZSwgYi5nZXQoa2V5KSwga2V5LCBhLCBiLCBzdGFjaywgYXJlVmFsdWVzRXF1YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIHNldFRhZzoge1xuICAgICAgICAgICAgICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGFWYWx1ZXMgPSBBcnJheS5mcm9tKGEudmFsdWVzKCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJWYWx1ZXMgPSBBcnJheS5mcm9tKGIudmFsdWVzKCkpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYVZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhVmFsdWUgPSBhVmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGJWYWx1ZXMuZmluZEluZGV4KGJWYWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNFcXVhbFdpdGhJbXBsKGFWYWx1ZSwgYlZhbHVlLCB1bmRlZmluZWQsIGEsIGIsIHN0YWNrLCBhcmVWYWx1ZXNFcXVhbCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYlZhbHVlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgYXJyYXlUYWc6XG4gICAgICAgICAgICBjYXNlIHVpbnQ4QXJyYXlUYWc6XG4gICAgICAgICAgICBjYXNlIHVpbnQ4Q2xhbXBlZEFycmF5VGFnOlxuICAgICAgICAgICAgY2FzZSB1aW50MTZBcnJheVRhZzpcbiAgICAgICAgICAgIGNhc2UgdWludDMyQXJyYXlUYWc6XG4gICAgICAgICAgICBjYXNlIGJpZ1VpbnQ2NEFycmF5VGFnOlxuICAgICAgICAgICAgY2FzZSBpbnQ4QXJyYXlUYWc6XG4gICAgICAgICAgICBjYXNlIGludDE2QXJyYXlUYWc6XG4gICAgICAgICAgICBjYXNlIGludDMyQXJyYXlUYWc6XG4gICAgICAgICAgICBjYXNlIGJpZ0ludDY0QXJyYXlUYWc6XG4gICAgICAgICAgICBjYXNlIGZsb2F0MzJBcnJheVRhZzpcbiAgICAgICAgICAgIGNhc2UgZmxvYXQ2NEFycmF5VGFnOiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIEJ1ZmZlci5pc0J1ZmZlcihhKSAhPT0gQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxXaXRoSW1wbChhW2ldLCBiW2ldLCBpLCBhLCBiLCBzdGFjaywgYXJlVmFsdWVzRXF1YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOiB7XG4gICAgICAgICAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZU9iamVjdHNFcXVhbChuZXcgVWludDhBcnJheShhKSwgbmV3IFVpbnQ4QXJyYXkoYiksIHN0YWNrLCBhcmVWYWx1ZXNFcXVhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIGRhdGFWaWV3VGFnOiB7XG4gICAgICAgICAgICAgICAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoIHx8IGEuYnl0ZU9mZnNldCAhPT0gYi5ieXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZU9iamVjdHNFcXVhbChuZXcgVWludDhBcnJheShhKSwgbmV3IFVpbnQ4QXJyYXkoYiksIHN0YWNrLCBhcmVWYWx1ZXNFcXVhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIGVycm9yVGFnOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEubmFtZSA9PT0gYi5uYW1lICYmIGEubWVzc2FnZSA9PT0gYi5tZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBvYmplY3RUYWc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmVFcXVhbEluc3RhbmNlcyA9IGFyZU9iamVjdHNFcXVhbChhLmNvbnN0cnVjdG9yLCBiLmNvbnN0cnVjdG9yLCBzdGFjaywgYXJlVmFsdWVzRXF1YWwpIHx8XG4gICAgICAgICAgICAgICAgICAgIChpc1BsYWluT2JqZWN0KGEpICYmIGlzUGxhaW5PYmplY3QoYikpO1xuICAgICAgICAgICAgICAgIGlmICghYXJlRXF1YWxJbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBhS2V5cyA9IFsuLi5PYmplY3Qua2V5cyhhKSwgLi4uZ2V0U3ltYm9scyhhKV07XG4gICAgICAgICAgICAgICAgY29uc3QgYktleXMgPSBbLi4uT2JqZWN0LmtleXMoYiksIC4uLmdldFN5bWJvbHMoYildO1xuICAgICAgICAgICAgICAgIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcEtleSA9IGFLZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhUHJvcCA9IGFbcHJvcEtleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghT2JqZWN0Lmhhc093bihiLCBwcm9wS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJQcm9wID0gYltwcm9wS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsV2l0aEltcGwoYVByb3AsIGJQcm9wLCBwcm9wS2V5LCBhLCBiLCBzdGFjaywgYXJlVmFsdWVzRXF1YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBzdGFjay5kZWxldGUoYSk7XG4gICAgICAgIHN0YWNrLmRlbGV0ZShiKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGlzRXF1YWxXaXRoIH07XG4iLCJpbXBvcnQgeyBpc0VxdWFsV2l0aCB9IGZyb20gJy4vaXNFcXVhbFdpdGgubWpzJztcbmltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi9mdW5jdGlvbi9ub29wLm1qcyc7XG5cbmZ1bmN0aW9uIGlzRXF1YWwoYSwgYikge1xuICAgIHJldHVybiBpc0VxdWFsV2l0aChhLCBiLCBub29wKTtcbn1cblxuZXhwb3J0IHsgaXNFcXVhbCB9O1xuIiwiZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEVycm9yO1xufVxuXG5leHBvcnQgeyBpc0Vycm9yIH07XG4iLCJpbXBvcnQgeyBpc0Jsb2IgfSBmcm9tICcuL2lzQmxvYi5tanMnO1xuXG5mdW5jdGlvbiBpc0ZpbGUoeCkge1xuICAgIGlmICh0eXBlb2YgRmlsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaXNCbG9iKHgpICYmIHggaW5zdGFuY2VvZiBGaWxlO1xufVxuXG5leHBvcnQgeyBpc0ZpbGUgfTtcbiIsImZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgeyBpc0Z1bmN0aW9uIH07XG4iLCJmdW5jdGlvbiBpc0pTT04odmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5leHBvcnQgeyBpc0pTT04gfTtcbiIsImltcG9ydCB7IGlzUGxhaW5PYmplY3QgfSBmcm9tICcuL2lzUGxhaW5PYmplY3QubWpzJztcblxuZnVuY3Rpb24gaXNKU09OVmFsdWUodmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgaXNKU09OQXJyYXkodmFsdWUpIHx8IGlzSlNPTk9iamVjdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6IHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzSlNPTkFycmF5KHZhbHVlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5ldmVyeShpdGVtID0+IGlzSlNPTlZhbHVlKGl0ZW0pKTtcbn1cbmZ1bmN0aW9uIGlzSlNPTk9iamVjdChvYmopIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3Qob2JqKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGtleXMgPSBSZWZsZWN0Lm93bktleXMob2JqKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0pTT05WYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IHsgaXNKU09OQXJyYXksIGlzSlNPTk9iamVjdCwgaXNKU09OVmFsdWUgfTtcbiIsImZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gICAgcmV0dXJuIE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSAmJiB2YWx1ZSA+PSAwO1xufVxuXG5leHBvcnQgeyBpc0xlbmd0aCB9O1xuIiwiZnVuY3Rpb24gaXNNYXAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBNYXA7XG59XG5cbmV4cG9ydCB7IGlzTWFwIH07XG4iLCJmdW5jdGlvbiBpc05pbCh4KSB7XG4gICAgcmV0dXJuIHggPT0gbnVsbDtcbn1cblxuZXhwb3J0IHsgaXNOaWwgfTtcbiIsImZ1bmN0aW9uIGlzTm9kZSgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3M/LnZlcnNpb25zPy5ub2RlICE9IG51bGw7XG59XG5cbmV4cG9ydCB7IGlzTm9kZSB9O1xuIiwiZnVuY3Rpb24gaXNOb3ROaWwoeCkge1xuICAgIHJldHVybiB4ICE9IG51bGw7XG59XG5cbmV4cG9ydCB7IGlzTm90TmlsIH07XG4iLCJmdW5jdGlvbiBpc051bGwoeCkge1xuICAgIHJldHVybiB4ID09PSBudWxsO1xufVxuXG5leHBvcnQgeyBpc051bGwgfTtcbiIsImZ1bmN0aW9uIGlzUHJvbWlzZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2U7XG59XG5cbmV4cG9ydCB7IGlzUHJvbWlzZSB9O1xuIiwiZnVuY3Rpb24gaXNSZWdFeHAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHA7XG59XG5cbmV4cG9ydCB7IGlzUmVnRXhwIH07XG4iLCJmdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFNldDtcbn1cblxuZXhwb3J0IHsgaXNTZXQgfTtcbiIsImZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG59XG5cbmV4cG9ydCB7IGlzU3RyaW5nIH07XG4iLCJmdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnO1xufVxuXG5leHBvcnQgeyBpc1N5bWJvbCB9O1xuIiwiZnVuY3Rpb24gaXNVbmRlZmluZWQoeCkge1xuICAgIHJldHVybiB4ID09PSB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCB7IGlzVW5kZWZpbmVkIH07XG4iLCJmdW5jdGlvbiBpc1dlYWtNYXAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBXZWFrTWFwO1xufVxuXG5leHBvcnQgeyBpc1dlYWtNYXAgfTtcbiIsImZ1bmN0aW9uIGlzV2Vha1NldCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFdlYWtTZXQ7XG59XG5cbmV4cG9ydCB7IGlzV2Vha1NldCB9O1xuIiwiY2xhc3MgU2VtYXBob3JlIHtcbiAgICBjYXBhY2l0eTtcbiAgICBhdmFpbGFibGU7XG4gICAgZGVmZXJyZWRUYXNrcyA9IFtdO1xuICAgIGNvbnN0cnVjdG9yKGNhcGFjaXR5KSB7XG4gICAgICAgIHRoaXMuY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICAgICAgdGhpcy5hdmFpbGFibGUgPSBjYXBhY2l0eTtcbiAgICB9XG4gICAgYXN5bmMgYWNxdWlyZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXZhaWxhYmxlID4gMCkge1xuICAgICAgICAgICAgdGhpcy5hdmFpbGFibGUtLTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRlZmVycmVkVGFza3MucHVzaChyZXNvbHZlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbGVhc2UoKSB7XG4gICAgICAgIGNvbnN0IGRlZmVycmVkVGFzayA9IHRoaXMuZGVmZXJyZWRUYXNrcy5zaGlmdCgpO1xuICAgICAgICBpZiAoZGVmZXJyZWRUYXNrICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRlZmVycmVkVGFzaygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF2YWlsYWJsZSA8IHRoaXMuY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIHRoaXMuYXZhaWxhYmxlKys7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IFNlbWFwaG9yZSB9O1xuIiwiaW1wb3J0IHsgU2VtYXBob3JlIH0gZnJvbSAnLi9zZW1hcGhvcmUubWpzJztcblxuY2xhc3MgTXV0ZXgge1xuICAgIHNlbWFwaG9yZSA9IG5ldyBTZW1hcGhvcmUoMSk7XG4gICAgZ2V0IGlzTG9ja2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW1hcGhvcmUuYXZhaWxhYmxlID09PSAwO1xuICAgIH1cbiAgICBhc3luYyBhY3F1aXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW1hcGhvcmUuYWNxdWlyZSgpO1xuICAgIH1cbiAgICByZWxlYXNlKCkge1xuICAgICAgICB0aGlzLnNlbWFwaG9yZS5yZWxlYXNlKCk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBNdXRleCB9O1xuIiwiaW1wb3J0IHsgZGVsYXkgfSBmcm9tICcuL2RlbGF5Lm1qcyc7XG5pbXBvcnQgeyBUaW1lb3V0RXJyb3IgfSBmcm9tICcuLi9lcnJvci9UaW1lb3V0RXJyb3IubWpzJztcblxuYXN5bmMgZnVuY3Rpb24gdGltZW91dChtcykge1xuICAgIGF3YWl0IGRlbGF5KG1zKTtcbiAgICB0aHJvdyBuZXcgVGltZW91dEVycm9yKCk7XG59XG5cbmV4cG9ydCB7IHRpbWVvdXQgfTtcbiIsImltcG9ydCB7IHRpbWVvdXQgfSBmcm9tICcuL3RpbWVvdXQubWpzJztcblxuYXN5bmMgZnVuY3Rpb24gd2l0aFRpbWVvdXQocnVuLCBtcykge1xuICAgIHJldHVybiBQcm9taXNlLnJhY2UoW3J1bigpLCB0aW1lb3V0KG1zKV0pO1xufVxuXG5leHBvcnQgeyB3aXRoVGltZW91dCB9O1xuIiwiaW1wb3J0IHsgd29yZHMgfSBmcm9tICcuL3dvcmRzLm1qcyc7XG5cbmZ1bmN0aW9uIGNvbnN0YW50Q2FzZShzdHIpIHtcbiAgICBjb25zdCB3b3JkcyQxID0gd29yZHMoc3RyKTtcbiAgICByZXR1cm4gd29yZHMkMS5tYXAod29yZCA9PiB3b3JkLnRvVXBwZXJDYXNlKCkpLmpvaW4oJ18nKTtcbn1cblxuZXhwb3J0IHsgY29uc3RhbnRDYXNlIH07XG4iLCJjb25zdCBkZWJ1cnJNYXAgPSBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKHtcbiAgICDDhjogJ0FlJyxcbiAgICDDkDogJ0QnLFxuICAgIMOYOiAnTycsXG4gICAgw546ICdUaCcsXG4gICAgw586ICdzcycsXG4gICAgw6Y6ICdhZScsXG4gICAgw7A6ICdkJyxcbiAgICDDuDogJ28nLFxuICAgIMO+OiAndGgnLFxuICAgIMSQOiAnRCcsXG4gICAgxJE6ICdkJyxcbiAgICDEpjogJ0gnLFxuICAgIMSnOiAnaCcsXG4gICAgxLE6ICdpJyxcbiAgICDEsjogJ0lKJyxcbiAgICDEszogJ2lqJyxcbiAgICDEuDogJ2snLFxuICAgIMS/OiAnTCcsXG4gICAgxYA6ICdsJyxcbiAgICDFgTogJ0wnLFxuICAgIMWCOiAnbCcsXG4gICAgxYk6IFwiJ25cIixcbiAgICDFijogJ04nLFxuICAgIMWLOiAnbicsXG4gICAgxZI6ICdPZScsXG4gICAgxZM6ICdvZScsXG4gICAgxaY6ICdUJyxcbiAgICDFpzogJ3QnLFxuICAgIMW/OiAncycsXG59KSk7XG5mdW5jdGlvbiBkZWJ1cnIoc3RyKSB7XG4gICAgc3RyID0gc3RyLm5vcm1hbGl6ZSgnTkZEJyk7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoYXIgPSBzdHJbaV07XG4gICAgICAgIGlmICgoY2hhciA+PSAnXFx1MDMwMCcgJiYgY2hhciA8PSAnXFx1MDM2ZicpIHx8IChjaGFyID49ICdcXHVmZTIwJyAmJiBjaGFyIDw9ICdcXHVmZTIzJykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBkZWJ1cnJNYXAuZ2V0KGNoYXIpID8/IGNoYXI7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCB7IGRlYnVyciB9O1xuIiwiY29uc3QgaHRtbEVzY2FwZXMgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiMzOTsnLFxufTtcbmZ1bmN0aW9uIGVzY2FwZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1smPD5cIiddL2csIG1hdGNoID0+IGh0bWxFc2NhcGVzW21hdGNoXSk7XG59XG5cbmV4cG9ydCB7IGVzY2FwZSB9O1xuIiwiZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csICdcXFxcJCYnKTtcbn1cblxuZXhwb3J0IHsgZXNjYXBlUmVnRXhwIH07XG4iLCJpbXBvcnQgeyB3b3JkcyB9IGZyb20gJy4vd29yZHMubWpzJztcblxuZnVuY3Rpb24ga2ViYWJDYXNlKHN0cikge1xuICAgIGNvbnN0IHdvcmRzJDEgPSB3b3JkcyhzdHIpO1xuICAgIHJldHVybiB3b3JkcyQxLm1hcCh3b3JkID0+IHdvcmQudG9Mb3dlckNhc2UoKSkuam9pbignLScpO1xufVxuXG5leHBvcnQgeyBrZWJhYkNhc2UgfTtcbiIsImltcG9ydCB7IHdvcmRzIH0gZnJvbSAnLi93b3Jkcy5tanMnO1xuXG5mdW5jdGlvbiBsb3dlckNhc2Uoc3RyKSB7XG4gICAgY29uc3Qgd29yZHMkMSA9IHdvcmRzKHN0cik7XG4gICAgcmV0dXJuIHdvcmRzJDEubWFwKHdvcmQgPT4gd29yZC50b0xvd2VyQ2FzZSgpKS5qb2luKCcgJyk7XG59XG5cbmV4cG9ydCB7IGxvd2VyQ2FzZSB9O1xuIiwiZnVuY3Rpb24gbG93ZXJGaXJzdChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnN1YnN0cmluZygwLCAxKS50b0xvd2VyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbn1cblxuZXhwb3J0IHsgbG93ZXJGaXJzdCB9O1xuIiwiZnVuY3Rpb24gcGFkKHN0ciwgbGVuZ3RoLCBjaGFycyA9ICcgJykge1xuICAgIHJldHVybiBzdHIucGFkU3RhcnQoTWF0aC5mbG9vcigobGVuZ3RoIC0gc3RyLmxlbmd0aCkgLyAyKSArIHN0ci5sZW5ndGgsIGNoYXJzKS5wYWRFbmQobGVuZ3RoLCBjaGFycyk7XG59XG5cbmV4cG9ydCB7IHBhZCB9O1xuIiwiaW1wb3J0IHsgY2FwaXRhbGl6ZSB9IGZyb20gJy4vY2FwaXRhbGl6ZS5tanMnO1xuaW1wb3J0IHsgd29yZHMgfSBmcm9tICcuL3dvcmRzLm1qcyc7XG5cbmZ1bmN0aW9uIHBhc2NhbENhc2Uoc3RyKSB7XG4gICAgY29uc3Qgd29yZHMkMSA9IHdvcmRzKHN0cik7XG4gICAgcmV0dXJuIHdvcmRzJDEubWFwKHdvcmQgPT4gY2FwaXRhbGl6ZSh3b3JkKSkuam9pbignJyk7XG59XG5cbmV4cG9ydCB7IHBhc2NhbENhc2UgfTtcbiIsImZ1bmN0aW9uIHJldmVyc2VTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gWy4uLnZhbHVlXS5yZXZlcnNlKCkuam9pbignJyk7XG59XG5cbmV4cG9ydCB7IHJldmVyc2VTdHJpbmcgfTtcbiIsImltcG9ydCB7IHdvcmRzIH0gZnJvbSAnLi93b3Jkcy5tanMnO1xuXG5mdW5jdGlvbiBzdGFydENhc2Uoc3RyKSB7XG4gICAgY29uc3Qgd29yZHMkMSA9IHdvcmRzKHN0ci50cmltKCkpO1xuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRzJDEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgd29yZCA9IHdvcmRzJDFbaV07XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnICc7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IHdvcmRbMF0udG9VcHBlckNhc2UoKSArIHdvcmQuc2xpY2UoMSkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IHsgc3RhcnRDYXNlIH07XG4iLCJmdW5jdGlvbiB0cmltRW5kKHN0ciwgY2hhcnMpIHtcbiAgICBpZiAoY2hhcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc3RyLnRyaW1FbmQoKTtcbiAgICB9XG4gICAgbGV0IGVuZEluZGV4ID0gc3RyLmxlbmd0aDtcbiAgICBzd2l0Y2ggKHR5cGVvZiBjaGFycykge1xuICAgICAgICBjYXNlICdzdHJpbmcnOiB7XG4gICAgICAgICAgICBpZiAoY2hhcnMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJ2NoYXJzJyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc2luZ2xlIGNoYXJhY3RlciBzdHJpbmcuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoZW5kSW5kZXggPiAwICYmIHN0cltlbmRJbmRleCAtIDFdID09PSBjaGFycykge1xuICAgICAgICAgICAgICAgIGVuZEluZGV4LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICAgICAgICB3aGlsZSAoZW5kSW5kZXggPiAwICYmIGNoYXJzLmluY2x1ZGVzKHN0cltlbmRJbmRleCAtIDFdKSkge1xuICAgICAgICAgICAgICAgIGVuZEluZGV4LS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgZW5kSW5kZXgpO1xufVxuXG5leHBvcnQgeyB0cmltRW5kIH07XG4iLCJmdW5jdGlvbiB0cmltU3RhcnQoc3RyLCBjaGFycykge1xuICAgIGlmIChjaGFycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzdHIudHJpbVN0YXJ0KCk7XG4gICAgfVxuICAgIGxldCBzdGFydEluZGV4ID0gMDtcbiAgICBzd2l0Y2ggKHR5cGVvZiBjaGFycykge1xuICAgICAgICBjYXNlICdzdHJpbmcnOiB7XG4gICAgICAgICAgICB3aGlsZSAoc3RhcnRJbmRleCA8IHN0ci5sZW5ndGggJiYgc3RyW3N0YXJ0SW5kZXhdID09PSBjaGFycykge1xuICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ29iamVjdCc6IHtcbiAgICAgICAgICAgIHdoaWxlIChzdGFydEluZGV4IDwgc3RyLmxlbmd0aCAmJiBjaGFycy5pbmNsdWRlcyhzdHJbc3RhcnRJbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKHN0YXJ0SW5kZXgpO1xufVxuXG5leHBvcnQgeyB0cmltU3RhcnQgfTtcbiIsImltcG9ydCB7IHRyaW1FbmQgfSBmcm9tICcuL3RyaW1FbmQubWpzJztcbmltcG9ydCB7IHRyaW1TdGFydCB9IGZyb20gJy4vdHJpbVN0YXJ0Lm1qcyc7XG5cbmZ1bmN0aW9uIHRyaW0oc3RyLCBjaGFycykge1xuICAgIGlmIChjaGFycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzdHIudHJpbSgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJpbVN0YXJ0KHRyaW1FbmQoc3RyLCBjaGFycyksIGNoYXJzKTtcbn1cblxuZXhwb3J0IHsgdHJpbSB9O1xuIiwiY29uc3QgaHRtbFVuZXNjYXBlcyA9IHtcbiAgICAnJmFtcDsnOiAnJicsXG4gICAgJyZsdDsnOiAnPCcsXG4gICAgJyZndDsnOiAnPicsXG4gICAgJyZxdW90Oyc6ICdcIicsXG4gICAgJyYjMzk7JzogXCInXCIsXG59O1xuZnVuY3Rpb24gdW5lc2NhcGUoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mKD86YW1wfGx0fGd0fHF1b3R8IygwKyk/MzkpOy9nLCBtYXRjaCA9PiBodG1sVW5lc2NhcGVzW21hdGNoXSB8fCBcIidcIik7XG59XG5cbmV4cG9ydCB7IHVuZXNjYXBlIH07XG4iLCJpbXBvcnQgeyB3b3JkcyB9IGZyb20gJy4vd29yZHMubWpzJztcblxuZnVuY3Rpb24gdXBwZXJDYXNlKHN0cikge1xuICAgIGNvbnN0IHdvcmRzJDEgPSB3b3JkcyhzdHIpO1xuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRzJDEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICs9IHdvcmRzJDFbaV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKGkgPCB3b3JkcyQxLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnICc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IHsgdXBwZXJDYXNlIH07XG4iLCJmdW5jdGlvbiB1cHBlckZpcnN0KHN0cikge1xuICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xufVxuXG5leHBvcnQgeyB1cHBlckZpcnN0IH07XG4iLCJmdW5jdGlvbiBhdHRlbXB0KGZ1bmMpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gW251bGwsIGZ1bmMoKV07XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gW2Vycm9yLCBudWxsXTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGF0dGVtcHQgfTtcbiIsImFzeW5jIGZ1bmN0aW9uIGF0dGVtcHRBc3luYyhmdW5jKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZnVuYygpO1xuICAgICAgICByZXR1cm4gW251bGwsIHJlc3VsdF07XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gW2Vycm9yLCBudWxsXTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGF0dGVtcHRBc3luYyB9O1xuIiwiZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG5cbmV4cG9ydCB7IGludmFyaWFudCB9O1xuIiwiaW1wb3J0IHsgQW55U2NoZW1hIH0gZnJvbSBcImFqdlwiO1xuaW1wb3J0IHsgVHlwZSB9IGZyb20gXCJAc2luY2xhaXIvdHlwZWJveFwiO1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0c0Zyb21TY2hlbWEoc2NoZW1hOiBBbnlTY2hlbWEpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgY29uc3QgcmVzdWx0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307XG4gIGNvbnN0IHByb3BlcnRpZXMgPSBzY2hlbWEucHJvcGVydGllcyB8fCB7fTtcbiAgY29uc3QgcmVxdWlyZWRQcm9wcyA9IEFycmF5LmlzQXJyYXkoc2NoZW1hLnJlcXVpcmVkKSA/IHNjaGVtYS5yZXF1aXJlZCA6IFtdO1xuXG4gIGNvbnNvbGUubG9nKFwiZ2V0RGVmYXVsdHNGcm9tU2NoZW1hXCIpO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwcm9wZXJ0aWVzKSkge1xuICAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgY29uc29sZS5sb2codmFsdWUpO1xuICAgIHJlc3VsdFtrZXldID0ge1xuICAgICAgcmVxdWlyZWQ6IHJlcXVpcmVkUHJvcHMuaW5jbHVkZXMoa2V5KSxcbiAgICAgIHZhbHVlOiB2YWx1ZS5kZWZhdWx0ID8/IFwiXCIsXG4gICAgfTtcbiAgICBpZiAoXCJub2RlVHlwZVwiIGluIHZhbHVlKSB7XG4gICAgICByZXN1bHRba2V5XS50eXBlID0gdmFsdWUubm9kZVR5cGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q3JlZGVudGlhbHNGcm9tU2NoZW1hKFxuICBzY2hlbWE6IFRTY2hlbWFcbik6IFJlY29yZDxzdHJpbmcsIHsgdHlwZTogc3RyaW5nOyBwYXNzd29yZD86IGJvb2xlYW4gfT4ge1xuICBjb25zdCByZXN1bHQ6IFJlY29yZDxzdHJpbmcsIHsgdHlwZTogc3RyaW5nOyBwYXNzd29yZD86IGJvb2xlYW4gfT4gPSB7fTtcbiAgY29uc3QgcHJvcGVydGllcyA9IHNjaGVtYS5wcm9wZXJ0aWVzIHx8IHt9O1xuICBjb25zdCByZXF1aXJlZFByb3BzID0gQXJyYXkuaXNBcnJheShzY2hlbWEucmVxdWlyZWQpID8gc2NoZW1hLnJlcXVpcmVkIDogW107XG5cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcGVydGllcykpIHtcbiAgICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgfVxuICAgIGNvbnN0IGlzUGFzc3dvcmQgPSB2YWx1ZS5mb3JtYXQgPT09IFwicGFzc3dvcmRcIjtcblxuICAgIHJlc3VsdFtrZXldID0ge1xuICAgICAgdHlwZTogaXNQYXNzd29yZCA/IFwicGFzc3dvcmRcIiA6IFwidGV4dFwiLFxuICAgICAgcmVxdWlyZWQ6IHJlcXVpcmVkUHJvcHMuaW5jbHVkZXMoa2V5KSxcbiAgICAgIHZhbHVlOiB2YWx1ZS5kZWZhdWx0ID8/IFwiXCIsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZFBhdHRlcm5XaXRoUFdEKHBhdHRlcm46IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IG9yaWdpbmFsID0gbmV3IFJlZ0V4cChgXiR7cGF0dGVybn0kYCk7XG4gIGNvbnN0IHB3ZCA9IC9eX19QV0RfXyQvO1xuICBjb25zdCBjb21iaW5lZCA9IG5ldyBSZWdFeHAoYCg/OiR7b3JpZ2luYWwuc291cmNlfXwke3B3ZC5zb3VyY2V9KWApO1xuICByZXR1cm4gY29tYmluZWQuc291cmNlO1xufVxuXG5mdW5jdGlvbiBwYXRjaFBhc3N3b3JkUGF0dGVybnMoc2NoZW1hOiBUU2NoZW1hKTogdm9pZCB7XG4gIGlmICghKFwicHJvcGVydGllc1wiIGluIHNjaGVtYSkpIHJldHVybjtcblxuICBjb25zdCBwcm9wcyA9IChzY2hlbWEgYXMgYW55KS5wcm9wZXJ0aWVzO1xuXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BzKSkge1xuICAgIGNvbnN0IHByb3AgPSB2YWx1ZSBhcyBhbnk7XG5cbiAgICBpZiAocHJvcC5mb3JtYXQgPT09IFwicGFzc3dvcmRcIiAmJiB0eXBlb2YgcHJvcC5wYXR0ZXJuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBwcm9wLnBhdHRlcm4gPSBleHRlbmRQYXR0ZXJuV2l0aFBXRChwcm9wLnBhdHRlcm4pO1xuICAgICAgcHJvcC5taW5MZW5ndGggPSAwOyAvLyBvcHRpb25hbDogYWxsb3cgXCJfX1BXRF9fXCJcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgZ2V0RGVmYXVsdHNGcm9tU2NoZW1hLFxuICBnZXRDcmVkZW50aWFsc0Zyb21TY2hlbWEsXG4gIHBhdGNoUGFzc3dvcmRQYXR0ZXJucyxcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVnZXhwQ29kZSA9IGV4cG9ydHMuZ2V0RXNtRXhwb3J0TmFtZSA9IGV4cG9ydHMuZ2V0UHJvcGVydHkgPSBleHBvcnRzLnNhZmVTdHJpbmdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyQ29uY2F0ID0gZXhwb3J0cy5hZGRDb2RlQXJnID0gZXhwb3J0cy5zdHIgPSBleHBvcnRzLl8gPSBleHBvcnRzLm5pbCA9IGV4cG9ydHMuX0NvZGUgPSBleHBvcnRzLk5hbWUgPSBleHBvcnRzLklERU5USUZJRVIgPSBleHBvcnRzLl9Db2RlT3JOYW1lID0gdm9pZCAwO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYW5lb3VzLWNsYXNzXG5jbGFzcyBfQ29kZU9yTmFtZSB7XG59XG5leHBvcnRzLl9Db2RlT3JOYW1lID0gX0NvZGVPck5hbWU7XG5leHBvcnRzLklERU5USUZJRVIgPSAvXlthLXokX11bYS16JF8wLTldKiQvaTtcbmNsYXNzIE5hbWUgZXh0ZW5kcyBfQ29kZU9yTmFtZSB7XG4gICAgY29uc3RydWN0b3Iocykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoIWV4cG9ydHMuSURFTlRJRklFUi50ZXN0KHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29kZUdlbjogbmFtZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclwiKTtcbiAgICAgICAgdGhpcy5zdHIgPSBzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyO1xuICAgIH1cbiAgICBlbXB0eVN0cigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB7IFt0aGlzLnN0cl06IDEgfTtcbiAgICB9XG59XG5leHBvcnRzLk5hbWUgPSBOYW1lO1xuY2xhc3MgX0NvZGUgZXh0ZW5kcyBfQ29kZU9yTmFtZSB7XG4gICAgY29uc3RydWN0b3IoY29kZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9pdGVtcyA9IHR5cGVvZiBjb2RlID09PSBcInN0cmluZ1wiID8gW2NvZGVdIDogY29kZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cjtcbiAgICB9XG4gICAgZW1wdHlTdHIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pdGVtcy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5faXRlbXNbMF07XG4gICAgICAgIHJldHVybiBpdGVtID09PSBcIlwiIHx8IGl0ZW0gPT09ICdcIlwiJztcbiAgICB9XG4gICAgZ2V0IHN0cigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuX3N0cikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKHRoaXMuX3N0ciA9IHRoaXMuX2l0ZW1zLnJlZHVjZSgocywgYykgPT4gYCR7c30ke2N9YCwgXCJcIikpKTtcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5fbmFtZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICh0aGlzLl9uYW1lcyA9IHRoaXMuX2l0ZW1zLnJlZHVjZSgobmFtZXMsIGMpID0+IHtcbiAgICAgICAgICAgIGlmIChjIGluc3RhbmNlb2YgTmFtZSlcbiAgICAgICAgICAgICAgICBuYW1lc1tjLnN0cl0gPSAobmFtZXNbYy5zdHJdIHx8IDApICsgMTtcbiAgICAgICAgICAgIHJldHVybiBuYW1lcztcbiAgICAgICAgfSwge30pKSk7XG4gICAgfVxufVxuZXhwb3J0cy5fQ29kZSA9IF9Db2RlO1xuZXhwb3J0cy5uaWwgPSBuZXcgX0NvZGUoXCJcIik7XG5mdW5jdGlvbiBfKHN0cnMsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBjb2RlID0gW3N0cnNbMF1dO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGFkZENvZGVBcmcoY29kZSwgYXJnc1tpXSk7XG4gICAgICAgIGNvZGUucHVzaChzdHJzWysraV0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9Db2RlKGNvZGUpO1xufVxuZXhwb3J0cy5fID0gXztcbmNvbnN0IHBsdXMgPSBuZXcgX0NvZGUoXCIrXCIpO1xuZnVuY3Rpb24gc3RyKHN0cnMsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBleHByID0gW3NhZmVTdHJpbmdpZnkoc3Ryc1swXSldO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGV4cHIucHVzaChwbHVzKTtcbiAgICAgICAgYWRkQ29kZUFyZyhleHByLCBhcmdzW2ldKTtcbiAgICAgICAgZXhwci5wdXNoKHBsdXMsIHNhZmVTdHJpbmdpZnkoc3Ryc1srK2ldKSk7XG4gICAgfVxuICAgIG9wdGltaXplKGV4cHIpO1xuICAgIHJldHVybiBuZXcgX0NvZGUoZXhwcik7XG59XG5leHBvcnRzLnN0ciA9IHN0cjtcbmZ1bmN0aW9uIGFkZENvZGVBcmcoY29kZSwgYXJnKSB7XG4gICAgaWYgKGFyZyBpbnN0YW5jZW9mIF9Db2RlKVxuICAgICAgICBjb2RlLnB1c2goLi4uYXJnLl9pdGVtcyk7XG4gICAgZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgTmFtZSlcbiAgICAgICAgY29kZS5wdXNoKGFyZyk7XG4gICAgZWxzZVxuICAgICAgICBjb2RlLnB1c2goaW50ZXJwb2xhdGUoYXJnKSk7XG59XG5leHBvcnRzLmFkZENvZGVBcmcgPSBhZGRDb2RlQXJnO1xuZnVuY3Rpb24gb3B0aW1pemUoZXhwcikge1xuICAgIGxldCBpID0gMTtcbiAgICB3aGlsZSAoaSA8IGV4cHIubGVuZ3RoIC0gMSkge1xuICAgICAgICBpZiAoZXhwcltpXSA9PT0gcGx1cykge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gbWVyZ2VFeHBySXRlbXMoZXhwcltpIC0gMV0sIGV4cHJbaSArIDFdKTtcbiAgICAgICAgICAgIGlmIChyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGV4cHIuc3BsaWNlKGkgLSAxLCAzLCByZXMpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwcltpKytdID0gXCIrXCI7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lcmdlRXhwckl0ZW1zKGEsIGIpIHtcbiAgICBpZiAoYiA9PT0gJ1wiXCInKVxuICAgICAgICByZXR1cm4gYTtcbiAgICBpZiAoYSA9PT0gJ1wiXCInKVxuICAgICAgICByZXR1cm4gYjtcbiAgICBpZiAodHlwZW9mIGEgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoYiBpbnN0YW5jZW9mIE5hbWUgfHwgYVthLmxlbmd0aCAtIDFdICE9PSAnXCInKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZW9mIGIgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiBgJHthLnNsaWNlKDAsIC0xKX0ke2J9XCJgO1xuICAgICAgICBpZiAoYlswXSA9PT0gJ1wiJylcbiAgICAgICAgICAgIHJldHVybiBhLnNsaWNlKDAsIC0xKSArIGIuc2xpY2UoMSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBiID09IFwic3RyaW5nXCIgJiYgYlswXSA9PT0gJ1wiJyAmJiAhKGEgaW5zdGFuY2VvZiBOYW1lKSlcbiAgICAgICAgcmV0dXJuIGBcIiR7YX0ke2Iuc2xpY2UoMSl9YDtcbiAgICByZXR1cm47XG59XG5mdW5jdGlvbiBzdHJDb25jYXQoYzEsIGMyKSB7XG4gICAgcmV0dXJuIGMyLmVtcHR5U3RyKCkgPyBjMSA6IGMxLmVtcHR5U3RyKCkgPyBjMiA6IHN0ciBgJHtjMX0ke2MyfWA7XG59XG5leHBvcnRzLnN0ckNvbmNhdCA9IHN0ckNvbmNhdDtcbi8vIFRPRE8gZG8gbm90IGFsbG93IGFycmF5cyBoZXJlXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSh4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHggPT0gXCJib29sZWFuXCIgfHwgeCA9PT0gbnVsbFxuICAgICAgICA/IHhcbiAgICAgICAgOiBzYWZlU3RyaW5naWZ5KEFycmF5LmlzQXJyYXkoeCkgPyB4LmpvaW4oXCIsXCIpIDogeCk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkoeCkge1xuICAgIHJldHVybiBuZXcgX0NvZGUoc2FmZVN0cmluZ2lmeSh4KSk7XG59XG5leHBvcnRzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcbmZ1bmN0aW9uIHNhZmVTdHJpbmdpZnkoeCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh4KVxuICAgICAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCBcIlxcXFx1MjAyOFwiKVxuICAgICAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCBcIlxcXFx1MjAyOVwiKTtcbn1cbmV4cG9ydHMuc2FmZVN0cmluZ2lmeSA9IHNhZmVTdHJpbmdpZnk7XG5mdW5jdGlvbiBnZXRQcm9wZXJ0eShrZXkpIHtcbiAgICByZXR1cm4gdHlwZW9mIGtleSA9PSBcInN0cmluZ1wiICYmIGV4cG9ydHMuSURFTlRJRklFUi50ZXN0KGtleSkgPyBuZXcgX0NvZGUoYC4ke2tleX1gKSA6IF8gYFske2tleX1dYDtcbn1cbmV4cG9ydHMuZ2V0UHJvcGVydHkgPSBnZXRQcm9wZXJ0eTtcbi8vRG9lcyBiZXN0IGVmZm9ydCB0byBmb3JtYXQgdGhlIG5hbWUgcHJvcGVybHlcbmZ1bmN0aW9uIGdldEVzbUV4cG9ydE5hbWUoa2V5KSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiAmJiBleHBvcnRzLklERU5USUZJRVIudGVzdChrZXkpKSB7XG4gICAgICAgIHJldHVybiBuZXcgX0NvZGUoYCR7a2V5fWApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IGludmFsaWQgZXhwb3J0IG5hbWU6ICR7a2V5fSwgdXNlIGV4cGxpY2l0ICRpZCBuYW1lIG1hcHBpbmdgKTtcbn1cbmV4cG9ydHMuZ2V0RXNtRXhwb3J0TmFtZSA9IGdldEVzbUV4cG9ydE5hbWU7XG5mdW5jdGlvbiByZWdleHBDb2RlKHJ4KSB7XG4gICAgcmV0dXJuIG5ldyBfQ29kZShyeC50b1N0cmluZygpKTtcbn1cbmV4cG9ydHMucmVnZXhwQ29kZSA9IHJlZ2V4cENvZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WYWx1ZVNjb3BlID0gZXhwb3J0cy5WYWx1ZVNjb3BlTmFtZSA9IGV4cG9ydHMuU2NvcGUgPSBleHBvcnRzLnZhcktpbmRzID0gZXhwb3J0cy5Vc2VkVmFsdWVTdGF0ZSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuL2NvZGVcIik7XG5jbGFzcyBWYWx1ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgc3VwZXIoYENvZGVHZW46IFwiY29kZVwiIGZvciAke25hbWV9IG5vdCBkZWZpbmVkYCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSBuYW1lLnZhbHVlO1xuICAgIH1cbn1cbnZhciBVc2VkVmFsdWVTdGF0ZTtcbihmdW5jdGlvbiAoVXNlZFZhbHVlU3RhdGUpIHtcbiAgICBVc2VkVmFsdWVTdGF0ZVtVc2VkVmFsdWVTdGF0ZVtcIlN0YXJ0ZWRcIl0gPSAwXSA9IFwiU3RhcnRlZFwiO1xuICAgIFVzZWRWYWx1ZVN0YXRlW1VzZWRWYWx1ZVN0YXRlW1wiQ29tcGxldGVkXCJdID0gMV0gPSBcIkNvbXBsZXRlZFwiO1xufSkoVXNlZFZhbHVlU3RhdGUgfHwgKGV4cG9ydHMuVXNlZFZhbHVlU3RhdGUgPSBVc2VkVmFsdWVTdGF0ZSA9IHt9KSk7XG5leHBvcnRzLnZhcktpbmRzID0ge1xuICAgIGNvbnN0OiBuZXcgY29kZV8xLk5hbWUoXCJjb25zdFwiKSxcbiAgICBsZXQ6IG5ldyBjb2RlXzEuTmFtZShcImxldFwiKSxcbiAgICB2YXI6IG5ldyBjb2RlXzEuTmFtZShcInZhclwiKSxcbn07XG5jbGFzcyBTY29wZSB7XG4gICAgY29uc3RydWN0b3IoeyBwcmVmaXhlcywgcGFyZW50IH0gPSB7fSkge1xuICAgICAgICB0aGlzLl9uYW1lcyA9IHt9O1xuICAgICAgICB0aGlzLl9wcmVmaXhlcyA9IHByZWZpeGVzO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIHRvTmFtZShuYW1lT3JQcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVPclByZWZpeCBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lID8gbmFtZU9yUHJlZml4IDogdGhpcy5uYW1lKG5hbWVPclByZWZpeCk7XG4gICAgfVxuICAgIG5hbWUocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBuZXcgY29kZV8xLk5hbWUodGhpcy5fbmV3TmFtZShwcmVmaXgpKTtcbiAgICB9XG4gICAgX25ld05hbWUocHJlZml4KSB7XG4gICAgICAgIGNvbnN0IG5nID0gdGhpcy5fbmFtZXNbcHJlZml4XSB8fCB0aGlzLl9uYW1lR3JvdXAocHJlZml4KTtcbiAgICAgICAgcmV0dXJuIGAke3ByZWZpeH0ke25nLmluZGV4Kyt9YDtcbiAgICB9XG4gICAgX25hbWVHcm91cChwcmVmaXgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCgoX2IgPSAoX2EgPSB0aGlzLl9wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5fcHJlZml4ZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oYXMocHJlZml4KSkgfHwgKHRoaXMuX3ByZWZpeGVzICYmICF0aGlzLl9wcmVmaXhlcy5oYXMocHJlZml4KSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogcHJlZml4IFwiJHtwcmVmaXh9XCIgaXMgbm90IGFsbG93ZWQgaW4gdGhpcyBzY29wZWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5fbmFtZXNbcHJlZml4XSA9IHsgcHJlZml4LCBpbmRleDogMCB9KTtcbiAgICB9XG59XG5leHBvcnRzLlNjb3BlID0gU2NvcGU7XG5jbGFzcyBWYWx1ZVNjb3BlTmFtZSBleHRlbmRzIGNvZGVfMS5OYW1lIHtcbiAgICBjb25zdHJ1Y3RvcihwcmVmaXgsIG5hbWVTdHIpIHtcbiAgICAgICAgc3VwZXIobmFtZVN0cik7XG4gICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSwgeyBwcm9wZXJ0eSwgaXRlbUluZGV4IH0pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNjb3BlUGF0aCA9ICgwLCBjb2RlXzEuXykgYC4ke25ldyBjb2RlXzEuTmFtZShwcm9wZXJ0eSl9WyR7aXRlbUluZGV4fV1gO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFsdWVTY29wZU5hbWUgPSBWYWx1ZVNjb3BlTmFtZTtcbmNvbnN0IGxpbmUgPSAoMCwgY29kZV8xLl8pIGBcXG5gO1xuY2xhc3MgVmFsdWVTY29wZSBleHRlbmRzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fc2NvcGUgPSBvcHRzLnNjb3BlO1xuICAgICAgICB0aGlzLm9wdHMgPSB7IC4uLm9wdHMsIF9uOiBvcHRzLmxpbmVzID8gbGluZSA6IGNvZGVfMS5uaWwgfTtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NvcGU7XG4gICAgfVxuICAgIG5hbWUocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBuZXcgVmFsdWVTY29wZU5hbWUocHJlZml4LCB0aGlzLl9uZXdOYW1lKHByZWZpeCkpO1xuICAgIH1cbiAgICB2YWx1ZShuYW1lT3JQcmVmaXgsIHZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHZhbHVlLnJlZiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29kZUdlbjogcmVmIG11c3QgYmUgcGFzc2VkIGluIHZhbHVlXCIpO1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgY29uc3QgeyBwcmVmaXggfSA9IG5hbWU7XG4gICAgICAgIGNvbnN0IHZhbHVlS2V5ID0gKF9hID0gdmFsdWUua2V5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2YWx1ZS5yZWY7XG4gICAgICAgIGxldCB2cyA9IHRoaXMuX3ZhbHVlc1twcmVmaXhdO1xuICAgICAgICBpZiAodnMpIHtcbiAgICAgICAgICAgIGNvbnN0IF9uYW1lID0gdnMuZ2V0KHZhbHVlS2V5KTtcbiAgICAgICAgICAgIGlmIChfbmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gX25hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2cyA9IHRoaXMuX3ZhbHVlc1twcmVmaXhdID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIHZzLnNldCh2YWx1ZUtleSwgbmFtZSk7XG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLl9zY29wZVtwcmVmaXhdIHx8ICh0aGlzLl9zY29wZVtwcmVmaXhdID0gW10pO1xuICAgICAgICBjb25zdCBpdGVtSW5kZXggPSBzLmxlbmd0aDtcbiAgICAgICAgc1tpdGVtSW5kZXhdID0gdmFsdWUucmVmO1xuICAgICAgICBuYW1lLnNldFZhbHVlKHZhbHVlLCB7IHByb3BlcnR5OiBwcmVmaXgsIGl0ZW1JbmRleCB9KTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIGdldFZhbHVlKHByZWZpeCwga2V5T3JSZWYpIHtcbiAgICAgICAgY29uc3QgdnMgPSB0aGlzLl92YWx1ZXNbcHJlZml4XTtcbiAgICAgICAgaWYgKCF2cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIHZzLmdldChrZXlPclJlZik7XG4gICAgfVxuICAgIHNjb3BlUmVmcyhzY29wZU5hbWUsIHZhbHVlcyA9IHRoaXMuX3ZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVkdWNlVmFsdWVzKHZhbHVlcywgKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmIChuYW1lLnNjb3BlUGF0aCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogbmFtZSBcIiR7bmFtZX1cIiBoYXMgbm8gdmFsdWVgKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY29kZV8xLl8pIGAke3Njb3BlTmFtZX0ke25hbWUuc2NvcGVQYXRofWA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzY29wZUNvZGUodmFsdWVzID0gdGhpcy5fdmFsdWVzLCB1c2VkVmFsdWVzLCBnZXRDb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWR1Y2VWYWx1ZXModmFsdWVzLCAobmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5hbWUudmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IG5hbWUgXCIke25hbWV9XCIgaGFzIG5vIHZhbHVlYCk7XG4gICAgICAgICAgICByZXR1cm4gbmFtZS52YWx1ZS5jb2RlO1xuICAgICAgICB9LCB1c2VkVmFsdWVzLCBnZXRDb2RlKTtcbiAgICB9XG4gICAgX3JlZHVjZVZhbHVlcyh2YWx1ZXMsIHZhbHVlQ29kZSwgdXNlZFZhbHVlcyA9IHt9LCBnZXRDb2RlKSB7XG4gICAgICAgIGxldCBjb2RlID0gY29kZV8xLm5pbDtcbiAgICAgICAgZm9yIChjb25zdCBwcmVmaXggaW4gdmFsdWVzKSB7XG4gICAgICAgICAgICBjb25zdCB2cyA9IHZhbHVlc1twcmVmaXhdO1xuICAgICAgICAgICAgaWYgKCF2cylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVTZXQgPSAodXNlZFZhbHVlc1twcmVmaXhdID0gdXNlZFZhbHVlc1twcmVmaXhdIHx8IG5ldyBNYXAoKSk7XG4gICAgICAgICAgICB2cy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVTZXQuaGFzKG5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgbmFtZVNldC5zZXQobmFtZSwgVXNlZFZhbHVlU3RhdGUuU3RhcnRlZCk7XG4gICAgICAgICAgICAgICAgbGV0IGMgPSB2YWx1ZUNvZGUobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmID0gdGhpcy5vcHRzLmVzNSA/IGV4cG9ydHMudmFyS2luZHMudmFyIDogZXhwb3J0cy52YXJLaW5kcy5jb25zdDtcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9ICgwLCBjb2RlXzEuXykgYCR7Y29kZX0ke2RlZn0gJHtuYW1lfSA9ICR7Y307JHt0aGlzLm9wdHMuX259YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKGMgPSBnZXRDb2RlID09PSBudWxsIHx8IGdldENvZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdldENvZGUobmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSAoMCwgY29kZV8xLl8pIGAke2NvZGV9JHtjfSR7dGhpcy5vcHRzLl9ufWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmFtZVNldC5zZXQobmFtZSwgVXNlZFZhbHVlU3RhdGUuQ29tcGxldGVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFsdWVTY29wZSA9IFZhbHVlU2NvcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY29wZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMub3IgPSBleHBvcnRzLmFuZCA9IGV4cG9ydHMubm90ID0gZXhwb3J0cy5Db2RlR2VuID0gZXhwb3J0cy5vcGVyYXRvcnMgPSBleHBvcnRzLnZhcktpbmRzID0gZXhwb3J0cy5WYWx1ZVNjb3BlTmFtZSA9IGV4cG9ydHMuVmFsdWVTY29wZSA9IGV4cG9ydHMuU2NvcGUgPSBleHBvcnRzLk5hbWUgPSBleHBvcnRzLnJlZ2V4cENvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IGV4cG9ydHMuZ2V0UHJvcGVydHkgPSBleHBvcnRzLm5pbCA9IGV4cG9ydHMuc3RyQ29uY2F0ID0gZXhwb3J0cy5zdHIgPSBleHBvcnRzLl8gPSB2b2lkIDA7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi9jb2RlXCIpO1xuY29uc3Qgc2NvcGVfMSA9IHJlcXVpcmUoXCIuL3Njb3BlXCIpO1xudmFyIGNvZGVfMiA9IHJlcXVpcmUoXCIuL2NvZGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuXzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0clwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLnN0cjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0ckNvbmNhdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLnN0ckNvbmNhdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5pbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLm5pbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFByb3BlcnR5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuZ2V0UHJvcGVydHk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJpbmdpZnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5zdHJpbmdpZnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWdleHBDb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIucmVnZXhwQ29kZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5OYW1lOyB9IH0pO1xudmFyIHNjb3BlXzIgPSByZXF1aXJlKFwiLi9zY29wZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNjb3BlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY29wZV8yLlNjb3BlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVmFsdWVTY29wZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NvcGVfMi5WYWx1ZVNjb3BlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVmFsdWVTY29wZU5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjb3BlXzIuVmFsdWVTY29wZU5hbWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2YXJLaW5kc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NvcGVfMi52YXJLaW5kczsgfSB9KTtcbmV4cG9ydHMub3BlcmF0b3JzID0ge1xuICAgIEdUOiBuZXcgY29kZV8xLl9Db2RlKFwiPlwiKSxcbiAgICBHVEU6IG5ldyBjb2RlXzEuX0NvZGUoXCI+PVwiKSxcbiAgICBMVDogbmV3IGNvZGVfMS5fQ29kZShcIjxcIiksXG4gICAgTFRFOiBuZXcgY29kZV8xLl9Db2RlKFwiPD1cIiksXG4gICAgRVE6IG5ldyBjb2RlXzEuX0NvZGUoXCI9PT1cIiksXG4gICAgTkVROiBuZXcgY29kZV8xLl9Db2RlKFwiIT09XCIpLFxuICAgIE5PVDogbmV3IGNvZGVfMS5fQ29kZShcIiFcIiksXG4gICAgT1I6IG5ldyBjb2RlXzEuX0NvZGUoXCJ8fFwiKSxcbiAgICBBTkQ6IG5ldyBjb2RlXzEuX0NvZGUoXCImJlwiKSxcbiAgICBBREQ6IG5ldyBjb2RlXzEuX0NvZGUoXCIrXCIpLFxufTtcbmNsYXNzIE5vZGUge1xuICAgIG9wdGltaXplTm9kZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKF9uYW1lcywgX2NvbnN0YW50cykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5jbGFzcyBEZWYgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YXJLaW5kLCBuYW1lLCByaHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YXJLaW5kID0gdmFyS2luZDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5yaHMgPSByaHM7XG4gICAgfVxuICAgIHJlbmRlcih7IGVzNSwgX24gfSkge1xuICAgICAgICBjb25zdCB2YXJLaW5kID0gZXM1ID8gc2NvcGVfMS52YXJLaW5kcy52YXIgOiB0aGlzLnZhcktpbmQ7XG4gICAgICAgIGNvbnN0IHJocyA9IHRoaXMucmhzID09PSB1bmRlZmluZWQgPyBcIlwiIDogYCA9ICR7dGhpcy5yaHN9YDtcbiAgICAgICAgcmV0dXJuIGAke3ZhcktpbmR9ICR7dGhpcy5uYW1lfSR7cmhzfTtgICsgX247XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICBpZiAoIW5hbWVzW3RoaXMubmFtZS5zdHJdKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5yaHMpXG4gICAgICAgICAgICB0aGlzLnJocyA9IG9wdGltaXplRXhwcih0aGlzLnJocywgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJocyBpbnN0YW5jZW9mIGNvZGVfMS5fQ29kZU9yTmFtZSA/IHRoaXMucmhzLm5hbWVzIDoge307XG4gICAgfVxufVxuY2xhc3MgQXNzaWduIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IobGhzLCByaHMsIHNpZGVFZmZlY3RzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubGhzID0gbGhzO1xuICAgICAgICB0aGlzLnJocyA9IHJocztcbiAgICAgICAgdGhpcy5zaWRlRWZmZWN0cyA9IHNpZGVFZmZlY3RzO1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmxoc30gPSAke3RoaXMucmhzfTtgICsgX247XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICBpZiAodGhpcy5saHMgaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSAmJiAhbmFtZXNbdGhpcy5saHMuc3RyXSAmJiAhdGhpcy5zaWRlRWZmZWN0cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5yaHMgPSBvcHRpbWl6ZUV4cHIodGhpcy5yaHMsIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICBjb25zdCBuYW1lcyA9IHRoaXMubGhzIGluc3RhbmNlb2YgY29kZV8xLk5hbWUgPyB7fSA6IHsgLi4udGhpcy5saHMubmFtZXMgfTtcbiAgICAgICAgcmV0dXJuIGFkZEV4cHJOYW1lcyhuYW1lcywgdGhpcy5yaHMpO1xuICAgIH1cbn1cbmNsYXNzIEFzc2lnbk9wIGV4dGVuZHMgQXNzaWduIHtcbiAgICBjb25zdHJ1Y3RvcihsaHMsIG9wLCByaHMsIHNpZGVFZmZlY3RzKSB7XG4gICAgICAgIHN1cGVyKGxocywgcmhzLCBzaWRlRWZmZWN0cyk7XG4gICAgICAgIHRoaXMub3AgPSBvcDtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5saHN9ICR7dGhpcy5vcH09ICR7dGhpcy5yaHN9O2AgKyBfbjtcbiAgICB9XG59XG5jbGFzcyBMYWJlbCBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGxhYmVsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgdGhpcy5uYW1lcyA9IHt9O1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmxhYmVsfTpgICsgX247XG4gICAgfVxufVxuY2xhc3MgQnJlYWsgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihsYWJlbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgICAgIHRoaXMubmFtZXMgPSB7fTtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICBjb25zdCBsYWJlbCA9IHRoaXMubGFiZWwgPyBgICR7dGhpcy5sYWJlbH1gIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIGBicmVhayR7bGFiZWx9O2AgKyBfbjtcbiAgICB9XG59XG5jbGFzcyBUaHJvdyBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGVycm9yKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICByZXR1cm4gYHRocm93ICR7dGhpcy5lcnJvcn07YCArIF9uO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yLm5hbWVzO1xuICAgIH1cbn1cbmNsYXNzIEFueUNvZGUgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY29kZX07YCArIF9uO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5vZGVzKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5jb2RlfWAgPyB0aGlzIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgdGhpcy5jb2RlID0gb3B0aW1pemVFeHByKHRoaXMuY29kZSwgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGUgaW5zdGFuY2VvZiBjb2RlXzEuX0NvZGVPck5hbWUgPyB0aGlzLmNvZGUubmFtZXMgOiB7fTtcbiAgICB9XG59XG5jbGFzcyBQYXJlbnROb2RlIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3Iobm9kZXMgPSBbXSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5vZGVzID0gbm9kZXM7XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLnJlZHVjZSgoY29kZSwgbikgPT4gY29kZSArIG4ucmVuZGVyKG9wdHMpLCBcIlwiKTtcbiAgICB9XG4gICAgb3B0aW1pemVOb2RlcygpIHtcbiAgICAgICAgY29uc3QgeyBub2RlcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBub2Rlc1tpXS5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShuKSlcbiAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSwgLi4ubik7XG4gICAgICAgICAgICBlbHNlIGlmIChuKVxuICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gbjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVzLmxlbmd0aCA+IDAgPyB0aGlzIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgY29uc3QgeyBub2RlcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIC8vIGl0ZXJhdGluZyBiYWNrd2FyZHMgaW1wcm92ZXMgMS1wYXNzIG9wdGltaXphdGlvblxuICAgICAgICAgICAgY29uc3QgbiA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKG4ub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHN1YnRyYWN0TmFtZXMobmFtZXMsIG4ubmFtZXMpO1xuICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2Rlcy5sZW5ndGggPiAwID8gdGhpcyA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5yZWR1Y2UoKG5hbWVzLCBuKSA9PiBhZGROYW1lcyhuYW1lcywgbi5uYW1lcyksIHt9KTtcbiAgICB9XG59XG5jbGFzcyBCbG9ja05vZGUgZXh0ZW5kcyBQYXJlbnROb2RlIHtcbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gXCJ7XCIgKyBvcHRzLl9uICsgc3VwZXIucmVuZGVyKG9wdHMpICsgXCJ9XCIgKyBvcHRzLl9uO1xuICAgIH1cbn1cbmNsYXNzIFJvb3QgZXh0ZW5kcyBQYXJlbnROb2RlIHtcbn1cbmNsYXNzIEVsc2UgZXh0ZW5kcyBCbG9ja05vZGUge1xufVxuRWxzZS5raW5kID0gXCJlbHNlXCI7XG5jbGFzcyBJZiBleHRlbmRzIEJsb2NrTm9kZSB7XG4gICAgY29uc3RydWN0b3IoY29uZGl0aW9uLCBub2Rlcykge1xuICAgICAgICBzdXBlcihub2Rlcyk7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICBsZXQgY29kZSA9IGBpZigke3RoaXMuY29uZGl0aW9ufSlgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgICAgICBpZiAodGhpcy5lbHNlKVxuICAgICAgICAgICAgY29kZSArPSBcImVsc2UgXCIgKyB0aGlzLmVsc2UucmVuZGVyKG9wdHMpO1xuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gICAgb3B0aW1pemVOb2RlcygpIHtcbiAgICAgICAgc3VwZXIub3B0aW1pemVOb2RlcygpO1xuICAgICAgICBjb25zdCBjb25kID0gdGhpcy5jb25kaXRpb247XG4gICAgICAgIGlmIChjb25kID09PSB0cnVlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZXM7IC8vIGVsc2UgaXMgaWdub3JlZCBoZXJlXG4gICAgICAgIGxldCBlID0gdGhpcy5lbHNlO1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgY29uc3QgbnMgPSBlLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgICAgIGUgPSB0aGlzLmVsc2UgPSBBcnJheS5pc0FycmF5KG5zKSA/IG5ldyBFbHNlKG5zKSA6IG5zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICBpZiAoY29uZCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBJZiA/IGUgOiBlLm5vZGVzO1xuICAgICAgICAgICAgaWYgKHRoaXMubm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJZihub3QoY29uZCksIGUgaW5zdGFuY2VvZiBJZiA/IFtlXSA6IGUubm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25kID09PSBmYWxzZSB8fCAhdGhpcy5ub2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5lbHNlID0gKF9hID0gdGhpcy5lbHNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgaWYgKCEoc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB8fCB0aGlzLmVsc2UpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IG9wdGltaXplRXhwcih0aGlzLmNvbmRpdGlvbiwgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gc3VwZXIubmFtZXM7XG4gICAgICAgIGFkZEV4cHJOYW1lcyhuYW1lcywgdGhpcy5jb25kaXRpb24pO1xuICAgICAgICBpZiAodGhpcy5lbHNlKVxuICAgICAgICAgICAgYWRkTmFtZXMobmFtZXMsIHRoaXMuZWxzZS5uYW1lcyk7XG4gICAgICAgIHJldHVybiBuYW1lcztcbiAgICB9XG59XG5JZi5raW5kID0gXCJpZlwiO1xuY2xhc3MgRm9yIGV4dGVuZHMgQmxvY2tOb2RlIHtcbn1cbkZvci5raW5kID0gXCJmb3JcIjtcbmNsYXNzIEZvckxvb3AgZXh0ZW5kcyBGb3Ige1xuICAgIGNvbnN0cnVjdG9yKGl0ZXJhdGlvbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLml0ZXJhdGlvbiA9IGl0ZXJhdGlvbjtcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGBmb3IoJHt0aGlzLml0ZXJhdGlvbn0pYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIGlmICghc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5pdGVyYXRpb24gPSBvcHRpbWl6ZUV4cHIodGhpcy5pdGVyYXRpb24sIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gYWRkTmFtZXMoc3VwZXIubmFtZXMsIHRoaXMuaXRlcmF0aW9uLm5hbWVzKTtcbiAgICB9XG59XG5jbGFzcyBGb3JSYW5nZSBleHRlbmRzIEZvciB7XG4gICAgY29uc3RydWN0b3IodmFyS2luZCwgbmFtZSwgZnJvbSwgdG8pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YXJLaW5kID0gdmFyS2luZDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICBjb25zdCB2YXJLaW5kID0gb3B0cy5lczUgPyBzY29wZV8xLnZhcktpbmRzLnZhciA6IHRoaXMudmFyS2luZDtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBmcm9tLCB0byB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGBmb3IoJHt2YXJLaW5kfSAke25hbWV9PSR7ZnJvbX07ICR7bmFtZX08JHt0b307ICR7bmFtZX0rKylgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gYWRkRXhwck5hbWVzKHN1cGVyLm5hbWVzLCB0aGlzLmZyb20pO1xuICAgICAgICByZXR1cm4gYWRkRXhwck5hbWVzKG5hbWVzLCB0aGlzLnRvKTtcbiAgICB9XG59XG5jbGFzcyBGb3JJdGVyIGV4dGVuZHMgRm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihsb29wLCB2YXJLaW5kLCBuYW1lLCBpdGVyYWJsZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxvb3AgPSBsb29wO1xuICAgICAgICB0aGlzLnZhcktpbmQgPSB2YXJLaW5kO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLml0ZXJhYmxlID0gaXRlcmFibGU7XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBgZm9yKCR7dGhpcy52YXJLaW5kfSAke3RoaXMubmFtZX0gJHt0aGlzLmxvb3B9ICR7dGhpcy5pdGVyYWJsZX0pYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIGlmICghc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5pdGVyYWJsZSA9IG9wdGltaXplRXhwcih0aGlzLml0ZXJhYmxlLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIGFkZE5hbWVzKHN1cGVyLm5hbWVzLCB0aGlzLml0ZXJhYmxlLm5hbWVzKTtcbiAgICB9XG59XG5jbGFzcyBGdW5jIGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBhcmdzLCBhc3luYykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICB0aGlzLmFzeW5jID0gYXN5bmM7XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIGNvbnN0IF9hc3luYyA9IHRoaXMuYXN5bmMgPyBcImFzeW5jIFwiIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIGAke19hc3luY31mdW5jdGlvbiAke3RoaXMubmFtZX0oJHt0aGlzLmFyZ3N9KWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxufVxuRnVuYy5raW5kID0gXCJmdW5jXCI7XG5jbGFzcyBSZXR1cm4gZXh0ZW5kcyBQYXJlbnROb2RlIHtcbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gXCJyZXR1cm4gXCIgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxufVxuUmV0dXJuLmtpbmQgPSBcInJldHVyblwiO1xuY2xhc3MgVHJ5IGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICBsZXQgY29kZSA9IFwidHJ5XCIgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgICAgIGlmICh0aGlzLmNhdGNoKVxuICAgICAgICAgICAgY29kZSArPSB0aGlzLmNhdGNoLnJlbmRlcihvcHRzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluYWxseSlcbiAgICAgICAgICAgIGNvZGUgKz0gdGhpcy5maW5hbGx5LnJlbmRlcihvcHRzKTtcbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICAgIG9wdGltaXplTm9kZXMoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHN1cGVyLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgKF9hID0gdGhpcy5jYXRjaCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgKF9iID0gdGhpcy5maW5hbGx5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub3B0aW1pemVOb2RlcygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHN1cGVyLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIChfYSA9IHRoaXMuY2F0Y2gpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICAoX2IgPSB0aGlzLmZpbmFsbHkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICBjb25zdCBuYW1lcyA9IHN1cGVyLm5hbWVzO1xuICAgICAgICBpZiAodGhpcy5jYXRjaClcbiAgICAgICAgICAgIGFkZE5hbWVzKG5hbWVzLCB0aGlzLmNhdGNoLm5hbWVzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluYWxseSlcbiAgICAgICAgICAgIGFkZE5hbWVzKG5hbWVzLCB0aGlzLmZpbmFsbHkubmFtZXMpO1xuICAgICAgICByZXR1cm4gbmFtZXM7XG4gICAgfVxufVxuY2xhc3MgQ2F0Y2ggZXh0ZW5kcyBCbG9ja05vZGUge1xuICAgIGNvbnN0cnVjdG9yKGVycm9yKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGBjYXRjaCgke3RoaXMuZXJyb3J9KWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxufVxuQ2F0Y2gua2luZCA9IFwiY2F0Y2hcIjtcbmNsYXNzIEZpbmFsbHkgZXh0ZW5kcyBCbG9ja05vZGUge1xuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBcImZpbmFsbHlcIiArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG59XG5GaW5hbGx5LmtpbmQgPSBcImZpbmFsbHlcIjtcbmNsYXNzIENvZGVHZW4ge1xuICAgIGNvbnN0cnVjdG9yKGV4dFNjb3BlLCBvcHRzID0ge30pIHtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0ge307XG4gICAgICAgIHRoaXMuX2Jsb2NrU3RhcnRzID0gW107XG4gICAgICAgIHRoaXMuX2NvbnN0YW50cyA9IHt9O1xuICAgICAgICB0aGlzLm9wdHMgPSB7IC4uLm9wdHMsIF9uOiBvcHRzLmxpbmVzID8gXCJcXG5cIiA6IFwiXCIgfTtcbiAgICAgICAgdGhpcy5fZXh0U2NvcGUgPSBleHRTY29wZTtcbiAgICAgICAgdGhpcy5fc2NvcGUgPSBuZXcgc2NvcGVfMS5TY29wZSh7IHBhcmVudDogZXh0U2NvcGUgfSk7XG4gICAgICAgIHRoaXMuX25vZGVzID0gW25ldyBSb290KCldO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3QucmVuZGVyKHRoaXMub3B0cyk7XG4gICAgfVxuICAgIC8vIHJldHVybnMgdW5pcXVlIG5hbWUgaW4gdGhlIGludGVybmFsIHNjb3BlXG4gICAgbmFtZShwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Njb3BlLm5hbWUocHJlZml4KTtcbiAgICB9XG4gICAgLy8gcmVzZXJ2ZXMgdW5pcXVlIG5hbWUgaW4gdGhlIGV4dGVybmFsIHNjb3BlXG4gICAgc2NvcGVOYW1lKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUubmFtZShwcmVmaXgpO1xuICAgIH1cbiAgICAvLyByZXNlcnZlcyB1bmlxdWUgbmFtZSBpbiB0aGUgZXh0ZXJuYWwgc2NvcGUgYW5kIGFzc2lnbnMgdmFsdWUgdG8gaXRcbiAgICBzY29wZVZhbHVlKHByZWZpeE9yTmFtZSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX2V4dFNjb3BlLnZhbHVlKHByZWZpeE9yTmFtZSwgdmFsdWUpO1xuICAgICAgICBjb25zdCB2cyA9IHRoaXMuX3ZhbHVlc1tuYW1lLnByZWZpeF0gfHwgKHRoaXMuX3ZhbHVlc1tuYW1lLnByZWZpeF0gPSBuZXcgU2V0KCkpO1xuICAgICAgICB2cy5hZGQobmFtZSk7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICBnZXRTY29wZVZhbHVlKHByZWZpeCwga2V5T3JSZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLmdldFZhbHVlKHByZWZpeCwga2V5T3JSZWYpO1xuICAgIH1cbiAgICAvLyByZXR1cm4gY29kZSB0aGF0IGFzc2lnbnMgdmFsdWVzIGluIHRoZSBleHRlcm5hbCBzY29wZSB0byB0aGUgbmFtZXMgdGhhdCBhcmUgdXNlZCBpbnRlcm5hbGx5XG4gICAgLy8gKHNhbWUgbmFtZXMgdGhhdCB3ZXJlIHJldHVybmVkIGJ5IGdlbi5zY29wZU5hbWUgb3IgZ2VuLnNjb3BlVmFsdWUpXG4gICAgc2NvcGVSZWZzKHNjb3BlTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUuc2NvcGVSZWZzKHNjb3BlTmFtZSwgdGhpcy5fdmFsdWVzKTtcbiAgICB9XG4gICAgc2NvcGVDb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUuc2NvcGVDb2RlKHRoaXMuX3ZhbHVlcyk7XG4gICAgfVxuICAgIF9kZWYodmFyS2luZCwgbmFtZU9yUHJlZml4LCByaHMsIGNvbnN0YW50KSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgaWYgKHJocyAhPT0gdW5kZWZpbmVkICYmIGNvbnN0YW50KVxuICAgICAgICAgICAgdGhpcy5fY29uc3RhbnRzW25hbWUuc3RyXSA9IHJocztcbiAgICAgICAgdGhpcy5fbGVhZk5vZGUobmV3IERlZih2YXJLaW5kLCBuYW1lLCByaHMpKTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIC8vIGBjb25zdGAgZGVjbGFyYXRpb24gKGB2YXJgIGluIGVzNSBtb2RlKVxuICAgIGNvbnN0KG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZihzY29wZV8xLnZhcktpbmRzLmNvbnN0LCBuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KTtcbiAgICB9XG4gICAgLy8gYGxldGAgZGVjbGFyYXRpb24gd2l0aCBvcHRpb25hbCBhc3NpZ25tZW50IChgdmFyYCBpbiBlczUgbW9kZSlcbiAgICBsZXQobmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmKHNjb3BlXzEudmFyS2luZHMubGV0LCBuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KTtcbiAgICB9XG4gICAgLy8gYHZhcmAgZGVjbGFyYXRpb24gd2l0aCBvcHRpb25hbCBhc3NpZ25tZW50XG4gICAgdmFyKG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZihzY29wZV8xLnZhcktpbmRzLnZhciwgbmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCk7XG4gICAgfVxuICAgIC8vIGFzc2lnbm1lbnQgY29kZVxuICAgIGFzc2lnbihsaHMsIHJocywgc2lkZUVmZmVjdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBBc3NpZ24obGhzLCByaHMsIHNpZGVFZmZlY3RzKSk7XG4gICAgfVxuICAgIC8vIGArPWAgY29kZVxuICAgIGFkZChsaHMsIHJocykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IEFzc2lnbk9wKGxocywgZXhwb3J0cy5vcGVyYXRvcnMuQURELCByaHMpKTtcbiAgICB9XG4gICAgLy8gYXBwZW5kcyBwYXNzZWQgU2FmZUV4cHIgdG8gY29kZSBvciBleGVjdXRlcyBCbG9ja1xuICAgIGNvZGUoYykge1xuICAgICAgICBpZiAodHlwZW9mIGMgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgYygpO1xuICAgICAgICBlbHNlIGlmIChjICE9PSBjb2RlXzEubmlsKVxuICAgICAgICAgICAgdGhpcy5fbGVhZk5vZGUobmV3IEFueUNvZGUoYykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gcmV0dXJucyBjb2RlIGZvciBvYmplY3QgbGl0ZXJhbCBmb3IgdGhlIHBhc3NlZCBhcmd1bWVudCBsaXN0IG9mIGtleS12YWx1ZSBwYWlyc1xuICAgIG9iamVjdCguLi5rZXlWYWx1ZXMpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IFtcIntcIl07XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGtleVZhbHVlcykge1xuICAgICAgICAgICAgaWYgKGNvZGUubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICBjb2RlLnB1c2goXCIsXCIpO1xuICAgICAgICAgICAgY29kZS5wdXNoKGtleSk7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSB2YWx1ZSB8fCB0aGlzLm9wdHMuZXM1KSB7XG4gICAgICAgICAgICAgICAgY29kZS5wdXNoKFwiOlwiKTtcbiAgICAgICAgICAgICAgICAoMCwgY29kZV8xLmFkZENvZGVBcmcpKGNvZGUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb2RlLnB1c2goXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbmV3IGNvZGVfMS5fQ29kZShjb2RlKTtcbiAgICB9XG4gICAgLy8gYGlmYCBjbGF1c2UgKG9yIHN0YXRlbWVudCBpZiBgdGhlbkJvZHlgIGFuZCwgb3B0aW9uYWxseSwgYGVsc2VCb2R5YCBhcmUgcGFzc2VkKVxuICAgIGlmKGNvbmRpdGlvbiwgdGhlbkJvZHksIGVsc2VCb2R5KSB7XG4gICAgICAgIHRoaXMuX2Jsb2NrTm9kZShuZXcgSWYoY29uZGl0aW9uKSk7XG4gICAgICAgIGlmICh0aGVuQm9keSAmJiBlbHNlQm9keSkge1xuICAgICAgICAgICAgdGhpcy5jb2RlKHRoZW5Cb2R5KS5lbHNlKCkuY29kZShlbHNlQm9keSkuZW5kSWYoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGVuQm9keSkge1xuICAgICAgICAgICAgdGhpcy5jb2RlKHRoZW5Cb2R5KS5lbmRJZigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsc2VCb2R5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwiZWxzZVwiIGJvZHkgd2l0aG91dCBcInRoZW5cIiBib2R5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGBlbHNlIGlmYCBjbGF1c2UgLSBpbnZhbGlkIHdpdGhvdXQgYGlmYCBvciBhZnRlciBgZWxzZWAgY2xhdXNlc1xuICAgIGVsc2VJZihjb25kaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vsc2VOb2RlKG5ldyBJZihjb25kaXRpb24pKTtcbiAgICB9XG4gICAgLy8gYGVsc2VgIGNsYXVzZSAtIG9ubHkgdmFsaWQgYWZ0ZXIgYGlmYCBvciBgZWxzZSBpZmAgY2xhdXNlc1xuICAgIGVsc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbHNlTm9kZShuZXcgRWxzZSgpKTtcbiAgICB9XG4gICAgLy8gZW5kIGBpZmAgc3RhdGVtZW50IChuZWVkZWQgaWYgZ2VuLmlmIHdhcyB1c2VkIG9ubHkgd2l0aCBjb25kaXRpb24pXG4gICAgZW5kSWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoSWYsIEVsc2UpO1xuICAgIH1cbiAgICBfZm9yKG5vZGUsIGZvckJvZHkpIHtcbiAgICAgICAgdGhpcy5fYmxvY2tOb2RlKG5vZGUpO1xuICAgICAgICBpZiAoZm9yQm9keSlcbiAgICAgICAgICAgIHRoaXMuY29kZShmb3JCb2R5KS5lbmRGb3IoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGEgZ2VuZXJpYyBgZm9yYCBjbGF1c2UgKG9yIHN0YXRlbWVudCBpZiBgZm9yQm9keWAgaXMgcGFzc2VkKVxuICAgIGZvcihpdGVyYXRpb24sIGZvckJvZHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvcihuZXcgRm9yTG9vcChpdGVyYXRpb24pLCBmb3JCb2R5KTtcbiAgICB9XG4gICAgLy8gYGZvcmAgc3RhdGVtZW50IGZvciBhIHJhbmdlIG9mIHZhbHVlc1xuICAgIGZvclJhbmdlKG5hbWVPclByZWZpeCwgZnJvbSwgdG8sIGZvckJvZHksIHZhcktpbmQgPSB0aGlzLm9wdHMuZXM1ID8gc2NvcGVfMS52YXJLaW5kcy52YXIgOiBzY29wZV8xLnZhcktpbmRzLmxldCkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvclJhbmdlKHZhcktpbmQsIG5hbWUsIGZyb20sIHRvKSwgKCkgPT4gZm9yQm9keShuYW1lKSk7XG4gICAgfVxuICAgIC8vIGBmb3Itb2ZgIHN0YXRlbWVudCAoaW4gZXM1IG1vZGUgcmVwbGFjZSB3aXRoIGEgbm9ybWFsIGZvciBsb29wKVxuICAgIGZvck9mKG5hbWVPclByZWZpeCwgaXRlcmFibGUsIGZvckJvZHksIHZhcktpbmQgPSBzY29wZV8xLnZhcktpbmRzLmNvbnN0KSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5lczUpIHtcbiAgICAgICAgICAgIGNvbnN0IGFyciA9IGl0ZXJhYmxlIGluc3RhbmNlb2YgY29kZV8xLk5hbWUgPyBpdGVyYWJsZSA6IHRoaXMudmFyKFwiX2FyclwiLCBpdGVyYWJsZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JSYW5nZShcIl9pXCIsIDAsICgwLCBjb2RlXzEuXykgYCR7YXJyfS5sZW5ndGhgLCAoaSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudmFyKG5hbWUsICgwLCBjb2RlXzEuXykgYCR7YXJyfVske2l9XWApO1xuICAgICAgICAgICAgICAgIGZvckJvZHkobmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZm9yKG5ldyBGb3JJdGVyKFwib2ZcIiwgdmFyS2luZCwgbmFtZSwgaXRlcmFibGUpLCAoKSA9PiBmb3JCb2R5KG5hbWUpKTtcbiAgICB9XG4gICAgLy8gYGZvci1pbmAgc3RhdGVtZW50LlxuICAgIC8vIFdpdGggb3B0aW9uIGBvd25Qcm9wZXJ0aWVzYCByZXBsYWNlZCB3aXRoIGEgYGZvci1vZmAgbG9vcCBmb3Igb2JqZWN0IGtleXNcbiAgICBmb3JJbihuYW1lT3JQcmVmaXgsIG9iaiwgZm9yQm9keSwgdmFyS2luZCA9IHRoaXMub3B0cy5lczUgPyBzY29wZV8xLnZhcktpbmRzLnZhciA6IHNjb3BlXzEudmFyS2luZHMuY29uc3QpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5vd25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JPZihuYW1lT3JQcmVmaXgsICgwLCBjb2RlXzEuXykgYE9iamVjdC5rZXlzKCR7b2JqfSlgLCBmb3JCb2R5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvckl0ZXIoXCJpblwiLCB2YXJLaW5kLCBuYW1lLCBvYmopLCAoKSA9PiBmb3JCb2R5KG5hbWUpKTtcbiAgICB9XG4gICAgLy8gZW5kIGBmb3JgIGxvb3BcbiAgICBlbmRGb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoRm9yKTtcbiAgICB9XG4gICAgLy8gYGxhYmVsYCBzdGF0ZW1lbnRcbiAgICBsYWJlbChsYWJlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IExhYmVsKGxhYmVsKSk7XG4gICAgfVxuICAgIC8vIGBicmVha2Agc3RhdGVtZW50XG4gICAgYnJlYWsobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBCcmVhayhsYWJlbCkpO1xuICAgIH1cbiAgICAvLyBgcmV0dXJuYCBzdGF0ZW1lbnRcbiAgICByZXR1cm4odmFsdWUpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBSZXR1cm4oKTtcbiAgICAgICAgdGhpcy5fYmxvY2tOb2RlKG5vZGUpO1xuICAgICAgICB0aGlzLmNvZGUodmFsdWUpO1xuICAgICAgICBpZiAobm9kZS5ub2Rlcy5sZW5ndGggIT09IDEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwicmV0dXJuXCIgc2hvdWxkIGhhdmUgb25lIG5vZGUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShSZXR1cm4pO1xuICAgIH1cbiAgICAvLyBgdHJ5YCBzdGF0ZW1lbnRcbiAgICB0cnkodHJ5Qm9keSwgY2F0Y2hDb2RlLCBmaW5hbGx5Q29kZSkge1xuICAgICAgICBpZiAoIWNhdGNoQ29kZSAmJiAhZmluYWxseUNvZGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwidHJ5XCIgd2l0aG91dCBcImNhdGNoXCIgYW5kIFwiZmluYWxseVwiJyk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgVHJ5KCk7XG4gICAgICAgIHRoaXMuX2Jsb2NrTm9kZShub2RlKTtcbiAgICAgICAgdGhpcy5jb2RlKHRyeUJvZHkpO1xuICAgICAgICBpZiAoY2F0Y2hDb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMubmFtZShcImVcIik7XG4gICAgICAgICAgICB0aGlzLl9jdXJyTm9kZSA9IG5vZGUuY2F0Y2ggPSBuZXcgQ2F0Y2goZXJyb3IpO1xuICAgICAgICAgICAgY2F0Y2hDb2RlKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmluYWxseUNvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJOb2RlID0gbm9kZS5maW5hbGx5ID0gbmV3IEZpbmFsbHkoKTtcbiAgICAgICAgICAgIHRoaXMuY29kZShmaW5hbGx5Q29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShDYXRjaCwgRmluYWxseSk7XG4gICAgfVxuICAgIC8vIGB0aHJvd2Agc3RhdGVtZW50XG4gICAgdGhyb3coZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBUaHJvdyhlcnJvcikpO1xuICAgIH1cbiAgICAvLyBzdGFydCBzZWxmLWJhbGFuY2luZyBibG9ja1xuICAgIGJsb2NrKGJvZHksIG5vZGVDb3VudCkge1xuICAgICAgICB0aGlzLl9ibG9ja1N0YXJ0cy5wdXNoKHRoaXMuX25vZGVzLmxlbmd0aCk7XG4gICAgICAgIGlmIChib2R5KVxuICAgICAgICAgICAgdGhpcy5jb2RlKGJvZHkpLmVuZEJsb2NrKG5vZGVDb3VudCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBlbmQgdGhlIGN1cnJlbnQgc2VsZi1iYWxhbmNpbmcgYmxvY2tcbiAgICBlbmRCbG9jayhub2RlQ291bnQpIHtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5fYmxvY2tTdGFydHMucG9wKCk7XG4gICAgICAgIGlmIChsZW4gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvZGVHZW46IG5vdCBpbiBzZWxmLWJhbGFuY2luZyBibG9ja1wiKTtcbiAgICAgICAgY29uc3QgdG9DbG9zZSA9IHRoaXMuX25vZGVzLmxlbmd0aCAtIGxlbjtcbiAgICAgICAgaWYgKHRvQ2xvc2UgPCAwIHx8IChub2RlQ291bnQgIT09IHVuZGVmaW5lZCAmJiB0b0Nsb3NlICE9PSBub2RlQ291bnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IHdyb25nIG51bWJlciBvZiBub2RlczogJHt0b0Nsb3NlfSB2cyAke25vZGVDb3VudH0gZXhwZWN0ZWRgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ub2Rlcy5sZW5ndGggPSBsZW47XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBgZnVuY3Rpb25gIGhlYWRpbmcgKG9yIGRlZmluaXRpb24gaWYgZnVuY0JvZHkgaXMgcGFzc2VkKVxuICAgIGZ1bmMobmFtZSwgYXJncyA9IGNvZGVfMS5uaWwsIGFzeW5jLCBmdW5jQm9keSkge1xuICAgICAgICB0aGlzLl9ibG9ja05vZGUobmV3IEZ1bmMobmFtZSwgYXJncywgYXN5bmMpKTtcbiAgICAgICAgaWYgKGZ1bmNCb2R5KVxuICAgICAgICAgICAgdGhpcy5jb2RlKGZ1bmNCb2R5KS5lbmRGdW5jKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBlbmQgZnVuY3Rpb24gZGVmaW5pdGlvblxuICAgIGVuZEZ1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoRnVuYyk7XG4gICAgfVxuICAgIG9wdGltaXplKG4gPSAxKSB7XG4gICAgICAgIHdoaWxlIChuLS0gPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yb290Lm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3Qub3B0aW1pemVOYW1lcyh0aGlzLl9yb290Lm5hbWVzLCB0aGlzLl9jb25zdGFudHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9sZWFmTm9kZShub2RlKSB7XG4gICAgICAgIHRoaXMuX2N1cnJOb2RlLm5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBfYmxvY2tOb2RlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5fY3Vyck5vZGUubm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgdGhpcy5fbm9kZXMucHVzaChub2RlKTtcbiAgICB9XG4gICAgX2VuZEJsb2NrTm9kZShOMSwgTjIpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuX2N1cnJOb2RlO1xuICAgICAgICBpZiAobiBpbnN0YW5jZW9mIE4xIHx8IChOMiAmJiBuIGluc3RhbmNlb2YgTjIpKSB7XG4gICAgICAgICAgICB0aGlzLl9ub2Rlcy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogbm90IGluIGJsb2NrIFwiJHtOMiA/IGAke04xLmtpbmR9LyR7TjIua2luZH1gIDogTjEua2luZH1cImApO1xuICAgIH1cbiAgICBfZWxzZU5vZGUobm9kZSkge1xuICAgICAgICBjb25zdCBuID0gdGhpcy5fY3Vyck5vZGU7XG4gICAgICAgIGlmICghKG4gaW5zdGFuY2VvZiBJZikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJlbHNlXCIgd2l0aG91dCBcImlmXCInKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdXJyTm9kZSA9IG4uZWxzZSA9IG5vZGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgX3Jvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub2Rlc1swXTtcbiAgICB9XG4gICAgZ2V0IF9jdXJyTm9kZSgpIHtcbiAgICAgICAgY29uc3QgbnMgPSB0aGlzLl9ub2RlcztcbiAgICAgICAgcmV0dXJuIG5zW25zLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBzZXQgX2N1cnJOb2RlKG5vZGUpIHtcbiAgICAgICAgY29uc3QgbnMgPSB0aGlzLl9ub2RlcztcbiAgICAgICAgbnNbbnMubGVuZ3RoIC0gMV0gPSBub2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29kZUdlbiA9IENvZGVHZW47XG5mdW5jdGlvbiBhZGROYW1lcyhuYW1lcywgZnJvbSkge1xuICAgIGZvciAoY29uc3QgbiBpbiBmcm9tKVxuICAgICAgICBuYW1lc1tuXSA9IChuYW1lc1tuXSB8fCAwKSArIChmcm9tW25dIHx8IDApO1xuICAgIHJldHVybiBuYW1lcztcbn1cbmZ1bmN0aW9uIGFkZEV4cHJOYW1lcyhuYW1lcywgZnJvbSkge1xuICAgIHJldHVybiBmcm9tIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlT3JOYW1lID8gYWRkTmFtZXMobmFtZXMsIGZyb20ubmFtZXMpIDogbmFtZXM7XG59XG5mdW5jdGlvbiBvcHRpbWl6ZUV4cHIoZXhwciwgbmFtZXMsIGNvbnN0YW50cykge1xuICAgIGlmIChleHByIGluc3RhbmNlb2YgY29kZV8xLk5hbWUpXG4gICAgICAgIHJldHVybiByZXBsYWNlTmFtZShleHByKTtcbiAgICBpZiAoIWNhbk9wdGltaXplKGV4cHIpKVxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICByZXR1cm4gbmV3IGNvZGVfMS5fQ29kZShleHByLl9pdGVtcy5yZWR1Y2UoKGl0ZW1zLCBjKSA9PiB7XG4gICAgICAgIGlmIChjIGluc3RhbmNlb2YgY29kZV8xLk5hbWUpXG4gICAgICAgICAgICBjID0gcmVwbGFjZU5hbWUoYyk7XG4gICAgICAgIGlmIChjIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlKVxuICAgICAgICAgICAgaXRlbXMucHVzaCguLi5jLl9pdGVtcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goYyk7XG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICB9LCBbXSkpO1xuICAgIGZ1bmN0aW9uIHJlcGxhY2VOYW1lKG4pIHtcbiAgICAgICAgY29uc3QgYyA9IGNvbnN0YW50c1tuLnN0cl07XG4gICAgICAgIGlmIChjID09PSB1bmRlZmluZWQgfHwgbmFtZXNbbi5zdHJdICE9PSAxKVxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIGRlbGV0ZSBuYW1lc1tuLnN0cl07XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5PcHRpbWl6ZShlKSB7XG4gICAgICAgIHJldHVybiAoZSBpbnN0YW5jZW9mIGNvZGVfMS5fQ29kZSAmJlxuICAgICAgICAgICAgZS5faXRlbXMuc29tZSgoYykgPT4gYyBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lICYmIG5hbWVzW2Muc3RyXSA9PT0gMSAmJiBjb25zdGFudHNbYy5zdHJdICE9PSB1bmRlZmluZWQpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdWJ0cmFjdE5hbWVzKG5hbWVzLCBmcm9tKSB7XG4gICAgZm9yIChjb25zdCBuIGluIGZyb20pXG4gICAgICAgIG5hbWVzW25dID0gKG5hbWVzW25dIHx8IDApIC0gKGZyb21bbl0gfHwgMCk7XG59XG5mdW5jdGlvbiBub3QoeCkge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PSBcImJvb2xlYW5cIiB8fCB0eXBlb2YgeCA9PSBcIm51bWJlclwiIHx8IHggPT09IG51bGwgPyAheCA6ICgwLCBjb2RlXzEuXykgYCEke3Bhcih4KX1gO1xufVxuZXhwb3J0cy5ub3QgPSBub3Q7XG5jb25zdCBhbmRDb2RlID0gbWFwcGVuZChleHBvcnRzLm9wZXJhdG9ycy5BTkQpO1xuLy8gYm9vbGVhbiBBTkQgKCYmKSBleHByZXNzaW9uIHdpdGggdGhlIHBhc3NlZCBhcmd1bWVudHNcbmZ1bmN0aW9uIGFuZCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGFyZ3MucmVkdWNlKGFuZENvZGUpO1xufVxuZXhwb3J0cy5hbmQgPSBhbmQ7XG5jb25zdCBvckNvZGUgPSBtYXBwZW5kKGV4cG9ydHMub3BlcmF0b3JzLk9SKTtcbi8vIGJvb2xlYW4gT1IgKHx8KSBleHByZXNzaW9uIHdpdGggdGhlIHBhc3NlZCBhcmd1bWVudHNcbmZ1bmN0aW9uIG9yKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gYXJncy5yZWR1Y2Uob3JDb2RlKTtcbn1cbmV4cG9ydHMub3IgPSBvcjtcbmZ1bmN0aW9uIG1hcHBlbmQob3ApIHtcbiAgICByZXR1cm4gKHgsIHkpID0+ICh4ID09PSBjb2RlXzEubmlsID8geSA6IHkgPT09IGNvZGVfMS5uaWwgPyB4IDogKDAsIGNvZGVfMS5fKSBgJHtwYXIoeCl9ICR7b3B9ICR7cGFyKHkpfWApO1xufVxuZnVuY3Rpb24gcGFyKHgpIHtcbiAgICByZXR1cm4geCBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lID8geCA6ICgwLCBjb2RlXzEuXykgYCgke3h9KWA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2hlY2tTdHJpY3RNb2RlID0gZXhwb3J0cy5nZXRFcnJvclBhdGggPSBleHBvcnRzLlR5cGUgPSBleHBvcnRzLnVzZUZ1bmMgPSBleHBvcnRzLnNldEV2YWx1YXRlZCA9IGV4cG9ydHMuZXZhbHVhdGVkUHJvcHNUb05hbWUgPSBleHBvcnRzLm1lcmdlRXZhbHVhdGVkID0gZXhwb3J0cy5lYWNoSXRlbSA9IGV4cG9ydHMudW5lc2NhcGVKc29uUG9pbnRlciA9IGV4cG9ydHMuZXNjYXBlSnNvblBvaW50ZXIgPSBleHBvcnRzLmVzY2FwZUZyYWdtZW50ID0gZXhwb3J0cy51bmVzY2FwZUZyYWdtZW50ID0gZXhwb3J0cy5zY2hlbWFSZWZPclZhbCA9IGV4cG9ydHMuc2NoZW1hSGFzUnVsZXNCdXRSZWYgPSBleHBvcnRzLnNjaGVtYUhhc1J1bGVzID0gZXhwb3J0cy5jaGVja1Vua25vd25SdWxlcyA9IGV4cG9ydHMuYWx3YXlzVmFsaWRTY2hlbWEgPSBleHBvcnRzLnRvSGFzaCA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvZGVnZW5cIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuL2NvZGVcIik7XG4vLyBUT0RPIHJlZmFjdG9yIHRvIHVzZSBTZXRcbmZ1bmN0aW9uIHRvSGFzaChhcnIpIHtcbiAgICBjb25zdCBoYXNoID0ge307XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGFycilcbiAgICAgICAgaGFzaFtpdGVtXSA9IHRydWU7XG4gICAgcmV0dXJuIGhhc2g7XG59XG5leHBvcnRzLnRvSGFzaCA9IHRvSGFzaDtcbmZ1bmN0aW9uIGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICBpZiAoT2JqZWN0LmtleXMoc2NoZW1hKS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGNoZWNrVW5rbm93blJ1bGVzKGl0LCBzY2hlbWEpO1xuICAgIHJldHVybiAhc2NoZW1hSGFzUnVsZXMoc2NoZW1hLCBpdC5zZWxmLlJVTEVTLmFsbCk7XG59XG5leHBvcnRzLmFsd2F5c1ZhbGlkU2NoZW1hID0gYWx3YXlzVmFsaWRTY2hlbWE7XG5mdW5jdGlvbiBjaGVja1Vua25vd25SdWxlcyhpdCwgc2NoZW1hID0gaXQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBvcHRzLCBzZWxmIH0gPSBpdDtcbiAgICBpZiAoIW9wdHMuc3RyaWN0U2NoZW1hKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgcnVsZXMgPSBzZWxmLlJVTEVTLmtleXdvcmRzO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICBpZiAoIXJ1bGVzW2tleV0pXG4gICAgICAgICAgICBjaGVja1N0cmljdE1vZGUoaXQsIGB1bmtub3duIGtleXdvcmQ6IFwiJHtrZXl9XCJgKTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrVW5rbm93blJ1bGVzID0gY2hlY2tVbmtub3duUnVsZXM7XG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlcyhzY2hlbWEsIHJ1bGVzKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiAhc2NoZW1hO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSlcbiAgICAgICAgaWYgKHJ1bGVzW2tleV0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLnNjaGVtYUhhc1J1bGVzID0gc2NoZW1hSGFzUnVsZXM7XG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlc0J1dFJlZihzY2hlbWEsIFJVTEVTKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiAhc2NoZW1hO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSlcbiAgICAgICAgaWYgKGtleSAhPT0gXCIkcmVmXCIgJiYgUlVMRVMuYWxsW2tleV0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLnNjaGVtYUhhc1J1bGVzQnV0UmVmID0gc2NoZW1hSGFzUnVsZXNCdXRSZWY7XG5mdW5jdGlvbiBzY2hlbWFSZWZPclZhbCh7IHRvcFNjaGVtYVJlZiwgc2NoZW1hUGF0aCB9LCBzY2hlbWEsIGtleXdvcmQsICRkYXRhKSB7XG4gICAgaWYgKCEkZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm51bWJlclwiIHx8IHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCR7c2NoZW1hfWA7XG4gICAgfVxuICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAke3RvcFNjaGVtYVJlZn0ke3NjaGVtYVBhdGh9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShrZXl3b3JkKX1gO1xufVxuZXhwb3J0cy5zY2hlbWFSZWZPclZhbCA9IHNjaGVtYVJlZk9yVmFsO1xuZnVuY3Rpb24gdW5lc2NhcGVGcmFnbWVudChzdHIpIHtcbiAgICByZXR1cm4gdW5lc2NhcGVKc29uUG9pbnRlcihkZWNvZGVVUklDb21wb25lbnQoc3RyKSk7XG59XG5leHBvcnRzLnVuZXNjYXBlRnJhZ21lbnQgPSB1bmVzY2FwZUZyYWdtZW50O1xuZnVuY3Rpb24gZXNjYXBlRnJhZ21lbnQoc3RyKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChlc2NhcGVKc29uUG9pbnRlcihzdHIpKTtcbn1cbmV4cG9ydHMuZXNjYXBlRnJhZ21lbnQgPSBlc2NhcGVGcmFnbWVudDtcbmZ1bmN0aW9uIGVzY2FwZUpzb25Qb2ludGVyKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyID09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBgJHtzdHJ9YDtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL34vZywgXCJ+MFwiKS5yZXBsYWNlKC9cXC8vZywgXCJ+MVwiKTtcbn1cbmV4cG9ydHMuZXNjYXBlSnNvblBvaW50ZXIgPSBlc2NhcGVKc29uUG9pbnRlcjtcbmZ1bmN0aW9uIHVuZXNjYXBlSnNvblBvaW50ZXIoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+MS9nLCBcIi9cIikucmVwbGFjZSgvfjAvZywgXCJ+XCIpO1xufVxuZXhwb3J0cy51bmVzY2FwZUpzb25Qb2ludGVyID0gdW5lc2NhcGVKc29uUG9pbnRlcjtcbmZ1bmN0aW9uIGVhY2hJdGVtKHhzLCBmKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoeHMpKSB7XG4gICAgICAgIGZvciAoY29uc3QgeCBvZiB4cylcbiAgICAgICAgICAgIGYoeCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmKHhzKTtcbiAgICB9XG59XG5leHBvcnRzLmVhY2hJdGVtID0gZWFjaEl0ZW07XG5mdW5jdGlvbiBtYWtlTWVyZ2VFdmFsdWF0ZWQoeyBtZXJnZU5hbWVzLCBtZXJnZVRvTmFtZSwgbWVyZ2VWYWx1ZXMsIHJlc3VsdFRvTmFtZSwgfSkge1xuICAgIHJldHVybiAoZ2VuLCBmcm9tLCB0bywgdG9OYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRvID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gZnJvbVxuICAgICAgICAgICAgOiB0byBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lXG4gICAgICAgICAgICAgICAgPyAoZnJvbSBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lID8gbWVyZ2VOYW1lcyhnZW4sIGZyb20sIHRvKSA6IG1lcmdlVG9OYW1lKGdlbiwgZnJvbSwgdG8pLCB0bylcbiAgICAgICAgICAgICAgICA6IGZyb20gaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZVxuICAgICAgICAgICAgICAgICAgICA/IChtZXJnZVRvTmFtZShnZW4sIHRvLCBmcm9tKSwgZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgOiBtZXJnZVZhbHVlcyhmcm9tLCB0byk7XG4gICAgICAgIHJldHVybiB0b05hbWUgPT09IGNvZGVnZW5fMS5OYW1lICYmICEocmVzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpID8gcmVzdWx0VG9OYW1lKGdlbiwgcmVzKSA6IHJlcztcbiAgICB9O1xufVxuZXhwb3J0cy5tZXJnZUV2YWx1YXRlZCA9IHtcbiAgICBwcm9wczogbWFrZU1lcmdlRXZhbHVhdGVkKHtcbiAgICAgICAgbWVyZ2VOYW1lczogKGdlbiwgZnJvbSwgdG8pID0+IGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke3RvfSAhPT0gdHJ1ZSAmJiAke2Zyb219ICE9PSB1bmRlZmluZWRgLCAoKSA9PiB7XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtmcm9tfSA9PT0gdHJ1ZWAsICgpID0+IGdlbi5hc3NpZ24odG8sIHRydWUpLCAoKSA9PiBnZW4uYXNzaWduKHRvLCAoMCwgY29kZWdlbl8xLl8pIGAke3RvfSB8fCB7fWApLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgT2JqZWN0LmFzc2lnbigke3RvfSwgJHtmcm9tfSlgKSk7XG4gICAgICAgIH0pLFxuICAgICAgICBtZXJnZVRvTmFtZTogKGdlbiwgZnJvbSwgdG8pID0+IGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke3RvfSAhPT0gdHJ1ZWAsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChmcm9tID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih0bywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHRvLCAoMCwgY29kZWdlbl8xLl8pIGAke3RvfSB8fCB7fWApO1xuICAgICAgICAgICAgICAgIHNldEV2YWx1YXRlZChnZW4sIHRvLCBmcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIG1lcmdlVmFsdWVzOiAoZnJvbSwgdG8pID0+IChmcm9tID09PSB0cnVlID8gdHJ1ZSA6IHsgLi4uZnJvbSwgLi4udG8gfSksXG4gICAgICAgIHJlc3VsdFRvTmFtZTogZXZhbHVhdGVkUHJvcHNUb05hbWUsXG4gICAgfSksXG4gICAgaXRlbXM6IG1ha2VNZXJnZUV2YWx1YXRlZCh7XG4gICAgICAgIG1lcmdlTmFtZXM6IChnZW4sIGZyb20sIHRvKSA9PiBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHt0b30gIT09IHRydWUgJiYgJHtmcm9tfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT4gZ2VuLmFzc2lnbih0bywgKDAsIGNvZGVnZW5fMS5fKSBgJHtmcm9tfSA9PT0gdHJ1ZSA/IHRydWUgOiAke3RvfSA+ICR7ZnJvbX0gPyAke3RvfSA6ICR7ZnJvbX1gKSksXG4gICAgICAgIG1lcmdlVG9OYW1lOiAoZ2VuLCBmcm9tLCB0bykgPT4gZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7dG99ICE9PSB0cnVlYCwgKCkgPT4gZ2VuLmFzc2lnbih0bywgZnJvbSA9PT0gdHJ1ZSA/IHRydWUgOiAoMCwgY29kZWdlbl8xLl8pIGAke3RvfSA+ICR7ZnJvbX0gPyAke3RvfSA6ICR7ZnJvbX1gKSksXG4gICAgICAgIG1lcmdlVmFsdWVzOiAoZnJvbSwgdG8pID0+IChmcm9tID09PSB0cnVlID8gdHJ1ZSA6IE1hdGgubWF4KGZyb20sIHRvKSksXG4gICAgICAgIHJlc3VsdFRvTmFtZTogKGdlbiwgaXRlbXMpID0+IGdlbi52YXIoXCJpdGVtc1wiLCBpdGVtcyksXG4gICAgfSksXG59O1xuZnVuY3Rpb24gZXZhbHVhdGVkUHJvcHNUb05hbWUoZ2VuLCBwcykge1xuICAgIGlmIChwcyA9PT0gdHJ1ZSlcbiAgICAgICAgcmV0dXJuIGdlbi52YXIoXCJwcm9wc1wiLCB0cnVlKTtcbiAgICBjb25zdCBwcm9wcyA9IGdlbi52YXIoXCJwcm9wc1wiLCAoMCwgY29kZWdlbl8xLl8pIGB7fWApO1xuICAgIGlmIChwcyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBzZXRFdmFsdWF0ZWQoZ2VuLCBwcm9wcywgcHMpO1xuICAgIHJldHVybiBwcm9wcztcbn1cbmV4cG9ydHMuZXZhbHVhdGVkUHJvcHNUb05hbWUgPSBldmFsdWF0ZWRQcm9wc1RvTmFtZTtcbmZ1bmN0aW9uIHNldEV2YWx1YXRlZChnZW4sIHByb3BzLCBwcykge1xuICAgIE9iamVjdC5rZXlzKHBzKS5mb3JFYWNoKChwKSA9PiBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7cHJvcHN9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShwKX1gLCB0cnVlKSk7XG59XG5leHBvcnRzLnNldEV2YWx1YXRlZCA9IHNldEV2YWx1YXRlZDtcbmNvbnN0IHNuaXBwZXRzID0ge307XG5mdW5jdGlvbiB1c2VGdW5jKGdlbiwgZikge1xuICAgIHJldHVybiBnZW4uc2NvcGVWYWx1ZShcImZ1bmNcIiwge1xuICAgICAgICByZWY6IGYsXG4gICAgICAgIGNvZGU6IHNuaXBwZXRzW2YuY29kZV0gfHwgKHNuaXBwZXRzW2YuY29kZV0gPSBuZXcgY29kZV8xLl9Db2RlKGYuY29kZSkpLFxuICAgIH0pO1xufVxuZXhwb3J0cy51c2VGdW5jID0gdXNlRnVuYztcbnZhciBUeXBlO1xuKGZ1bmN0aW9uIChUeXBlKSB7XG4gICAgVHlwZVtUeXBlW1wiTnVtXCJdID0gMF0gPSBcIk51bVwiO1xuICAgIFR5cGVbVHlwZVtcIlN0clwiXSA9IDFdID0gXCJTdHJcIjtcbn0pKFR5cGUgfHwgKGV4cG9ydHMuVHlwZSA9IFR5cGUgPSB7fSkpO1xuZnVuY3Rpb24gZ2V0RXJyb3JQYXRoKGRhdGFQcm9wLCBkYXRhUHJvcFR5cGUsIGpzUHJvcGVydHlTeW50YXgpIHtcbiAgICAvLyBsZXQgcGF0aFxuICAgIGlmIChkYXRhUHJvcCBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKSB7XG4gICAgICAgIGNvbnN0IGlzTnVtYmVyID0gZGF0YVByb3BUeXBlID09PSBUeXBlLk51bTtcbiAgICAgICAgcmV0dXJuIGpzUHJvcGVydHlTeW50YXhcbiAgICAgICAgICAgID8gaXNOdW1iZXJcbiAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuXykgYFwiW1wiICsgJHtkYXRhUHJvcH0gKyBcIl1cImBcbiAgICAgICAgICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuXykgYFwiWydcIiArICR7ZGF0YVByb3B9ICsgXCInXVwiYFxuICAgICAgICAgICAgOiBpc051bWJlclxuICAgICAgICAgICAgICAgID8gKDAsIGNvZGVnZW5fMS5fKSBgXCIvXCIgKyAke2RhdGFQcm9wfWBcbiAgICAgICAgICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuXykgYFwiL1wiICsgJHtkYXRhUHJvcH0ucmVwbGFjZSgvfi9nLCBcIn4wXCIpLnJlcGxhY2UoL1xcXFwvL2csIFwifjFcIilgOyAvLyBUT0RPIG1heWJlIHVzZSBnbG9iYWwgZXNjYXBlUG9pbnRlclxuICAgIH1cbiAgICByZXR1cm4ganNQcm9wZXJ0eVN5bnRheCA/ICgwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKGRhdGFQcm9wKS50b1N0cmluZygpIDogXCIvXCIgKyBlc2NhcGVKc29uUG9pbnRlcihkYXRhUHJvcCk7XG59XG5leHBvcnRzLmdldEVycm9yUGF0aCA9IGdldEVycm9yUGF0aDtcbmZ1bmN0aW9uIGNoZWNrU3RyaWN0TW9kZShpdCwgbXNnLCBtb2RlID0gaXQub3B0cy5zdHJpY3RTY2hlbWEpIHtcbiAgICBpZiAoIW1vZGUpXG4gICAgICAgIHJldHVybjtcbiAgICBtc2cgPSBgc3RyaWN0IG1vZGU6ICR7bXNnfWA7XG4gICAgaWYgKG1vZGUgPT09IHRydWUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIGl0LnNlbGYubG9nZ2VyLndhcm4obXNnKTtcbn1cbmV4cG9ydHMuY2hlY2tTdHJpY3RNb2RlID0gY2hlY2tTdHJpY3RNb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lcyA9IHtcbiAgICAvLyB2YWxpZGF0aW9uIGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgIGRhdGE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImRhdGFcIiksIC8vIGRhdGEgcGFzc2VkIHRvIHZhbGlkYXRpb24gZnVuY3Rpb25cbiAgICAvLyBhcmdzIHBhc3NlZCBmcm9tIHJlZmVyZW5jaW5nIHNjaGVtYVxuICAgIHZhbEN4dDogbmV3IGNvZGVnZW5fMS5OYW1lKFwidmFsQ3h0XCIpLCAvLyB2YWxpZGF0aW9uL2RhdGEgY29udGV4dCAtIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseSwgaXQgaXMgZGVzdHJ1Y3R1cmVkIHRvIHRoZSBuYW1lcyBiZWxvd1xuICAgIGluc3RhbmNlUGF0aDogbmV3IGNvZGVnZW5fMS5OYW1lKFwiaW5zdGFuY2VQYXRoXCIpLFxuICAgIHBhcmVudERhdGE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInBhcmVudERhdGFcIiksXG4gICAgcGFyZW50RGF0YVByb3BlcnR5OiBuZXcgY29kZWdlbl8xLk5hbWUoXCJwYXJlbnREYXRhUHJvcGVydHlcIiksXG4gICAgcm9vdERhdGE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInJvb3REYXRhXCIpLCAvLyByb290IGRhdGEgLSBzYW1lIGFzIHRoZSBkYXRhIHBhc3NlZCB0byB0aGUgZmlyc3QvdG9wIHZhbGlkYXRpb24gZnVuY3Rpb25cbiAgICBkeW5hbWljQW5jaG9yczogbmV3IGNvZGVnZW5fMS5OYW1lKFwiZHluYW1pY0FuY2hvcnNcIiksIC8vIHVzZWQgdG8gc3VwcG9ydCByZWN1cnNpdmVSZWYgYW5kIGR5bmFtaWNSZWZcbiAgICAvLyBmdW5jdGlvbiBzY29wZWQgdmFyaWFibGVzXG4gICAgdkVycm9yczogbmV3IGNvZGVnZW5fMS5OYW1lKFwidkVycm9yc1wiKSwgLy8gbnVsbCBvciBhcnJheSBvZiB2YWxpZGF0aW9uIGVycm9yc1xuICAgIGVycm9yczogbmV3IGNvZGVnZW5fMS5OYW1lKFwiZXJyb3JzXCIpLCAvLyBjb3VudGVyIG9mIHZhbGlkYXRpb24gZXJyb3JzXG4gICAgdGhpczogbmV3IGNvZGVnZW5fMS5OYW1lKFwidGhpc1wiKSxcbiAgICAvLyBcImdsb2JhbHNcIlxuICAgIHNlbGY6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInNlbGZcIiksXG4gICAgc2NvcGU6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInNjb3BlXCIpLFxuICAgIC8vIEpURCBzZXJpYWxpemUvcGFyc2UgbmFtZSBmb3IgSlNPTiBzdHJpbmcgYW5kIHBvc2l0aW9uXG4gICAganNvbjogbmV3IGNvZGVnZW5fMS5OYW1lKFwianNvblwiKSxcbiAgICBqc29uUG9zOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJqc29uUG9zXCIpLFxuICAgIGpzb25MZW46IG5ldyBjb2RlZ2VuXzEuTmFtZShcImpzb25MZW5cIiksXG4gICAganNvblBhcnQ6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImpzb25QYXJ0XCIpLFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5hbWVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmFtZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4dGVuZEVycm9ycyA9IGV4cG9ydHMucmVzZXRFcnJvcnNDb3VudCA9IGV4cG9ydHMucmVwb3J0RXh0cmFFcnJvciA9IGV4cG9ydHMucmVwb3J0RXJyb3IgPSBleHBvcnRzLmtleXdvcmQkRGF0YUVycm9yID0gZXhwb3J0cy5rZXl3b3JkRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi9uYW1lc1wiKTtcbmV4cG9ydHMua2V5d29yZEVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQgfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IHBhc3MgXCIke2tleXdvcmR9XCIga2V5d29yZCB2YWxpZGF0aW9uYCxcbn07XG5leHBvcnRzLmtleXdvcmQkRGF0YUVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQsIHNjaGVtYVR5cGUgfSkgPT4gc2NoZW1hVHlwZVxuICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuc3RyKSBgXCIke2tleXdvcmR9XCIga2V5d29yZCBtdXN0IGJlICR7c2NoZW1hVHlwZX0gKCRkYXRhKWBcbiAgICAgICAgOiAoMCwgY29kZWdlbl8xLnN0cikgYFwiJHtrZXl3b3JkfVwiIGtleXdvcmQgaXMgaW52YWxpZCAoJGRhdGEpYCxcbn07XG5mdW5jdGlvbiByZXBvcnRFcnJvcihjeHQsIGVycm9yID0gZXhwb3J0cy5rZXl3b3JkRXJyb3IsIGVycm9yUGF0aHMsIG92ZXJyaWRlQWxsRXJyb3JzKSB7XG4gICAgY29uc3QgeyBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHsgZ2VuLCBjb21wb3NpdGVSdWxlLCBhbGxFcnJvcnMgfSA9IGl0O1xuICAgIGNvbnN0IGVyck9iaiA9IGVycm9yT2JqZWN0Q29kZShjeHQsIGVycm9yLCBlcnJvclBhdGhzKTtcbiAgICBpZiAob3ZlcnJpZGVBbGxFcnJvcnMgIT09IG51bGwgJiYgb3ZlcnJpZGVBbGxFcnJvcnMgIT09IHZvaWQgMCA/IG92ZXJyaWRlQWxsRXJyb3JzIDogKGNvbXBvc2l0ZVJ1bGUgfHwgYWxsRXJyb3JzKSkge1xuICAgICAgICBhZGRFcnJvcihnZW4sIGVyck9iaik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm5FcnJvcnMoaXQsICgwLCBjb2RlZ2VuXzEuXykgYFske2Vyck9ian1dYCk7XG4gICAgfVxufVxuZXhwb3J0cy5yZXBvcnRFcnJvciA9IHJlcG9ydEVycm9yO1xuZnVuY3Rpb24gcmVwb3J0RXh0cmFFcnJvcihjeHQsIGVycm9yID0gZXhwb3J0cy5rZXl3b3JkRXJyb3IsIGVycm9yUGF0aHMpIHtcbiAgICBjb25zdCB7IGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgeyBnZW4sIGNvbXBvc2l0ZVJ1bGUsIGFsbEVycm9ycyB9ID0gaXQ7XG4gICAgY29uc3QgZXJyT2JqID0gZXJyb3JPYmplY3RDb2RlKGN4dCwgZXJyb3IsIGVycm9yUGF0aHMpO1xuICAgIGFkZEVycm9yKGdlbiwgZXJyT2JqKTtcbiAgICBpZiAoIShjb21wb3NpdGVSdWxlIHx8IGFsbEVycm9ycykpIHtcbiAgICAgICAgcmV0dXJuRXJyb3JzKGl0LCBuYW1lc18xLmRlZmF1bHQudkVycm9ycyk7XG4gICAgfVxufVxuZXhwb3J0cy5yZXBvcnRFeHRyYUVycm9yID0gcmVwb3J0RXh0cmFFcnJvcjtcbmZ1bmN0aW9uIHJlc2V0RXJyb3JzQ291bnQoZ2VuLCBlcnJzQ291bnQpIHtcbiAgICBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMsIGVycnNDb3VudCk7XG4gICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9ICE9PSBudWxsYCwgKCkgPT4gZ2VuLmlmKGVycnNDb3VudCwgKCkgPT4gZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5sZW5ndGhgLCBlcnJzQ291bnQpLCAoKSA9PiBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCBudWxsKSkpO1xufVxuZXhwb3J0cy5yZXNldEVycm9yc0NvdW50ID0gcmVzZXRFcnJvcnNDb3VudDtcbmZ1bmN0aW9uIGV4dGVuZEVycm9ycyh7IGdlbiwga2V5d29yZCwgc2NoZW1hVmFsdWUsIGRhdGEsIGVycnNDb3VudCwgaXQsIH0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZXJyc0NvdW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICBjb25zdCBlcnIgPSBnZW4ubmFtZShcImVyclwiKTtcbiAgICBnZW4uZm9yUmFuZ2UoXCJpXCIsIGVycnNDb3VudCwgbmFtZXNfMS5kZWZhdWx0LmVycm9ycywgKGkpID0+IHtcbiAgICAgICAgZ2VuLmNvbnN0KGVyciwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc31bJHtpfV1gKTtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyfS5pbnN0YW5jZVBhdGggPT09IHVuZGVmaW5lZGAsICgpID0+IGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtlcnJ9Lmluc3RhbmNlUGF0aGAsICgwLCBjb2RlZ2VuXzEuc3RyQ29uY2F0KShuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBpdC5lcnJvclBhdGgpKSk7XG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtlcnJ9LnNjaGVtYVBhdGhgLCAoMCwgY29kZWdlbl8xLnN0cikgYCR7aXQuZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWApO1xuICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyfS5zY2hlbWFgLCBzY2hlbWFWYWx1ZSk7XG4gICAgICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyfS5kYXRhYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuZXh0ZW5kRXJyb3JzID0gZXh0ZW5kRXJyb3JzO1xuZnVuY3Rpb24gYWRkRXJyb3IoZ2VuLCBlcnJPYmopIHtcbiAgICBjb25zdCBlcnIgPSBnZW4uY29uc3QoXCJlcnJcIiwgZXJyT2JqKTtcbiAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30gPT09IG51bGxgLCAoKSA9PiBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCAoMCwgY29kZWdlbl8xLl8pIGBbJHtlcnJ9XWApLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5wdXNoKCR7ZXJyfSlgKTtcbiAgICBnZW4uY29kZSgoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9KytgKTtcbn1cbmZ1bmN0aW9uIHJldHVybkVycm9ycyhpdCwgZXJycykge1xuICAgIGNvbnN0IHsgZ2VuLCB2YWxpZGF0ZU5hbWUsIHNjaGVtYUVudiB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYUVudi4kYXN5bmMpIHtcbiAgICAgICAgZ2VuLnRocm93KCgwLCBjb2RlZ2VuXzEuXykgYG5ldyAke2l0LlZhbGlkYXRpb25FcnJvcn0oJHtlcnJzfSlgKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHt2YWxpZGF0ZU5hbWV9LmVycm9yc2AsIGVycnMpO1xuICAgICAgICBnZW4ucmV0dXJuKGZhbHNlKTtcbiAgICB9XG59XG5jb25zdCBFID0ge1xuICAgIGtleXdvcmQ6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImtleXdvcmRcIiksXG4gICAgc2NoZW1hUGF0aDogbmV3IGNvZGVnZW5fMS5OYW1lKFwic2NoZW1hUGF0aFwiKSwgLy8gYWxzbyB1c2VkIGluIEpURCBlcnJvcnNcbiAgICBwYXJhbXM6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInBhcmFtc1wiKSxcbiAgICBwcm9wZXJ0eU5hbWU6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInByb3BlcnR5TmFtZVwiKSxcbiAgICBtZXNzYWdlOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJtZXNzYWdlXCIpLFxuICAgIHNjaGVtYTogbmV3IGNvZGVnZW5fMS5OYW1lKFwic2NoZW1hXCIpLFxuICAgIHBhcmVudFNjaGVtYTogbmV3IGNvZGVnZW5fMS5OYW1lKFwicGFyZW50U2NoZW1hXCIpLFxufTtcbmZ1bmN0aW9uIGVycm9yT2JqZWN0Q29kZShjeHQsIGVycm9yLCBlcnJvclBhdGhzKSB7XG4gICAgY29uc3QgeyBjcmVhdGVFcnJvcnMgfSA9IGN4dC5pdDtcbiAgICBpZiAoY3JlYXRlRXJyb3JzID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYHt9YDtcbiAgICByZXR1cm4gZXJyb3JPYmplY3QoY3h0LCBlcnJvciwgZXJyb3JQYXRocyk7XG59XG5mdW5jdGlvbiBlcnJvck9iamVjdChjeHQsIGVycm9yLCBlcnJvclBhdGhzID0ge30pIHtcbiAgICBjb25zdCB7IGdlbiwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCBrZXlWYWx1ZXMgPSBbXG4gICAgICAgIGVycm9ySW5zdGFuY2VQYXRoKGl0LCBlcnJvclBhdGhzKSxcbiAgICAgICAgZXJyb3JTY2hlbWFQYXRoKGN4dCwgZXJyb3JQYXRocyksXG4gICAgXTtcbiAgICBleHRyYUVycm9yUHJvcHMoY3h0LCBlcnJvciwga2V5VmFsdWVzKTtcbiAgICByZXR1cm4gZ2VuLm9iamVjdCguLi5rZXlWYWx1ZXMpO1xufVxuZnVuY3Rpb24gZXJyb3JJbnN0YW5jZVBhdGgoeyBlcnJvclBhdGggfSwgeyBpbnN0YW5jZVBhdGggfSkge1xuICAgIGNvbnN0IGluc3RQYXRoID0gaW5zdGFuY2VQYXRoXG4gICAgICAgID8gKDAsIGNvZGVnZW5fMS5zdHIpIGAke2Vycm9yUGF0aH0keygwLCB1dGlsXzEuZ2V0RXJyb3JQYXRoKShpbnN0YW5jZVBhdGgsIHV0aWxfMS5UeXBlLlN0cil9YFxuICAgICAgICA6IGVycm9yUGF0aDtcbiAgICByZXR1cm4gW25hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsICgwLCBjb2RlZ2VuXzEuc3RyQ29uY2F0KShuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBpbnN0UGF0aCldO1xufVxuZnVuY3Rpb24gZXJyb3JTY2hlbWFQYXRoKHsga2V5d29yZCwgaXQ6IHsgZXJyU2NoZW1hUGF0aCB9IH0sIHsgc2NoZW1hUGF0aCwgcGFyZW50U2NoZW1hIH0pIHtcbiAgICBsZXQgc2NoUGF0aCA9IHBhcmVudFNjaGVtYSA/IGVyclNjaGVtYVBhdGggOiAoMCwgY29kZWdlbl8xLnN0cikgYCR7ZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWA7XG4gICAgaWYgKHNjaGVtYVBhdGgpIHtcbiAgICAgICAgc2NoUGF0aCA9ICgwLCBjb2RlZ2VuXzEuc3RyKSBgJHtzY2hQYXRofSR7KDAsIHV0aWxfMS5nZXRFcnJvclBhdGgpKHNjaGVtYVBhdGgsIHV0aWxfMS5UeXBlLlN0cil9YDtcbiAgICB9XG4gICAgcmV0dXJuIFtFLnNjaGVtYVBhdGgsIHNjaFBhdGhdO1xufVxuZnVuY3Rpb24gZXh0cmFFcnJvclByb3BzKGN4dCwgeyBwYXJhbXMsIG1lc3NhZ2UgfSwga2V5VmFsdWVzKSB7XG4gICAgY29uc3QgeyBrZXl3b3JkLCBkYXRhLCBzY2hlbWFWYWx1ZSwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCB7IG9wdHMsIHByb3BlcnR5TmFtZSwgdG9wU2NoZW1hUmVmLCBzY2hlbWFQYXRoIH0gPSBpdDtcbiAgICBrZXlWYWx1ZXMucHVzaChbRS5rZXl3b3JkLCBrZXl3b3JkXSwgW0UucGFyYW1zLCB0eXBlb2YgcGFyYW1zID09IFwiZnVuY3Rpb25cIiA/IHBhcmFtcyhjeHQpIDogcGFyYW1zIHx8ICgwLCBjb2RlZ2VuXzEuXykgYHt9YF0pO1xuICAgIGlmIChvcHRzLm1lc3NhZ2VzKSB7XG4gICAgICAgIGtleVZhbHVlcy5wdXNoKFtFLm1lc3NhZ2UsIHR5cGVvZiBtZXNzYWdlID09IFwiZnVuY3Rpb25cIiA/IG1lc3NhZ2UoY3h0KSA6IG1lc3NhZ2VdKTtcbiAgICB9XG4gICAgaWYgKG9wdHMudmVyYm9zZSkge1xuICAgICAgICBrZXlWYWx1ZXMucHVzaChbRS5zY2hlbWEsIHNjaGVtYVZhbHVlXSwgW0UucGFyZW50U2NoZW1hLCAoMCwgY29kZWdlbl8xLl8pIGAke3RvcFNjaGVtYVJlZn0ke3NjaGVtYVBhdGh9YF0sIFtuYW1lc18xLmRlZmF1bHQuZGF0YSwgZGF0YV0pO1xuICAgIH1cbiAgICBpZiAocHJvcGVydHlOYW1lKVxuICAgICAgICBrZXlWYWx1ZXMucHVzaChbRS5wcm9wZXJ0eU5hbWUsIHByb3BlcnR5TmFtZV0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ib29sT3JFbXB0eVNjaGVtYSA9IGV4cG9ydHMudG9wQm9vbE9yRW1wdHlTY2hlbWEgPSB2b2lkIDA7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vbmFtZXNcIik7XG5jb25zdCBib29sRXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJib29sZWFuIHNjaGVtYSBpcyBmYWxzZVwiLFxufTtcbmZ1bmN0aW9uIHRvcEJvb2xPckVtcHR5U2NoZW1hKGl0KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgdmFsaWRhdGVOYW1lIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICBmYWxzZVNjaGVtYUVycm9yKGl0LCBmYWxzZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiBzY2hlbWEuJGFzeW5jID09PSB0cnVlKSB7XG4gICAgICAgIGdlbi5yZXR1cm4obmFtZXNfMS5kZWZhdWx0LmRhdGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke3ZhbGlkYXRlTmFtZX0uZXJyb3JzYCwgbnVsbCk7XG4gICAgICAgIGdlbi5yZXR1cm4odHJ1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy50b3BCb29sT3JFbXB0eVNjaGVtYSA9IHRvcEJvb2xPckVtcHR5U2NoZW1hO1xuZnVuY3Rpb24gYm9vbE9yRW1wdHlTY2hlbWEoaXQsIHZhbGlkKSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZ2VuLnZhcih2YWxpZCwgZmFsc2UpOyAvLyBUT0RPIHZhclxuICAgICAgICBmYWxzZVNjaGVtYUVycm9yKGl0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi52YXIodmFsaWQsIHRydWUpOyAvLyBUT0RPIHZhclxuICAgIH1cbn1cbmV4cG9ydHMuYm9vbE9yRW1wdHlTY2hlbWEgPSBib29sT3JFbXB0eVNjaGVtYTtcbmZ1bmN0aW9uIGZhbHNlU2NoZW1hRXJyb3IoaXQsIG92ZXJyaWRlQWxsRXJyb3JzKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEgfSA9IGl0O1xuICAgIC8vIFRPRE8gbWF5YmUgc29tZSBvdGhlciBpbnRlcmZhY2Ugc2hvdWxkIGJlIHVzZWQgZm9yIG5vbi1rZXl3b3JkIHZhbGlkYXRpb24gZXJyb3JzLi4uXG4gICAgY29uc3QgY3h0ID0ge1xuICAgICAgICBnZW4sXG4gICAgICAgIGtleXdvcmQ6IFwiZmFsc2Ugc2NoZW1hXCIsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHNjaGVtYTogZmFsc2UsXG4gICAgICAgIHNjaGVtYUNvZGU6IGZhbHNlLFxuICAgICAgICBzY2hlbWFWYWx1ZTogZmFsc2UsXG4gICAgICAgIHBhcmFtczoge30sXG4gICAgICAgIGl0LFxuICAgIH07XG4gICAgKDAsIGVycm9yc18xLnJlcG9ydEVycm9yKShjeHQsIGJvb2xFcnJvciwgdW5kZWZpbmVkLCBvdmVycmlkZUFsbEVycm9ycyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib29sU2NoZW1hLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRSdWxlcyA9IGV4cG9ydHMuaXNKU09OVHlwZSA9IHZvaWQgMDtcbmNvbnN0IF9qc29uVHlwZXMgPSBbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJpbnRlZ2VyXCIsIFwiYm9vbGVhblwiLCBcIm51bGxcIiwgXCJvYmplY3RcIiwgXCJhcnJheVwiXTtcbmNvbnN0IGpzb25UeXBlcyA9IG5ldyBTZXQoX2pzb25UeXBlcyk7XG5mdW5jdGlvbiBpc0pTT05UeXBlKHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT0gXCJzdHJpbmdcIiAmJiBqc29uVHlwZXMuaGFzKHgpO1xufVxuZXhwb3J0cy5pc0pTT05UeXBlID0gaXNKU09OVHlwZTtcbmZ1bmN0aW9uIGdldFJ1bGVzKCkge1xuICAgIGNvbnN0IGdyb3VwcyA9IHtcbiAgICAgICAgbnVtYmVyOiB7IHR5cGU6IFwibnVtYmVyXCIsIHJ1bGVzOiBbXSB9LFxuICAgICAgICBzdHJpbmc6IHsgdHlwZTogXCJzdHJpbmdcIiwgcnVsZXM6IFtdIH0sXG4gICAgICAgIGFycmF5OiB7IHR5cGU6IFwiYXJyYXlcIiwgcnVsZXM6IFtdIH0sXG4gICAgICAgIG9iamVjdDogeyB0eXBlOiBcIm9iamVjdFwiLCBydWxlczogW10gfSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVzOiB7IC4uLmdyb3VwcywgaW50ZWdlcjogdHJ1ZSwgYm9vbGVhbjogdHJ1ZSwgbnVsbDogdHJ1ZSB9LFxuICAgICAgICBydWxlczogW3sgcnVsZXM6IFtdIH0sIGdyb3Vwcy5udW1iZXIsIGdyb3Vwcy5zdHJpbmcsIGdyb3Vwcy5hcnJheSwgZ3JvdXBzLm9iamVjdF0sXG4gICAgICAgIHBvc3Q6IHsgcnVsZXM6IFtdIH0sXG4gICAgICAgIGFsbDoge30sXG4gICAgICAgIGtleXdvcmRzOiB7fSxcbiAgICB9O1xufVxuZXhwb3J0cy5nZXRSdWxlcyA9IGdldFJ1bGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnVsZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNob3VsZFVzZVJ1bGUgPSBleHBvcnRzLnNob3VsZFVzZUdyb3VwID0gZXhwb3J0cy5zY2hlbWFIYXNSdWxlc0ZvclR5cGUgPSB2b2lkIDA7XG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlc0ZvclR5cGUoeyBzY2hlbWEsIHNlbGYgfSwgdHlwZSkge1xuICAgIGNvbnN0IGdyb3VwID0gc2VsZi5SVUxFUy50eXBlc1t0eXBlXTtcbiAgICByZXR1cm4gZ3JvdXAgJiYgZ3JvdXAgIT09IHRydWUgJiYgc2hvdWxkVXNlR3JvdXAoc2NoZW1hLCBncm91cCk7XG59XG5leHBvcnRzLnNjaGVtYUhhc1J1bGVzRm9yVHlwZSA9IHNjaGVtYUhhc1J1bGVzRm9yVHlwZTtcbmZ1bmN0aW9uIHNob3VsZFVzZUdyb3VwKHNjaGVtYSwgZ3JvdXApIHtcbiAgICByZXR1cm4gZ3JvdXAucnVsZXMuc29tZSgocnVsZSkgPT4gc2hvdWxkVXNlUnVsZShzY2hlbWEsIHJ1bGUpKTtcbn1cbmV4cG9ydHMuc2hvdWxkVXNlR3JvdXAgPSBzaG91bGRVc2VHcm91cDtcbmZ1bmN0aW9uIHNob3VsZFVzZVJ1bGUoc2NoZW1hLCBydWxlKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoc2NoZW1hW3J1bGUua2V5d29yZF0gIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAoKF9hID0gcnVsZS5kZWZpbml0aW9uLmltcGxlbWVudHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb21lKChrd2QpID0+IHNjaGVtYVtrd2RdICE9PSB1bmRlZmluZWQpKSk7XG59XG5leHBvcnRzLnNob3VsZFVzZVJ1bGUgPSBzaG91bGRVc2VSdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwbGljYWJpbGl0eS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVwb3J0VHlwZUVycm9yID0gZXhwb3J0cy5jaGVja0RhdGFUeXBlcyA9IGV4cG9ydHMuY2hlY2tEYXRhVHlwZSA9IGV4cG9ydHMuY29lcmNlQW5kQ2hlY2tEYXRhVHlwZSA9IGV4cG9ydHMuZ2V0SlNPTlR5cGVzID0gZXhwb3J0cy5nZXRTY2hlbWFUeXBlcyA9IGV4cG9ydHMuRGF0YVR5cGUgPSB2b2lkIDA7XG5jb25zdCBydWxlc18xID0gcmVxdWlyZShcIi4uL3J1bGVzXCIpO1xuY29uc3QgYXBwbGljYWJpbGl0eV8xID0gcmVxdWlyZShcIi4vYXBwbGljYWJpbGl0eVwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgRGF0YVR5cGU7XG4oZnVuY3Rpb24gKERhdGFUeXBlKSB7XG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJDb3JyZWN0XCJdID0gMF0gPSBcIkNvcnJlY3RcIjtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcIldyb25nXCJdID0gMV0gPSBcIldyb25nXCI7XG59KShEYXRhVHlwZSB8fCAoZXhwb3J0cy5EYXRhVHlwZSA9IERhdGFUeXBlID0ge30pKTtcbmZ1bmN0aW9uIGdldFNjaGVtYVR5cGVzKHNjaGVtYSkge1xuICAgIGNvbnN0IHR5cGVzID0gZ2V0SlNPTlR5cGVzKHNjaGVtYS50eXBlKTtcbiAgICBjb25zdCBoYXNOdWxsID0gdHlwZXMuaW5jbHVkZXMoXCJudWxsXCIpO1xuICAgIGlmIChoYXNOdWxsKSB7XG4gICAgICAgIGlmIChzY2hlbWEubnVsbGFibGUgPT09IGZhbHNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZTogbnVsbCBjb250cmFkaWN0cyBudWxsYWJsZTogZmFsc2VcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIXR5cGVzLmxlbmd0aCAmJiBzY2hlbWEubnVsbGFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm51bGxhYmxlXCIgY2Fubm90IGJlIHVzZWQgd2l0aG91dCBcInR5cGVcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEubnVsbGFibGUgPT09IHRydWUpXG4gICAgICAgICAgICB0eXBlcy5wdXNoKFwibnVsbFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVzO1xufVxuZXhwb3J0cy5nZXRTY2hlbWFUeXBlcyA9IGdldFNjaGVtYVR5cGVzO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWR1bmRhbnQtdHlwZS1jb25zdGl0dWVudHNcbmZ1bmN0aW9uIGdldEpTT05UeXBlcyh0cykge1xuICAgIGNvbnN0IHR5cGVzID0gQXJyYXkuaXNBcnJheSh0cykgPyB0cyA6IHRzID8gW3RzXSA6IFtdO1xuICAgIGlmICh0eXBlcy5ldmVyeShydWxlc18xLmlzSlNPTlR5cGUpKVxuICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZSBtdXN0IGJlIEpTT05UeXBlIG9yIEpTT05UeXBlW106IFwiICsgdHlwZXMuam9pbihcIixcIikpO1xufVxuZXhwb3J0cy5nZXRKU09OVHlwZXMgPSBnZXRKU09OVHlwZXM7XG5mdW5jdGlvbiBjb2VyY2VBbmRDaGVja0RhdGFUeXBlKGl0LCB0eXBlcykge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBvcHRzIH0gPSBpdDtcbiAgICBjb25zdCBjb2VyY2VUbyA9IGNvZXJjZVRvVHlwZXModHlwZXMsIG9wdHMuY29lcmNlVHlwZXMpO1xuICAgIGNvbnN0IGNoZWNrVHlwZXMgPSB0eXBlcy5sZW5ndGggPiAwICYmXG4gICAgICAgICEoY29lcmNlVG8ubGVuZ3RoID09PSAwICYmIHR5cGVzLmxlbmd0aCA9PT0gMSAmJiAoMCwgYXBwbGljYWJpbGl0eV8xLnNjaGVtYUhhc1J1bGVzRm9yVHlwZSkoaXQsIHR5cGVzWzBdKSk7XG4gICAgaWYgKGNoZWNrVHlwZXMpIHtcbiAgICAgICAgY29uc3Qgd3JvbmdUeXBlID0gY2hlY2tEYXRhVHlwZXModHlwZXMsIGRhdGEsIG9wdHMuc3RyaWN0TnVtYmVycywgRGF0YVR5cGUuV3JvbmcpO1xuICAgICAgICBnZW4uaWYod3JvbmdUeXBlLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29lcmNlVG8ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGNvZXJjZURhdGEoaXQsIHR5cGVzLCBjb2VyY2VUbyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmVwb3J0VHlwZUVycm9yKGl0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjaGVja1R5cGVzO1xufVxuZXhwb3J0cy5jb2VyY2VBbmRDaGVja0RhdGFUeXBlID0gY29lcmNlQW5kQ2hlY2tEYXRhVHlwZTtcbmNvbnN0IENPRVJDSUJMRSA9IG5ldyBTZXQoW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiaW50ZWdlclwiLCBcImJvb2xlYW5cIiwgXCJudWxsXCJdKTtcbmZ1bmN0aW9uIGNvZXJjZVRvVHlwZXModHlwZXMsIGNvZXJjZVR5cGVzKSB7XG4gICAgcmV0dXJuIGNvZXJjZVR5cGVzXG4gICAgICAgID8gdHlwZXMuZmlsdGVyKCh0KSA9PiBDT0VSQ0lCTEUuaGFzKHQpIHx8IChjb2VyY2VUeXBlcyA9PT0gXCJhcnJheVwiICYmIHQgPT09IFwiYXJyYXlcIikpXG4gICAgICAgIDogW107XG59XG5mdW5jdGlvbiBjb2VyY2VEYXRhKGl0LCB0eXBlcywgY29lcmNlVG8pIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgb3B0cyB9ID0gaXQ7XG4gICAgY29uc3QgZGF0YVR5cGUgPSBnZW4ubGV0KFwiZGF0YVR5cGVcIiwgKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7ZGF0YX1gKTtcbiAgICBjb25zdCBjb2VyY2VkID0gZ2VuLmxldChcImNvZXJjZWRcIiwgKDAsIGNvZGVnZW5fMS5fKSBgdW5kZWZpbmVkYCk7XG4gICAgaWYgKG9wdHMuY29lcmNlVHlwZXMgPT09IFwiYXJyYXlcIikge1xuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhVHlwZX0gPT0gJ29iamVjdCcgJiYgQXJyYXkuaXNBcnJheSgke2RhdGF9KSAmJiAke2RhdGF9Lmxlbmd0aCA9PSAxYCwgKCkgPT4gZ2VuXG4gICAgICAgICAgICAuYXNzaWduKGRhdGEsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX1bMF1gKVxuICAgICAgICAgICAgLmFzc2lnbihkYXRhVHlwZSwgKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7ZGF0YX1gKVxuICAgICAgICAgICAgLmlmKGNoZWNrRGF0YVR5cGVzKHR5cGVzLCBkYXRhLCBvcHRzLnN0cmljdE51bWJlcnMpLCAoKSA9PiBnZW4uYXNzaWduKGNvZXJjZWQsIGRhdGEpKSk7XG4gICAgfVxuICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2NvZXJjZWR9ICE9PSB1bmRlZmluZWRgKTtcbiAgICBmb3IgKGNvbnN0IHQgb2YgY29lcmNlVG8pIHtcbiAgICAgICAgaWYgKENPRVJDSUJMRS5oYXModCkgfHwgKHQgPT09IFwiYXJyYXlcIiAmJiBvcHRzLmNvZXJjZVR5cGVzID09PSBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICBjb2VyY2VTcGVjaWZpY1R5cGUodCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2VuLmVsc2UoKTtcbiAgICByZXBvcnRUeXBlRXJyb3IoaXQpO1xuICAgIGdlbi5lbmRJZigpO1xuICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2NvZXJjZWR9ICE9PSB1bmRlZmluZWRgLCAoKSA9PiB7XG4gICAgICAgIGdlbi5hc3NpZ24oZGF0YSwgY29lcmNlZCk7XG4gICAgICAgIGFzc2lnblBhcmVudERhdGEoaXQsIGNvZXJjZWQpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGNvZXJjZVNwZWNpZmljVHlwZSh0KSB7XG4gICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YVR5cGV9ID09IFwibnVtYmVyXCIgfHwgJHtkYXRhVHlwZX0gPT0gXCJib29sZWFuXCJgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsICgwLCBjb2RlZ2VuXzEuXykgYFwiXCIgKyAke2RhdGF9YClcbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9ID09PSBudWxsYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCAoMCwgY29kZWdlbl8xLl8pIGBcIlwiYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YVR5cGV9ID09IFwiYm9vbGVhblwiIHx8ICR7ZGF0YX0gPT09IG51bGxcbiAgICAgICAgICAgICAgfHwgKCR7ZGF0YVR5cGV9ID09IFwic3RyaW5nXCIgJiYgJHtkYXRhfSAmJiAke2RhdGF9ID09ICske2RhdGF9KWApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgKDAsIGNvZGVnZW5fMS5fKSBgKyR7ZGF0YX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwiaW50ZWdlclwiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YVR5cGV9ID09PSBcImJvb2xlYW5cIiB8fCAke2RhdGF9ID09PSBudWxsXG4gICAgICAgICAgICAgIHx8ICgke2RhdGFUeXBlfSA9PT0gXCJzdHJpbmdcIiAmJiAke2RhdGF9ICYmICR7ZGF0YX0gPT0gKyR7ZGF0YX0gJiYgISgke2RhdGF9ICUgMSkpYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCAoMCwgY29kZWdlbl8xLl8pIGArJHtkYXRhfWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSA9PT0gXCJmYWxzZVwiIHx8ICR7ZGF0YX0gPT09IDAgfHwgJHtkYXRhfSA9PT0gbnVsbGApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSA9PT0gXCJ0cnVlXCIgfHwgJHtkYXRhfSA9PT0gMWApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcIm51bGxcIjpcbiAgICAgICAgICAgICAgICBnZW4uZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0gPT09IFwiXCIgfHwgJHtkYXRhfSA9PT0gMCB8fCAke2RhdGF9ID09PSBmYWxzZWApO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oY29lcmNlZCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhVHlwZX0gPT09IFwic3RyaW5nXCIgfHwgJHtkYXRhVHlwZX0gPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgICAgfHwgJHtkYXRhVHlwZX0gPT09IFwiYm9vbGVhblwiIHx8ICR7ZGF0YX0gPT09IG51bGxgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsICgwLCBjb2RlZ2VuXzEuXykgYFske2RhdGF9XWApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzaWduUGFyZW50RGF0YSh7IGdlbiwgcGFyZW50RGF0YSwgcGFyZW50RGF0YVByb3BlcnR5IH0sIGV4cHIpIHtcbiAgICAvLyBUT0RPIHVzZSBnZW4ucHJvcGVydHlcbiAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtwYXJlbnREYXRhfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT4gZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke3BhcmVudERhdGF9WyR7cGFyZW50RGF0YVByb3BlcnR5fV1gLCBleHByKSk7XG59XG5mdW5jdGlvbiBjaGVja0RhdGFUeXBlKGRhdGFUeXBlLCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0ID0gRGF0YVR5cGUuQ29ycmVjdCkge1xuICAgIGNvbnN0IEVRID0gY29ycmVjdCA9PT0gRGF0YVR5cGUuQ29ycmVjdCA/IGNvZGVnZW5fMS5vcGVyYXRvcnMuRVEgOiBjb2RlZ2VuXzEub3BlcmF0b3JzLk5FUTtcbiAgICBsZXQgY29uZDtcbiAgICBzd2l0Y2ggKGRhdGFUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSAke0VRfSBudWxsYDtcbiAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICBjb25kID0gKDAsIGNvZGVnZW5fMS5fKSBgQXJyYXkuaXNBcnJheSgke2RhdGF9KWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgY29uZCA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0gJiYgdHlwZW9mICR7ZGF0YX0gPT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSgke2RhdGF9KWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImludGVnZXJcIjpcbiAgICAgICAgICAgIGNvbmQgPSBudW1Db25kKCgwLCBjb2RlZ2VuXzEuXykgYCEoJHtkYXRhfSAlIDEpICYmICFpc05hTigke2RhdGF9KWApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGNvbmQgPSBudW1Db25kKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtkYXRhfSAke0VRfSAke2RhdGFUeXBlfWA7XG4gICAgfVxuICAgIHJldHVybiBjb3JyZWN0ID09PSBEYXRhVHlwZS5Db3JyZWN0ID8gY29uZCA6ICgwLCBjb2RlZ2VuXzEubm90KShjb25kKTtcbiAgICBmdW5jdGlvbiBudW1Db25kKF9jb25kID0gY29kZWdlbl8xLm5pbCkge1xuICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5hbmQpKCgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2RhdGF9ID09IFwibnVtYmVyXCJgLCBfY29uZCwgc3RyaWN0TnVtcyA/ICgwLCBjb2RlZ2VuXzEuXykgYGlzRmluaXRlKCR7ZGF0YX0pYCA6IGNvZGVnZW5fMS5uaWwpO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tEYXRhVHlwZSA9IGNoZWNrRGF0YVR5cGU7XG5mdW5jdGlvbiBjaGVja0RhdGFUeXBlcyhkYXRhVHlwZXMsIGRhdGEsIHN0cmljdE51bXMsIGNvcnJlY3QpIHtcbiAgICBpZiAoZGF0YVR5cGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gY2hlY2tEYXRhVHlwZShkYXRhVHlwZXNbMF0sIGRhdGEsIHN0cmljdE51bXMsIGNvcnJlY3QpO1xuICAgIH1cbiAgICBsZXQgY29uZDtcbiAgICBjb25zdCB0eXBlcyA9ICgwLCB1dGlsXzEudG9IYXNoKShkYXRhVHlwZXMpO1xuICAgIGlmICh0eXBlcy5hcnJheSAmJiB0eXBlcy5vYmplY3QpIHtcbiAgICAgICAgY29uc3Qgbm90T2JqID0gKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7ZGF0YX0gIT0gXCJvYmplY3RcImA7XG4gICAgICAgIGNvbmQgPSB0eXBlcy5udWxsID8gbm90T2JqIDogKDAsIGNvZGVnZW5fMS5fKSBgISR7ZGF0YX0gfHwgJHtub3RPYmp9YDtcbiAgICAgICAgZGVsZXRlIHR5cGVzLm51bGw7XG4gICAgICAgIGRlbGV0ZSB0eXBlcy5hcnJheTtcbiAgICAgICAgZGVsZXRlIHR5cGVzLm9iamVjdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbmQgPSBjb2RlZ2VuXzEubmlsO1xuICAgIH1cbiAgICBpZiAodHlwZXMubnVtYmVyKVxuICAgICAgICBkZWxldGUgdHlwZXMuaW50ZWdlcjtcbiAgICBmb3IgKGNvbnN0IHQgaW4gdHlwZXMpXG4gICAgICAgIGNvbmQgPSAoMCwgY29kZWdlbl8xLmFuZCkoY29uZCwgY2hlY2tEYXRhVHlwZSh0LCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0KSk7XG4gICAgcmV0dXJuIGNvbmQ7XG59XG5leHBvcnRzLmNoZWNrRGF0YVR5cGVzID0gY2hlY2tEYXRhVHlwZXM7XG5jb25zdCB0eXBlRXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgc2NoZW1hIH0pID0+IGBtdXN0IGJlICR7c2NoZW1hfWAsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWEsIHNjaGVtYVZhbHVlIH0pID0+IHR5cGVvZiBzY2hlbWEgPT0gXCJzdHJpbmdcIiA/ICgwLCBjb2RlZ2VuXzEuXykgYHt0eXBlOiAke3NjaGVtYX19YCA6ICgwLCBjb2RlZ2VuXzEuXykgYHt0eXBlOiAke3NjaGVtYVZhbHVlfX1gLFxufTtcbmZ1bmN0aW9uIHJlcG9ydFR5cGVFcnJvcihpdCkge1xuICAgIGNvbnN0IGN4dCA9IGdldFR5cGVFcnJvckNvbnRleHQoaXQpO1xuICAgICgwLCBlcnJvcnNfMS5yZXBvcnRFcnJvcikoY3h0LCB0eXBlRXJyb3IpO1xufVxuZXhwb3J0cy5yZXBvcnRUeXBlRXJyb3IgPSByZXBvcnRUeXBlRXJyb3I7XG5mdW5jdGlvbiBnZXRUeXBlRXJyb3JDb250ZXh0KGl0KSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIHNjaGVtYSB9ID0gaXQ7XG4gICAgY29uc3Qgc2NoZW1hQ29kZSA9ICgwLCB1dGlsXzEuc2NoZW1hUmVmT3JWYWwpKGl0LCBzY2hlbWEsIFwidHlwZVwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZW4sXG4gICAgICAgIGtleXdvcmQ6IFwidHlwZVwiLFxuICAgICAgICBkYXRhLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYS50eXBlLFxuICAgICAgICBzY2hlbWFDb2RlLFxuICAgICAgICBzY2hlbWFWYWx1ZTogc2NoZW1hQ29kZSxcbiAgICAgICAgcGFyZW50U2NoZW1hOiBzY2hlbWEsXG4gICAgICAgIHBhcmFtczoge30sXG4gICAgICAgIGl0LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhVHlwZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXNzaWduRGVmYXVsdHMgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuZnVuY3Rpb24gYXNzaWduRGVmYXVsdHMoaXQsIHR5KSB7XG4gICAgY29uc3QgeyBwcm9wZXJ0aWVzLCBpdGVtcyB9ID0gaXQuc2NoZW1hO1xuICAgIGlmICh0eSA9PT0gXCJvYmplY3RcIiAmJiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGFzc2lnbkRlZmF1bHQoaXQsIGtleSwgcHJvcGVydGllc1trZXldLmRlZmF1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5ID09PSBcImFycmF5XCIgJiYgQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgICAgaXRlbXMuZm9yRWFjaCgoc2NoLCBpKSA9PiBhc3NpZ25EZWZhdWx0KGl0LCBpLCBzY2guZGVmYXVsdCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzaWduRGVmYXVsdHMgPSBhc3NpZ25EZWZhdWx0cztcbmZ1bmN0aW9uIGFzc2lnbkRlZmF1bHQoaXQsIHByb3AsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGNvbnN0IHsgZ2VuLCBjb21wb3NpdGVSdWxlLCBkYXRhLCBvcHRzIH0gPSBpdDtcbiAgICBpZiAoZGVmYXVsdFZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBjaGlsZERhdGEgPSAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShwcm9wKX1gO1xuICAgIGlmIChjb21wb3NpdGVSdWxlKSB7XG4gICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgYGRlZmF1bHQgaXMgaWdub3JlZCBmb3I6ICR7Y2hpbGREYXRhfWApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjb25kaXRpb24gPSAoMCwgY29kZWdlbl8xLl8pIGAke2NoaWxkRGF0YX0gPT09IHVuZGVmaW5lZGA7XG4gICAgaWYgKG9wdHMudXNlRGVmYXVsdHMgPT09IFwiZW1wdHlcIikge1xuICAgICAgICBjb25kaXRpb24gPSAoMCwgY29kZWdlbl8xLl8pIGAke2NvbmRpdGlvbn0gfHwgJHtjaGlsZERhdGF9ID09PSBudWxsIHx8ICR7Y2hpbGREYXRhfSA9PT0gXCJcImA7XG4gICAgfVxuICAgIC8vIGAke2NoaWxkRGF0YX0gPT09IHVuZGVmaW5lZGAgK1xuICAgIC8vIChvcHRzLnVzZURlZmF1bHRzID09PSBcImVtcHR5XCIgPyBgIHx8ICR7Y2hpbGREYXRhfSA9PT0gbnVsbCB8fCAke2NoaWxkRGF0YX0gPT09IFwiXCJgIDogXCJcIilcbiAgICBnZW4uaWYoY29uZGl0aW9uLCAoMCwgY29kZWdlbl8xLl8pIGAke2NoaWxkRGF0YX0gPSAkeygwLCBjb2RlZ2VuXzEuc3RyaW5naWZ5KShkZWZhdWx0VmFsdWUpfWApO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlVW5pb24gPSBleHBvcnRzLnZhbGlkYXRlQXJyYXkgPSBleHBvcnRzLnVzZVBhdHRlcm4gPSBleHBvcnRzLmNhbGxWYWxpZGF0ZUNvZGUgPSBleHBvcnRzLnNjaGVtYVByb3BlcnRpZXMgPSBleHBvcnRzLmFsbFNjaGVtYVByb3BlcnRpZXMgPSBleHBvcnRzLm5vUHJvcGVydHlJbkRhdGEgPSBleHBvcnRzLnByb3BlcnR5SW5EYXRhID0gZXhwb3J0cy5pc093blByb3BlcnR5ID0gZXhwb3J0cy5oYXNQcm9wRnVuYyA9IGV4cG9ydHMucmVwb3J0TWlzc2luZ1Byb3AgPSBleHBvcnRzLmNoZWNrTWlzc2luZ1Byb3AgPSBleHBvcnRzLmNoZWNrUmVwb3J0TWlzc2luZ1Byb3AgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vY29tcGlsZS9uYW1lc1wiKTtcbmNvbnN0IHV0aWxfMiA9IHJlcXVpcmUoXCIuLi9jb21waWxlL3V0aWxcIik7XG5mdW5jdGlvbiBjaGVja1JlcG9ydE1pc3NpbmdQcm9wKGN4dCwgcHJvcCkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgIGdlbi5pZihub1Byb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4ge1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHsgbWlzc2luZ1Byb3BlcnR5OiAoMCwgY29kZWdlbl8xLl8pIGAke3Byb3B9YCB9LCB0cnVlKTtcbiAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgfSk7XG59XG5leHBvcnRzLmNoZWNrUmVwb3J0TWlzc2luZ1Byb3AgPSBjaGVja1JlcG9ydE1pc3NpbmdQcm9wO1xuZnVuY3Rpb24gY2hlY2tNaXNzaW5nUHJvcCh7IGdlbiwgZGF0YSwgaXQ6IHsgb3B0cyB9IH0sIHByb3BlcnRpZXMsIG1pc3NpbmcpIHtcbiAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5vcikoLi4ucHJvcGVydGllcy5tYXAoKHByb3ApID0+ICgwLCBjb2RlZ2VuXzEuYW5kKShub1Byb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgb3B0cy5vd25Qcm9wZXJ0aWVzKSwgKDAsIGNvZGVnZW5fMS5fKSBgJHttaXNzaW5nfSA9ICR7cHJvcH1gKSkpO1xufVxuZXhwb3J0cy5jaGVja01pc3NpbmdQcm9wID0gY2hlY2tNaXNzaW5nUHJvcDtcbmZ1bmN0aW9uIHJlcG9ydE1pc3NpbmdQcm9wKGN4dCwgbWlzc2luZykge1xuICAgIGN4dC5zZXRQYXJhbXMoeyBtaXNzaW5nUHJvcGVydHk6IG1pc3NpbmcgfSwgdHJ1ZSk7XG4gICAgY3h0LmVycm9yKCk7XG59XG5leHBvcnRzLnJlcG9ydE1pc3NpbmdQcm9wID0gcmVwb3J0TWlzc2luZ1Byb3A7XG5mdW5jdGlvbiBoYXNQcm9wRnVuYyhnZW4pIHtcbiAgICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJmdW5jXCIsIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgICByZWY6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICAgIGNvZGU6ICgwLCBjb2RlZ2VuXzEuXykgYE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlgLFxuICAgIH0pO1xufVxuZXhwb3J0cy5oYXNQcm9wRnVuYyA9IGhhc1Byb3BGdW5jO1xuZnVuY3Rpb24gaXNPd25Qcm9wZXJ0eShnZW4sIGRhdGEsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCR7aGFzUHJvcEZ1bmMoZ2VuKX0uY2FsbCgke2RhdGF9LCAke3Byb3BlcnR5fSlgO1xufVxuZXhwb3J0cy5pc093blByb3BlcnR5ID0gaXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIHByb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcGVydHksIG93blByb3BlcnRpZXMpIHtcbiAgICBjb25zdCBjb25kID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkocHJvcGVydHkpfSAhPT0gdW5kZWZpbmVkYDtcbiAgICByZXR1cm4gb3duUHJvcGVydGllcyA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7Y29uZH0gJiYgJHtpc093blByb3BlcnR5KGdlbiwgZGF0YSwgcHJvcGVydHkpfWAgOiBjb25kO1xufVxuZXhwb3J0cy5wcm9wZXJ0eUluRGF0YSA9IHByb3BlcnR5SW5EYXRhO1xuZnVuY3Rpb24gbm9Qcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3BlcnR5LCBvd25Qcm9wZXJ0aWVzKSB7XG4gICAgY29uc3QgY29uZCA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKHByb3BlcnR5KX0gPT09IHVuZGVmaW5lZGA7XG4gICAgcmV0dXJuIG93blByb3BlcnRpZXMgPyAoMCwgY29kZWdlbl8xLm9yKShjb25kLCAoMCwgY29kZWdlbl8xLm5vdCkoaXNPd25Qcm9wZXJ0eShnZW4sIGRhdGEsIHByb3BlcnR5KSkpIDogY29uZDtcbn1cbmV4cG9ydHMubm9Qcm9wZXJ0eUluRGF0YSA9IG5vUHJvcGVydHlJbkRhdGE7XG5mdW5jdGlvbiBhbGxTY2hlbWFQcm9wZXJ0aWVzKHNjaGVtYU1hcCkge1xuICAgIHJldHVybiBzY2hlbWFNYXAgPyBPYmplY3Qua2V5cyhzY2hlbWFNYXApLmZpbHRlcigocCkgPT4gcCAhPT0gXCJfX3Byb3RvX19cIikgOiBbXTtcbn1cbmV4cG9ydHMuYWxsU2NoZW1hUHJvcGVydGllcyA9IGFsbFNjaGVtYVByb3BlcnRpZXM7XG5mdW5jdGlvbiBzY2hlbWFQcm9wZXJ0aWVzKGl0LCBzY2hlbWFNYXApIHtcbiAgICByZXR1cm4gYWxsU2NoZW1hUHJvcGVydGllcyhzY2hlbWFNYXApLmZpbHRlcigocCkgPT4gISgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWFNYXBbcF0pKTtcbn1cbmV4cG9ydHMuc2NoZW1hUHJvcGVydGllcyA9IHNjaGVtYVByb3BlcnRpZXM7XG5mdW5jdGlvbiBjYWxsVmFsaWRhdGVDb2RlKHsgc2NoZW1hQ29kZSwgZGF0YSwgaXQ6IHsgZ2VuLCB0b3BTY2hlbWFSZWYsIHNjaGVtYVBhdGgsIGVycm9yUGF0aCB9LCBpdCB9LCBmdW5jLCBjb250ZXh0LCBwYXNzU2NoZW1hKSB7XG4gICAgY29uc3QgZGF0YUFuZFNjaGVtYSA9IHBhc3NTY2hlbWEgPyAoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYUNvZGV9LCAke2RhdGF9LCAke3RvcFNjaGVtYVJlZn0ke3NjaGVtYVBhdGh9YCA6IGRhdGE7XG4gICAgY29uc3QgdmFsQ3h0ID0gW1xuICAgICAgICBbbmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aCwgKDAsIGNvZGVnZW5fMS5zdHJDb25jYXQpKG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsIGVycm9yUGF0aCldLFxuICAgICAgICBbbmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGEsIGl0LnBhcmVudERhdGFdLFxuICAgICAgICBbbmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eSwgaXQucGFyZW50RGF0YVByb3BlcnR5XSxcbiAgICAgICAgW25hbWVzXzEuZGVmYXVsdC5yb290RGF0YSwgbmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhXSxcbiAgICBdO1xuICAgIGlmIChpdC5vcHRzLmR5bmFtaWNSZWYpXG4gICAgICAgIHZhbEN4dC5wdXNoKFtuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnMsIG5hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9yc10pO1xuICAgIGNvbnN0IGFyZ3MgPSAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGFBbmRTY2hlbWF9LCAke2dlbi5vYmplY3QoLi4udmFsQ3h0KX1gO1xuICAgIHJldHVybiBjb250ZXh0ICE9PSBjb2RlZ2VuXzEubmlsID8gKDAsIGNvZGVnZW5fMS5fKSBgJHtmdW5jfS5jYWxsKCR7Y29udGV4dH0sICR7YXJnc30pYCA6ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZnVuY30oJHthcmdzfSlgO1xufVxuZXhwb3J0cy5jYWxsVmFsaWRhdGVDb2RlID0gY2FsbFZhbGlkYXRlQ29kZTtcbmNvbnN0IG5ld1JlZ0V4cCA9ICgwLCBjb2RlZ2VuXzEuXykgYG5ldyBSZWdFeHBgO1xuZnVuY3Rpb24gdXNlUGF0dGVybih7IGdlbiwgaXQ6IHsgb3B0cyB9IH0sIHBhdHRlcm4pIHtcbiAgICBjb25zdCB1ID0gb3B0cy51bmljb2RlUmVnRXhwID8gXCJ1XCIgOiBcIlwiO1xuICAgIGNvbnN0IHsgcmVnRXhwIH0gPSBvcHRzLmNvZGU7XG4gICAgY29uc3QgcnggPSByZWdFeHAocGF0dGVybiwgdSk7XG4gICAgcmV0dXJuIGdlbi5zY29wZVZhbHVlKFwicGF0dGVyblwiLCB7XG4gICAgICAgIGtleTogcngudG9TdHJpbmcoKSxcbiAgICAgICAgcmVmOiByeCxcbiAgICAgICAgY29kZTogKDAsIGNvZGVnZW5fMS5fKSBgJHtyZWdFeHAuY29kZSA9PT0gXCJuZXcgUmVnRXhwXCIgPyBuZXdSZWdFeHAgOiAoMCwgdXRpbF8yLnVzZUZ1bmMpKGdlbiwgcmVnRXhwKX0oJHtwYXR0ZXJufSwgJHt1fSlgLFxuICAgIH0pO1xufVxuZXhwb3J0cy51c2VQYXR0ZXJuID0gdXNlUGF0dGVybjtcbmZ1bmN0aW9uIHZhbGlkYXRlQXJyYXkoY3h0KSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGtleXdvcmQsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgIGlmIChpdC5hbGxFcnJvcnMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRBcnIgPSBnZW4ubGV0KFwidmFsaWRcIiwgdHJ1ZSk7XG4gICAgICAgIHZhbGlkYXRlSXRlbXMoKCkgPT4gZ2VuLmFzc2lnbih2YWxpZEFyciwgZmFsc2UpKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkQXJyO1xuICAgIH1cbiAgICBnZW4udmFyKHZhbGlkLCB0cnVlKTtcbiAgICB2YWxpZGF0ZUl0ZW1zKCgpID0+IGdlbi5icmVhaygpKTtcbiAgICByZXR1cm4gdmFsaWQ7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVJdGVtcyhub3RWYWxpZCkge1xuICAgICAgICBjb25zdCBsZW4gPSBnZW4uY29uc3QoXCJsZW5cIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfS5sZW5ndGhgKTtcbiAgICAgICAgZ2VuLmZvclJhbmdlKFwiaVwiLCAwLCBsZW4sIChpKSA9PiB7XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkLFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wOiBpLFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wVHlwZTogdXRpbF8xLlR5cGUuTnVtLFxuICAgICAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSh2YWxpZCksIG5vdFZhbGlkKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUFycmF5ID0gdmFsaWRhdGVBcnJheTtcbmZ1bmN0aW9uIHZhbGlkYXRlVW5pb24oY3h0KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgIGNvbnN0IGFsd2F5c1ZhbGlkID0gc2NoZW1hLnNvbWUoKHNjaCkgPT4gKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaCkpO1xuICAgIGlmIChhbHdheXNWYWxpZCAmJiAhaXQub3B0cy51bmV2YWx1YXRlZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIGZhbHNlKTtcbiAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpO1xuICAgIGdlbi5ibG9jaygoKSA9PiBzY2hlbWEuZm9yRWFjaCgoX3NjaCwgaSkgPT4ge1xuICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgIGtleXdvcmQsXG4gICAgICAgICAgICBzY2hlbWFQcm9wOiBpLFxuICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgfSwgc2NoVmFsaWQpO1xuICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCAoMCwgY29kZWdlbl8xLl8pIGAke3ZhbGlkfSB8fCAke3NjaFZhbGlkfWApO1xuICAgICAgICBjb25zdCBtZXJnZWQgPSBjeHQubWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hDeHQsIHNjaFZhbGlkKTtcbiAgICAgICAgLy8gY2FuIHNob3J0LWNpcmN1aXQgaWYgYHVuZXZhbHVhdGVkUHJvcGVydGllcy9JdGVtc2Agbm90IHN1cHBvcnRlZCAob3B0cy51bmV2YWx1YXRlZCAhPT0gdHJ1ZSlcbiAgICAgICAgLy8gb3IgaWYgYWxsIHByb3BlcnRpZXMgYW5kIGl0ZW1zIHdlcmUgZXZhbHVhdGVkIChpdC5wcm9wcyA9PT0gdHJ1ZSAmJiBpdC5pdGVtcyA9PT0gdHJ1ZSlcbiAgICAgICAgaWYgKCFtZXJnZWQpXG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSk7XG4gICAgfSkpO1xuICAgIGN4dC5yZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpO1xufVxuZXhwb3J0cy52YWxpZGF0ZVVuaW9uID0gdmFsaWRhdGVVbmlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlS2V5d29yZFVzYWdlID0gZXhwb3J0cy52YWxpZFNjaGVtYVR5cGUgPSBleHBvcnRzLmZ1bmNLZXl3b3JkQ29kZSA9IGV4cG9ydHMubWFjcm9LZXl3b3JkQ29kZSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi9uYW1lc1wiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi8uLi92b2NhYnVsYXJpZXMvY29kZVwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmZ1bmN0aW9uIG1hY3JvS2V5d29yZENvZGUoY3h0LCBkZWYpIHtcbiAgICBjb25zdCB7IGdlbiwga2V5d29yZCwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgbWFjcm9TY2hlbWEgPSBkZWYubWFjcm8uY2FsbChpdC5zZWxmLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQpO1xuICAgIGNvbnN0IHNjaGVtYVJlZiA9IHVzZUtleXdvcmQoZ2VuLCBrZXl3b3JkLCBtYWNyb1NjaGVtYSk7XG4gICAgaWYgKGl0Lm9wdHMudmFsaWRhdGVTY2hlbWEgIT09IGZhbHNlKVxuICAgICAgICBpdC5zZWxmLnZhbGlkYXRlU2NoZW1hKG1hY3JvU2NoZW1hLCB0cnVlKTtcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgIHNjaGVtYTogbWFjcm9TY2hlbWEsXG4gICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5uaWwsXG4gICAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gLFxuICAgICAgICB0b3BTY2hlbWFSZWY6IHNjaGVtYVJlZixcbiAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICB9LCB2YWxpZCk7XG4gICAgY3h0LnBhc3ModmFsaWQsICgpID0+IGN4dC5lcnJvcih0cnVlKSk7XG59XG5leHBvcnRzLm1hY3JvS2V5d29yZENvZGUgPSBtYWNyb0tleXdvcmRDb2RlO1xuZnVuY3Rpb24gZnVuY0tleXdvcmRDb2RlKGN4dCwgZGVmKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgZ2VuLCBrZXl3b3JkLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgJGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgY2hlY2tBc3luY0tleXdvcmQoaXQsIGRlZik7XG4gICAgY29uc3QgdmFsaWRhdGUgPSAhJGRhdGEgJiYgZGVmLmNvbXBpbGUgPyBkZWYuY29tcGlsZS5jYWxsKGl0LnNlbGYsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCkgOiBkZWYudmFsaWRhdGU7XG4gICAgY29uc3QgdmFsaWRhdGVSZWYgPSB1c2VLZXl3b3JkKGdlbiwga2V5d29yZCwgdmFsaWRhdGUpO1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCB2YWxpZGF0ZUtleXdvcmQpO1xuICAgIGN4dC5vaygoX2EgPSBkZWYudmFsaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbGlkKTtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUtleXdvcmQoKSB7XG4gICAgICAgIGlmIChkZWYuZXJyb3JzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYXNzaWduVmFsaWQoKTtcbiAgICAgICAgICAgIGlmIChkZWYubW9kaWZ5aW5nKVxuICAgICAgICAgICAgICAgIG1vZGlmeURhdGEoY3h0KTtcbiAgICAgICAgICAgIHJlcG9ydEVycnMoKCkgPT4gY3h0LmVycm9yKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcnVsZUVycnMgPSBkZWYuYXN5bmMgPyB2YWxpZGF0ZUFzeW5jKCkgOiB2YWxpZGF0ZVN5bmMoKTtcbiAgICAgICAgICAgIGlmIChkZWYubW9kaWZ5aW5nKVxuICAgICAgICAgICAgICAgIG1vZGlmeURhdGEoY3h0KTtcbiAgICAgICAgICAgIHJlcG9ydEVycnMoKCkgPT4gYWRkRXJycyhjeHQsIHJ1bGVFcnJzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVBc3luYygpIHtcbiAgICAgICAgY29uc3QgcnVsZUVycnMgPSBnZW4ubGV0KFwicnVsZUVycnNcIiwgbnVsbCk7XG4gICAgICAgIGdlbi50cnkoKCkgPT4gYXNzaWduVmFsaWQoKDAsIGNvZGVnZW5fMS5fKSBgYXdhaXQgYCksIChlKSA9PiBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSkuaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtlfSBpbnN0YW5jZW9mICR7aXQuVmFsaWRhdGlvbkVycm9yfWAsICgpID0+IGdlbi5hc3NpZ24ocnVsZUVycnMsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZX0uZXJyb3JzYCksICgpID0+IGdlbi50aHJvdyhlKSkpO1xuICAgICAgICByZXR1cm4gcnVsZUVycnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlU3luYygpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVFcnJzID0gKDAsIGNvZGVnZW5fMS5fKSBgJHt2YWxpZGF0ZVJlZn0uZXJyb3JzYDtcbiAgICAgICAgZ2VuLmFzc2lnbih2YWxpZGF0ZUVycnMsIG51bGwpO1xuICAgICAgICBhc3NpZ25WYWxpZChjb2RlZ2VuXzEubmlsKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlRXJycztcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzaWduVmFsaWQoX2F3YWl0ID0gZGVmLmFzeW5jID8gKDAsIGNvZGVnZW5fMS5fKSBgYXdhaXQgYCA6IGNvZGVnZW5fMS5uaWwpIHtcbiAgICAgICAgY29uc3QgcGFzc0N4dCA9IGl0Lm9wdHMucGFzc0NvbnRleHQgPyBuYW1lc18xLmRlZmF1bHQudGhpcyA6IG5hbWVzXzEuZGVmYXVsdC5zZWxmO1xuICAgICAgICBjb25zdCBwYXNzU2NoZW1hID0gISgoXCJjb21waWxlXCIgaW4gZGVmICYmICEkZGF0YSkgfHwgZGVmLnNjaGVtYSA9PT0gZmFsc2UpO1xuICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCAoMCwgY29kZWdlbl8xLl8pIGAke19hd2FpdH0keygwLCBjb2RlXzEuY2FsbFZhbGlkYXRlQ29kZSkoY3h0LCB2YWxpZGF0ZVJlZiwgcGFzc0N4dCwgcGFzc1NjaGVtYSl9YCwgZGVmLm1vZGlmeWluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcG9ydEVycnMoZXJyb3JzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSgoX2EgPSBkZWYudmFsaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbGlkKSwgZXJyb3JzKTtcbiAgICB9XG59XG5leHBvcnRzLmZ1bmNLZXl3b3JkQ29kZSA9IGZ1bmNLZXl3b3JkQ29kZTtcbmZ1bmN0aW9uIG1vZGlmeURhdGEoY3h0KSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgZ2VuLmlmKGl0LnBhcmVudERhdGEsICgpID0+IGdlbi5hc3NpZ24oZGF0YSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5wYXJlbnREYXRhfVske2l0LnBhcmVudERhdGFQcm9wZXJ0eX1dYCkpO1xufVxuZnVuY3Rpb24gYWRkRXJycyhjeHQsIGVycnMpIHtcbiAgICBjb25zdCB7IGdlbiB9ID0gY3h0O1xuICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGBBcnJheS5pc0FycmF5KCR7ZXJyc30pYCwgKCkgPT4ge1xuICAgICAgICBnZW5cbiAgICAgICAgICAgIC5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9ID09PSBudWxsID8gJHtlcnJzfSA6ICR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9LmNvbmNhdCgke2VycnN9KWApXG4gICAgICAgICAgICAuYXNzaWduKG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9Lmxlbmd0aGApO1xuICAgICAgICAoMCwgZXJyb3JzXzEuZXh0ZW5kRXJyb3JzKShjeHQpO1xuICAgIH0sICgpID0+IGN4dC5lcnJvcigpKTtcbn1cbmZ1bmN0aW9uIGNoZWNrQXN5bmNLZXl3b3JkKHsgc2NoZW1hRW52IH0sIGRlZikge1xuICAgIGlmIChkZWYuYXN5bmMgJiYgIXNjaGVtYUVudi4kYXN5bmMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFzeW5jIGtleXdvcmQgaW4gc3luYyBzY2hlbWFcIik7XG59XG5mdW5jdGlvbiB1c2VLZXl3b3JkKGdlbiwga2V5d29yZCwgcmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGtleXdvcmQgXCIke2tleXdvcmR9XCIgZmFpbGVkIHRvIGNvbXBpbGVgKTtcbiAgICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJrZXl3b3JkXCIsIHR5cGVvZiByZXN1bHQgPT0gXCJmdW5jdGlvblwiID8geyByZWY6IHJlc3VsdCB9IDogeyByZWY6IHJlc3VsdCwgY29kZTogKDAsIGNvZGVnZW5fMS5zdHJpbmdpZnkpKHJlc3VsdCkgfSk7XG59XG5mdW5jdGlvbiB2YWxpZFNjaGVtYVR5cGUoc2NoZW1hLCBzY2hlbWFUeXBlLCBhbGxvd1VuZGVmaW5lZCA9IGZhbHNlKSB7XG4gICAgLy8gVE9ETyBhZGQgdGVzdHNcbiAgICByZXR1cm4gKCFzY2hlbWFUeXBlLmxlbmd0aCB8fFxuICAgICAgICBzY2hlbWFUeXBlLnNvbWUoKHN0KSA9PiBzdCA9PT0gXCJhcnJheVwiXG4gICAgICAgICAgICA/IEFycmF5LmlzQXJyYXkoc2NoZW1hKVxuICAgICAgICAgICAgOiBzdCA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgICAgID8gc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShzY2hlbWEpXG4gICAgICAgICAgICAgICAgOiB0eXBlb2Ygc2NoZW1hID09IHN0IHx8IChhbGxvd1VuZGVmaW5lZCAmJiB0eXBlb2Ygc2NoZW1hID09IFwidW5kZWZpbmVkXCIpKSk7XG59XG5leHBvcnRzLnZhbGlkU2NoZW1hVHlwZSA9IHZhbGlkU2NoZW1hVHlwZTtcbmZ1bmN0aW9uIHZhbGlkYXRlS2V5d29yZFVzYWdlKHsgc2NoZW1hLCBvcHRzLCBzZWxmLCBlcnJTY2hlbWFQYXRoIH0sIGRlZiwga2V5d29yZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRlZi5rZXl3b3JkKSA/ICFkZWYua2V5d29yZC5pbmNsdWRlcyhrZXl3b3JkKSA6IGRlZi5rZXl3b3JkICE9PSBrZXl3b3JkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICB9XG4gICAgY29uc3QgZGVwcyA9IGRlZi5kZXBlbmRlbmNpZXM7XG4gICAgaWYgKGRlcHMgPT09IG51bGwgfHwgZGVwcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVwcy5zb21lKChrd2QpID0+ICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2NoZW1hLCBrd2QpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcmVudCBzY2hlbWEgbXVzdCBoYXZlIGRlcGVuZGVuY2llcyBvZiAke2tleXdvcmR9OiAke2RlcHMuam9pbihcIixcIil9YCk7XG4gICAgfVxuICAgIGlmIChkZWYudmFsaWRhdGVTY2hlbWEpIHtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBkZWYudmFsaWRhdGVTY2hlbWEoc2NoZW1hW2tleXdvcmRdKTtcbiAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYGtleXdvcmQgXCIke2tleXdvcmR9XCIgdmFsdWUgaXMgaW52YWxpZCBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiOiBgICtcbiAgICAgICAgICAgICAgICBzZWxmLmVycm9yc1RleHQoZGVmLnZhbGlkYXRlU2NoZW1hLmVycm9ycyk7XG4gICAgICAgICAgICBpZiAob3B0cy52YWxpZGF0ZVNjaGVtYSA9PT0gXCJsb2dcIilcbiAgICAgICAgICAgICAgICBzZWxmLmxvZ2dlci5lcnJvcihtc2cpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUtleXdvcmRVc2FnZSA9IHZhbGlkYXRlS2V5d29yZFVzYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5d29yZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0ZW5kU3Vic2NoZW1hTW9kZSA9IGV4cG9ydHMuZXh0ZW5kU3Vic2NoZW1hRGF0YSA9IGV4cG9ydHMuZ2V0U3Vic2NoZW1hID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmZ1bmN0aW9uIGdldFN1YnNjaGVtYShpdCwgeyBrZXl3b3JkLCBzY2hlbWFQcm9wLCBzY2hlbWEsIHNjaGVtYVBhdGgsIGVyclNjaGVtYVBhdGgsIHRvcFNjaGVtYVJlZiB9KSB7XG4gICAgaWYgKGtleXdvcmQgIT09IHVuZGVmaW5lZCAmJiBzY2hlbWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGggXCJrZXl3b3JkXCIgYW5kIFwic2NoZW1hXCIgcGFzc2VkLCBvbmx5IG9uZSBhbGxvd2VkJyk7XG4gICAgfVxuICAgIGlmIChrZXl3b3JkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgc2NoID0gaXQuc2NoZW1hW2tleXdvcmRdO1xuICAgICAgICByZXR1cm4gc2NoZW1hUHJvcCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHNjaCxcbiAgICAgICAgICAgICAgICBzY2hlbWFQYXRoOiAoMCwgY29kZWdlbl8xLl8pIGAke2l0LnNjaGVtYVBhdGh9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShrZXl3b3JkKX1gLFxuICAgICAgICAgICAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiBzY2hbc2NoZW1hUHJvcF0sXG4gICAgICAgICAgICAgICAgc2NoZW1hUGF0aDogKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5zY2hlbWFQYXRofSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkoa2V5d29yZCl9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShzY2hlbWFQcm9wKX1gLFxuICAgICAgICAgICAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH0vJHsoMCwgdXRpbF8xLmVzY2FwZUZyYWdtZW50KShzY2hlbWFQcm9wKX1gLFxuICAgICAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChzY2hlbWFQYXRoID09PSB1bmRlZmluZWQgfHwgZXJyU2NoZW1hUGF0aCA9PT0gdW5kZWZpbmVkIHx8IHRvcFNjaGVtYVJlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wic2NoZW1hUGF0aFwiLCBcImVyclNjaGVtYVBhdGhcIiBhbmQgXCJ0b3BTY2hlbWFSZWZcIiBhcmUgcmVxdWlyZWQgd2l0aCBcInNjaGVtYVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgIHNjaGVtYVBhdGgsXG4gICAgICAgICAgICB0b3BTY2hlbWFSZWYsXG4gICAgICAgICAgICBlcnJTY2hlbWFQYXRoLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VpdGhlciBcImtleXdvcmRcIiBvciBcInNjaGVtYVwiIG11c3QgYmUgcGFzc2VkJyk7XG59XG5leHBvcnRzLmdldFN1YnNjaGVtYSA9IGdldFN1YnNjaGVtYTtcbmZ1bmN0aW9uIGV4dGVuZFN1YnNjaGVtYURhdGEoc3Vic2NoZW1hLCBpdCwgeyBkYXRhUHJvcCwgZGF0YVByb3BUeXBlOiBkcFR5cGUsIGRhdGEsIGRhdGFUeXBlcywgcHJvcGVydHlOYW1lIH0pIHtcbiAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkICYmIGRhdGFQcm9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdib3RoIFwiZGF0YVwiIGFuZCBcImRhdGFQcm9wXCIgcGFzc2VkLCBvbmx5IG9uZSBhbGxvd2VkJyk7XG4gICAgfVxuICAgIGNvbnN0IHsgZ2VuIH0gPSBpdDtcbiAgICBpZiAoZGF0YVByb3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB7IGVycm9yUGF0aCwgZGF0YVBhdGhBcnIsIG9wdHMgfSA9IGl0O1xuICAgICAgICBjb25zdCBuZXh0RGF0YSA9IGdlbi5sZXQoXCJkYXRhXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuZGF0YX0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKGRhdGFQcm9wKX1gLCB0cnVlKTtcbiAgICAgICAgZGF0YUNvbnRleHRQcm9wcyhuZXh0RGF0YSk7XG4gICAgICAgIHN1YnNjaGVtYS5lcnJvclBhdGggPSAoMCwgY29kZWdlbl8xLnN0cikgYCR7ZXJyb3JQYXRofSR7KDAsIHV0aWxfMS5nZXRFcnJvclBhdGgpKGRhdGFQcm9wLCBkcFR5cGUsIG9wdHMuanNQcm9wZXJ0eVN5bnRheCl9YDtcbiAgICAgICAgc3Vic2NoZW1hLnBhcmVudERhdGFQcm9wZXJ0eSA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YVByb3B9YDtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFQYXRoQXJyID0gWy4uLmRhdGFQYXRoQXJyLCBzdWJzY2hlbWEucGFyZW50RGF0YVByb3BlcnR5XTtcbiAgICB9XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBuZXh0RGF0YSA9IGRhdGEgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSA/IGRhdGEgOiBnZW4ubGV0KFwiZGF0YVwiLCBkYXRhLCB0cnVlKTsgLy8gcmVwbGFjZWFibGUgaWYgdXNlZCBvbmNlP1xuICAgICAgICBkYXRhQ29udGV4dFByb3BzKG5leHREYXRhKTtcbiAgICAgICAgaWYgKHByb3BlcnR5TmFtZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgc3Vic2NoZW1hLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZTtcbiAgICAgICAgLy8gVE9ETyBzb21ldGhpbmcgaXMgcG9zc2libHkgd3JvbmcgaGVyZSB3aXRoIG5vdCBjaGFuZ2luZyBwYXJlbnREYXRhUHJvcGVydHkgYW5kIG5vdCBhcHBlbmRpbmcgZGF0YVBhdGhBcnJcbiAgICB9XG4gICAgaWYgKGRhdGFUeXBlcylcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFUeXBlcyA9IGRhdGFUeXBlcztcbiAgICBmdW5jdGlvbiBkYXRhQ29udGV4dFByb3BzKF9uZXh0RGF0YSkge1xuICAgICAgICBzdWJzY2hlbWEuZGF0YSA9IF9uZXh0RGF0YTtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFMZXZlbCA9IGl0LmRhdGFMZXZlbCArIDE7XG4gICAgICAgIHN1YnNjaGVtYS5kYXRhVHlwZXMgPSBbXTtcbiAgICAgICAgaXQuZGVmaW5lZFByb3BlcnRpZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHN1YnNjaGVtYS5wYXJlbnREYXRhID0gaXQuZGF0YTtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGFOYW1lcyA9IFsuLi5pdC5kYXRhTmFtZXMsIF9uZXh0RGF0YV07XG4gICAgfVxufVxuZXhwb3J0cy5leHRlbmRTdWJzY2hlbWFEYXRhID0gZXh0ZW5kU3Vic2NoZW1hRGF0YTtcbmZ1bmN0aW9uIGV4dGVuZFN1YnNjaGVtYU1vZGUoc3Vic2NoZW1hLCB7IGp0ZERpc2NyaW1pbmF0b3IsIGp0ZE1ldGFkYXRhLCBjb21wb3NpdGVSdWxlLCBjcmVhdGVFcnJvcnMsIGFsbEVycm9ycyB9KSB7XG4gICAgaWYgKGNvbXBvc2l0ZVJ1bGUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgc3Vic2NoZW1hLmNvbXBvc2l0ZVJ1bGUgPSBjb21wb3NpdGVSdWxlO1xuICAgIGlmIChjcmVhdGVFcnJvcnMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgc3Vic2NoZW1hLmNyZWF0ZUVycm9ycyA9IGNyZWF0ZUVycm9ycztcbiAgICBpZiAoYWxsRXJyb3JzICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHN1YnNjaGVtYS5hbGxFcnJvcnMgPSBhbGxFcnJvcnM7XG4gICAgc3Vic2NoZW1hLmp0ZERpc2NyaW1pbmF0b3IgPSBqdGREaXNjcmltaW5hdG9yOyAvLyBub3QgaW5oZXJpdGVkXG4gICAgc3Vic2NoZW1hLmp0ZE1ldGFkYXRhID0ganRkTWV0YWRhdGE7IC8vIG5vdCBpbmhlcml0ZWRcbn1cbmV4cG9ydHMuZXh0ZW5kU3Vic2NoZW1hTW9kZSA9IGV4dGVuZFN1YnNjaGVtYU1vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY2hlbWEuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBkbyBub3QgZWRpdCAuanMgZmlsZXMgZGlyZWN0bHkgLSBlZGl0IHNyYy9pbmRleC5qc3RcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PSAnb2JqZWN0Jykge1xuICAgIGlmIChhLmNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgbGVuZ3RoLCBpLCBrZXlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgICAgaWYgKCFlcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG5cblxuICAgIGlmIChhLmNvbnN0cnVjdG9yID09PSBSZWdFeHApIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncztcbiAgICBpZiAoYS52YWx1ZU9mICE9PSBPYmplY3QucHJvdG90eXBlLnZhbHVlT2YpIHJldHVybiBhLnZhbHVlT2YoKSA9PT0gYi52YWx1ZU9mKCk7XG4gICAgaWYgKGEudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleXNbaV0pKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoIWVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gdHJ1ZSBpZiBib3RoIE5hTiwgZmFsc2Ugb3RoZXJ3aXNlXG4gIHJldHVybiBhIT09YSAmJiBiIT09Yjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0cmF2ZXJzZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNjaGVtYSwgb3B0cywgY2IpIHtcbiAgLy8gTGVnYWN5IHN1cHBvcnQgZm9yIHYwLjMuMSBhbmQgZWFybGllci5cbiAgaWYgKHR5cGVvZiBvcHRzID09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgY2IgPSBvcHRzLmNiIHx8IGNiO1xuICB2YXIgcHJlID0gKHR5cGVvZiBjYiA9PSAnZnVuY3Rpb24nKSA/IGNiIDogY2IucHJlIHx8IGZ1bmN0aW9uKCkge307XG4gIHZhciBwb3N0ID0gY2IucG9zdCB8fCBmdW5jdGlvbigpIHt9O1xuXG4gIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaGVtYSwgJycsIHNjaGVtYSk7XG59O1xuXG5cbnRyYXZlcnNlLmtleXdvcmRzID0ge1xuICBhZGRpdGlvbmFsSXRlbXM6IHRydWUsXG4gIGl0ZW1zOiB0cnVlLFxuICBjb250YWluczogdHJ1ZSxcbiAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHRydWUsXG4gIHByb3BlcnR5TmFtZXM6IHRydWUsXG4gIG5vdDogdHJ1ZSxcbiAgaWY6IHRydWUsXG4gIHRoZW46IHRydWUsXG4gIGVsc2U6IHRydWVcbn07XG5cbnRyYXZlcnNlLmFycmF5S2V5d29yZHMgPSB7XG4gIGl0ZW1zOiB0cnVlLFxuICBhbGxPZjogdHJ1ZSxcbiAgYW55T2Y6IHRydWUsXG4gIG9uZU9mOiB0cnVlXG59O1xuXG50cmF2ZXJzZS5wcm9wc0tleXdvcmRzID0ge1xuICAkZGVmczogdHJ1ZSxcbiAgZGVmaW5pdGlvbnM6IHRydWUsXG4gIHByb3BlcnRpZXM6IHRydWUsXG4gIHBhdHRlcm5Qcm9wZXJ0aWVzOiB0cnVlLFxuICBkZXBlbmRlbmNpZXM6IHRydWVcbn07XG5cbnRyYXZlcnNlLnNraXBLZXl3b3JkcyA9IHtcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgZW51bTogdHJ1ZSxcbiAgY29uc3Q6IHRydWUsXG4gIHJlcXVpcmVkOiB0cnVlLFxuICBtYXhpbXVtOiB0cnVlLFxuICBtaW5pbXVtOiB0cnVlLFxuICBleGNsdXNpdmVNYXhpbXVtOiB0cnVlLFxuICBleGNsdXNpdmVNaW5pbXVtOiB0cnVlLFxuICBtdWx0aXBsZU9mOiB0cnVlLFxuICBtYXhMZW5ndGg6IHRydWUsXG4gIG1pbkxlbmd0aDogdHJ1ZSxcbiAgcGF0dGVybjogdHJ1ZSxcbiAgZm9ybWF0OiB0cnVlLFxuICBtYXhJdGVtczogdHJ1ZSxcbiAgbWluSXRlbXM6IHRydWUsXG4gIHVuaXF1ZUl0ZW1zOiB0cnVlLFxuICBtYXhQcm9wZXJ0aWVzOiB0cnVlLFxuICBtaW5Qcm9wZXJ0aWVzOiB0cnVlXG59O1xuXG5cbmZ1bmN0aW9uIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaGVtYSwganNvblB0ciwgcm9vdFNjaGVtYSwgcGFyZW50SnNvblB0ciwgcGFyZW50S2V5d29yZCwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCkge1xuICBpZiAoc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgIHByZShzY2hlbWEsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpO1xuICAgIGZvciAodmFyIGtleSBpbiBzY2hlbWEpIHtcbiAgICAgIHZhciBzY2ggPSBzY2hlbWFba2V5XTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaCkpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0cmF2ZXJzZS5hcnJheUtleXdvcmRzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHNjaC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaFtpXSwganNvblB0ciArICcvJyArIGtleSArICcvJyArIGksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hLCBpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgaW4gdHJhdmVyc2UucHJvcHNLZXl3b3Jkcykge1xuICAgICAgICBpZiAoc2NoICYmIHR5cGVvZiBzY2ggPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHNjaClcbiAgICAgICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaFtwcm9wXSwganNvblB0ciArICcvJyArIGtleSArICcvJyArIGVzY2FwZUpzb25QdHIocHJvcCksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hLCBwcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgaW4gdHJhdmVyc2Uua2V5d29yZHMgfHwgKG9wdHMuYWxsS2V5cyAmJiAhKGtleSBpbiB0cmF2ZXJzZS5za2lwS2V5d29yZHMpKSkge1xuICAgICAgICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2gsIGpzb25QdHIgKyAnLycgKyBrZXksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9zdChzY2hlbWEsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZXNjYXBlSnNvblB0cihzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+L2csICd+MCcpLnJlcGxhY2UoL1xcLy9nLCAnfjEnKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRTY2hlbWFSZWZzID0gZXhwb3J0cy5yZXNvbHZlVXJsID0gZXhwb3J0cy5ub3JtYWxpemVJZCA9IGV4cG9ydHMuX2dldEZ1bGxQYXRoID0gZXhwb3J0cy5nZXRGdWxsUGF0aCA9IGV4cG9ydHMuaW5saW5lUmVmID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IGVxdWFsID0gcmVxdWlyZShcImZhc3QtZGVlcC1lcXVhbFwiKTtcbmNvbnN0IHRyYXZlcnNlID0gcmVxdWlyZShcImpzb24tc2NoZW1hLXRyYXZlcnNlXCIpO1xuLy8gVE9ETyByZWZhY3RvciB0byB1c2Uga2V5d29yZCBkZWZpbml0aW9uc1xuY29uc3QgU0lNUExFX0lOTElORUQgPSBuZXcgU2V0KFtcbiAgICBcInR5cGVcIixcbiAgICBcImZvcm1hdFwiLFxuICAgIFwicGF0dGVyblwiLFxuICAgIFwibWF4TGVuZ3RoXCIsXG4gICAgXCJtaW5MZW5ndGhcIixcbiAgICBcIm1heFByb3BlcnRpZXNcIixcbiAgICBcIm1pblByb3BlcnRpZXNcIixcbiAgICBcIm1heEl0ZW1zXCIsXG4gICAgXCJtaW5JdGVtc1wiLFxuICAgIFwibWF4aW11bVwiLFxuICAgIFwibWluaW11bVwiLFxuICAgIFwidW5pcXVlSXRlbXNcIixcbiAgICBcIm11bHRpcGxlT2ZcIixcbiAgICBcInJlcXVpcmVkXCIsXG4gICAgXCJlbnVtXCIsXG4gICAgXCJjb25zdFwiLFxuXSk7XG5mdW5jdGlvbiBpbmxpbmVSZWYoc2NoZW1hLCBsaW1pdCA9IHRydWUpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGxpbWl0ID09PSB0cnVlKVxuICAgICAgICByZXR1cm4gIWhhc1JlZihzY2hlbWEpO1xuICAgIGlmICghbGltaXQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gY291bnRLZXlzKHNjaGVtYSkgPD0gbGltaXQ7XG59XG5leHBvcnRzLmlubGluZVJlZiA9IGlubGluZVJlZjtcbmNvbnN0IFJFRl9LRVlXT1JEUyA9IG5ldyBTZXQoW1xuICAgIFwiJHJlZlwiLFxuICAgIFwiJHJlY3Vyc2l2ZVJlZlwiLFxuICAgIFwiJHJlY3Vyc2l2ZUFuY2hvclwiLFxuICAgIFwiJGR5bmFtaWNSZWZcIixcbiAgICBcIiRkeW5hbWljQW5jaG9yXCIsXG5dKTtcbmZ1bmN0aW9uIGhhc1JlZihzY2hlbWEpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKFJFRl9LRVlXT1JEUy5oYXMoa2V5KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCBzY2ggPSBzY2hlbWFba2V5XTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoKSAmJiBzY2guc29tZShoYXNSZWYpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwib2JqZWN0XCIgJiYgaGFzUmVmKHNjaCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY291bnRLZXlzKHNjaGVtYSkge1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIGlmIChrZXkgPT09IFwiJHJlZlwiKVxuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICBjb3VudCsrO1xuICAgICAgICBpZiAoU0lNUExFX0lOTElORUQuaGFzKGtleSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWFba2V5XSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAoMCwgdXRpbF8xLmVhY2hJdGVtKShzY2hlbWFba2V5XSwgKHNjaCkgPT4gKGNvdW50ICs9IGNvdW50S2V5cyhzY2gpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50ID09PSBJbmZpbml0eSlcbiAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xufVxuZnVuY3Rpb24gZ2V0RnVsbFBhdGgocmVzb2x2ZXIsIGlkID0gXCJcIiwgbm9ybWFsaXplKSB7XG4gICAgaWYgKG5vcm1hbGl6ZSAhPT0gZmFsc2UpXG4gICAgICAgIGlkID0gbm9ybWFsaXplSWQoaWQpO1xuICAgIGNvbnN0IHAgPSByZXNvbHZlci5wYXJzZShpZCk7XG4gICAgcmV0dXJuIF9nZXRGdWxsUGF0aChyZXNvbHZlciwgcCk7XG59XG5leHBvcnRzLmdldEZ1bGxQYXRoID0gZ2V0RnVsbFBhdGg7XG5mdW5jdGlvbiBfZ2V0RnVsbFBhdGgocmVzb2x2ZXIsIHApIHtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gcmVzb2x2ZXIuc2VyaWFsaXplKHApO1xuICAgIHJldHVybiBzZXJpYWxpemVkLnNwbGl0KFwiI1wiKVswXSArIFwiI1wiO1xufVxuZXhwb3J0cy5fZ2V0RnVsbFBhdGggPSBfZ2V0RnVsbFBhdGg7XG5jb25zdCBUUkFJTElOR19TTEFTSF9IQVNIID0gLyNcXC8/JC87XG5mdW5jdGlvbiBub3JtYWxpemVJZChpZCkge1xuICAgIHJldHVybiBpZCA/IGlkLnJlcGxhY2UoVFJBSUxJTkdfU0xBU0hfSEFTSCwgXCJcIikgOiBcIlwiO1xufVxuZXhwb3J0cy5ub3JtYWxpemVJZCA9IG5vcm1hbGl6ZUlkO1xuZnVuY3Rpb24gcmVzb2x2ZVVybChyZXNvbHZlciwgYmFzZUlkLCBpZCkge1xuICAgIGlkID0gbm9ybWFsaXplSWQoaWQpO1xuICAgIHJldHVybiByZXNvbHZlci5yZXNvbHZlKGJhc2VJZCwgaWQpO1xufVxuZXhwb3J0cy5yZXNvbHZlVXJsID0gcmVzb2x2ZVVybDtcbmNvbnN0IEFOQ0hPUiA9IC9eW2Etel9dWy1hLXowLTkuX10qJC9pO1xuZnVuY3Rpb24gZ2V0U2NoZW1hUmVmcyhzY2hlbWEsIGJhc2VJZCkge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4ge307XG4gICAgY29uc3QgeyBzY2hlbWFJZCwgdXJpUmVzb2x2ZXIgfSA9IHRoaXMub3B0cztcbiAgICBjb25zdCBzY2hJZCA9IG5vcm1hbGl6ZUlkKHNjaGVtYVtzY2hlbWFJZF0gfHwgYmFzZUlkKTtcbiAgICBjb25zdCBiYXNlSWRzID0geyBcIlwiOiBzY2hJZCB9O1xuICAgIGNvbnN0IHBhdGhQcmVmaXggPSBnZXRGdWxsUGF0aCh1cmlSZXNvbHZlciwgc2NoSWQsIGZhbHNlKTtcbiAgICBjb25zdCBsb2NhbFJlZnMgPSB7fTtcbiAgICBjb25zdCBzY2hlbWFSZWZzID0gbmV3IFNldCgpO1xuICAgIHRyYXZlcnNlKHNjaGVtYSwgeyBhbGxLZXlzOiB0cnVlIH0sIChzY2gsIGpzb25QdHIsIF8sIHBhcmVudEpzb25QdHIpID0+IHtcbiAgICAgICAgaWYgKHBhcmVudEpzb25QdHIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZnVsbFBhdGggPSBwYXRoUHJlZml4ICsganNvblB0cjtcbiAgICAgICAgbGV0IGlubmVyQmFzZUlkID0gYmFzZUlkc1twYXJlbnRKc29uUHRyXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hbc2NoZW1hSWRdID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBpbm5lckJhc2VJZCA9IGFkZFJlZi5jYWxsKHRoaXMsIHNjaFtzY2hlbWFJZF0pO1xuICAgICAgICBhZGRBbmNob3IuY2FsbCh0aGlzLCBzY2guJGFuY2hvcik7XG4gICAgICAgIGFkZEFuY2hvci5jYWxsKHRoaXMsIHNjaC4kZHluYW1pY0FuY2hvcik7XG4gICAgICAgIGJhc2VJZHNbanNvblB0cl0gPSBpbm5lckJhc2VJZDtcbiAgICAgICAgZnVuY3Rpb24gYWRkUmVmKHJlZikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgICAgICAgY29uc3QgX3Jlc29sdmUgPSB0aGlzLm9wdHMudXJpUmVzb2x2ZXIucmVzb2x2ZTtcbiAgICAgICAgICAgIHJlZiA9IG5vcm1hbGl6ZUlkKGlubmVyQmFzZUlkID8gX3Jlc29sdmUoaW5uZXJCYXNlSWQsIHJlZikgOiByZWYpO1xuICAgICAgICAgICAgaWYgKHNjaGVtYVJlZnMuaGFzKHJlZikpXG4gICAgICAgICAgICAgICAgdGhyb3cgYW1iaWd1b3MocmVmKTtcbiAgICAgICAgICAgIHNjaGVtYVJlZnMuYWRkKHJlZik7XG4gICAgICAgICAgICBsZXQgc2NoT3JSZWYgPSB0aGlzLnJlZnNbcmVmXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoT3JSZWYgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBzY2hPclJlZiA9IHRoaXMucmVmc1tzY2hPclJlZl07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaE9yUmVmID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBjaGVja0FtYmlndW9zUmVmKHNjaCwgc2NoT3JSZWYuc2NoZW1hLCByZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVmICE9PSBub3JtYWxpemVJZChmdWxsUGF0aCkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVmWzBdID09PSBcIiNcIikge1xuICAgICAgICAgICAgICAgICAgICBjaGVja0FtYmlndW9zUmVmKHNjaCwgbG9jYWxSZWZzW3JlZl0sIHJlZik7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsUmVmc1tyZWZdID0gc2NoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZzW3JlZl0gPSBmdWxsUGF0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVmO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFkZEFuY2hvcihhbmNob3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYW5jaG9yID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFOQ0hPUi50ZXN0KGFuY2hvcikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBhbmNob3IgXCIke2FuY2hvcn1cImApO1xuICAgICAgICAgICAgICAgIGFkZFJlZi5jYWxsKHRoaXMsIGAjJHthbmNob3J9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbG9jYWxSZWZzO1xuICAgIGZ1bmN0aW9uIGNoZWNrQW1iaWd1b3NSZWYoc2NoMSwgc2NoMiwgcmVmKSB7XG4gICAgICAgIGlmIChzY2gyICE9PSB1bmRlZmluZWQgJiYgIWVxdWFsKHNjaDEsIHNjaDIpKVxuICAgICAgICAgICAgdGhyb3cgYW1iaWd1b3MocmVmKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYW1iaWd1b3MocmVmKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoYHJlZmVyZW5jZSBcIiR7cmVmfVwiIHJlc29sdmVzIHRvIG1vcmUgdGhhbiBvbmUgc2NoZW1hYCk7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRTY2hlbWFSZWZzID0gZ2V0U2NoZW1hUmVmcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldERhdGEgPSBleHBvcnRzLktleXdvcmRDeHQgPSBleHBvcnRzLnZhbGlkYXRlRnVuY3Rpb25Db2RlID0gdm9pZCAwO1xuY29uc3QgYm9vbFNjaGVtYV8xID0gcmVxdWlyZShcIi4vYm9vbFNjaGVtYVwiKTtcbmNvbnN0IGRhdGFUeXBlXzEgPSByZXF1aXJlKFwiLi9kYXRhVHlwZVwiKTtcbmNvbnN0IGFwcGxpY2FiaWxpdHlfMSA9IHJlcXVpcmUoXCIuL2FwcGxpY2FiaWxpdHlcIik7XG5jb25zdCBkYXRhVHlwZV8yID0gcmVxdWlyZShcIi4vZGF0YVR5cGVcIik7XG5jb25zdCBkZWZhdWx0c18xID0gcmVxdWlyZShcIi4vZGVmYXVsdHNcIik7XG5jb25zdCBrZXl3b3JkXzEgPSByZXF1aXJlKFwiLi9rZXl3b3JkXCIpO1xuY29uc3Qgc3Vic2NoZW1hXzEgPSByZXF1aXJlKFwiLi9zdWJzY2hlbWFcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vbmFtZXNcIik7XG5jb25zdCByZXNvbHZlXzEgPSByZXF1aXJlKFwiLi4vcmVzb2x2ZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuLy8gc2NoZW1hIGNvbXBpbGF0aW9uIC0gZ2VuZXJhdGVzIHZhbGlkYXRpb24gZnVuY3Rpb24sIHN1YnNjaGVtYUNvZGUgKGJlbG93KSBpcyB1c2VkIGZvciBzdWJzY2hlbWFzXG5mdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uQ29kZShpdCkge1xuICAgIGlmIChpc1NjaGVtYU9iaihpdCkpIHtcbiAgICAgICAgY2hlY2tLZXl3b3JkcyhpdCk7XG4gICAgICAgIGlmIChzY2hlbWFDeHRIYXNSdWxlcyhpdCkpIHtcbiAgICAgICAgICAgIHRvcFNjaGVtYU9iakNvZGUoaXQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhbGlkYXRlRnVuY3Rpb24oaXQsICgpID0+ICgwLCBib29sU2NoZW1hXzEudG9wQm9vbE9yRW1wdHlTY2hlbWEpKGl0KSk7XG59XG5leHBvcnRzLnZhbGlkYXRlRnVuY3Rpb25Db2RlID0gdmFsaWRhdGVGdW5jdGlvbkNvZGU7XG5mdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uKHsgZ2VuLCB2YWxpZGF0ZU5hbWUsIHNjaGVtYSwgc2NoZW1hRW52LCBvcHRzIH0sIGJvZHkpIHtcbiAgICBpZiAob3B0cy5jb2RlLmVzNSkge1xuICAgICAgICBnZW4uZnVuYyh2YWxpZGF0ZU5hbWUsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LmRhdGF9LCAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9YCwgc2NoZW1hRW52LiRhc3luYywgKCkgPT4ge1xuICAgICAgICAgICAgZ2VuLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgXCJ1c2Ugc3RyaWN0XCI7ICR7ZnVuY1NvdXJjZVVybChzY2hlbWEsIG9wdHMpfWApO1xuICAgICAgICAgICAgZGVzdHJ1Y3R1cmVWYWxDeHRFUzUoZ2VuLCBvcHRzKTtcbiAgICAgICAgICAgIGdlbi5jb2RlKGJvZHkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi5mdW5jKHZhbGlkYXRlTmFtZSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQuZGF0YX0sICR7ZGVzdHJ1Y3R1cmVWYWxDeHQob3B0cyl9YCwgc2NoZW1hRW52LiRhc3luYywgKCkgPT4gZ2VuLmNvZGUoZnVuY1NvdXJjZVVybChzY2hlbWEsIG9wdHMpKS5jb2RlKGJvZHkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXN0cnVjdHVyZVZhbEN4dChvcHRzKSB7XG4gICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYHske25hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGh9PVwiXCIsICR7bmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGF9LCAke25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHl9LCAke25hbWVzXzEuZGVmYXVsdC5yb290RGF0YX09JHtuYW1lc18xLmRlZmF1bHQuZGF0YX0ke29wdHMuZHluYW1pY1JlZiA/ICgwLCBjb2RlZ2VuXzEuXykgYCwgJHtuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnN9PXt9YCA6IGNvZGVnZW5fMS5uaWx9fT17fWA7XG59XG5mdW5jdGlvbiBkZXN0cnVjdHVyZVZhbEN4dEVTNShnZW4sIG9wdHMpIHtcbiAgICBnZW4uaWYobmFtZXNfMS5kZWZhdWx0LnZhbEN4dCwgKCkgPT4ge1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZhbEN4dH0uJHtuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRofWApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGF9YCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fS4ke25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHl9YCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhfWApO1xuICAgICAgICBpZiAob3B0cy5keW5hbWljUmVmKVxuICAgICAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnMsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZhbEN4dH0uJHtuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnN9YCk7XG4gICAgfSwgKCkgPT4ge1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsICgwLCBjb2RlZ2VuXzEuXykgYFwiXCJgKTtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YSwgKDAsIGNvZGVnZW5fMS5fKSBgdW5kZWZpbmVkYCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eSwgKDAsIGNvZGVnZW5fMS5fKSBgdW5kZWZpbmVkYCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhLCBuYW1lc18xLmRlZmF1bHQuZGF0YSk7XG4gICAgICAgIGlmIChvcHRzLmR5bmFtaWNSZWYpXG4gICAgICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9ycywgKDAsIGNvZGVnZW5fMS5fKSBge31gKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHRvcFNjaGVtYU9iakNvZGUoaXQpIHtcbiAgICBjb25zdCB7IHNjaGVtYSwgb3B0cywgZ2VuIH0gPSBpdDtcbiAgICB2YWxpZGF0ZUZ1bmN0aW9uKGl0LCAoKSA9PiB7XG4gICAgICAgIGlmIChvcHRzLiRjb21tZW50ICYmIHNjaGVtYS4kY29tbWVudClcbiAgICAgICAgICAgIGNvbW1lbnRLZXl3b3JkKGl0KTtcbiAgICAgICAgY2hlY2tOb0RlZmF1bHQoaXQpO1xuICAgICAgICBnZW4ubGV0KG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCBudWxsKTtcbiAgICAgICAgZ2VuLmxldChuYW1lc18xLmRlZmF1bHQuZXJyb3JzLCAwKTtcbiAgICAgICAgaWYgKG9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgICAgICByZXNldEV2YWx1YXRlZChpdCk7XG4gICAgICAgIHR5cGVBbmRLZXl3b3JkcyhpdCk7XG4gICAgICAgIHJldHVyblJlc3VsdHMoaXQpO1xuICAgIH0pO1xuICAgIHJldHVybjtcbn1cbmZ1bmN0aW9uIHJlc2V0RXZhbHVhdGVkKGl0KSB7XG4gICAgLy8gVE9ETyBtYXliZSBzb21lIGhvb2sgdG8gZXhlY3V0ZSBpdCBpbiB0aGUgZW5kIHRvIGNoZWNrIHdoZXRoZXIgcHJvcHMvaXRlbXMgYXJlIE5hbWUsIGFzIGluIGFzc2lnbkV2YWx1YXRlZFxuICAgIGNvbnN0IHsgZ2VuLCB2YWxpZGF0ZU5hbWUgfSA9IGl0O1xuICAgIGl0LmV2YWx1YXRlZCA9IGdlbi5jb25zdChcImV2YWx1YXRlZFwiLCAoMCwgY29kZWdlbl8xLl8pIGAke3ZhbGlkYXRlTmFtZX0uZXZhbHVhdGVkYCk7XG4gICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuZXZhbHVhdGVkfS5keW5hbWljUHJvcHNgLCAoKSA9PiBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuZXZhbHVhdGVkfS5wcm9wc2AsICgwLCBjb2RlZ2VuXzEuXykgYHVuZGVmaW5lZGApKTtcbiAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5ldmFsdWF0ZWR9LmR5bmFtaWNJdGVtc2AsICgpID0+IGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5ldmFsdWF0ZWR9Lml0ZW1zYCwgKDAsIGNvZGVnZW5fMS5fKSBgdW5kZWZpbmVkYCkpO1xufVxuZnVuY3Rpb24gZnVuY1NvdXJjZVVybChzY2hlbWEsIG9wdHMpIHtcbiAgICBjb25zdCBzY2hJZCA9IHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiBzY2hlbWFbb3B0cy5zY2hlbWFJZF07XG4gICAgcmV0dXJuIHNjaElkICYmIChvcHRzLmNvZGUuc291cmNlIHx8IG9wdHMuY29kZS5wcm9jZXNzKSA/ICgwLCBjb2RlZ2VuXzEuXykgYC8qIyBzb3VyY2VVUkw9JHtzY2hJZH0gKi9gIDogY29kZWdlbl8xLm5pbDtcbn1cbi8vIHNjaGVtYSBjb21waWxhdGlvbiAtIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCByZWN1cnNpdmVseSB0byBnZW5lcmF0ZSBjb2RlIGZvciBzdWItc2NoZW1hc1xuZnVuY3Rpb24gc3Vic2NoZW1hQ29kZShpdCwgdmFsaWQpIHtcbiAgICBpZiAoaXNTY2hlbWFPYmooaXQpKSB7XG4gICAgICAgIGNoZWNrS2V5d29yZHMoaXQpO1xuICAgICAgICBpZiAoc2NoZW1hQ3h0SGFzUnVsZXMoaXQpKSB7XG4gICAgICAgICAgICBzdWJTY2hlbWFPYmpDb2RlKGl0LCB2YWxpZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgKDAsIGJvb2xTY2hlbWFfMS5ib29sT3JFbXB0eVNjaGVtYSkoaXQsIHZhbGlkKTtcbn1cbmZ1bmN0aW9uIHNjaGVtYUN4dEhhc1J1bGVzKHsgc2NoZW1hLCBzZWxmIH0pIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuICFzY2hlbWE7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKVxuICAgICAgICBpZiAoc2VsZi5SVUxFUy5hbGxba2V5XSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzU2NoZW1hT2JqKGl0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpdC5zY2hlbWEgIT0gXCJib29sZWFuXCI7XG59XG5mdW5jdGlvbiBzdWJTY2hlbWFPYmpDb2RlKGl0LCB2YWxpZCkge1xuICAgIGNvbnN0IHsgc2NoZW1hLCBnZW4sIG9wdHMgfSA9IGl0O1xuICAgIGlmIChvcHRzLiRjb21tZW50ICYmIHNjaGVtYS4kY29tbWVudClcbiAgICAgICAgY29tbWVudEtleXdvcmQoaXQpO1xuICAgIHVwZGF0ZUNvbnRleHQoaXQpO1xuICAgIGNoZWNrQXN5bmNTY2hlbWEoaXQpO1xuICAgIGNvbnN0IGVycnNDb3VudCA9IGdlbi5jb25zdChcIl9lcnJzXCIsIG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMpO1xuICAgIHR5cGVBbmRLZXl3b3JkcyhpdCwgZXJyc0NvdW50KTtcbiAgICAvLyBUT0RPIHZhclxuICAgIGdlbi52YXIodmFsaWQsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyc0NvdW50fSA9PT0gJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfWApO1xufVxuZnVuY3Rpb24gY2hlY2tLZXl3b3JkcyhpdCkge1xuICAgICgwLCB1dGlsXzEuY2hlY2tVbmtub3duUnVsZXMpKGl0KTtcbiAgICBjaGVja1JlZnNBbmRLZXl3b3JkcyhpdCk7XG59XG5mdW5jdGlvbiB0eXBlQW5kS2V5d29yZHMoaXQsIGVycnNDb3VudCkge1xuICAgIGlmIChpdC5vcHRzLmp0ZClcbiAgICAgICAgcmV0dXJuIHNjaGVtYUtleXdvcmRzKGl0LCBbXSwgZmFsc2UsIGVycnNDb3VudCk7XG4gICAgY29uc3QgdHlwZXMgPSAoMCwgZGF0YVR5cGVfMS5nZXRTY2hlbWFUeXBlcykoaXQuc2NoZW1hKTtcbiAgICBjb25zdCBjaGVja2VkVHlwZXMgPSAoMCwgZGF0YVR5cGVfMS5jb2VyY2VBbmRDaGVja0RhdGFUeXBlKShpdCwgdHlwZXMpO1xuICAgIHNjaGVtYUtleXdvcmRzKGl0LCB0eXBlcywgIWNoZWNrZWRUeXBlcywgZXJyc0NvdW50KTtcbn1cbmZ1bmN0aW9uIGNoZWNrUmVmc0FuZEtleXdvcmRzKGl0KSB7XG4gICAgY29uc3QgeyBzY2hlbWEsIGVyclNjaGVtYVBhdGgsIG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgIGlmIChzY2hlbWEuJHJlZiAmJiBvcHRzLmlnbm9yZUtleXdvcmRzV2l0aFJlZiAmJiAoMCwgdXRpbF8xLnNjaGVtYUhhc1J1bGVzQnV0UmVmKShzY2hlbWEsIHNlbGYuUlVMRVMpKSB7XG4gICAgICAgIHNlbGYubG9nZ2VyLndhcm4oYCRyZWY6IGtleXdvcmRzIGlnbm9yZWQgaW4gc2NoZW1hIGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCJgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja05vRGVmYXVsdChpdCkge1xuICAgIGNvbnN0IHsgc2NoZW1hLCBvcHRzIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hLmRlZmF1bHQgIT09IHVuZGVmaW5lZCAmJiBvcHRzLnVzZURlZmF1bHRzICYmIG9wdHMuc3RyaWN0U2NoZW1hKSB7XG4gICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgXCJkZWZhdWx0IGlzIGlnbm9yZWQgaW4gdGhlIHNjaGVtYSByb290XCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRleHQoaXQpIHtcbiAgICBjb25zdCBzY2hJZCA9IGl0LnNjaGVtYVtpdC5vcHRzLnNjaGVtYUlkXTtcbiAgICBpZiAoc2NoSWQpXG4gICAgICAgIGl0LmJhc2VJZCA9ICgwLCByZXNvbHZlXzEucmVzb2x2ZVVybCkoaXQub3B0cy51cmlSZXNvbHZlciwgaXQuYmFzZUlkLCBzY2hJZCk7XG59XG5mdW5jdGlvbiBjaGVja0FzeW5jU2NoZW1hKGl0KSB7XG4gICAgaWYgKGl0LnNjaGVtYS4kYXN5bmMgJiYgIWl0LnNjaGVtYUVudi4kYXN5bmMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFzeW5jIHNjaGVtYSBpbiBzeW5jIHNjaGVtYVwiKTtcbn1cbmZ1bmN0aW9uIGNvbW1lbnRLZXl3b3JkKHsgZ2VuLCBzY2hlbWFFbnYsIHNjaGVtYSwgZXJyU2NoZW1hUGF0aCwgb3B0cyB9KSB7XG4gICAgY29uc3QgbXNnID0gc2NoZW1hLiRjb21tZW50O1xuICAgIGlmIChvcHRzLiRjb21tZW50ID09PSB0cnVlKSB7XG4gICAgICAgIGdlbi5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnNlbGZ9LmxvZ2dlci5sb2coJHttc2d9KWApO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygb3B0cy4kY29tbWVudCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hUGF0aCA9ICgwLCBjb2RlZ2VuXzEuc3RyKSBgJHtlcnJTY2hlbWFQYXRofS8kY29tbWVudGA7XG4gICAgICAgIGNvbnN0IHJvb3ROYW1lID0gZ2VuLnNjb3BlVmFsdWUoXCJyb290XCIsIHsgcmVmOiBzY2hlbWFFbnYucm9vdCB9KTtcbiAgICAgICAgZ2VuLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQuc2VsZn0ub3B0cy4kY29tbWVudCgke21zZ30sICR7c2NoZW1hUGF0aH0sICR7cm9vdE5hbWV9LnNjaGVtYSlgKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXR1cm5SZXN1bHRzKGl0KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYUVudiwgdmFsaWRhdGVOYW1lLCBWYWxpZGF0aW9uRXJyb3IsIG9wdHMgfSA9IGl0O1xuICAgIGlmIChzY2hlbWFFbnYuJGFzeW5jKSB7XG4gICAgICAgIC8vIFRPRE8gYXNzaWduIHVuZXZhbHVhdGVkXG4gICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9ID09PSAwYCwgKCkgPT4gZ2VuLnJldHVybihuYW1lc18xLmRlZmF1bHQuZGF0YSksICgpID0+IGdlbi50aHJvdygoMCwgY29kZWdlbl8xLl8pIGBuZXcgJHtWYWxpZGF0aW9uRXJyb3J9KCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9KWApKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHt2YWxpZGF0ZU5hbWV9LmVycm9yc2AsIG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzKTtcbiAgICAgICAgaWYgKG9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgICAgICBhc3NpZ25FdmFsdWF0ZWQoaXQpO1xuICAgICAgICBnZW4ucmV0dXJuKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc30gPT09IDBgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhc3NpZ25FdmFsdWF0ZWQoeyBnZW4sIGV2YWx1YXRlZCwgcHJvcHMsIGl0ZW1zIH0pIHtcbiAgICBpZiAocHJvcHMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSlcbiAgICAgICAgZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke2V2YWx1YXRlZH0ucHJvcHNgLCBwcm9wcyk7XG4gICAgaWYgKGl0ZW1zIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpXG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtldmFsdWF0ZWR9Lml0ZW1zYCwgaXRlbXMpO1xufVxuZnVuY3Rpb24gc2NoZW1hS2V5d29yZHMoaXQsIHR5cGVzLCB0eXBlRXJyb3JzLCBlcnJzQ291bnQpIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBkYXRhLCBhbGxFcnJvcnMsIG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgIGNvbnN0IHsgUlVMRVMgfSA9IHNlbGY7XG4gICAgaWYgKHNjaGVtYS4kcmVmICYmIChvcHRzLmlnbm9yZUtleXdvcmRzV2l0aFJlZiB8fCAhKDAsIHV0aWxfMS5zY2hlbWFIYXNSdWxlc0J1dFJlZikoc2NoZW1hLCBSVUxFUykpKSB7XG4gICAgICAgIGdlbi5ibG9jaygoKSA9PiBrZXl3b3JkQ29kZShpdCwgXCIkcmVmXCIsIFJVTEVTLmFsbC4kcmVmLmRlZmluaXRpb24pKTsgLy8gVE9ETyB0eXBlY2FzdFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghb3B0cy5qdGQpXG4gICAgICAgIGNoZWNrU3RyaWN0VHlwZXMoaXQsIHR5cGVzKTtcbiAgICBnZW4uYmxvY2soKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIFJVTEVTLnJ1bGVzKVxuICAgICAgICAgICAgZ3JvdXBLZXl3b3Jkcyhncm91cCk7XG4gICAgICAgIGdyb3VwS2V5d29yZHMoUlVMRVMucG9zdCk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gZ3JvdXBLZXl3b3Jkcyhncm91cCkge1xuICAgICAgICBpZiAoISgwLCBhcHBsaWNhYmlsaXR5XzEuc2hvdWxkVXNlR3JvdXApKHNjaGVtYSwgZ3JvdXApKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZ3JvdXAudHlwZSkge1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBkYXRhVHlwZV8yLmNoZWNrRGF0YVR5cGUpKGdyb3VwLnR5cGUsIGRhdGEsIG9wdHMuc3RyaWN0TnVtYmVycykpO1xuICAgICAgICAgICAgaXRlcmF0ZUtleXdvcmRzKGl0LCBncm91cCk7XG4gICAgICAgICAgICBpZiAodHlwZXMubGVuZ3RoID09PSAxICYmIHR5cGVzWzBdID09PSBncm91cC50eXBlICYmIHR5cGVFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICBnZW4uZWxzZSgpO1xuICAgICAgICAgICAgICAgICgwLCBkYXRhVHlwZV8yLnJlcG9ydFR5cGVFcnJvcikoaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVyYXRlS2V5d29yZHMoaXQsIGdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIG1ha2UgaXQgXCJva1wiIGNhbGw/XG4gICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc30gPT09ICR7ZXJyc0NvdW50IHx8IDB9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXRlcmF0ZUtleXdvcmRzKGl0LCBncm91cCkge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIG9wdHM6IHsgdXNlRGVmYXVsdHMgfSwgfSA9IGl0O1xuICAgIGlmICh1c2VEZWZhdWx0cylcbiAgICAgICAgKDAsIGRlZmF1bHRzXzEuYXNzaWduRGVmYXVsdHMpKGl0LCBncm91cC50eXBlKTtcbiAgICBnZW4uYmxvY2soKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgZ3JvdXAucnVsZXMpIHtcbiAgICAgICAgICAgIGlmICgoMCwgYXBwbGljYWJpbGl0eV8xLnNob3VsZFVzZVJ1bGUpKHNjaGVtYSwgcnVsZSkpIHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkQ29kZShpdCwgcnVsZS5rZXl3b3JkLCBydWxlLmRlZmluaXRpb24sIGdyb3VwLnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjaGVja1N0cmljdFR5cGVzKGl0LCB0eXBlcykge1xuICAgIGlmIChpdC5zY2hlbWFFbnYubWV0YSB8fCAhaXQub3B0cy5zdHJpY3RUeXBlcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGNoZWNrQ29udGV4dFR5cGVzKGl0LCB0eXBlcyk7XG4gICAgaWYgKCFpdC5vcHRzLmFsbG93VW5pb25UeXBlcylcbiAgICAgICAgY2hlY2tNdWx0aXBsZVR5cGVzKGl0LCB0eXBlcyk7XG4gICAgY2hlY2tLZXl3b3JkVHlwZXMoaXQsIGl0LmRhdGFUeXBlcyk7XG59XG5mdW5jdGlvbiBjaGVja0NvbnRleHRUeXBlcyhpdCwgdHlwZXMpIHtcbiAgICBpZiAoIXR5cGVzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghaXQuZGF0YVR5cGVzLmxlbmd0aCkge1xuICAgICAgICBpdC5kYXRhVHlwZXMgPSB0eXBlcztcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0eXBlcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgIGlmICghaW5jbHVkZXNUeXBlKGl0LmRhdGFUeXBlcywgdCkpIHtcbiAgICAgICAgICAgIHN0cmljdFR5cGVzRXJyb3IoaXQsIGB0eXBlIFwiJHt0fVwiIG5vdCBhbGxvd2VkIGJ5IGNvbnRleHQgXCIke2l0LmRhdGFUeXBlcy5qb2luKFwiLFwiKX1cImApO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbmFycm93U2NoZW1hVHlwZXMoaXQsIHR5cGVzKTtcbn1cbmZ1bmN0aW9uIGNoZWNrTXVsdGlwbGVUeXBlcyhpdCwgdHMpIHtcbiAgICBpZiAodHMubGVuZ3RoID4gMSAmJiAhKHRzLmxlbmd0aCA9PT0gMiAmJiB0cy5pbmNsdWRlcyhcIm51bGxcIikpKSB7XG4gICAgICAgIHN0cmljdFR5cGVzRXJyb3IoaXQsIFwidXNlIGFsbG93VW5pb25UeXBlcyB0byBhbGxvdyB1bmlvbiB0eXBlIGtleXdvcmRcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tLZXl3b3JkVHlwZXMoaXQsIHRzKSB7XG4gICAgY29uc3QgcnVsZXMgPSBpdC5zZWxmLlJVTEVTLmFsbDtcbiAgICBmb3IgKGNvbnN0IGtleXdvcmQgaW4gcnVsZXMpIHtcbiAgICAgICAgY29uc3QgcnVsZSA9IHJ1bGVzW2tleXdvcmRdO1xuICAgICAgICBpZiAodHlwZW9mIHJ1bGUgPT0gXCJvYmplY3RcIiAmJiAoMCwgYXBwbGljYWJpbGl0eV8xLnNob3VsZFVzZVJ1bGUpKGl0LnNjaGVtYSwgcnVsZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gcnVsZS5kZWZpbml0aW9uO1xuICAgICAgICAgICAgaWYgKHR5cGUubGVuZ3RoICYmICF0eXBlLnNvbWUoKHQpID0+IGhhc0FwcGxpY2FibGVUeXBlKHRzLCB0KSkpIHtcbiAgICAgICAgICAgICAgICBzdHJpY3RUeXBlc0Vycm9yKGl0LCBgbWlzc2luZyB0eXBlIFwiJHt0eXBlLmpvaW4oXCIsXCIpfVwiIGZvciBrZXl3b3JkIFwiJHtrZXl3b3JkfVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBoYXNBcHBsaWNhYmxlVHlwZShzY2hUcywga3dkVCkge1xuICAgIHJldHVybiBzY2hUcy5pbmNsdWRlcyhrd2RUKSB8fCAoa3dkVCA9PT0gXCJudW1iZXJcIiAmJiBzY2hUcy5pbmNsdWRlcyhcImludGVnZXJcIikpO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNUeXBlKHRzLCB0KSB7XG4gICAgcmV0dXJuIHRzLmluY2x1ZGVzKHQpIHx8ICh0ID09PSBcImludGVnZXJcIiAmJiB0cy5pbmNsdWRlcyhcIm51bWJlclwiKSk7XG59XG5mdW5jdGlvbiBuYXJyb3dTY2hlbWFUeXBlcyhpdCwgd2l0aFR5cGVzKSB7XG4gICAgY29uc3QgdHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHQgb2YgaXQuZGF0YVR5cGVzKSB7XG4gICAgICAgIGlmIChpbmNsdWRlc1R5cGUod2l0aFR5cGVzLCB0KSlcbiAgICAgICAgICAgIHRzLnB1c2godCk7XG4gICAgICAgIGVsc2UgaWYgKHdpdGhUeXBlcy5pbmNsdWRlcyhcImludGVnZXJcIikgJiYgdCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRzLnB1c2goXCJpbnRlZ2VyXCIpO1xuICAgIH1cbiAgICBpdC5kYXRhVHlwZXMgPSB0cztcbn1cbmZ1bmN0aW9uIHN0cmljdFR5cGVzRXJyb3IoaXQsIG1zZykge1xuICAgIGNvbnN0IHNjaGVtYVBhdGggPSBpdC5zY2hlbWFFbnYuYmFzZUlkICsgaXQuZXJyU2NoZW1hUGF0aDtcbiAgICBtc2cgKz0gYCBhdCBcIiR7c2NoZW1hUGF0aH1cIiAoc3RyaWN0VHlwZXMpYDtcbiAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIG1zZywgaXQub3B0cy5zdHJpY3RUeXBlcyk7XG59XG5jbGFzcyBLZXl3b3JkQ3h0IHtcbiAgICBjb25zdHJ1Y3RvcihpdCwgZGVmLCBrZXl3b3JkKSB7XG4gICAgICAgICgwLCBrZXl3b3JkXzEudmFsaWRhdGVLZXl3b3JkVXNhZ2UpKGl0LCBkZWYsIGtleXdvcmQpO1xuICAgICAgICB0aGlzLmdlbiA9IGl0LmdlbjtcbiAgICAgICAgdGhpcy5hbGxFcnJvcnMgPSBpdC5hbGxFcnJvcnM7XG4gICAgICAgIHRoaXMua2V5d29yZCA9IGtleXdvcmQ7XG4gICAgICAgIHRoaXMuZGF0YSA9IGl0LmRhdGE7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gaXQuc2NoZW1hW2tleXdvcmRdO1xuICAgICAgICB0aGlzLiRkYXRhID0gZGVmLiRkYXRhICYmIGl0Lm9wdHMuJGRhdGEgJiYgdGhpcy5zY2hlbWEgJiYgdGhpcy5zY2hlbWEuJGRhdGE7XG4gICAgICAgIHRoaXMuc2NoZW1hVmFsdWUgPSAoMCwgdXRpbF8xLnNjaGVtYVJlZk9yVmFsKShpdCwgdGhpcy5zY2hlbWEsIGtleXdvcmQsIHRoaXMuJGRhdGEpO1xuICAgICAgICB0aGlzLnNjaGVtYVR5cGUgPSBkZWYuc2NoZW1hVHlwZTtcbiAgICAgICAgdGhpcy5wYXJlbnRTY2hlbWEgPSBpdC5zY2hlbWE7XG4gICAgICAgIHRoaXMucGFyYW1zID0ge307XG4gICAgICAgIHRoaXMuaXQgPSBpdDtcbiAgICAgICAgdGhpcy5kZWYgPSBkZWY7XG4gICAgICAgIGlmICh0aGlzLiRkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVtYUNvZGUgPSBpdC5nZW4uY29uc3QoXCJ2U2NoZW1hXCIsIGdldERhdGEodGhpcy4kZGF0YSwgaXQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2NoZW1hQ29kZSA9IHRoaXMuc2NoZW1hVmFsdWU7XG4gICAgICAgICAgICBpZiAoISgwLCBrZXl3b3JkXzEudmFsaWRTY2hlbWFUeXBlKSh0aGlzLnNjaGVtYSwgZGVmLnNjaGVtYVR5cGUsIGRlZi5hbGxvd1VuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7a2V5d29yZH0gdmFsdWUgbXVzdCBiZSAke0pTT04uc3RyaW5naWZ5KGRlZi5zY2hlbWFUeXBlKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJjb2RlXCIgaW4gZGVmID8gZGVmLnRyYWNrRXJyb3JzIDogZGVmLmVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyc0NvdW50ID0gaXQuZ2VuLmNvbnN0KFwiX2VycnNcIiwgbmFtZXNfMS5kZWZhdWx0LmVycm9ycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0KGNvbmRpdGlvbiwgc3VjY2Vzc0FjdGlvbiwgZmFpbEFjdGlvbikge1xuICAgICAgICB0aGlzLmZhaWxSZXN1bHQoKDAsIGNvZGVnZW5fMS5ub3QpKGNvbmRpdGlvbiksIHN1Y2Nlc3NBY3Rpb24sIGZhaWxBY3Rpb24pO1xuICAgIH1cbiAgICBmYWlsUmVzdWx0KGNvbmRpdGlvbiwgc3VjY2Vzc0FjdGlvbiwgZmFpbEFjdGlvbikge1xuICAgICAgICB0aGlzLmdlbi5pZihjb25kaXRpb24pO1xuICAgICAgICBpZiAoZmFpbEFjdGlvbilcbiAgICAgICAgICAgIGZhaWxBY3Rpb24oKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5lcnJvcigpO1xuICAgICAgICBpZiAoc3VjY2Vzc0FjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5nZW4uZWxzZSgpO1xuICAgICAgICAgICAgc3VjY2Vzc0FjdGlvbigpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgdGhpcy5nZW4uZW5kSWYoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmdlbi5lbHNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFzcyhjb25kaXRpb24sIGZhaWxBY3Rpb24pIHtcbiAgICAgICAgdGhpcy5mYWlsUmVzdWx0KCgwLCBjb2RlZ2VuXzEubm90KShjb25kaXRpb24pLCB1bmRlZmluZWQsIGZhaWxBY3Rpb24pO1xuICAgIH1cbiAgICBmYWlsKGNvbmRpdGlvbikge1xuICAgICAgICBpZiAoY29uZGl0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgdGhpcy5nZW4uaWYoZmFsc2UpOyAvLyB0aGlzIGJyYW5jaCB3aWxsIGJlIHJlbW92ZWQgYnkgZ2VuLm9wdGltaXplXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZW4uaWYoY29uZGl0aW9uKTtcbiAgICAgICAgdGhpcy5lcnJvcigpO1xuICAgICAgICBpZiAodGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICB0aGlzLmdlbi5lbmRJZigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmdlbi5lbHNlKCk7XG4gICAgfVxuICAgIGZhaWwkZGF0YShjb25kaXRpb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLiRkYXRhKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbChjb25kaXRpb24pO1xuICAgICAgICBjb25zdCB7IHNjaGVtYUNvZGUgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZmFpbCgoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYUNvZGV9ICE9PSB1bmRlZmluZWQgJiYgKCR7KDAsIGNvZGVnZW5fMS5vcikodGhpcy5pbnZhbGlkJGRhdGEoKSwgY29uZGl0aW9uKX0pYCk7XG4gICAgfVxuICAgIGVycm9yKGFwcGVuZCwgZXJyb3JQYXJhbXMsIGVycm9yUGF0aHMpIHtcbiAgICAgICAgaWYgKGVycm9yUGFyYW1zKSB7XG4gICAgICAgICAgICB0aGlzLnNldFBhcmFtcyhlcnJvclBhcmFtcyk7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcihhcHBlbmQsIGVycm9yUGF0aHMpO1xuICAgICAgICAgICAgdGhpcy5zZXRQYXJhbXMoe30pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Vycm9yKGFwcGVuZCwgZXJyb3JQYXRocyk7XG4gICAgfVxuICAgIF9lcnJvcihhcHBlbmQsIGVycm9yUGF0aHMpIHtcbiAgICAgICAgO1xuICAgICAgICAoYXBwZW5kID8gZXJyb3JzXzEucmVwb3J0RXh0cmFFcnJvciA6IGVycm9yc18xLnJlcG9ydEVycm9yKSh0aGlzLCB0aGlzLmRlZi5lcnJvciwgZXJyb3JQYXRocyk7XG4gICAgfVxuICAgICRkYXRhRXJyb3IoKSB7XG4gICAgICAgICgwLCBlcnJvcnNfMS5yZXBvcnRFcnJvcikodGhpcywgdGhpcy5kZWYuJGRhdGFFcnJvciB8fCBlcnJvcnNfMS5rZXl3b3JkJERhdGFFcnJvcik7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5lcnJzQ291bnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWRkIFwidHJhY2tFcnJvcnNcIiB0byBrZXl3b3JkIGRlZmluaXRpb24nKTtcbiAgICAgICAgKDAsIGVycm9yc18xLnJlc2V0RXJyb3JzQ291bnQpKHRoaXMuZ2VuLCB0aGlzLmVycnNDb3VudCk7XG4gICAgfVxuICAgIG9rKGNvbmQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsbEVycm9ycylcbiAgICAgICAgICAgIHRoaXMuZ2VuLmlmKGNvbmQpO1xuICAgIH1cbiAgICBzZXRQYXJhbXMob2JqLCBhc3NpZ24pIHtcbiAgICAgICAgaWYgKGFzc2lnbilcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5wYXJhbXMsIG9iaik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gb2JqO1xuICAgIH1cbiAgICBibG9jayRkYXRhKHZhbGlkLCBjb2RlQmxvY2ssICRkYXRhVmFsaWQgPSBjb2RlZ2VuXzEubmlsKSB7XG4gICAgICAgIHRoaXMuZ2VuLmJsb2NrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2skZGF0YSh2YWxpZCwgJGRhdGFWYWxpZCk7XG4gICAgICAgICAgICBjb2RlQmxvY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNoZWNrJGRhdGEodmFsaWQgPSBjb2RlZ2VuXzEubmlsLCAkZGF0YVZhbGlkID0gY29kZWdlbl8xLm5pbCkge1xuICAgICAgICBpZiAoIXRoaXMuJGRhdGEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWFDb2RlLCBzY2hlbWFUeXBlLCBkZWYgfSA9IHRoaXM7XG4gICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm9yKSgoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYUNvZGV9ID09PSB1bmRlZmluZWRgLCAkZGF0YVZhbGlkKSk7XG4gICAgICAgIGlmICh2YWxpZCAhPT0gY29kZWdlbl8xLm5pbClcbiAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpO1xuICAgICAgICBpZiAoc2NoZW1hVHlwZS5sZW5ndGggfHwgZGVmLnZhbGlkYXRlU2NoZW1hKSB7XG4gICAgICAgICAgICBnZW4uZWxzZUlmKHRoaXMuaW52YWxpZCRkYXRhKCkpO1xuICAgICAgICAgICAgdGhpcy4kZGF0YUVycm9yKCk7XG4gICAgICAgICAgICBpZiAodmFsaWQgIT09IGNvZGVnZW5fMS5uaWwpXG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGdlbi5lbHNlKCk7XG4gICAgfVxuICAgIGludmFsaWQkZGF0YSgpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYUNvZGUsIHNjaGVtYVR5cGUsIGRlZiwgaXQgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLm9yKSh3cm9uZyREYXRhVHlwZSgpLCBpbnZhbGlkJERhdGFTY2hlbWEoKSk7XG4gICAgICAgIGZ1bmN0aW9uIHdyb25nJERhdGFUeXBlKCkge1xuICAgICAgICAgICAgaWYgKHNjaGVtYVR5cGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKCEoc2NoZW1hQ29kZSBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0ID0gQXJyYXkuaXNBcnJheShzY2hlbWFUeXBlKSA/IHNjaGVtYVR5cGUgOiBbc2NoZW1hVHlwZV07XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCR7KDAsIGRhdGFUeXBlXzIuY2hlY2tEYXRhVHlwZXMpKHN0LCBzY2hlbWFDb2RlLCBpdC5vcHRzLnN0cmljdE51bWJlcnMsIGRhdGFUeXBlXzIuRGF0YVR5cGUuV3JvbmcpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLm5pbDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbnZhbGlkJERhdGFTY2hlbWEoKSB7XG4gICAgICAgICAgICBpZiAoZGVmLnZhbGlkYXRlU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGVTY2hlbWFSZWYgPSBnZW4uc2NvcGVWYWx1ZShcInZhbGlkYXRlJGRhdGFcIiwgeyByZWY6IGRlZi52YWxpZGF0ZVNjaGVtYSB9KTsgLy8gVE9ETyB2YWx1ZS5jb2RlIGZvciBzdGFuZGFsb25lXG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCEke3ZhbGlkYXRlU2NoZW1hUmVmfSgke3NjaGVtYUNvZGV9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLm5pbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdWJzY2hlbWEoYXBwbCwgdmFsaWQpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NoZW1hID0gKDAsIHN1YnNjaGVtYV8xLmdldFN1YnNjaGVtYSkodGhpcy5pdCwgYXBwbCk7XG4gICAgICAgICgwLCBzdWJzY2hlbWFfMS5leHRlbmRTdWJzY2hlbWFEYXRhKShzdWJzY2hlbWEsIHRoaXMuaXQsIGFwcGwpO1xuICAgICAgICAoMCwgc3Vic2NoZW1hXzEuZXh0ZW5kU3Vic2NoZW1hTW9kZSkoc3Vic2NoZW1hLCBhcHBsKTtcbiAgICAgICAgY29uc3QgbmV4dENvbnRleHQgPSB7IC4uLnRoaXMuaXQsIC4uLnN1YnNjaGVtYSwgaXRlbXM6IHVuZGVmaW5lZCwgcHJvcHM6IHVuZGVmaW5lZCB9O1xuICAgICAgICBzdWJzY2hlbWFDb2RlKG5leHRDb250ZXh0LCB2YWxpZCk7XG4gICAgICAgIHJldHVybiBuZXh0Q29udGV4dDtcbiAgICB9XG4gICAgbWVyZ2VFdmFsdWF0ZWQoc2NoZW1hQ3h0LCB0b05hbWUpIHtcbiAgICAgICAgY29uc3QgeyBpdCwgZ2VuIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWl0Lm9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChpdC5wcm9wcyAhPT0gdHJ1ZSAmJiBzY2hlbWFDeHQucHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaXQucHJvcHMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQucHJvcHMoZ2VuLCBzY2hlbWFDeHQucHJvcHMsIGl0LnByb3BzLCB0b05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5pdGVtcyAhPT0gdHJ1ZSAmJiBzY2hlbWFDeHQuaXRlbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaXQuaXRlbXMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBzY2hlbWFDeHQuaXRlbXMsIGl0Lml0ZW1zLCB0b05hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoZW1hQ3h0LCB2YWxpZCkge1xuICAgICAgICBjb25zdCB7IGl0LCBnZW4gfSA9IHRoaXM7XG4gICAgICAgIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIChpdC5wcm9wcyAhPT0gdHJ1ZSB8fCBpdC5pdGVtcyAhPT0gdHJ1ZSkpIHtcbiAgICAgICAgICAgIGdlbi5pZih2YWxpZCwgKCkgPT4gdGhpcy5tZXJnZUV2YWx1YXRlZChzY2hlbWFDeHQsIGNvZGVnZW5fMS5OYW1lKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuS2V5d29yZEN4dCA9IEtleXdvcmRDeHQ7XG5mdW5jdGlvbiBrZXl3b3JkQ29kZShpdCwga2V5d29yZCwgZGVmLCBydWxlVHlwZSkge1xuICAgIGNvbnN0IGN4dCA9IG5ldyBLZXl3b3JkQ3h0KGl0LCBkZWYsIGtleXdvcmQpO1xuICAgIGlmIChcImNvZGVcIiBpbiBkZWYpIHtcbiAgICAgICAgZGVmLmNvZGUoY3h0LCBydWxlVHlwZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGN4dC4kZGF0YSAmJiBkZWYudmFsaWRhdGUpIHtcbiAgICAgICAgKDAsIGtleXdvcmRfMS5mdW5jS2V5d29yZENvZGUpKGN4dCwgZGVmKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoXCJtYWNyb1wiIGluIGRlZikge1xuICAgICAgICAoMCwga2V5d29yZF8xLm1hY3JvS2V5d29yZENvZGUpKGN4dCwgZGVmKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGVmLmNvbXBpbGUgfHwgZGVmLnZhbGlkYXRlKSB7XG4gICAgICAgICgwLCBrZXl3b3JkXzEuZnVuY0tleXdvcmRDb2RlKShjeHQsIGRlZik7XG4gICAgfVxufVxuY29uc3QgSlNPTl9QT0lOVEVSID0gL15cXC8oPzpbXn5dfH4wfH4xKSokLztcbmNvbnN0IFJFTEFUSVZFX0pTT05fUE9JTlRFUiA9IC9eKFswLTldKykoI3xcXC8oPzpbXn5dfH4wfH4xKSopPyQvO1xuZnVuY3Rpb24gZ2V0RGF0YSgkZGF0YSwgeyBkYXRhTGV2ZWwsIGRhdGFOYW1lcywgZGF0YVBhdGhBcnIgfSkge1xuICAgIGxldCBqc29uUG9pbnRlcjtcbiAgICBsZXQgZGF0YTtcbiAgICBpZiAoJGRhdGEgPT09IFwiXCIpXG4gICAgICAgIHJldHVybiBuYW1lc18xLmRlZmF1bHQucm9vdERhdGE7XG4gICAgaWYgKCRkYXRhWzBdID09PSBcIi9cIikge1xuICAgICAgICBpZiAoIUpTT05fUE9JTlRFUi50ZXN0KCRkYXRhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBKU09OLXBvaW50ZXI6ICR7JGRhdGF9YCk7XG4gICAgICAgIGpzb25Qb2ludGVyID0gJGRhdGE7XG4gICAgICAgIGRhdGEgPSBuYW1lc18xLmRlZmF1bHQucm9vdERhdGE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gUkVMQVRJVkVfSlNPTl9QT0lOVEVSLmV4ZWMoJGRhdGEpO1xuICAgICAgICBpZiAoIW1hdGNoZXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSlNPTi1wb2ludGVyOiAkeyRkYXRhfWApO1xuICAgICAgICBjb25zdCB1cCA9ICttYXRjaGVzWzFdO1xuICAgICAgICBqc29uUG9pbnRlciA9IG1hdGNoZXNbMl07XG4gICAgICAgIGlmIChqc29uUG9pbnRlciA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgIGlmICh1cCA+PSBkYXRhTGV2ZWwpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKFwicHJvcGVydHkvaW5kZXhcIiwgdXApKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhUGF0aEFycltkYXRhTGV2ZWwgLSB1cF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwID4gZGF0YUxldmVsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKFwiZGF0YVwiLCB1cCkpO1xuICAgICAgICBkYXRhID0gZGF0YU5hbWVzW2RhdGFMZXZlbCAtIHVwXTtcbiAgICAgICAgaWYgKCFqc29uUG9pbnRlcilcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBsZXQgZXhwciA9IGRhdGE7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBqc29uUG9pbnRlci5zcGxpdChcIi9cIik7XG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgICAgICBkYXRhID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkoKDAsIHV0aWxfMS51bmVzY2FwZUpzb25Qb2ludGVyKShzZWdtZW50KSl9YDtcbiAgICAgICAgICAgIGV4cHIgPSAoMCwgY29kZWdlbl8xLl8pIGAke2V4cHJ9ICYmICR7ZGF0YX1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHByO1xuICAgIGZ1bmN0aW9uIGVycm9yTXNnKHBvaW50ZXJUeXBlLCB1cCkge1xuICAgICAgICByZXR1cm4gYENhbm5vdCBhY2Nlc3MgJHtwb2ludGVyVHlwZX0gJHt1cH0gbGV2ZWxzIHVwLCBjdXJyZW50IGxldmVsIGlzICR7ZGF0YUxldmVsfWA7XG4gICAgfVxufVxuZXhwb3J0cy5nZXREYXRhID0gZ2V0RGF0YTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGVycm9ycykge1xuICAgICAgICBzdXBlcihcInZhbGlkYXRpb24gZmFpbGVkXCIpO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhpcy5hanYgPSB0aGlzLnZhbGlkYXRpb24gPSB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFZhbGlkYXRpb25FcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkYXRpb25fZXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCByZXNvbHZlXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlXCIpO1xuY2xhc3MgTWlzc2luZ1JlZkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlc29sdmVyLCBiYXNlSWQsIHJlZiwgbXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyB8fCBgY2FuJ3QgcmVzb2x2ZSByZWZlcmVuY2UgJHtyZWZ9IGZyb20gaWQgJHtiYXNlSWR9YCk7XG4gICAgICAgIHRoaXMubWlzc2luZ1JlZiA9ICgwLCByZXNvbHZlXzEucmVzb2x2ZVVybCkocmVzb2x2ZXIsIGJhc2VJZCwgcmVmKTtcbiAgICAgICAgdGhpcy5taXNzaW5nU2NoZW1hID0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkoKDAsIHJlc29sdmVfMS5nZXRGdWxsUGF0aCkocmVzb2x2ZXIsIHRoaXMubWlzc2luZ1JlZikpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IE1pc3NpbmdSZWZFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZl9lcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVzb2x2ZVNjaGVtYSA9IGV4cG9ydHMuZ2V0Q29tcGlsaW5nU2NoZW1hID0gZXhwb3J0cy5yZXNvbHZlUmVmID0gZXhwb3J0cy5jb21waWxlU2NoZW1hID0gZXhwb3J0cy5TY2hlbWFFbnYgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuXCIpO1xuY29uc3QgdmFsaWRhdGlvbl9lcnJvcl8xID0gcmVxdWlyZShcIi4uL3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvclwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi9uYW1lc1wiKTtcbmNvbnN0IHJlc29sdmVfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgdmFsaWRhdGVfMSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRlXCIpO1xuY2xhc3MgU2NoZW1hRW52IHtcbiAgICBjb25zdHJ1Y3RvcihlbnYpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnJlZnMgPSB7fTtcbiAgICAgICAgdGhpcy5keW5hbWljQW5jaG9ycyA9IHt9O1xuICAgICAgICBsZXQgc2NoZW1hO1xuICAgICAgICBpZiAodHlwZW9mIGVudi5zY2hlbWEgPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIHNjaGVtYSA9IGVudi5zY2hlbWE7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gZW52LnNjaGVtYTtcbiAgICAgICAgdGhpcy5zY2hlbWFJZCA9IGVudi5zY2hlbWFJZDtcbiAgICAgICAgdGhpcy5yb290ID0gZW52LnJvb3QgfHwgdGhpcztcbiAgICAgICAgdGhpcy5iYXNlSWQgPSAoX2EgPSBlbnYuYmFzZUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoMCwgcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKShzY2hlbWEgPT09IG51bGwgfHwgc2NoZW1hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2hlbWFbZW52LnNjaGVtYUlkIHx8IFwiJGlkXCJdKTtcbiAgICAgICAgdGhpcy5zY2hlbWFQYXRoID0gZW52LnNjaGVtYVBhdGg7XG4gICAgICAgIHRoaXMubG9jYWxSZWZzID0gZW52LmxvY2FsUmVmcztcbiAgICAgICAgdGhpcy5tZXRhID0gZW52Lm1ldGE7XG4gICAgICAgIHRoaXMuJGFzeW5jID0gc2NoZW1hID09PSBudWxsIHx8IHNjaGVtYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoZW1hLiRhc3luYztcbiAgICAgICAgdGhpcy5yZWZzID0ge307XG4gICAgfVxufVxuZXhwb3J0cy5TY2hlbWFFbnYgPSBTY2hlbWFFbnY7XG4vLyBsZXQgY29kZVNpemUgPSAwXG4vLyBsZXQgbm9kZUNvdW50ID0gMFxuLy8gQ29tcGlsZXMgc2NoZW1hIGluIFNjaGVtYUVudlxuZnVuY3Rpb24gY29tcGlsZVNjaGVtYShzY2gpIHtcbiAgICAvLyBUT0RPIHJlZmFjdG9yIC0gcmVtb3ZlIGNvbXBpbGF0aW9uc1xuICAgIGNvbnN0IF9zY2ggPSBnZXRDb21waWxpbmdTY2hlbWEuY2FsbCh0aGlzLCBzY2gpO1xuICAgIGlmIChfc2NoKVxuICAgICAgICByZXR1cm4gX3NjaDtcbiAgICBjb25zdCByb290SWQgPSAoMCwgcmVzb2x2ZV8xLmdldEZ1bGxQYXRoKSh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIHNjaC5yb290LmJhc2VJZCk7IC8vIFRPRE8gaWYgZ2V0RnVsbFBhdGggcmVtb3ZlZCAxIHRlc3RzIGZhaWxzXG4gICAgY29uc3QgeyBlczUsIGxpbmVzIH0gPSB0aGlzLm9wdHMuY29kZTtcbiAgICBjb25zdCB7IG93blByb3BlcnRpZXMgfSA9IHRoaXMub3B0cztcbiAgICBjb25zdCBnZW4gPSBuZXcgY29kZWdlbl8xLkNvZGVHZW4odGhpcy5zY29wZSwgeyBlczUsIGxpbmVzLCBvd25Qcm9wZXJ0aWVzIH0pO1xuICAgIGxldCBfVmFsaWRhdGlvbkVycm9yO1xuICAgIGlmIChzY2guJGFzeW5jKSB7XG4gICAgICAgIF9WYWxpZGF0aW9uRXJyb3IgPSBnZW4uc2NvcGVWYWx1ZShcIkVycm9yXCIsIHtcbiAgICAgICAgICAgIHJlZjogdmFsaWRhdGlvbl9lcnJvcl8xLmRlZmF1bHQsXG4gICAgICAgICAgICBjb2RlOiAoMCwgY29kZWdlbl8xLl8pIGByZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS92YWxpZGF0aW9uX2Vycm9yXCIpLmRlZmF1bHRgLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRhdGVOYW1lID0gZ2VuLnNjb3BlTmFtZShcInZhbGlkYXRlXCIpO1xuICAgIHNjaC52YWxpZGF0ZU5hbWUgPSB2YWxpZGF0ZU5hbWU7XG4gICAgY29uc3Qgc2NoZW1hQ3h0ID0ge1xuICAgICAgICBnZW4sXG4gICAgICAgIGFsbEVycm9yczogdGhpcy5vcHRzLmFsbEVycm9ycyxcbiAgICAgICAgZGF0YTogbmFtZXNfMS5kZWZhdWx0LmRhdGEsXG4gICAgICAgIHBhcmVudERhdGE6IG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhLFxuICAgICAgICBwYXJlbnREYXRhUHJvcGVydHk6IG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHksXG4gICAgICAgIGRhdGFOYW1lczogW25hbWVzXzEuZGVmYXVsdC5kYXRhXSxcbiAgICAgICAgZGF0YVBhdGhBcnI6IFtjb2RlZ2VuXzEubmlsXSwgLy8gVE9ETyBjYW4gaXRzIGxlbmd0aCBiZSB1c2VkIGFzIGRhdGFMZXZlbCBpZiBuaWwgaXMgcmVtb3ZlZD9cbiAgICAgICAgZGF0YUxldmVsOiAwLFxuICAgICAgICBkYXRhVHlwZXM6IFtdLFxuICAgICAgICBkZWZpbmVkUHJvcGVydGllczogbmV3IFNldCgpLFxuICAgICAgICB0b3BTY2hlbWFSZWY6IGdlbi5zY29wZVZhbHVlKFwic2NoZW1hXCIsIHRoaXMub3B0cy5jb2RlLnNvdXJjZSA9PT0gdHJ1ZVxuICAgICAgICAgICAgPyB7IHJlZjogc2NoLnNjaGVtYSwgY29kZTogKDAsIGNvZGVnZW5fMS5zdHJpbmdpZnkpKHNjaC5zY2hlbWEpIH1cbiAgICAgICAgICAgIDogeyByZWY6IHNjaC5zY2hlbWEgfSksXG4gICAgICAgIHZhbGlkYXRlTmFtZSxcbiAgICAgICAgVmFsaWRhdGlvbkVycm9yOiBfVmFsaWRhdGlvbkVycm9yLFxuICAgICAgICBzY2hlbWE6IHNjaC5zY2hlbWEsXG4gICAgICAgIHNjaGVtYUVudjogc2NoLFxuICAgICAgICByb290SWQsXG4gICAgICAgIGJhc2VJZDogc2NoLmJhc2VJZCB8fCByb290SWQsXG4gICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5uaWwsXG4gICAgICAgIGVyclNjaGVtYVBhdGg6IHNjaC5zY2hlbWFQYXRoIHx8ICh0aGlzLm9wdHMuanRkID8gXCJcIiA6IFwiI1wiKSxcbiAgICAgICAgZXJyb3JQYXRoOiAoMCwgY29kZWdlbl8xLl8pIGBcIlwiYCxcbiAgICAgICAgb3B0czogdGhpcy5vcHRzLFxuICAgICAgICBzZWxmOiB0aGlzLFxuICAgIH07XG4gICAgbGV0IHNvdXJjZUNvZGU7XG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fY29tcGlsYXRpb25zLmFkZChzY2gpO1xuICAgICAgICAoMCwgdmFsaWRhdGVfMS52YWxpZGF0ZUZ1bmN0aW9uQ29kZSkoc2NoZW1hQ3h0KTtcbiAgICAgICAgZ2VuLm9wdGltaXplKHRoaXMub3B0cy5jb2RlLm9wdGltaXplKTtcbiAgICAgICAgLy8gZ2VuLm9wdGltaXplKDEpXG4gICAgICAgIGNvbnN0IHZhbGlkYXRlQ29kZSA9IGdlbi50b1N0cmluZygpO1xuICAgICAgICBzb3VyY2VDb2RlID0gYCR7Z2VuLnNjb3BlUmVmcyhuYW1lc18xLmRlZmF1bHQuc2NvcGUpfXJldHVybiAke3ZhbGlkYXRlQ29kZX1gO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygoY29kZVNpemUgKz0gc291cmNlQ29kZS5sZW5ndGgpLCAobm9kZUNvdW50ICs9IGdlbi5ub2RlQ291bnQpKVxuICAgICAgICBpZiAodGhpcy5vcHRzLmNvZGUucHJvY2VzcylcbiAgICAgICAgICAgIHNvdXJjZUNvZGUgPSB0aGlzLm9wdHMuY29kZS5wcm9jZXNzKHNvdXJjZUNvZGUsIHNjaCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiXFxuXFxuXFxuICoqKiBcXG5cIiwgc291cmNlQ29kZSlcbiAgICAgICAgY29uc3QgbWFrZVZhbGlkYXRlID0gbmV3IEZ1bmN0aW9uKGAke25hbWVzXzEuZGVmYXVsdC5zZWxmfWAsIGAke25hbWVzXzEuZGVmYXVsdC5zY29wZX1gLCBzb3VyY2VDb2RlKTtcbiAgICAgICAgY29uc3QgdmFsaWRhdGUgPSBtYWtlVmFsaWRhdGUodGhpcywgdGhpcy5zY29wZS5nZXQoKSk7XG4gICAgICAgIHRoaXMuc2NvcGUudmFsdWUodmFsaWRhdGVOYW1lLCB7IHJlZjogdmFsaWRhdGUgfSk7XG4gICAgICAgIHZhbGlkYXRlLmVycm9ycyA9IG51bGw7XG4gICAgICAgIHZhbGlkYXRlLnNjaGVtYSA9IHNjaC5zY2hlbWE7XG4gICAgICAgIHZhbGlkYXRlLnNjaGVtYUVudiA9IHNjaDtcbiAgICAgICAgaWYgKHNjaC4kYXN5bmMpXG4gICAgICAgICAgICB2YWxpZGF0ZS4kYXN5bmMgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmNvZGUuc291cmNlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZS5zb3VyY2UgPSB7IHZhbGlkYXRlTmFtZSwgdmFsaWRhdGVDb2RlLCBzY29wZVZhbHVlczogZ2VuLl92YWx1ZXMgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRzLnVuZXZhbHVhdGVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3BzLCBpdGVtcyB9ID0gc2NoZW1hQ3h0O1xuICAgICAgICAgICAgdmFsaWRhdGUuZXZhbHVhdGVkID0ge1xuICAgICAgICAgICAgICAgIHByb3BzOiBwcm9wcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lID8gdW5kZWZpbmVkIDogcHJvcHMsXG4gICAgICAgICAgICAgICAgaXRlbXM6IGl0ZW1zIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUgPyB1bmRlZmluZWQgOiBpdGVtcyxcbiAgICAgICAgICAgICAgICBkeW5hbWljUHJvcHM6IHByb3BzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUsXG4gICAgICAgICAgICAgICAgZHluYW1pY0l0ZW1zOiBpdGVtcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZS5zb3VyY2UpXG4gICAgICAgICAgICAgICAgdmFsaWRhdGUuc291cmNlLmV2YWx1YXRlZCA9ICgwLCBjb2RlZ2VuXzEuc3RyaW5naWZ5KSh2YWxpZGF0ZS5ldmFsdWF0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHNjaC52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuICAgICAgICByZXR1cm4gc2NoO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBkZWxldGUgc2NoLnZhbGlkYXRlO1xuICAgICAgICBkZWxldGUgc2NoLnZhbGlkYXRlTmFtZTtcbiAgICAgICAgaWYgKHNvdXJjZUNvZGUpXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIkVycm9yIGNvbXBpbGluZyBzY2hlbWEsIGZ1bmN0aW9uIGNvZGU6XCIsIHNvdXJjZUNvZGUpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlxcblxcblxcbiAqKiogXFxuXCIsIHNvdXJjZUNvZGUsIHRoaXMub3B0cylcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGF0aW9ucy5kZWxldGUoc2NoKTtcbiAgICB9XG59XG5leHBvcnRzLmNvbXBpbGVTY2hlbWEgPSBjb21waWxlU2NoZW1hO1xuZnVuY3Rpb24gcmVzb2x2ZVJlZihyb290LCBiYXNlSWQsIHJlZikge1xuICAgIHZhciBfYTtcbiAgICByZWYgPSAoMCwgcmVzb2x2ZV8xLnJlc29sdmVVcmwpKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCByZWYpO1xuICAgIGNvbnN0IHNjaE9yRnVuYyA9IHJvb3QucmVmc1tyZWZdO1xuICAgIGlmIChzY2hPckZ1bmMpXG4gICAgICAgIHJldHVybiBzY2hPckZ1bmM7XG4gICAgbGV0IF9zY2ggPSByZXNvbHZlLmNhbGwodGhpcywgcm9vdCwgcmVmKTtcbiAgICBpZiAoX3NjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IChfYSA9IHJvb3QubG9jYWxSZWZzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbcmVmXTsgLy8gVE9ETyBtYXliZSBsb2NhbFJlZnMgc2hvdWxkIGhvbGQgU2NoZW1hRW52XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgaWYgKHNjaGVtYSlcbiAgICAgICAgICAgIF9zY2ggPSBuZXcgU2NoZW1hRW52KHsgc2NoZW1hLCBzY2hlbWFJZCwgcm9vdCwgYmFzZUlkIH0pO1xuICAgIH1cbiAgICBpZiAoX3NjaCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgcmV0dXJuIChyb290LnJlZnNbcmVmXSA9IGlubGluZU9yQ29tcGlsZS5jYWxsKHRoaXMsIF9zY2gpKTtcbn1cbmV4cG9ydHMucmVzb2x2ZVJlZiA9IHJlc29sdmVSZWY7XG5mdW5jdGlvbiBpbmxpbmVPckNvbXBpbGUoc2NoKSB7XG4gICAgaWYgKCgwLCByZXNvbHZlXzEuaW5saW5lUmVmKShzY2guc2NoZW1hLCB0aGlzLm9wdHMuaW5saW5lUmVmcykpXG4gICAgICAgIHJldHVybiBzY2guc2NoZW1hO1xuICAgIHJldHVybiBzY2gudmFsaWRhdGUgPyBzY2ggOiBjb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoKTtcbn1cbi8vIEluZGV4IG9mIHNjaGVtYSBjb21waWxhdGlvbiBpbiB0aGUgY3VycmVudGx5IGNvbXBpbGVkIGxpc3RcbmZ1bmN0aW9uIGdldENvbXBpbGluZ1NjaGVtYShzY2hFbnYpIHtcbiAgICBmb3IgKGNvbnN0IHNjaCBvZiB0aGlzLl9jb21waWxhdGlvbnMpIHtcbiAgICAgICAgaWYgKHNhbWVTY2hlbWFFbnYoc2NoLCBzY2hFbnYpKVxuICAgICAgICAgICAgcmV0dXJuIHNjaDtcbiAgICB9XG59XG5leHBvcnRzLmdldENvbXBpbGluZ1NjaGVtYSA9IGdldENvbXBpbGluZ1NjaGVtYTtcbmZ1bmN0aW9uIHNhbWVTY2hlbWFFbnYoczEsIHMyKSB7XG4gICAgcmV0dXJuIHMxLnNjaGVtYSA9PT0gczIuc2NoZW1hICYmIHMxLnJvb3QgPT09IHMyLnJvb3QgJiYgczEuYmFzZUlkID09PSBzMi5iYXNlSWQ7XG59XG4vLyByZXNvbHZlIGFuZCBjb21waWxlIHRoZSByZWZlcmVuY2VzICgkcmVmKVxuLy8gVE9ETyByZXR1cm5zIEFueVNjaGVtYU9iamVjdCAoaWYgdGhlIHNjaGVtYSBjYW4gYmUgaW5saW5lZCkgb3IgdmFsaWRhdGlvbiBmdW5jdGlvblxuZnVuY3Rpb24gcmVzb2x2ZShyb290LCAvLyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcm9vdCBzY2hlbWEgZm9yIHRoZSBjdXJyZW50IHNjaGVtYVxucmVmIC8vIHJlZmVyZW5jZSB0byByZXNvbHZlXG4pIHtcbiAgICBsZXQgc2NoO1xuICAgIHdoaWxlICh0eXBlb2YgKHNjaCA9IHRoaXMucmVmc1tyZWZdKSA9PSBcInN0cmluZ1wiKVxuICAgICAgICByZWYgPSBzY2g7XG4gICAgcmV0dXJuIHNjaCB8fCB0aGlzLnNjaGVtYXNbcmVmXSB8fCByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgcmVmKTtcbn1cbi8vIFJlc29sdmUgc2NoZW1hLCBpdHMgcm9vdCBhbmQgYmFzZUlkXG5mdW5jdGlvbiByZXNvbHZlU2NoZW1hKHJvb3QsIC8vIHJvb3Qgb2JqZWN0IHdpdGggcHJvcGVydGllcyBzY2hlbWEsIHJlZnMgVE9ETyBiZWxvdyBTY2hlbWFFbnYgaXMgYXNzaWduZWQgdG8gaXRcbnJlZiAvLyByZWZlcmVuY2UgdG8gcmVzb2x2ZVxuKSB7XG4gICAgY29uc3QgcCA9IHRoaXMub3B0cy51cmlSZXNvbHZlci5wYXJzZShyZWYpO1xuICAgIGNvbnN0IHJlZlBhdGggPSAoMCwgcmVzb2x2ZV8xLl9nZXRGdWxsUGF0aCkodGhpcy5vcHRzLnVyaVJlc29sdmVyLCBwKTtcbiAgICBsZXQgYmFzZUlkID0gKDAsIHJlc29sdmVfMS5nZXRGdWxsUGF0aCkodGhpcy5vcHRzLnVyaVJlc29sdmVyLCByb290LmJhc2VJZCwgdW5kZWZpbmVkKTtcbiAgICAvLyBUT0RPIGBPYmplY3Qua2V5cyhyb290LnNjaGVtYSkubGVuZ3RoID4gMGAgc2hvdWxkIG5vdCBiZSBuZWVkZWQgLSBidXQgcmVtb3ZpbmcgYnJlYWtzIDIgdGVzdHNcbiAgICBpZiAoT2JqZWN0LmtleXMocm9vdC5zY2hlbWEpLmxlbmd0aCA+IDAgJiYgcmVmUGF0aCA9PT0gYmFzZUlkKSB7XG4gICAgICAgIHJldHVybiBnZXRKc29uUG9pbnRlci5jYWxsKHRoaXMsIHAsIHJvb3QpO1xuICAgIH1cbiAgICBjb25zdCBpZCA9ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKHJlZlBhdGgpO1xuICAgIGNvbnN0IHNjaE9yUmVmID0gdGhpcy5yZWZzW2lkXSB8fCB0aGlzLnNjaGVtYXNbaWRdO1xuICAgIGlmICh0eXBlb2Ygc2NoT3JSZWYgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBzY2ggPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgc2NoT3JSZWYpO1xuICAgICAgICBpZiAodHlwZW9mIChzY2ggPT09IG51bGwgfHwgc2NoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2guc2NoZW1hKSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIGdldEpzb25Qb2ludGVyLmNhbGwodGhpcywgcCwgc2NoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAoc2NoT3JSZWYgPT09IG51bGwgfHwgc2NoT3JSZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaE9yUmVmLnNjaGVtYSkgIT09IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIXNjaE9yUmVmLnZhbGlkYXRlKVxuICAgICAgICBjb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoT3JSZWYpO1xuICAgIGlmIChpZCA9PT0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkocmVmKSkge1xuICAgICAgICBjb25zdCB7IHNjaGVtYSB9ID0gc2NoT3JSZWY7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgY29uc3Qgc2NoSWQgPSBzY2hlbWFbc2NoZW1hSWRdO1xuICAgICAgICBpZiAoc2NoSWQpXG4gICAgICAgICAgICBiYXNlSWQgPSAoMCwgcmVzb2x2ZV8xLnJlc29sdmVVcmwpKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCBzY2hJZCk7XG4gICAgICAgIHJldHVybiBuZXcgU2NoZW1hRW52KHsgc2NoZW1hLCBzY2hlbWFJZCwgcm9vdCwgYmFzZUlkIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwLCBzY2hPclJlZik7XG59XG5leHBvcnRzLnJlc29sdmVTY2hlbWEgPSByZXNvbHZlU2NoZW1hO1xuY29uc3QgUFJFVkVOVF9TQ09QRV9DSEFOR0UgPSBuZXcgU2V0KFtcbiAgICBcInByb3BlcnRpZXNcIixcbiAgICBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gICAgXCJlbnVtXCIsXG4gICAgXCJkZXBlbmRlbmNpZXNcIixcbiAgICBcImRlZmluaXRpb25zXCIsXG5dKTtcbmZ1bmN0aW9uIGdldEpzb25Qb2ludGVyKHBhcnNlZFJlZiwgeyBiYXNlSWQsIHNjaGVtYSwgcm9vdCB9KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICgoKF9hID0gcGFyc2VkUmVmLmZyYWdtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pICE9PSBcIi9cIilcbiAgICAgICAgcmV0dXJuO1xuICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJzZWRSZWYuZnJhZ21lbnQuc2xpY2UoMSkuc3BsaXQoXCIvXCIpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgcGFydFNjaGVtYSA9IHNjaGVtYVsoMCwgdXRpbF8xLnVuZXNjYXBlRnJhZ21lbnQpKHBhcnQpXTtcbiAgICAgICAgaWYgKHBhcnRTY2hlbWEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc2NoZW1hID0gcGFydFNjaGVtYTtcbiAgICAgICAgLy8gVE9ETyBQUkVWRU5UX1NDT1BFX0NIQU5HRSBjb3VsZCBiZSBkZWZpbmVkIGluIGtleXdvcmQgZGVmP1xuICAgICAgICBjb25zdCBzY2hJZCA9IHR5cGVvZiBzY2hlbWEgPT09IFwib2JqZWN0XCIgJiYgc2NoZW1hW3RoaXMub3B0cy5zY2hlbWFJZF07XG4gICAgICAgIGlmICghUFJFVkVOVF9TQ09QRV9DSEFOR0UuaGFzKHBhcnQpICYmIHNjaElkKSB7XG4gICAgICAgICAgICBiYXNlSWQgPSAoMCwgcmVzb2x2ZV8xLnJlc29sdmVVcmwpKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCBzY2hJZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGVudjtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSAhPSBcImJvb2xlYW5cIiAmJiBzY2hlbWEuJHJlZiAmJiAhKDAsIHV0aWxfMS5zY2hlbWFIYXNSdWxlc0J1dFJlZikoc2NoZW1hLCB0aGlzLlJVTEVTKSkge1xuICAgICAgICBjb25zdCAkcmVmID0gKDAsIHJlc29sdmVfMS5yZXNvbHZlVXJsKSh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIGJhc2VJZCwgc2NoZW1hLiRyZWYpO1xuICAgICAgICBlbnYgPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgJHJlZik7XG4gICAgfVxuICAgIC8vIGV2ZW4gdGhvdWdoIHJlc29sdXRpb24gZmFpbGVkIHdlIG5lZWQgdG8gcmV0dXJuIFNjaGVtYUVudiB0byB0aHJvdyBleGNlcHRpb25cbiAgICAvLyBzbyB0aGF0IGNvbXBpbGVBc3luYyBsb2FkcyBtaXNzaW5nIHNjaGVtYS5cbiAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgZW52ID0gZW52IHx8IG5ldyBTY2hlbWFFbnYoeyBzY2hlbWEsIHNjaGVtYUlkLCByb290LCBiYXNlSWQgfSk7XG4gICAgaWYgKGVudi5zY2hlbWEgIT09IGVudi5yb290LnNjaGVtYSlcbiAgICAgICAgcmV0dXJuIGVudjtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEhFWCA9IHtcbiAgMDogMCxcbiAgMTogMSxcbiAgMjogMixcbiAgMzogMyxcbiAgNDogNCxcbiAgNTogNSxcbiAgNjogNixcbiAgNzogNyxcbiAgODogOCxcbiAgOTogOSxcbiAgYTogMTAsXG4gIEE6IDEwLFxuICBiOiAxMSxcbiAgQjogMTEsXG4gIGM6IDEyLFxuICBDOiAxMixcbiAgZDogMTMsXG4gIEQ6IDEzLFxuICBlOiAxNCxcbiAgRTogMTQsXG4gIGY6IDE1LFxuICBGOiAxNVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSEVYXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBIRVggfSA9IHJlcXVpcmUoJy4vc2NvcGVkQ2hhcnMnKVxuXG5jb25zdCBJUFY0X1JFRyA9IC9eKD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZHsyfXxbMS05XVxcZHxcXGQpXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfDFcXGR7Mn18WzEtOV1cXGR8XFxkKSQvdVxuXG5mdW5jdGlvbiBub3JtYWxpemVJUHY0IChob3N0KSB7XG4gIGlmIChmaW5kVG9rZW4oaG9zdCwgJy4nKSA8IDMpIHsgcmV0dXJuIHsgaG9zdCwgaXNJUFY0OiBmYWxzZSB9IH1cbiAgY29uc3QgbWF0Y2hlcyA9IGhvc3QubWF0Y2goSVBWNF9SRUcpIHx8IFtdXG4gIGNvbnN0IFthZGRyZXNzXSA9IG1hdGNoZXNcbiAgaWYgKGFkZHJlc3MpIHtcbiAgICByZXR1cm4geyBob3N0OiBzdHJpcExlYWRpbmdaZXJvcyhhZGRyZXNzLCAnLicpLCBpc0lQVjQ6IHRydWUgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IGhvc3QsIGlzSVBWNDogZmFsc2UgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gaW5wdXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2tlZXBaZXJvPWZhbHNlXVxuICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ0FycmF5VG9IZXhTdHJpcHBlZCAoaW5wdXQsIGtlZXBaZXJvID0gZmFsc2UpIHtcbiAgbGV0IGFjYyA9ICcnXG4gIGxldCBzdHJpcCA9IHRydWVcbiAgZm9yIChjb25zdCBjIG9mIGlucHV0KSB7XG4gICAgaWYgKEhFWFtjXSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgaWYgKGMgIT09ICcwJyAmJiBzdHJpcCA9PT0gdHJ1ZSkgc3RyaXAgPSBmYWxzZVxuICAgIGlmICghc3RyaXApIGFjYyArPSBjXG4gIH1cbiAgaWYgKGtlZXBaZXJvICYmIGFjYy5sZW5ndGggPT09IDApIGFjYyA9ICcwJ1xuICByZXR1cm4gYWNjXG59XG5cbmZ1bmN0aW9uIGdldElQVjYgKGlucHV0KSB7XG4gIGxldCB0b2tlbkNvdW50ID0gMFxuICBjb25zdCBvdXRwdXQgPSB7IGVycm9yOiBmYWxzZSwgYWRkcmVzczogJycsIHpvbmU6ICcnIH1cbiAgY29uc3QgYWRkcmVzcyA9IFtdXG4gIGNvbnN0IGJ1ZmZlciA9IFtdXG4gIGxldCBpc1pvbmUgPSBmYWxzZVxuICBsZXQgZW5kaXB2NkVuY291bnRlcmVkID0gZmFsc2VcbiAgbGV0IGVuZElwdjYgPSBmYWxzZVxuXG4gIGZ1bmN0aW9uIGNvbnN1bWUgKCkge1xuICAgIGlmIChidWZmZXIubGVuZ3RoKSB7XG4gICAgICBpZiAoaXNab25lID09PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBoZXggPSBzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWQoYnVmZmVyKVxuICAgICAgICBpZiAoaGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhZGRyZXNzLnB1c2goaGV4KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dHB1dC5lcnJvciA9IHRydWVcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnVmZmVyLmxlbmd0aCA9IDBcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjdXJzb3IgPSBpbnB1dFtpXVxuICAgIGlmIChjdXJzb3IgPT09ICdbJyB8fCBjdXJzb3IgPT09ICddJykgeyBjb250aW51ZSB9XG4gICAgaWYgKGN1cnNvciA9PT0gJzonKSB7XG4gICAgICBpZiAoZW5kaXB2NkVuY291bnRlcmVkID09PSB0cnVlKSB7XG4gICAgICAgIGVuZElwdjYgPSB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoIWNvbnN1bWUoKSkgeyBicmVhayB9XG4gICAgICB0b2tlbkNvdW50KytcbiAgICAgIGFkZHJlc3MucHVzaCgnOicpXG4gICAgICBpZiAodG9rZW5Db3VudCA+IDcpIHtcbiAgICAgICAgLy8gbm90IHZhbGlkXG4gICAgICAgIG91dHB1dC5lcnJvciA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmIChpIC0gMSA+PSAwICYmIGlucHV0W2kgLSAxXSA9PT0gJzonKSB7XG4gICAgICAgIGVuZGlwdjZFbmNvdW50ZXJlZCA9IHRydWVcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlXG4gICAgfSBlbHNlIGlmIChjdXJzb3IgPT09ICclJykge1xuICAgICAgaWYgKCFjb25zdW1lKCkpIHsgYnJlYWsgfVxuICAgICAgLy8gc3dpdGNoIHRvIHpvbmUgZGV0ZWN0aW9uXG4gICAgICBpc1pvbmUgPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlci5wdXNoKGN1cnNvcilcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICB9XG4gIGlmIChidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGlzWm9uZSkge1xuICAgICAgb3V0cHV0LnpvbmUgPSBidWZmZXIuam9pbignJylcbiAgICB9IGVsc2UgaWYgKGVuZElwdjYpIHtcbiAgICAgIGFkZHJlc3MucHVzaChidWZmZXIuam9pbignJykpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZHJlc3MucHVzaChzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWQoYnVmZmVyKSlcbiAgICB9XG4gIH1cbiAgb3V0cHV0LmFkZHJlc3MgPSBhZGRyZXNzLmpvaW4oJycpXG4gIHJldHVybiBvdXRwdXRcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplSVB2NiAoaG9zdCkge1xuICBpZiAoZmluZFRva2VuKGhvc3QsICc6JykgPCAyKSB7IHJldHVybiB7IGhvc3QsIGlzSVBWNjogZmFsc2UgfSB9XG4gIGNvbnN0IGlwdjYgPSBnZXRJUFY2KGhvc3QpXG5cbiAgaWYgKCFpcHY2LmVycm9yKSB7XG4gICAgbGV0IG5ld0hvc3QgPSBpcHY2LmFkZHJlc3NcbiAgICBsZXQgZXNjYXBlZEhvc3QgPSBpcHY2LmFkZHJlc3NcbiAgICBpZiAoaXB2Ni56b25lKSB7XG4gICAgICBuZXdIb3N0ICs9ICclJyArIGlwdjYuem9uZVxuICAgICAgZXNjYXBlZEhvc3QgKz0gJyUyNScgKyBpcHY2LnpvbmVcbiAgICB9XG4gICAgcmV0dXJuIHsgaG9zdDogbmV3SG9zdCwgZXNjYXBlZEhvc3QsIGlzSVBWNjogdHJ1ZSB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgaG9zdCwgaXNJUFY2OiBmYWxzZSB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RyaXBMZWFkaW5nWmVyb3MgKHN0ciwgdG9rZW4pIHtcbiAgbGV0IG91dCA9ICcnXG4gIGxldCBza2lwID0gdHJ1ZVxuICBjb25zdCBsID0gc3RyLmxlbmd0aFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IGMgPSBzdHJbaV1cbiAgICBpZiAoYyA9PT0gJzAnICYmIHNraXApIHtcbiAgICAgIGlmICgoaSArIDEgPD0gbCAmJiBzdHJbaSArIDFdID09PSB0b2tlbikgfHwgaSArIDEgPT09IGwpIHtcbiAgICAgICAgb3V0ICs9IGNcbiAgICAgICAgc2tpcCA9IGZhbHNlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjID09PSB0b2tlbikge1xuICAgICAgICBza2lwID0gdHJ1ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2tpcCA9IGZhbHNlXG4gICAgICB9XG4gICAgICBvdXQgKz0gY1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIGZpbmRUb2tlbiAoc3RyLCB0b2tlbikge1xuICBsZXQgaW5kID0gMFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHJbaV0gPT09IHRva2VuKSBpbmQrK1xuICB9XG4gIHJldHVybiBpbmRcbn1cblxuY29uc3QgUkRTMSA9IC9eXFwuXFwuP1xcLy91XG5jb25zdCBSRFMyID0gL15cXC9cXC4oPzpcXC98JCkvdVxuY29uc3QgUkRTMyA9IC9eXFwvXFwuXFwuKD86XFwvfCQpL3VcbmNvbnN0IFJEUzUgPSAvXlxcLz8oPzoufFxcbikqPyg/PVxcL3wkKS91XG5cbmZ1bmN0aW9uIHJlbW92ZURvdFNlZ21lbnRzIChpbnB1dCkge1xuICBjb25zdCBvdXRwdXQgPSBbXVxuXG4gIHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcbiAgICBpZiAoaW5wdXQubWF0Y2goUkRTMSkpIHtcbiAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMxLCAnJylcbiAgICB9IGVsc2UgaWYgKGlucHV0Lm1hdGNoKFJEUzIpKSB7XG4gICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoUkRTMiwgJy8nKVxuICAgIH0gZWxzZSBpZiAoaW5wdXQubWF0Y2goUkRTMykpIHtcbiAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMzLCAnLycpXG4gICAgICBvdXRwdXQucG9wKClcbiAgICB9IGVsc2UgaWYgKGlucHV0ID09PSAnLicgfHwgaW5wdXQgPT09ICcuLicpIHtcbiAgICAgIGlucHV0ID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaW0gPSBpbnB1dC5tYXRjaChSRFM1KVxuICAgICAgaWYgKGltKSB7XG4gICAgICAgIGNvbnN0IHMgPSBpbVswXVxuICAgICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKHMubGVuZ3RoKVxuICAgICAgICBvdXRwdXQucHVzaChzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGRvdCBzZWdtZW50IGNvbmRpdGlvbicpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcgKGNvbXBvbmVudHMsIGVzYykge1xuICBjb25zdCBmdW5jID0gZXNjICE9PSB0cnVlID8gZXNjYXBlIDogdW5lc2NhcGVcbiAgaWYgKGNvbXBvbmVudHMuc2NoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnRzLnNjaGVtZSA9IGZ1bmMoY29tcG9uZW50cy5zY2hlbWUpXG4gIH1cbiAgaWYgKGNvbXBvbmVudHMudXNlcmluZm8gIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudHMudXNlcmluZm8gPSBmdW5jKGNvbXBvbmVudHMudXNlcmluZm8pXG4gIH1cbiAgaWYgKGNvbXBvbmVudHMuaG9zdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50cy5ob3N0ID0gZnVuYyhjb21wb25lbnRzLmhvc3QpXG4gIH1cbiAgaWYgKGNvbXBvbmVudHMucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50cy5wYXRoID0gZnVuYyhjb21wb25lbnRzLnBhdGgpXG4gIH1cbiAgaWYgKGNvbXBvbmVudHMucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudHMucXVlcnkgPSBmdW5jKGNvbXBvbmVudHMucXVlcnkpXG4gIH1cbiAgaWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudHMuZnJhZ21lbnQgPSBmdW5jKGNvbXBvbmVudHMuZnJhZ21lbnQpXG4gIH1cbiAgcmV0dXJuIGNvbXBvbmVudHNcbn1cblxuZnVuY3Rpb24gcmVjb21wb3NlQXV0aG9yaXR5IChjb21wb25lbnRzKSB7XG4gIGNvbnN0IHVyaVRva2VucyA9IFtdXG5cbiAgaWYgKGNvbXBvbmVudHMudXNlcmluZm8gIT09IHVuZGVmaW5lZCkge1xuICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMudXNlcmluZm8pXG4gICAgdXJpVG9rZW5zLnB1c2goJ0AnKVxuICB9XG5cbiAgaWYgKGNvbXBvbmVudHMuaG9zdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IGhvc3QgPSB1bmVzY2FwZShjb21wb25lbnRzLmhvc3QpXG4gICAgY29uc3QgaXBWNHJlcyA9IG5vcm1hbGl6ZUlQdjQoaG9zdClcblxuICAgIGlmIChpcFY0cmVzLmlzSVBWNCkge1xuICAgICAgaG9zdCA9IGlwVjRyZXMuaG9zdFxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpcFY2cmVzID0gbm9ybWFsaXplSVB2NihpcFY0cmVzLmhvc3QpXG4gICAgICBpZiAoaXBWNnJlcy5pc0lQVjYgPT09IHRydWUpIHtcbiAgICAgICAgaG9zdCA9IGBbJHtpcFY2cmVzLmVzY2FwZWRIb3N0fV1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBob3N0ID0gY29tcG9uZW50cy5ob3N0XG4gICAgICB9XG4gICAgfVxuICAgIHVyaVRva2Vucy5wdXNoKGhvc3QpXG4gIH1cblxuICBpZiAodHlwZW9mIGNvbXBvbmVudHMucG9ydCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGNvbXBvbmVudHMucG9ydCA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmlUb2tlbnMucHVzaCgnOicpXG4gICAgdXJpVG9rZW5zLnB1c2goU3RyaW5nKGNvbXBvbmVudHMucG9ydCkpXG4gIH1cblxuICByZXR1cm4gdXJpVG9rZW5zLmxlbmd0aCA/IHVyaVRva2Vucy5qb2luKCcnKSA6IHVuZGVmaW5lZFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlY29tcG9zZUF1dGhvcml0eSxcbiAgbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcsXG4gIHJlbW92ZURvdFNlZ21lbnRzLFxuICBub3JtYWxpemVJUHY0LFxuICBub3JtYWxpemVJUHY2LFxuICBzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWRcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBVVUlEX1JFRyA9IC9eW1xcZGEtZl17OH0tW1xcZGEtZl17NH0tW1xcZGEtZl17NH0tW1xcZGEtZl17NH0tW1xcZGEtZl17MTJ9JC9pdVxuY29uc3QgVVJOX1JFRyA9IC8oW1xcZGEtel1bXFxkXFwtYS16XXswLDMxfSk6KCg/OltcXHchJCcoKSorLFxcLS46Oz1AXXwlW1xcZGEtZl17Mn0pKykvaXVcblxuZnVuY3Rpb24gaXNTZWN1cmUgKHdzQ29tcG9uZW50cykge1xuICByZXR1cm4gdHlwZW9mIHdzQ29tcG9uZW50cy5zZWN1cmUgPT09ICdib29sZWFuJyA/IHdzQ29tcG9uZW50cy5zZWN1cmUgOiBTdHJpbmcod3NDb21wb25lbnRzLnNjaGVtZSkudG9Mb3dlckNhc2UoKSA9PT0gJ3dzcydcbn1cblxuZnVuY3Rpb24gaHR0cFBhcnNlIChjb21wb25lbnRzKSB7XG4gIGlmICghY29tcG9uZW50cy5ob3N0KSB7XG4gICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgJ0hUVFAgVVJJcyBtdXN0IGhhdmUgYSBob3N0LidcbiAgfVxuXG4gIHJldHVybiBjb21wb25lbnRzXG59XG5cbmZ1bmN0aW9uIGh0dHBTZXJpYWxpemUgKGNvbXBvbmVudHMpIHtcbiAgY29uc3Qgc2VjdXJlID0gU3RyaW5nKGNvbXBvbmVudHMuc2NoZW1lKS50b0xvd2VyQ2FzZSgpID09PSAnaHR0cHMnXG5cbiAgLy8gbm9ybWFsaXplIHRoZSBkZWZhdWx0IHBvcnRcbiAgaWYgKGNvbXBvbmVudHMucG9ydCA9PT0gKHNlY3VyZSA/IDQ0MyA6IDgwKSB8fCBjb21wb25lbnRzLnBvcnQgPT09ICcnKSB7XG4gICAgY29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBub3JtYWxpemUgdGhlIGVtcHR5IHBhdGhcbiAgaWYgKCFjb21wb25lbnRzLnBhdGgpIHtcbiAgICBjb21wb25lbnRzLnBhdGggPSAnLydcbiAgfVxuXG4gIC8vIE5PVEU6IFdlIGRvIG5vdCBwYXJzZSBxdWVyeSBzdHJpbmdzIGZvciBIVFRQIFVSSXNcbiAgLy8gYXMgV1dXIEZvcm0gVXJsIEVuY29kZWQgcXVlcnkgc3RyaW5ncyBhcmUgcGFydCBvZiB0aGUgSFRNTDQrIHNwZWMsXG4gIC8vIGFuZCBub3QgdGhlIEhUVFAgc3BlYy5cblxuICByZXR1cm4gY29tcG9uZW50c1xufVxuXG5mdW5jdGlvbiB3c1BhcnNlICh3c0NvbXBvbmVudHMpIHtcbi8vIGluZGljYXRlIGlmIHRoZSBzZWN1cmUgZmxhZyBpcyBzZXRcbiAgd3NDb21wb25lbnRzLnNlY3VyZSA9IGlzU2VjdXJlKHdzQ29tcG9uZW50cylcblxuICAvLyBjb25zdHJ1Y3QgcmVzb3VjZSBuYW1lXG4gIHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUgPSAod3NDb21wb25lbnRzLnBhdGggfHwgJy8nKSArICh3c0NvbXBvbmVudHMucXVlcnkgPyAnPycgKyB3c0NvbXBvbmVudHMucXVlcnkgOiAnJylcbiAgd3NDb21wb25lbnRzLnBhdGggPSB1bmRlZmluZWRcbiAgd3NDb21wb25lbnRzLnF1ZXJ5ID0gdW5kZWZpbmVkXG5cbiAgcmV0dXJuIHdzQ29tcG9uZW50c1xufVxuXG5mdW5jdGlvbiB3c1NlcmlhbGl6ZSAod3NDb21wb25lbnRzKSB7XG4vLyBub3JtYWxpemUgdGhlIGRlZmF1bHQgcG9ydFxuICBpZiAod3NDb21wb25lbnRzLnBvcnQgPT09IChpc1NlY3VyZSh3c0NvbXBvbmVudHMpID8gNDQzIDogODApIHx8IHdzQ29tcG9uZW50cy5wb3J0ID09PSAnJykge1xuICAgIHdzQ29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBlbnN1cmUgc2NoZW1lIG1hdGNoZXMgc2VjdXJlIGZsYWdcbiAgaWYgKHR5cGVvZiB3c0NvbXBvbmVudHMuc2VjdXJlID09PSAnYm9vbGVhbicpIHtcbiAgICB3c0NvbXBvbmVudHMuc2NoZW1lID0gKHdzQ29tcG9uZW50cy5zZWN1cmUgPyAnd3NzJyA6ICd3cycpXG4gICAgd3NDb21wb25lbnRzLnNlY3VyZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gcmVjb25zdHJ1Y3QgcGF0aCBmcm9tIHJlc291cmNlIG5hbWVcbiAgaWYgKHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUpIHtcbiAgICBjb25zdCBbcGF0aCwgcXVlcnldID0gd3NDb21wb25lbnRzLnJlc291cmNlTmFtZS5zcGxpdCgnPycpXG4gICAgd3NDb21wb25lbnRzLnBhdGggPSAocGF0aCAmJiBwYXRoICE9PSAnLycgPyBwYXRoIDogdW5kZWZpbmVkKVxuICAgIHdzQ29tcG9uZW50cy5xdWVyeSA9IHF1ZXJ5XG4gICAgd3NDb21wb25lbnRzLnJlc291cmNlTmFtZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gZm9yYmlkIGZyYWdtZW50IGNvbXBvbmVudFxuICB3c0NvbXBvbmVudHMuZnJhZ21lbnQgPSB1bmRlZmluZWRcblxuICByZXR1cm4gd3NDb21wb25lbnRzXG59XG5cbmZ1bmN0aW9uIHVyblBhcnNlICh1cm5Db21wb25lbnRzLCBvcHRpb25zKSB7XG4gIGlmICghdXJuQ29tcG9uZW50cy5wYXRoKSB7XG4gICAgdXJuQ29tcG9uZW50cy5lcnJvciA9ICdVUk4gY2FuIG5vdCBiZSBwYXJzZWQnXG4gICAgcmV0dXJuIHVybkNvbXBvbmVudHNcbiAgfVxuICBjb25zdCBtYXRjaGVzID0gdXJuQ29tcG9uZW50cy5wYXRoLm1hdGNoKFVSTl9SRUcpXG4gIGlmIChtYXRjaGVzKSB7XG4gICAgY29uc3Qgc2NoZW1lID0gb3B0aW9ucy5zY2hlbWUgfHwgdXJuQ29tcG9uZW50cy5zY2hlbWUgfHwgJ3VybidcbiAgICB1cm5Db21wb25lbnRzLm5pZCA9IG1hdGNoZXNbMV0udG9Mb3dlckNhc2UoKVxuICAgIHVybkNvbXBvbmVudHMubnNzID0gbWF0Y2hlc1syXVxuICAgIGNvbnN0IHVyblNjaGVtZSA9IGAke3NjaGVtZX06JHtvcHRpb25zLm5pZCB8fCB1cm5Db21wb25lbnRzLm5pZH1gXG4gICAgY29uc3Qgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbdXJuU2NoZW1lXVxuICAgIHVybkNvbXBvbmVudHMucGF0aCA9IHVuZGVmaW5lZFxuXG4gICAgaWYgKHNjaGVtZUhhbmRsZXIpIHtcbiAgICAgIHVybkNvbXBvbmVudHMgPSBzY2hlbWVIYW5kbGVyLnBhcnNlKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHVybkNvbXBvbmVudHMuZXJyb3IgPSB1cm5Db21wb25lbnRzLmVycm9yIHx8ICdVUk4gY2FuIG5vdCBiZSBwYXJzZWQuJ1xuICB9XG5cbiAgcmV0dXJuIHVybkNvbXBvbmVudHNcbn1cblxuZnVuY3Rpb24gdXJuU2VyaWFsaXplICh1cm5Db21wb25lbnRzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNjaGVtZSA9IG9wdGlvbnMuc2NoZW1lIHx8IHVybkNvbXBvbmVudHMuc2NoZW1lIHx8ICd1cm4nXG4gIGNvbnN0IG5pZCA9IHVybkNvbXBvbmVudHMubmlkLnRvTG93ZXJDYXNlKClcbiAgY29uc3QgdXJuU2NoZW1lID0gYCR7c2NoZW1lfToke29wdGlvbnMubmlkIHx8IG5pZH1gXG4gIGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTW3VyblNjaGVtZV1cblxuICBpZiAoc2NoZW1lSGFuZGxlcikge1xuICAgIHVybkNvbXBvbmVudHMgPSBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZSh1cm5Db21wb25lbnRzLCBvcHRpb25zKVxuICB9XG5cbiAgY29uc3QgdXJpQ29tcG9uZW50cyA9IHVybkNvbXBvbmVudHNcbiAgY29uc3QgbnNzID0gdXJuQ29tcG9uZW50cy5uc3NcbiAgdXJpQ29tcG9uZW50cy5wYXRoID0gYCR7bmlkIHx8IG9wdGlvbnMubmlkfToke25zc31gXG5cbiAgb3B0aW9ucy5za2lwRXNjYXBlID0gdHJ1ZVxuICByZXR1cm4gdXJpQ29tcG9uZW50c1xufVxuXG5mdW5jdGlvbiB1cm51dWlkUGFyc2UgKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgY29uc3QgdXVpZENvbXBvbmVudHMgPSB1cm5Db21wb25lbnRzXG4gIHV1aWRDb21wb25lbnRzLnV1aWQgPSB1dWlkQ29tcG9uZW50cy5uc3NcbiAgdXVpZENvbXBvbmVudHMubnNzID0gdW5kZWZpbmVkXG5cbiAgaWYgKCFvcHRpb25zLnRvbGVyYW50ICYmICghdXVpZENvbXBvbmVudHMudXVpZCB8fCAhVVVJRF9SRUcudGVzdCh1dWlkQ29tcG9uZW50cy51dWlkKSkpIHtcbiAgICB1dWlkQ29tcG9uZW50cy5lcnJvciA9IHV1aWRDb21wb25lbnRzLmVycm9yIHx8ICdVVUlEIGlzIG5vdCB2YWxpZC4nXG4gIH1cblxuICByZXR1cm4gdXVpZENvbXBvbmVudHNcbn1cblxuZnVuY3Rpb24gdXJudXVpZFNlcmlhbGl6ZSAodXVpZENvbXBvbmVudHMpIHtcbiAgY29uc3QgdXJuQ29tcG9uZW50cyA9IHV1aWRDb21wb25lbnRzXG4gIC8vIG5vcm1hbGl6ZSBVVUlEXG4gIHVybkNvbXBvbmVudHMubnNzID0gKHV1aWRDb21wb25lbnRzLnV1aWQgfHwgJycpLnRvTG93ZXJDYXNlKClcbiAgcmV0dXJuIHVybkNvbXBvbmVudHNcbn1cblxuY29uc3QgaHR0cCA9IHtcbiAgc2NoZW1lOiAnaHR0cCcsXG4gIGRvbWFpbkhvc3Q6IHRydWUsXG4gIHBhcnNlOiBodHRwUGFyc2UsXG4gIHNlcmlhbGl6ZTogaHR0cFNlcmlhbGl6ZVxufVxuXG5jb25zdCBodHRwcyA9IHtcbiAgc2NoZW1lOiAnaHR0cHMnLFxuICBkb21haW5Ib3N0OiBodHRwLmRvbWFpbkhvc3QsXG4gIHBhcnNlOiBodHRwUGFyc2UsXG4gIHNlcmlhbGl6ZTogaHR0cFNlcmlhbGl6ZVxufVxuXG5jb25zdCB3cyA9IHtcbiAgc2NoZW1lOiAnd3MnLFxuICBkb21haW5Ib3N0OiB0cnVlLFxuICBwYXJzZTogd3NQYXJzZSxcbiAgc2VyaWFsaXplOiB3c1NlcmlhbGl6ZVxufVxuXG5jb25zdCB3c3MgPSB7XG4gIHNjaGVtZTogJ3dzcycsXG4gIGRvbWFpbkhvc3Q6IHdzLmRvbWFpbkhvc3QsXG4gIHBhcnNlOiB3cy5wYXJzZSxcbiAgc2VyaWFsaXplOiB3cy5zZXJpYWxpemVcbn1cblxuY29uc3QgdXJuID0ge1xuICBzY2hlbWU6ICd1cm4nLFxuICBwYXJzZTogdXJuUGFyc2UsXG4gIHNlcmlhbGl6ZTogdXJuU2VyaWFsaXplLFxuICBza2lwTm9ybWFsaXplOiB0cnVlXG59XG5cbmNvbnN0IHVybnV1aWQgPSB7XG4gIHNjaGVtZTogJ3Vybjp1dWlkJyxcbiAgcGFyc2U6IHVybnV1aWRQYXJzZSxcbiAgc2VyaWFsaXplOiB1cm51dWlkU2VyaWFsaXplLFxuICBza2lwTm9ybWFsaXplOiB0cnVlXG59XG5cbmNvbnN0IFNDSEVNRVMgPSB7XG4gIGh0dHAsXG4gIGh0dHBzLFxuICB3cyxcbiAgd3NzLFxuICB1cm4sXG4gICd1cm46dXVpZCc6IHVybnV1aWRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTQ0hFTUVTXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBub3JtYWxpemVJUHY2LCBub3JtYWxpemVJUHY0LCByZW1vdmVEb3RTZWdtZW50cywgcmVjb21wb3NlQXV0aG9yaXR5LCBub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyB9ID0gcmVxdWlyZSgnLi9saWIvdXRpbHMnKVxuY29uc3QgU0NIRU1FUyA9IHJlcXVpcmUoJy4vbGliL3NjaGVtZXMnKVxuXG5mdW5jdGlvbiBub3JtYWxpemUgKHVyaSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHVyaSA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmkgPSBzZXJpYWxpemUocGFyc2UodXJpLCBvcHRpb25zKSwgb3B0aW9ucylcbiAgfSBlbHNlIGlmICh0eXBlb2YgdXJpID09PSAnb2JqZWN0Jykge1xuICAgIHVyaSA9IHBhcnNlKHNlcmlhbGl6ZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKVxuICB9XG4gIHJldHVybiB1cmlcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZSAoYmFzZVVSSSwgcmVsYXRpdmVVUkksIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2NoZW1lbGVzc09wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgc2NoZW1lOiAnbnVsbCcgfSwgb3B0aW9ucylcbiAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlQ29tcG9uZW50cyhwYXJzZShiYXNlVVJJLCBzY2hlbWVsZXNzT3B0aW9ucyksIHBhcnNlKHJlbGF0aXZlVVJJLCBzY2hlbWVsZXNzT3B0aW9ucyksIHNjaGVtZWxlc3NPcHRpb25zLCB0cnVlKVxuICByZXR1cm4gc2VyaWFsaXplKHJlc29sdmVkLCB7IC4uLnNjaGVtZWxlc3NPcHRpb25zLCBza2lwRXNjYXBlOiB0cnVlIH0pXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnRzIChiYXNlLCByZWxhdGl2ZSwgb3B0aW9ucywgc2tpcE5vcm1hbGl6YXRpb24pIHtcbiAgY29uc3QgdGFyZ2V0ID0ge31cbiAgaWYgKCFza2lwTm9ybWFsaXphdGlvbikge1xuICAgIGJhc2UgPSBwYXJzZShzZXJpYWxpemUoYmFzZSwgb3B0aW9ucyksIG9wdGlvbnMpIC8vIG5vcm1hbGl6ZSBiYXNlIGNvbXBvbmVudHNcbiAgICByZWxhdGl2ZSA9IHBhcnNlKHNlcmlhbGl6ZShyZWxhdGl2ZSwgb3B0aW9ucyksIG9wdGlvbnMpIC8vIG5vcm1hbGl6ZSByZWxhdGl2ZSBjb21wb25lbnRzXG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICBpZiAoIW9wdGlvbnMudG9sZXJhbnQgJiYgcmVsYXRpdmUuc2NoZW1lKSB7XG4gICAgdGFyZ2V0LnNjaGVtZSA9IHJlbGF0aXZlLnNjaGVtZVxuICAgIC8vIHRhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG4gICAgdGFyZ2V0LnVzZXJpbmZvID0gcmVsYXRpdmUudXNlcmluZm9cbiAgICB0YXJnZXQuaG9zdCA9IHJlbGF0aXZlLmhvc3RcbiAgICB0YXJnZXQucG9ydCA9IHJlbGF0aXZlLnBvcnRcbiAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGggfHwgJycpXG4gICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnlcbiAgfSBlbHNlIHtcbiAgICBpZiAocmVsYXRpdmUudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgcmVsYXRpdmUucG9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyB0YXJnZXQuYXV0aG9yaXR5ID0gcmVsYXRpdmUuYXV0aG9yaXR5O1xuICAgICAgdGFyZ2V0LnVzZXJpbmZvID0gcmVsYXRpdmUudXNlcmluZm9cbiAgICAgIHRhcmdldC5ob3N0ID0gcmVsYXRpdmUuaG9zdFxuICAgICAgdGFyZ2V0LnBvcnQgPSByZWxhdGl2ZS5wb3J0XG4gICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGggfHwgJycpXG4gICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXJlbGF0aXZlLnBhdGgpIHtcbiAgICAgICAgdGFyZ2V0LnBhdGggPSBiYXNlLnBhdGhcbiAgICAgICAgaWYgKHJlbGF0aXZlLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldC5xdWVyeSA9IGJhc2UucXVlcnlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlbGF0aXZlLnBhdGguY2hhckF0KDApID09PSAnLycpIHtcbiAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKChiYXNlLnVzZXJpbmZvICE9PSB1bmRlZmluZWQgfHwgYmFzZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgYmFzZS5wb3J0ICE9PSB1bmRlZmluZWQpICYmICFiYXNlLnBhdGgpIHtcbiAgICAgICAgICAgIHRhcmdldC5wYXRoID0gJy8nICsgcmVsYXRpdmUucGF0aFxuICAgICAgICAgIH0gZWxzZSBpZiAoIWJhc2UucGF0aCkge1xuICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZWxhdGl2ZS5wYXRoXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKDAsIGJhc2UucGF0aC5sYXN0SW5kZXhPZignLycpICsgMSkgKyByZWxhdGl2ZS5wYXRoXG4gICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHModGFyZ2V0LnBhdGgpXG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnlcbiAgICAgIH1cbiAgICAgIC8vIHRhcmdldC5hdXRob3JpdHkgPSBiYXNlLmF1dGhvcml0eTtcbiAgICAgIHRhcmdldC51c2VyaW5mbyA9IGJhc2UudXNlcmluZm9cbiAgICAgIHRhcmdldC5ob3N0ID0gYmFzZS5ob3N0XG4gICAgICB0YXJnZXQucG9ydCA9IGJhc2UucG9ydFxuICAgIH1cbiAgICB0YXJnZXQuc2NoZW1lID0gYmFzZS5zY2hlbWVcbiAgfVxuXG4gIHRhcmdldC5mcmFnbWVudCA9IHJlbGF0aXZlLmZyYWdtZW50XG5cbiAgcmV0dXJuIHRhcmdldFxufVxuXG5mdW5jdGlvbiBlcXVhbCAodXJpQSwgdXJpQiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHVyaUEgPT09ICdzdHJpbmcnKSB7XG4gICAgdXJpQSA9IHVuZXNjYXBlKHVyaUEpXG4gICAgdXJpQSA9IHNlcmlhbGl6ZShub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhwYXJzZSh1cmlBLCBvcHRpb25zKSwgdHJ1ZSksIHsgLi4ub3B0aW9ucywgc2tpcEVzY2FwZTogdHJ1ZSB9KVxuICB9IGVsc2UgaWYgKHR5cGVvZiB1cmlBID09PSAnb2JqZWN0Jykge1xuICAgIHVyaUEgPSBzZXJpYWxpemUobm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcodXJpQSwgdHJ1ZSksIHsgLi4ub3B0aW9ucywgc2tpcEVzY2FwZTogdHJ1ZSB9KVxuICB9XG5cbiAgaWYgKHR5cGVvZiB1cmlCID09PSAnc3RyaW5nJykge1xuICAgIHVyaUIgPSB1bmVzY2FwZSh1cmlCKVxuICAgIHVyaUIgPSBzZXJpYWxpemUobm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcocGFyc2UodXJpQiwgb3B0aW9ucyksIHRydWUpLCB7IC4uLm9wdGlvbnMsIHNraXBFc2NhcGU6IHRydWUgfSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgdXJpQiA9PT0gJ29iamVjdCcpIHtcbiAgICB1cmlCID0gc2VyaWFsaXplKG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKHVyaUIsIHRydWUpLCB7IC4uLm9wdGlvbnMsIHNraXBFc2NhcGU6IHRydWUgfSlcbiAgfVxuXG4gIHJldHVybiB1cmlBLnRvTG93ZXJDYXNlKCkgPT09IHVyaUIudG9Mb3dlckNhc2UoKVxufVxuXG5mdW5jdGlvbiBzZXJpYWxpemUgKGNtcHRzLCBvcHRzKSB7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSB7XG4gICAgaG9zdDogY21wdHMuaG9zdCxcbiAgICBzY2hlbWU6IGNtcHRzLnNjaGVtZSxcbiAgICB1c2VyaW5mbzogY21wdHMudXNlcmluZm8sXG4gICAgcG9ydDogY21wdHMucG9ydCxcbiAgICBwYXRoOiBjbXB0cy5wYXRoLFxuICAgIHF1ZXJ5OiBjbXB0cy5xdWVyeSxcbiAgICBuaWQ6IGNtcHRzLm5pZCxcbiAgICBuc3M6IGNtcHRzLm5zcyxcbiAgICB1dWlkOiBjbXB0cy51dWlkLFxuICAgIGZyYWdtZW50OiBjbXB0cy5mcmFnbWVudCxcbiAgICByZWZlcmVuY2U6IGNtcHRzLnJlZmVyZW5jZSxcbiAgICByZXNvdXJjZU5hbWU6IGNtcHRzLnJlc291cmNlTmFtZSxcbiAgICBzZWN1cmU6IGNtcHRzLnNlY3VyZSxcbiAgICBlcnJvcjogJydcbiAgfVxuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cylcbiAgY29uc3QgdXJpVG9rZW5zID0gW11cblxuICAvLyBmaW5kIHNjaGVtZSBoYW5kbGVyXG4gIGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTWyhvcHRpb25zLnNjaGVtZSB8fCBjb21wb25lbnRzLnNjaGVtZSB8fCAnJykudG9Mb3dlckNhc2UoKV1cblxuICAvLyBwZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBzZXJpYWxpemF0aW9uXG4gIGlmIChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKSBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZShjb21wb25lbnRzLCBvcHRpb25zKVxuXG4gIGlmIChjb21wb25lbnRzLnBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICghb3B0aW9ucy5za2lwRXNjYXBlKSB7XG4gICAgICBjb21wb25lbnRzLnBhdGggPSBlc2NhcGUoY29tcG9uZW50cy5wYXRoKVxuXG4gICAgICBpZiAoY29tcG9uZW50cy5zY2hlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb21wb25lbnRzLnBhdGggPSBjb21wb25lbnRzLnBhdGguc3BsaXQoJyUzQScpLmpvaW4oJzonKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21wb25lbnRzLnBhdGggPSB1bmVzY2FwZShjb21wb25lbnRzLnBhdGgpXG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSAnc3VmZml4JyAmJiBjb21wb25lbnRzLnNjaGVtZSkge1xuICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMuc2NoZW1lLCAnOicpXG4gIH1cblxuICBjb25zdCBhdXRob3JpdHkgPSByZWNvbXBvc2VBdXRob3JpdHkoY29tcG9uZW50cylcbiAgaWYgKGF1dGhvcml0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSAnc3VmZml4Jykge1xuICAgICAgdXJpVG9rZW5zLnB1c2goJy8vJylcbiAgICB9XG5cbiAgICB1cmlUb2tlbnMucHVzaChhdXRob3JpdHkpXG5cbiAgICBpZiAoY29tcG9uZW50cy5wYXRoICYmIGNvbXBvbmVudHMucGF0aC5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgdXJpVG9rZW5zLnB1c2goJy8nKVxuICAgIH1cbiAgfVxuICBpZiAoY29tcG9uZW50cy5wYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICBsZXQgcyA9IGNvbXBvbmVudHMucGF0aFxuXG4gICAgaWYgKCFvcHRpb25zLmFic29sdXRlUGF0aCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIuYWJzb2x1dGVQYXRoKSkge1xuICAgICAgcyA9IHJlbW92ZURvdFNlZ21lbnRzKHMpXG4gICAgfVxuXG4gICAgaWYgKGF1dGhvcml0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzID0gcy5yZXBsYWNlKC9eXFwvXFwvL3UsICcvJTJGJykgLy8gZG9uJ3QgYWxsb3cgdGhlIHBhdGggdG8gc3RhcnQgd2l0aCBcIi8vXCJcbiAgICB9XG5cbiAgICB1cmlUb2tlbnMucHVzaChzKVxuICB9XG5cbiAgaWYgKGNvbXBvbmVudHMucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgIHVyaVRva2Vucy5wdXNoKCc/JywgY29tcG9uZW50cy5xdWVyeSlcbiAgfVxuXG4gIGlmIChjb21wb25lbnRzLmZyYWdtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICB1cmlUb2tlbnMucHVzaCgnIycsIGNvbXBvbmVudHMuZnJhZ21lbnQpXG4gIH1cbiAgcmV0dXJuIHVyaVRva2Vucy5qb2luKCcnKVxufVxuXG5jb25zdCBoZXhMb29rVXAgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMjcgfSwgKF92LCBrKSA9PiAvW14hXCIkJicoKSorLFxcLS47PV9gYS16e31+XS91LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShrKSkpXG5cbmZ1bmN0aW9uIG5vblNpbXBsZURvbWFpbiAodmFsdWUpIHtcbiAgbGV0IGNvZGUgPSAwXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKGNvZGUgPiAxMjYgfHwgaGV4TG9va1VwW2NvZGVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuY29uc3QgVVJJX1BBUlNFID0gL14oPzooW14jLzo/XSspOik/KD86XFwvXFwvKCg/OihbXiMvP0BdKilAKT8oXFxbW14jLz9cXF1dK1xcXXxbXiMvOj9dKikoPzo6KFxcZCopKT8pKT8oW14jP10qKSg/OlxcPyhbXiNdKikpPyg/OiMoKD86LnxbXFxuXFxyXSkqKSk/L3VcblxuZnVuY3Rpb24gcGFyc2UgKHVyaSwgb3B0cykge1xuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cylcbiAgY29uc3QgcGFyc2VkID0ge1xuICAgIHNjaGVtZTogdW5kZWZpbmVkLFxuICAgIHVzZXJpbmZvOiB1bmRlZmluZWQsXG4gICAgaG9zdDogJycsXG4gICAgcG9ydDogdW5kZWZpbmVkLFxuICAgIHBhdGg6ICcnLFxuICAgIHF1ZXJ5OiB1bmRlZmluZWQsXG4gICAgZnJhZ21lbnQ6IHVuZGVmaW5lZFxuICB9XG4gIGNvbnN0IGdvdEVuY29kaW5nID0gdXJpLmluZGV4T2YoJyUnKSAhPT0gLTFcbiAgbGV0IGlzSVAgPSBmYWxzZVxuICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgPT09ICdzdWZmaXgnKSB1cmkgPSAob3B0aW9ucy5zY2hlbWUgPyBvcHRpb25zLnNjaGVtZSArICc6JyA6ICcnKSArICcvLycgKyB1cmlcblxuICBjb25zdCBtYXRjaGVzID0gdXJpLm1hdGNoKFVSSV9QQVJTRSlcblxuICBpZiAobWF0Y2hlcykge1xuICAgIC8vIHN0b3JlIGVhY2ggY29tcG9uZW50XG4gICAgcGFyc2VkLnNjaGVtZSA9IG1hdGNoZXNbMV1cbiAgICBwYXJzZWQudXNlcmluZm8gPSBtYXRjaGVzWzNdXG4gICAgcGFyc2VkLmhvc3QgPSBtYXRjaGVzWzRdXG4gICAgcGFyc2VkLnBvcnQgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMClcbiAgICBwYXJzZWQucGF0aCA9IG1hdGNoZXNbNl0gfHwgJydcbiAgICBwYXJzZWQucXVlcnkgPSBtYXRjaGVzWzddXG4gICAgcGFyc2VkLmZyYWdtZW50ID0gbWF0Y2hlc1s4XVxuXG4gICAgLy8gZml4IHBvcnQgbnVtYmVyXG4gICAgaWYgKGlzTmFOKHBhcnNlZC5wb3J0KSkge1xuICAgICAgcGFyc2VkLnBvcnQgPSBtYXRjaGVzWzVdXG4gICAgfVxuICAgIGlmIChwYXJzZWQuaG9zdCkge1xuICAgICAgY29uc3QgaXB2NHJlc3VsdCA9IG5vcm1hbGl6ZUlQdjQocGFyc2VkLmhvc3QpXG4gICAgICBpZiAoaXB2NHJlc3VsdC5pc0lQVjQgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGlwdjZyZXN1bHQgPSBub3JtYWxpemVJUHY2KGlwdjRyZXN1bHQuaG9zdClcbiAgICAgICAgcGFyc2VkLmhvc3QgPSBpcHY2cmVzdWx0Lmhvc3QudG9Mb3dlckNhc2UoKVxuICAgICAgICBpc0lQID0gaXB2NnJlc3VsdC5pc0lQVjZcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZC5ob3N0ID0gaXB2NHJlc3VsdC5ob3N0XG4gICAgICAgIGlzSVAgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJzZWQuc2NoZW1lID09PSB1bmRlZmluZWQgJiYgcGFyc2VkLnVzZXJpbmZvID09PSB1bmRlZmluZWQgJiYgcGFyc2VkLmhvc3QgPT09IHVuZGVmaW5lZCAmJiBwYXJzZWQucG9ydCA9PT0gdW5kZWZpbmVkICYmIHBhcnNlZC5xdWVyeSA9PT0gdW5kZWZpbmVkICYmICFwYXJzZWQucGF0aCkge1xuICAgICAgcGFyc2VkLnJlZmVyZW5jZSA9ICdzYW1lLWRvY3VtZW50J1xuICAgIH0gZWxzZSBpZiAocGFyc2VkLnNjaGVtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJzZWQucmVmZXJlbmNlID0gJ3JlbGF0aXZlJ1xuICAgIH0gZWxzZSBpZiAocGFyc2VkLmZyYWdtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhcnNlZC5yZWZlcmVuY2UgPSAnYWJzb2x1dGUnXG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlZC5yZWZlcmVuY2UgPSAndXJpJ1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciByZWZlcmVuY2UgZXJyb3JzXG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICYmIG9wdGlvbnMucmVmZXJlbmNlICE9PSAnc3VmZml4JyAmJiBvcHRpb25zLnJlZmVyZW5jZSAhPT0gcGFyc2VkLnJlZmVyZW5jZSkge1xuICAgICAgcGFyc2VkLmVycm9yID0gcGFyc2VkLmVycm9yIHx8ICdVUkkgaXMgbm90IGEgJyArIG9wdGlvbnMucmVmZXJlbmNlICsgJyByZWZlcmVuY2UuJ1xuICAgIH1cblxuICAgIC8vIGZpbmQgc2NoZW1lIGhhbmRsZXJcbiAgICBjb25zdCBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1sob3B0aW9ucy5zY2hlbWUgfHwgcGFyc2VkLnNjaGVtZSB8fCAnJykudG9Mb3dlckNhc2UoKV1cblxuICAgIC8vIGNoZWNrIGlmIHNjaGVtZSBjYW4ndCBoYW5kbGUgSVJJc1xuICAgIGlmICghb3B0aW9ucy51bmljb2RlU3VwcG9ydCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIudW5pY29kZVN1cHBvcnQpKSB7XG4gICAgICAvLyBpZiBob3N0IGNvbXBvbmVudCBpcyBhIGRvbWFpbiBuYW1lXG4gICAgICBpZiAocGFyc2VkLmhvc3QgJiYgKG9wdGlvbnMuZG9tYWluSG9zdCB8fCAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLmRvbWFpbkhvc3QpKSAmJiBpc0lQID09PSBmYWxzZSAmJiBub25TaW1wbGVEb21haW4ocGFyc2VkLmhvc3QpKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgVW5pY29kZSBJRE4gLT4gQVNDSUkgSUROXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcGFyc2VkLmhvc3QgPSBVUkwuZG9tYWluVG9BU0NJSShwYXJzZWQuaG9zdC50b0xvd2VyQ2FzZSgpKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcGFyc2VkLmVycm9yID0gcGFyc2VkLmVycm9yIHx8IFwiSG9zdCdzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIEFTQ0lJOiBcIiArIGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gY29udmVydCBJUkkgLT4gVVJJXG4gICAgfVxuXG4gICAgaWYgKCFzY2hlbWVIYW5kbGVyIHx8IChzY2hlbWVIYW5kbGVyICYmICFzY2hlbWVIYW5kbGVyLnNraXBOb3JtYWxpemUpKSB7XG4gICAgICBpZiAoZ290RW5jb2RpbmcgJiYgcGFyc2VkLnNjaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcnNlZC5zY2hlbWUgPSB1bmVzY2FwZShwYXJzZWQuc2NoZW1lKVxuICAgICAgfVxuICAgICAgaWYgKGdvdEVuY29kaW5nICYmIHBhcnNlZC5ob3N0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyc2VkLmhvc3QgPSB1bmVzY2FwZShwYXJzZWQuaG9zdClcbiAgICAgIH1cbiAgICAgIGlmIChwYXJzZWQucGF0aCkge1xuICAgICAgICBwYXJzZWQucGF0aCA9IGVzY2FwZSh1bmVzY2FwZShwYXJzZWQucGF0aCkpXG4gICAgICB9XG4gICAgICBpZiAocGFyc2VkLmZyYWdtZW50KSB7XG4gICAgICAgIHBhcnNlZC5mcmFnbWVudCA9IGVuY29kZVVSSShkZWNvZGVVUklDb21wb25lbnQocGFyc2VkLmZyYWdtZW50KSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBwYXJzaW5nXG4gICAgaWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5wYXJzZSkge1xuICAgICAgc2NoZW1lSGFuZGxlci5wYXJzZShwYXJzZWQsIG9wdGlvbnMpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhcnNlZC5lcnJvciA9IHBhcnNlZC5lcnJvciB8fCAnVVJJIGNhbiBub3QgYmUgcGFyc2VkLidcbiAgfVxuICByZXR1cm4gcGFyc2VkXG59XG5cbmNvbnN0IGZhc3RVcmkgPSB7XG4gIFNDSEVNRVMsXG4gIG5vcm1hbGl6ZSxcbiAgcmVzb2x2ZSxcbiAgcmVzb2x2ZUNvbXBvbmVudHMsXG4gIGVxdWFsLFxuICBzZXJpYWxpemUsXG4gIHBhcnNlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmFzdFVyaVxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGZhc3RVcmlcbm1vZHVsZS5leHBvcnRzLmZhc3RVcmkgPSBmYXN0VXJpXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHVyaSA9IHJlcXVpcmUoXCJmYXN0LXVyaVwiKTtcbnVyaS5jb2RlID0gJ3JlcXVpcmUoXCJhanYvZGlzdC9ydW50aW1lL3VyaVwiKS5kZWZhdWx0JztcbmV4cG9ydHMuZGVmYXVsdCA9IHVyaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVyaS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29kZUdlbiA9IGV4cG9ydHMuTmFtZSA9IGV4cG9ydHMubmlsID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMuXyA9IGV4cG9ydHMuS2V5d29yZEN4dCA9IHZvaWQgMDtcbnZhciB2YWxpZGF0ZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZS92YWxpZGF0ZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIktleXdvcmRDeHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRlXzEuS2V5d29yZEN4dDsgfSB9KTtcbnZhciBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL2NvZGVnZW5cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuXzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0clwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLnN0cjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ2lmeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLnN0cmluZ2lmeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5pbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLm5pbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5OYW1lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29kZUdlblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLkNvZGVHZW47IH0gfSk7XG5jb25zdCB2YWxpZGF0aW9uX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIik7XG5jb25zdCByZWZfZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvcmVmX2Vycm9yXCIpO1xuY29uc3QgcnVsZXNfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvcnVsZXNcIik7XG5jb25zdCBjb21waWxlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlXCIpO1xuY29uc3QgY29kZWdlbl8yID0gcmVxdWlyZShcIi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgcmVzb2x2ZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZS9yZXNvbHZlXCIpO1xuY29uc3QgZGF0YVR5cGVfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCAkZGF0YVJlZlNjaGVtYSA9IHJlcXVpcmUoXCIuL3JlZnMvZGF0YS5qc29uXCIpO1xuY29uc3QgdXJpXzEgPSByZXF1aXJlKFwiLi9ydW50aW1lL3VyaVwiKTtcbmNvbnN0IGRlZmF1bHRSZWdFeHAgPSAoc3RyLCBmbGFncykgPT4gbmV3IFJlZ0V4cChzdHIsIGZsYWdzKTtcbmRlZmF1bHRSZWdFeHAuY29kZSA9IFwibmV3IFJlZ0V4cFwiO1xuY29uc3QgTUVUQV9JR05PUkVfT1BUSU9OUyA9IFtcInJlbW92ZUFkZGl0aW9uYWxcIiwgXCJ1c2VEZWZhdWx0c1wiLCBcImNvZXJjZVR5cGVzXCJdO1xuY29uc3QgRVhUX1NDT1BFX05BTUVTID0gbmV3IFNldChbXG4gICAgXCJ2YWxpZGF0ZVwiLFxuICAgIFwic2VyaWFsaXplXCIsXG4gICAgXCJwYXJzZVwiLFxuICAgIFwid3JhcHBlclwiLFxuICAgIFwicm9vdFwiLFxuICAgIFwic2NoZW1hXCIsXG4gICAgXCJrZXl3b3JkXCIsXG4gICAgXCJwYXR0ZXJuXCIsXG4gICAgXCJmb3JtYXRzXCIsXG4gICAgXCJ2YWxpZGF0ZSRkYXRhXCIsXG4gICAgXCJmdW5jXCIsXG4gICAgXCJvYmpcIixcbiAgICBcIkVycm9yXCIsXG5dKTtcbmNvbnN0IHJlbW92ZWRPcHRpb25zID0ge1xuICAgIGVycm9yRGF0YVBhdGg6IFwiXCIsXG4gICAgZm9ybWF0OiBcImB2YWxpZGF0ZUZvcm1hdHM6IGZhbHNlYCBjYW4gYmUgdXNlZCBpbnN0ZWFkLlwiLFxuICAgIG51bGxhYmxlOiAnXCJudWxsYWJsZVwiIGtleXdvcmQgaXMgc3VwcG9ydGVkIGJ5IGRlZmF1bHQuJyxcbiAgICBqc29uUG9pbnRlcnM6IFwiRGVwcmVjYXRlZCBqc1Byb3BlcnR5U3ludGF4IGNhbiBiZSB1c2VkIGluc3RlYWQuXCIsXG4gICAgZXh0ZW5kUmVmczogXCJEZXByZWNhdGVkIGlnbm9yZUtleXdvcmRzV2l0aFJlZiBjYW4gYmUgdXNlZCBpbnN0ZWFkLlwiLFxuICAgIG1pc3NpbmdSZWZzOiBcIlBhc3MgZW1wdHkgc2NoZW1hIHdpdGggJGlkIHRoYXQgc2hvdWxkIGJlIGlnbm9yZWQgdG8gYWp2LmFkZFNjaGVtYS5cIixcbiAgICBwcm9jZXNzQ29kZTogXCJVc2Ugb3B0aW9uIGBjb2RlOiB7cHJvY2VzczogKGNvZGUsIHNjaGVtYUVudjogb2JqZWN0KSA9PiBzdHJpbmd9YFwiLFxuICAgIHNvdXJjZUNvZGU6IFwiVXNlIG9wdGlvbiBgY29kZToge3NvdXJjZTogdHJ1ZX1gXCIsXG4gICAgc3RyaWN0RGVmYXVsdHM6IFwiSXQgaXMgZGVmYXVsdCBub3csIHNlZSBvcHRpb24gYHN0cmljdGAuXCIsXG4gICAgc3RyaWN0S2V5d29yZHM6IFwiSXQgaXMgZGVmYXVsdCBub3csIHNlZSBvcHRpb24gYHN0cmljdGAuXCIsXG4gICAgdW5pcXVlSXRlbXM6ICdcInVuaXF1ZUl0ZW1zXCIga2V5d29yZCBpcyBhbHdheXMgdmFsaWRhdGVkLicsXG4gICAgdW5rbm93bkZvcm1hdHM6IFwiRGlzYWJsZSBzdHJpY3QgbW9kZSBvciBwYXNzIGB0cnVlYCB0byBgYWp2LmFkZEZvcm1hdGAgKG9yIGBmb3JtYXRzYCBvcHRpb24pLlwiLFxuICAgIGNhY2hlOiBcIk1hcCBpcyB1c2VkIGFzIGNhY2hlLCBzY2hlbWEgb2JqZWN0IGFzIGtleS5cIixcbiAgICBzZXJpYWxpemU6IFwiTWFwIGlzIHVzZWQgYXMgY2FjaGUsIHNjaGVtYSBvYmplY3QgYXMga2V5LlwiLFxuICAgIGFqdkVycm9yczogXCJJdCBpcyBkZWZhdWx0IG5vdy5cIixcbn07XG5jb25zdCBkZXByZWNhdGVkT3B0aW9ucyA9IHtcbiAgICBpZ25vcmVLZXl3b3Jkc1dpdGhSZWY6IFwiXCIsXG4gICAganNQcm9wZXJ0eVN5bnRheDogXCJcIixcbiAgICB1bmljb2RlOiAnXCJtaW5MZW5ndGhcIi9cIm1heExlbmd0aFwiIGFjY291bnQgZm9yIHVuaWNvZGUgY2hhcmFjdGVycyBieSBkZWZhdWx0LicsXG59O1xuY29uc3QgTUFYX0VYUFJFU1NJT04gPSAyMDA7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gcmVxdWlyZWRPcHRpb25zKG8pIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sLCBfbSwgX28sIF9wLCBfcSwgX3IsIF9zLCBfdCwgX3UsIF92LCBfdywgX3gsIF95LCBfeiwgXzA7XG4gICAgY29uc3QgcyA9IG8uc3RyaWN0O1xuICAgIGNvbnN0IF9vcHR6ID0gKF9hID0gby5jb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW1pemU7XG4gICAgY29uc3Qgb3B0aW1pemUgPSBfb3B0eiA9PT0gdHJ1ZSB8fCBfb3B0eiA9PT0gdW5kZWZpbmVkID8gMSA6IF9vcHR6IHx8IDA7XG4gICAgY29uc3QgcmVnRXhwID0gKF9jID0gKF9iID0gby5jb2RlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVnRXhwKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBkZWZhdWx0UmVnRXhwO1xuICAgIGNvbnN0IHVyaVJlc29sdmVyID0gKF9kID0gby51cmlSZXNvbHZlcikgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdXJpXzEuZGVmYXVsdDtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdHJpY3RTY2hlbWE6IChfZiA9IChfZSA9IG8uc3RyaWN0U2NoZW1hKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBzKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiB0cnVlLFxuICAgICAgICBzdHJpY3ROdW1iZXJzOiAoX2ggPSAoX2cgPSBvLnN0cmljdE51bWJlcnMpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IHMpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IHRydWUsXG4gICAgICAgIHN0cmljdFR5cGVzOiAoX2sgPSAoX2ogPSBvLnN0cmljdFR5cGVzKSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiBzKSAhPT0gbnVsbCAmJiBfayAhPT0gdm9pZCAwID8gX2sgOiBcImxvZ1wiLFxuICAgICAgICBzdHJpY3RUdXBsZXM6IChfbSA9IChfbCA9IG8uc3RyaWN0VHVwbGVzKSAhPT0gbnVsbCAmJiBfbCAhPT0gdm9pZCAwID8gX2wgOiBzKSAhPT0gbnVsbCAmJiBfbSAhPT0gdm9pZCAwID8gX20gOiBcImxvZ1wiLFxuICAgICAgICBzdHJpY3RSZXF1aXJlZDogKF9wID0gKF9vID0gby5zdHJpY3RSZXF1aXJlZCkgIT09IG51bGwgJiYgX28gIT09IHZvaWQgMCA/IF9vIDogcykgIT09IG51bGwgJiYgX3AgIT09IHZvaWQgMCA/IF9wIDogZmFsc2UsXG4gICAgICAgIGNvZGU6IG8uY29kZSA/IHsgLi4uby5jb2RlLCBvcHRpbWl6ZSwgcmVnRXhwIH0gOiB7IG9wdGltaXplLCByZWdFeHAgfSxcbiAgICAgICAgbG9vcFJlcXVpcmVkOiAoX3EgPSBvLmxvb3BSZXF1aXJlZCkgIT09IG51bGwgJiYgX3EgIT09IHZvaWQgMCA/IF9xIDogTUFYX0VYUFJFU1NJT04sXG4gICAgICAgIGxvb3BFbnVtOiAoX3IgPSBvLmxvb3BFbnVtKSAhPT0gbnVsbCAmJiBfciAhPT0gdm9pZCAwID8gX3IgOiBNQVhfRVhQUkVTU0lPTixcbiAgICAgICAgbWV0YTogKF9zID0gby5tZXRhKSAhPT0gbnVsbCAmJiBfcyAhPT0gdm9pZCAwID8gX3MgOiB0cnVlLFxuICAgICAgICBtZXNzYWdlczogKF90ID0gby5tZXNzYWdlcykgIT09IG51bGwgJiYgX3QgIT09IHZvaWQgMCA/IF90IDogdHJ1ZSxcbiAgICAgICAgaW5saW5lUmVmczogKF91ID0gby5pbmxpbmVSZWZzKSAhPT0gbnVsbCAmJiBfdSAhPT0gdm9pZCAwID8gX3UgOiB0cnVlLFxuICAgICAgICBzY2hlbWFJZDogKF92ID0gby5zY2hlbWFJZCkgIT09IG51bGwgJiYgX3YgIT09IHZvaWQgMCA/IF92IDogXCIkaWRcIixcbiAgICAgICAgYWRkVXNlZFNjaGVtYTogKF93ID0gby5hZGRVc2VkU2NoZW1hKSAhPT0gbnVsbCAmJiBfdyAhPT0gdm9pZCAwID8gX3cgOiB0cnVlLFxuICAgICAgICB2YWxpZGF0ZVNjaGVtYTogKF94ID0gby52YWxpZGF0ZVNjaGVtYSkgIT09IG51bGwgJiYgX3ggIT09IHZvaWQgMCA/IF94IDogdHJ1ZSxcbiAgICAgICAgdmFsaWRhdGVGb3JtYXRzOiAoX3kgPSBvLnZhbGlkYXRlRm9ybWF0cykgIT09IG51bGwgJiYgX3kgIT09IHZvaWQgMCA/IF95IDogdHJ1ZSxcbiAgICAgICAgdW5pY29kZVJlZ0V4cDogKF96ID0gby51bmljb2RlUmVnRXhwKSAhPT0gbnVsbCAmJiBfeiAhPT0gdm9pZCAwID8gX3ogOiB0cnVlLFxuICAgICAgICBpbnQzMnJhbmdlOiAoXzAgPSBvLmludDMycmFuZ2UpICE9PSBudWxsICYmIF8wICE9PSB2b2lkIDAgPyBfMCA6IHRydWUsXG4gICAgICAgIHVyaVJlc29sdmVyOiB1cmlSZXNvbHZlcixcbiAgICB9O1xufVxuY2xhc3MgQWp2IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICAgICAgdGhpcy5zY2hlbWFzID0ge307XG4gICAgICAgIHRoaXMucmVmcyA9IHt9O1xuICAgICAgICB0aGlzLmZvcm1hdHMgPSB7fTtcbiAgICAgICAgdGhpcy5fY29tcGlsYXRpb25zID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLl9sb2FkaW5nID0ge307XG4gICAgICAgIHRoaXMuX2NhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICBvcHRzID0gdGhpcy5vcHRzID0geyAuLi5vcHRzLCAuLi5yZXF1aXJlZE9wdGlvbnMob3B0cykgfTtcbiAgICAgICAgY29uc3QgeyBlczUsIGxpbmVzIH0gPSB0aGlzLm9wdHMuY29kZTtcbiAgICAgICAgdGhpcy5zY29wZSA9IG5ldyBjb2RlZ2VuXzIuVmFsdWVTY29wZSh7IHNjb3BlOiB7fSwgcHJlZml4ZXM6IEVYVF9TQ09QRV9OQU1FUywgZXM1LCBsaW5lcyB9KTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBnZXRMb2dnZXIob3B0cy5sb2dnZXIpO1xuICAgICAgICBjb25zdCBmb3JtYXRPcHQgPSBvcHRzLnZhbGlkYXRlRm9ybWF0cztcbiAgICAgICAgb3B0cy52YWxpZGF0ZUZvcm1hdHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5SVUxFUyA9ICgwLCBydWxlc18xLmdldFJ1bGVzKSgpO1xuICAgICAgICBjaGVja09wdGlvbnMuY2FsbCh0aGlzLCByZW1vdmVkT3B0aW9ucywgb3B0cywgXCJOT1QgU1VQUE9SVEVEXCIpO1xuICAgICAgICBjaGVja09wdGlvbnMuY2FsbCh0aGlzLCBkZXByZWNhdGVkT3B0aW9ucywgb3B0cywgXCJERVBSRUNBVEVEXCIsIFwid2FyblwiKTtcbiAgICAgICAgdGhpcy5fbWV0YU9wdHMgPSBnZXRNZXRhU2NoZW1hT3B0aW9ucy5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAob3B0cy5mb3JtYXRzKVxuICAgICAgICAgICAgYWRkSW5pdGlhbEZvcm1hdHMuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fYWRkVm9jYWJ1bGFyaWVzKCk7XG4gICAgICAgIHRoaXMuX2FkZERlZmF1bHRNZXRhU2NoZW1hKCk7XG4gICAgICAgIGlmIChvcHRzLmtleXdvcmRzKVxuICAgICAgICAgICAgYWRkSW5pdGlhbEtleXdvcmRzLmNhbGwodGhpcywgb3B0cy5rZXl3b3Jkcyk7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5tZXRhID09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICB0aGlzLmFkZE1ldGFTY2hlbWEob3B0cy5tZXRhKTtcbiAgICAgICAgYWRkSW5pdGlhbFNjaGVtYXMuY2FsbCh0aGlzKTtcbiAgICAgICAgb3B0cy52YWxpZGF0ZUZvcm1hdHMgPSBmb3JtYXRPcHQ7XG4gICAgfVxuICAgIF9hZGRWb2NhYnVsYXJpZXMoKSB7XG4gICAgICAgIHRoaXMuYWRkS2V5d29yZChcIiRhc3luY1wiKTtcbiAgICB9XG4gICAgX2FkZERlZmF1bHRNZXRhU2NoZW1hKCkge1xuICAgICAgICBjb25zdCB7ICRkYXRhLCBtZXRhLCBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICBsZXQgX2RhdGFSZWZTY2hlbWEgPSAkZGF0YVJlZlNjaGVtYTtcbiAgICAgICAgaWYgKHNjaGVtYUlkID09PSBcImlkXCIpIHtcbiAgICAgICAgICAgIF9kYXRhUmVmU2NoZW1hID0geyAuLi4kZGF0YVJlZlNjaGVtYSB9O1xuICAgICAgICAgICAgX2RhdGFSZWZTY2hlbWEuaWQgPSBfZGF0YVJlZlNjaGVtYS4kaWQ7XG4gICAgICAgICAgICBkZWxldGUgX2RhdGFSZWZTY2hlbWEuJGlkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhICYmICRkYXRhKVxuICAgICAgICAgICAgdGhpcy5hZGRNZXRhU2NoZW1hKF9kYXRhUmVmU2NoZW1hLCBfZGF0YVJlZlNjaGVtYVtzY2hlbWFJZF0sIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdE1ldGEoKSB7XG4gICAgICAgIGNvbnN0IHsgbWV0YSwgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgcmV0dXJuICh0aGlzLm9wdHMuZGVmYXVsdE1ldGEgPSB0eXBlb2YgbWV0YSA9PSBcIm9iamVjdFwiID8gbWV0YVtzY2hlbWFJZF0gfHwgbWV0YSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHZhbGlkYXRlKHNjaGVtYUtleVJlZiwgLy8ga2V5LCByZWYgb3Igc2NoZW1hIG9iamVjdFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkdW5kYW50LXR5cGUtY29uc3RpdHVlbnRzXG4gICAgZGF0YSAvLyB0byBiZSB2YWxpZGF0ZWRcbiAgICApIHtcbiAgICAgICAgbGV0IHY7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hS2V5UmVmID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHYgPSB0aGlzLmdldFNjaGVtYShzY2hlbWFLZXlSZWYpO1xuICAgICAgICAgICAgaWYgKCF2KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gc2NoZW1hIHdpdGgga2V5IG9yIHJlZiBcIiR7c2NoZW1hS2V5UmVmfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2ID0gdGhpcy5jb21waWxlKHNjaGVtYUtleVJlZik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWQgPSB2KGRhdGEpO1xuICAgICAgICBpZiAoIShcIiRhc3luY1wiIGluIHYpKVxuICAgICAgICAgICAgdGhpcy5lcnJvcnMgPSB2LmVycm9ycztcbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cbiAgICBjb21waWxlKHNjaGVtYSwgX21ldGEpIHtcbiAgICAgICAgY29uc3Qgc2NoID0gdGhpcy5fYWRkU2NoZW1hKHNjaGVtYSwgX21ldGEpO1xuICAgICAgICByZXR1cm4gKHNjaC52YWxpZGF0ZSB8fCB0aGlzLl9jb21waWxlU2NoZW1hRW52KHNjaCkpO1xuICAgIH1cbiAgICBjb21waWxlQXN5bmMoc2NoZW1hLCBtZXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRzLmxvYWRTY2hlbWEgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zLmxvYWRTY2hlbWEgc2hvdWxkIGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBsb2FkU2NoZW1hIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIHJldHVybiBydW5Db21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2hlbWEsIG1ldGEpO1xuICAgICAgICBhc3luYyBmdW5jdGlvbiBydW5Db21waWxlQXN5bmMoX3NjaGVtYSwgX21ldGEpIHtcbiAgICAgICAgICAgIGF3YWl0IGxvYWRNZXRhU2NoZW1hLmNhbGwodGhpcywgX3NjaGVtYS4kc2NoZW1hKTtcbiAgICAgICAgICAgIGNvbnN0IHNjaCA9IHRoaXMuX2FkZFNjaGVtYShfc2NoZW1hLCBfbWV0YSk7XG4gICAgICAgICAgICByZXR1cm4gc2NoLnZhbGlkYXRlIHx8IF9jb21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2gpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRNZXRhU2NoZW1hKCRyZWYpIHtcbiAgICAgICAgICAgIGlmICgkcmVmICYmICF0aGlzLmdldFNjaGVtYSgkcmVmKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJ1bkNvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHsgJHJlZiB9LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmdW5jdGlvbiBfY29tcGlsZUFzeW5jKHNjaCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcGlsZVNjaGVtYUVudihzY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgcmVmX2Vycm9yXzEuZGVmYXVsdCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgY2hlY2tMb2FkZWQuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBsb2FkTWlzc2luZ1NjaGVtYS5jYWxsKHRoaXMsIGUubWlzc2luZ1NjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrTG9hZGVkKHsgbWlzc2luZ1NjaGVtYTogcmVmLCBtaXNzaW5nUmVmIH0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlZnNbcmVmXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW55U2NoZW1hICR7cmVmfSBpcyBsb2FkZWQgYnV0ICR7bWlzc2luZ1JlZn0gY2Fubm90IGJlIHJlc29sdmVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gbG9hZE1pc3NpbmdTY2hlbWEocmVmKSB7XG4gICAgICAgICAgICBjb25zdCBfc2NoZW1hID0gYXdhaXQgX2xvYWRTY2hlbWEuY2FsbCh0aGlzLCByZWYpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlZnNbcmVmXSlcbiAgICAgICAgICAgICAgICBhd2FpdCBsb2FkTWV0YVNjaGVtYS5jYWxsKHRoaXMsIF9zY2hlbWEuJHNjaGVtYSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVmc1tyZWZdKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2NoZW1hKF9zY2hlbWEsIHJlZiwgbWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gX2xvYWRTY2hlbWEocmVmKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gdGhpcy5fbG9hZGluZ1tyZWZdO1xuICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCAodGhpcy5fbG9hZGluZ1tyZWZdID0gbG9hZFNjaGVtYShyZWYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9sb2FkaW5nW3JlZl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQWRkcyBzY2hlbWEgdG8gdGhlIGluc3RhbmNlXG4gICAgYWRkU2NoZW1hKHNjaGVtYSwgLy8gSWYgYXJyYXkgaXMgcGFzc2VkLCBga2V5YCB3aWxsIGJlIGlnbm9yZWRcbiAgICBrZXksIC8vIE9wdGlvbmFsIHNjaGVtYSBrZXkuIENhbiBiZSBwYXNzZWQgdG8gYHZhbGlkYXRlYCBtZXRob2QgaW5zdGVhZCBvZiBzY2hlbWEgb2JqZWN0IG9yIGlkL3JlZi4gT25lIHNjaGVtYSBwZXIgaW5zdGFuY2UgY2FuIGhhdmUgZW1wdHkgYGlkYCBhbmQgYGtleWAuXG4gICAgX21ldGEsIC8vIHRydWUgaWYgc2NoZW1hIGlzIGEgbWV0YS1zY2hlbWEuIFVzZWQgaW50ZXJuYWxseSwgYWRkTWV0YVNjaGVtYSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgIF92YWxpZGF0ZVNjaGVtYSA9IHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSAvLyBmYWxzZSB0byBza2lwIHNjaGVtYSB2YWxpZGF0aW9uLiBVc2VkIGludGVybmFsbHksIG9wdGlvbiB2YWxpZGF0ZVNjaGVtYSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgICkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNjaCBvZiBzY2hlbWEpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWEoc2NoLCB1bmRlZmluZWQsIF9tZXRhLCBfdmFsaWRhdGVTY2hlbWEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICAgICAgaWQgPSBzY2hlbWFbc2NoZW1hSWRdO1xuICAgICAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGlkICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNjaGVtYSAke3NjaGVtYUlkfSBtdXN0IGJlIHN0cmluZ2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGtleSA9ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKGtleSB8fCBpZCk7XG4gICAgICAgIHRoaXMuX2NoZWNrVW5pcXVlKGtleSk7XG4gICAgICAgIHRoaXMuc2NoZW1hc1trZXldID0gdGhpcy5fYWRkU2NoZW1hKHNjaGVtYSwgX21ldGEsIGtleSwgX3ZhbGlkYXRlU2NoZW1hLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIEFkZCBzY2hlbWEgdGhhdCB3aWxsIGJlIHVzZWQgdG8gdmFsaWRhdGUgb3RoZXIgc2NoZW1hc1xuICAgIC8vIG9wdGlvbnMgaW4gTUVUQV9JR05PUkVfT1BUSU9OUyBhcmUgYWx3YXkgc2V0IHRvIGZhbHNlXG4gICAgYWRkTWV0YVNjaGVtYShzY2hlbWEsIGtleSwgLy8gc2NoZW1hIGtleVxuICAgIF92YWxpZGF0ZVNjaGVtYSA9IHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSAvLyBmYWxzZSB0byBza2lwIHNjaGVtYSB2YWxpZGF0aW9uLCBjYW4gYmUgdXNlZCB0byBvdmVycmlkZSB2YWxpZGF0ZVNjaGVtYSBvcHRpb24gZm9yIG1ldGEtc2NoZW1hXG4gICAgKSB7XG4gICAgICAgIHRoaXMuYWRkU2NoZW1hKHNjaGVtYSwga2V5LCB0cnVlLCBfdmFsaWRhdGVTY2hlbWEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gIFZhbGlkYXRlIHNjaGVtYSBhZ2FpbnN0IGl0cyBtZXRhLXNjaGVtYVxuICAgIHZhbGlkYXRlU2NoZW1hKHNjaGVtYSwgdGhyb3dPckxvZ0Vycm9yKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCAkc2NoZW1hO1xuICAgICAgICAkc2NoZW1hID0gc2NoZW1hLiRzY2hlbWE7XG4gICAgICAgIGlmICgkc2NoZW1hICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mICRzY2hlbWEgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJHNjaGVtYSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgICRzY2hlbWEgPSAkc2NoZW1hIHx8IHRoaXMub3B0cy5kZWZhdWx0TWV0YSB8fCB0aGlzLmRlZmF1bHRNZXRhKCk7XG4gICAgICAgIGlmICghJHNjaGVtYSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIm1ldGEtc2NoZW1hIG5vdCBhdmFpbGFibGVcIik7XG4gICAgICAgICAgICB0aGlzLmVycm9ycyA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWxpZCA9IHRoaXMudmFsaWRhdGUoJHNjaGVtYSwgc2NoZW1hKTtcbiAgICAgICAgaWYgKCF2YWxpZCAmJiB0aHJvd09yTG9nRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBcInNjaGVtYSBpcyBpbnZhbGlkOiBcIiArIHRoaXMuZXJyb3JzVGV4dCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSA9PT0gXCJsb2dcIilcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cbiAgICAvLyBHZXQgY29tcGlsZWQgc2NoZW1hIGJ5IGBrZXlgIG9yIGByZWZgLlxuICAgIC8vIChga2V5YCB0aGF0IHdhcyBwYXNzZWQgdG8gYGFkZFNjaGVtYWAgb3IgZnVsbCBzY2hlbWEgcmVmZXJlbmNlIC0gYHNjaGVtYS4kaWRgIG9yIHJlc29sdmVkIGlkKVxuICAgIGdldFNjaGVtYShrZXlSZWYpIHtcbiAgICAgICAgbGV0IHNjaDtcbiAgICAgICAgd2hpbGUgKHR5cGVvZiAoc2NoID0gZ2V0U2NoRW52LmNhbGwodGhpcywga2V5UmVmKSkgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGtleVJlZiA9IHNjaDtcbiAgICAgICAgaWYgKHNjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgICAgICBjb25zdCByb290ID0gbmV3IGNvbXBpbGVfMS5TY2hlbWFFbnYoeyBzY2hlbWE6IHt9LCBzY2hlbWFJZCB9KTtcbiAgICAgICAgICAgIHNjaCA9IGNvbXBpbGVfMS5yZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwga2V5UmVmKTtcbiAgICAgICAgICAgIGlmICghc2NoKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMucmVmc1trZXlSZWZdID0gc2NoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoc2NoLnZhbGlkYXRlIHx8IHRoaXMuX2NvbXBpbGVTY2hlbWFFbnYoc2NoKSk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBjYWNoZWQgc2NoZW1hKHMpLlxuICAgIC8vIElmIG5vIHBhcmFtZXRlciBpcyBwYXNzZWQgYWxsIHNjaGVtYXMgYnV0IG1ldGEtc2NoZW1hcyBhcmUgcmVtb3ZlZC5cbiAgICAvLyBJZiBSZWdFeHAgaXMgcGFzc2VkIGFsbCBzY2hlbWFzIHdpdGgga2V5L2lkIG1hdGNoaW5nIHBhdHRlcm4gYnV0IG1ldGEtc2NoZW1hcyBhcmUgcmVtb3ZlZC5cbiAgICAvLyBFdmVuIGlmIHNjaGVtYSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIHNjaGVtYXMgaXQgc3RpbGwgY2FuIGJlIHJlbW92ZWQgYXMgb3RoZXIgc2NoZW1hcyBoYXZlIGxvY2FsIHJlZmVyZW5jZXMuXG4gICAgcmVtb3ZlU2NoZW1hKHNjaGVtYUtleVJlZikge1xuICAgICAgICBpZiAoc2NoZW1hS2V5UmVmIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMuc2NoZW1hcywgc2NoZW1hS2V5UmVmKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5yZWZzLCBzY2hlbWFLZXlSZWYpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0eXBlb2Ygc2NoZW1hS2V5UmVmKSB7XG4gICAgICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLnNjaGVtYXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5yZWZzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoID0gZ2V0U2NoRW52LmNhbGwodGhpcywgc2NoZW1hS2V5UmVmKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjaCA9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5kZWxldGUoc2NoLnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2NoZW1hc1tzY2hlbWFLZXlSZWZdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlZnNbc2NoZW1hS2V5UmVmXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gc2NoZW1hS2V5UmVmO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmRlbGV0ZShjYWNoZUtleSk7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gc2NoZW1hS2V5UmVmW3RoaXMub3B0cy5zY2hlbWFJZF07XG4gICAgICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkID0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkoaWQpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zY2hlbWFzW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucmVmc1tpZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYucmVtb3ZlU2NoZW1hOiBpbnZhbGlkIHBhcmFtZXRlclwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgXCJ2b2NhYnVsYXJ5XCIgLSBhIGNvbGxlY3Rpb24gb2Yga2V5d29yZHNcbiAgICBhZGRWb2NhYnVsYXJ5KGRlZmluaXRpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3QgZGVmIG9mIGRlZmluaXRpb25zKVxuICAgICAgICAgICAgdGhpcy5hZGRLZXl3b3JkKGRlZik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGRLZXl3b3JkKGt3ZE9yRGVmLCBkZWYgLy8gZGVwcmVjYXRlZFxuICAgICkge1xuICAgICAgICBsZXQga2V5d29yZDtcbiAgICAgICAgaWYgKHR5cGVvZiBrd2RPckRlZiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBrZXl3b3JkID0ga3dkT3JEZWY7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZiA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcInRoZXNlIHBhcmFtZXRlcnMgYXJlIGRlcHJlY2F0ZWQsIHNlZSBkb2NzIGZvciBhZGRLZXl3b3JkXCIpO1xuICAgICAgICAgICAgICAgIGRlZi5rZXl3b3JkID0ga2V5d29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Yga3dkT3JEZWYgPT0gXCJvYmplY3RcIiAmJiBkZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVmID0ga3dkT3JEZWY7XG4gICAgICAgICAgICBrZXl3b3JkID0gZGVmLmtleXdvcmQ7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXl3b3JkKSAmJiAha2V5d29yZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhZGRLZXl3b3Jkczoga2V5d29yZCBtdXN0IGJlIHN0cmluZyBvciBub24tZW1wdHkgYXJyYXlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFkZEtleXdvcmRzIHBhcmFtZXRlcnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tLZXl3b3JkLmNhbGwodGhpcywga2V5d29yZCwgZGVmKTtcbiAgICAgICAgaWYgKCFkZWYpIHtcbiAgICAgICAgICAgICgwLCB1dGlsXzEuZWFjaEl0ZW0pKGtleXdvcmQsIChrd2QpID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrd2QpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGtleXdvcmRNZXRhc2NoZW1hLmNhbGwodGhpcywgZGVmKTtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgIC4uLmRlZixcbiAgICAgICAgICAgIHR5cGU6ICgwLCBkYXRhVHlwZV8xLmdldEpTT05UeXBlcykoZGVmLnR5cGUpLFxuICAgICAgICAgICAgc2NoZW1hVHlwZTogKDAsIGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKShkZWYuc2NoZW1hVHlwZSksXG4gICAgICAgIH07XG4gICAgICAgICgwLCB1dGlsXzEuZWFjaEl0ZW0pKGtleXdvcmQsIGRlZmluaXRpb24udHlwZS5sZW5ndGggPT09IDBcbiAgICAgICAgICAgID8gKGspID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrLCBkZWZpbml0aW9uKVxuICAgICAgICAgICAgOiAoaykgPT4gZGVmaW5pdGlvbi50eXBlLmZvckVhY2goKHQpID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrLCBkZWZpbml0aW9uLCB0KSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0S2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIGNvbnN0IHJ1bGUgPSB0aGlzLlJVTEVTLmFsbFtrZXl3b3JkXTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBydWxlID09IFwib2JqZWN0XCIgPyBydWxlLmRlZmluaXRpb24gOiAhIXJ1bGU7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBrZXl3b3JkXG4gICAgcmVtb3ZlS2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIC8vIFRPRE8gcmV0dXJuIHR5cGUgc2hvdWxkIGJlIEFqdlxuICAgICAgICBjb25zdCB7IFJVTEVTIH0gPSB0aGlzO1xuICAgICAgICBkZWxldGUgUlVMRVMua2V5d29yZHNba2V5d29yZF07XG4gICAgICAgIGRlbGV0ZSBSVUxFUy5hbGxba2V5d29yZF07XG4gICAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgUlVMRVMucnVsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBncm91cC5ydWxlcy5maW5kSW5kZXgoKHJ1bGUpID0+IHJ1bGUua2V5d29yZCA9PT0ga2V5d29yZCk7XG4gICAgICAgICAgICBpZiAoaSA+PSAwKVxuICAgICAgICAgICAgICAgIGdyb3VwLnJ1bGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gQWRkIGZvcm1hdFxuICAgIGFkZEZvcm1hdChuYW1lLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGZvcm1hdCA9IG5ldyBSZWdFeHAoZm9ybWF0KTtcbiAgICAgICAgdGhpcy5mb3JtYXRzW25hbWVdID0gZm9ybWF0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZXJyb3JzVGV4dChlcnJvcnMgPSB0aGlzLmVycm9ycywgLy8gb3B0aW9uYWwgYXJyYXkgb2YgdmFsaWRhdGlvbiBlcnJvcnNcbiAgICB7IHNlcGFyYXRvciA9IFwiLCBcIiwgZGF0YVZhciA9IFwiZGF0YVwiIH0gPSB7fSAvLyBvcHRpb25hbCBvcHRpb25zIHdpdGggcHJvcGVydGllcyBgc2VwYXJhdG9yYCBhbmQgYGRhdGFWYXJgXG4gICAgKSB7XG4gICAgICAgIGlmICghZXJyb3JzIHx8IGVycm9ycy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gXCJObyBlcnJvcnNcIjtcbiAgICAgICAgcmV0dXJuIGVycm9yc1xuICAgICAgICAgICAgLm1hcCgoZSkgPT4gYCR7ZGF0YVZhcn0ke2UuaW5zdGFuY2VQYXRofSAke2UubWVzc2FnZX1gKVxuICAgICAgICAgICAgLnJlZHVjZSgodGV4dCwgbXNnKSA9PiB0ZXh0ICsgc2VwYXJhdG9yICsgbXNnKTtcbiAgICB9XG4gICAgJGRhdGFNZXRhU2NoZW1hKG1ldGFTY2hlbWEsIGtleXdvcmRzSnNvblBvaW50ZXJzKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVzID0gdGhpcy5SVUxFUy5hbGw7XG4gICAgICAgIG1ldGFTY2hlbWEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1ldGFTY2hlbWEpKTtcbiAgICAgICAgZm9yIChjb25zdCBqc29uUG9pbnRlciBvZiBrZXl3b3Jkc0pzb25Qb2ludGVycykge1xuICAgICAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBqc29uUG9pbnRlci5zcGxpdChcIi9cIikuc2xpY2UoMSk7IC8vIGZpcnN0IHNlZ21lbnQgaXMgYW4gZW1wdHkgc3RyaW5nXG4gICAgICAgICAgICBsZXQga2V5d29yZHMgPSBtZXRhU2NoZW1hO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzZWcgb2Ygc2VnbWVudHMpXG4gICAgICAgICAgICAgICAga2V5d29yZHMgPSBrZXl3b3Jkc1tzZWddO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcnVsZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBydWxlID0gcnVsZXNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJ1bGUgIT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgeyAkZGF0YSB9ID0gcnVsZS5kZWZpbml0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IGtleXdvcmRzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKCRkYXRhICYmIHNjaGVtYSlcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZHNba2V5XSA9IHNjaGVtYU9yRGF0YShzY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRhU2NoZW1hO1xuICAgIH1cbiAgICBfcmVtb3ZlQWxsU2NoZW1hcyhzY2hlbWFzLCByZWdleCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleVJlZiBpbiBzY2hlbWFzKSB7XG4gICAgICAgICAgICBjb25zdCBzY2ggPSBzY2hlbWFzW2tleVJlZl07XG4gICAgICAgICAgICBpZiAoIXJlZ2V4IHx8IHJlZ2V4LnRlc3Qoa2V5UmVmKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYXNba2V5UmVmXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2NoICYmICFzY2gubWV0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5kZWxldGUoc2NoLnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFzW2tleVJlZl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9hZGRTY2hlbWEoc2NoZW1hLCBtZXRhLCBiYXNlSWQsIHZhbGlkYXRlU2NoZW1hID0gdGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hLCBhZGRTY2hlbWEgPSB0aGlzLm9wdHMuYWRkVXNlZFNjaGVtYSkge1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWQgPSBzY2hlbWFbc2NoZW1hSWRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5qdGQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2NoZW1hIG11c3QgYmUgb2JqZWN0XCIpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNjaGVtYSAhPSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY2hlbWEgbXVzdCBiZSBvYmplY3Qgb3IgYm9vbGVhblwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2NoID0gdGhpcy5fY2FjaGUuZ2V0KHNjaGVtYSk7XG4gICAgICAgIGlmIChzY2ggIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBzY2g7XG4gICAgICAgIGJhc2VJZCA9ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKGlkIHx8IGJhc2VJZCk7XG4gICAgICAgIGNvbnN0IGxvY2FsUmVmcyA9IHJlc29sdmVfMS5nZXRTY2hlbWFSZWZzLmNhbGwodGhpcywgc2NoZW1hLCBiYXNlSWQpO1xuICAgICAgICBzY2ggPSBuZXcgY29tcGlsZV8xLlNjaGVtYUVudih7IHNjaGVtYSwgc2NoZW1hSWQsIG1ldGEsIGJhc2VJZCwgbG9jYWxSZWZzIH0pO1xuICAgICAgICB0aGlzLl9jYWNoZS5zZXQoc2NoLnNjaGVtYSwgc2NoKTtcbiAgICAgICAgaWYgKGFkZFNjaGVtYSAmJiAhYmFzZUlkLnN0YXJ0c1dpdGgoXCIjXCIpKSB7XG4gICAgICAgICAgICAvLyBUT0RPIGF0bSBpdCBpcyBhbGxvd2VkIHRvIG92ZXJ3cml0ZSBzY2hlbWFzIHdpdGhvdXQgaWQgKGluc3RlYWQgb2Ygbm90IGFkZGluZyB0aGVtKVxuICAgICAgICAgICAgaWYgKGJhc2VJZClcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1VuaXF1ZShiYXNlSWQpO1xuICAgICAgICAgICAgdGhpcy5yZWZzW2Jhc2VJZF0gPSBzY2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbGlkYXRlU2NoZW1hKVxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVNjaGVtYShzY2hlbWEsIHRydWUpO1xuICAgICAgICByZXR1cm4gc2NoO1xuICAgIH1cbiAgICBfY2hlY2tVbmlxdWUoaWQpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NoZW1hc1tpZF0gfHwgdGhpcy5yZWZzW2lkXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzY2hlbWEgd2l0aCBrZXkgb3IgaWQgXCIke2lkfVwiIGFscmVhZHkgZXhpc3RzYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NvbXBpbGVTY2hlbWFFbnYoc2NoKSB7XG4gICAgICAgIGlmIChzY2gubWV0YSlcbiAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVNZXRhU2NoZW1hKHNjaCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNvbXBpbGVfMS5jb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghc2NoLnZhbGlkYXRlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICByZXR1cm4gc2NoLnZhbGlkYXRlO1xuICAgIH1cbiAgICBfY29tcGlsZU1ldGFTY2hlbWEoc2NoKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRPcHRzID0gdGhpcy5vcHRzO1xuICAgICAgICB0aGlzLm9wdHMgPSB0aGlzLl9tZXRhT3B0cztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbXBpbGVfMS5jb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMub3B0cyA9IGN1cnJlbnRPcHRzO1xuICAgICAgICB9XG4gICAgfVxufVxuQWp2LlZhbGlkYXRpb25FcnJvciA9IHZhbGlkYXRpb25fZXJyb3JfMS5kZWZhdWx0O1xuQWp2Lk1pc3NpbmdSZWZFcnJvciA9IHJlZl9lcnJvcl8xLmRlZmF1bHQ7XG5leHBvcnRzLmRlZmF1bHQgPSBBanY7XG5mdW5jdGlvbiBjaGVja09wdGlvbnMoY2hlY2tPcHRzLCBvcHRpb25zLCBtc2csIGxvZyA9IFwiZXJyb3JcIikge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNoZWNrT3B0cykge1xuICAgICAgICBjb25zdCBvcHQgPSBrZXk7XG4gICAgICAgIGlmIChvcHQgaW4gb3B0aW9ucylcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyW2xvZ10oYCR7bXNnfTogb3B0aW9uICR7a2V5fS4gJHtjaGVja09wdHNbb3B0XX1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRTY2hFbnYoa2V5UmVmKSB7XG4gICAga2V5UmVmID0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkoa2V5UmVmKTsgLy8gVE9ETyB0ZXN0cyBmYWlsIHdpdGhvdXQgdGhpcyBsaW5lXG4gICAgcmV0dXJuIHRoaXMuc2NoZW1hc1trZXlSZWZdIHx8IHRoaXMucmVmc1trZXlSZWZdO1xufVxuZnVuY3Rpb24gYWRkSW5pdGlhbFNjaGVtYXMoKSB7XG4gICAgY29uc3Qgb3B0c1NjaGVtYXMgPSB0aGlzLm9wdHMuc2NoZW1hcztcbiAgICBpZiAoIW9wdHNTY2hlbWFzKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0c1NjaGVtYXMpKVxuICAgICAgICB0aGlzLmFkZFNjaGVtYShvcHRzU2NoZW1hcyk7XG4gICAgZWxzZVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRzU2NoZW1hcylcbiAgICAgICAgICAgIHRoaXMuYWRkU2NoZW1hKG9wdHNTY2hlbWFzW2tleV0sIGtleSk7XG59XG5mdW5jdGlvbiBhZGRJbml0aWFsRm9ybWF0cygpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5vcHRzLmZvcm1hdHMpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gdGhpcy5vcHRzLmZvcm1hdHNbbmFtZV07XG4gICAgICAgIGlmIChmb3JtYXQpXG4gICAgICAgICAgICB0aGlzLmFkZEZvcm1hdChuYW1lLCBmb3JtYXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZEluaXRpYWxLZXl3b3JkcyhkZWZzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmcykpIHtcbiAgICAgICAgdGhpcy5hZGRWb2NhYnVsYXJ5KGRlZnMpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyLndhcm4oXCJrZXl3b3JkcyBvcHRpb24gYXMgbWFwIGlzIGRlcHJlY2F0ZWQsIHBhc3MgYXJyYXlcIik7XG4gICAgZm9yIChjb25zdCBrZXl3b3JkIGluIGRlZnMpIHtcbiAgICAgICAgY29uc3QgZGVmID0gZGVmc1trZXl3b3JkXTtcbiAgICAgICAgaWYgKCFkZWYua2V5d29yZClcbiAgICAgICAgICAgIGRlZi5rZXl3b3JkID0ga2V5d29yZDtcbiAgICAgICAgdGhpcy5hZGRLZXl3b3JkKGRlZik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0TWV0YVNjaGVtYU9wdGlvbnMoKSB7XG4gICAgY29uc3QgbWV0YU9wdHMgPSB7IC4uLnRoaXMub3B0cyB9O1xuICAgIGZvciAoY29uc3Qgb3B0IG9mIE1FVEFfSUdOT1JFX09QVElPTlMpXG4gICAgICAgIGRlbGV0ZSBtZXRhT3B0c1tvcHRdO1xuICAgIHJldHVybiBtZXRhT3B0cztcbn1cbmNvbnN0IG5vTG9ncyA9IHsgbG9nKCkgeyB9LCB3YXJuKCkgeyB9LCBlcnJvcigpIHsgfSB9O1xuZnVuY3Rpb24gZ2V0TG9nZ2VyKGxvZ2dlcikge1xuICAgIGlmIChsb2dnZXIgPT09IGZhbHNlKVxuICAgICAgICByZXR1cm4gbm9Mb2dzO1xuICAgIGlmIChsb2dnZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIGNvbnNvbGU7XG4gICAgaWYgKGxvZ2dlci5sb2cgJiYgbG9nZ2VyLndhcm4gJiYgbG9nZ2VyLmVycm9yKVxuICAgICAgICByZXR1cm4gbG9nZ2VyO1xuICAgIHRocm93IG5ldyBFcnJvcihcImxvZ2dlciBtdXN0IGltcGxlbWVudCBsb2csIHdhcm4gYW5kIGVycm9yIG1ldGhvZHNcIik7XG59XG5jb25zdCBLRVlXT1JEX05BTUUgPSAvXlthLXpfJF1bYS16MC05XyQ6LV0qJC9pO1xuZnVuY3Rpb24gY2hlY2tLZXl3b3JkKGtleXdvcmQsIGRlZikge1xuICAgIGNvbnN0IHsgUlVMRVMgfSA9IHRoaXM7XG4gICAgKDAsIHV0aWxfMS5lYWNoSXRlbSkoa2V5d29yZCwgKGt3ZCkgPT4ge1xuICAgICAgICBpZiAoUlVMRVMua2V5d29yZHNba3dkXSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5d29yZCAke2t3ZH0gaXMgYWxyZWFkeSBkZWZpbmVkYCk7XG4gICAgICAgIGlmICghS0VZV09SRF9OQU1FLnRlc3Qoa3dkKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5d29yZCAke2t3ZH0gaGFzIGludmFsaWQgbmFtZWApO1xuICAgIH0pO1xuICAgIGlmICghZGVmKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGRlZi4kZGF0YSAmJiAhKFwiY29kZVwiIGluIGRlZiB8fCBcInZhbGlkYXRlXCIgaW4gZGVmKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyRkYXRhIGtleXdvcmQgbXVzdCBoYXZlIFwiY29kZVwiIG9yIFwidmFsaWRhdGVcIiBmdW5jdGlvbicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZFJ1bGUoa2V5d29yZCwgZGVmaW5pdGlvbiwgZGF0YVR5cGUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcG9zdCA9IGRlZmluaXRpb24gPT09IG51bGwgfHwgZGVmaW5pdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVmaW5pdGlvbi5wb3N0O1xuICAgIGlmIChkYXRhVHlwZSAmJiBwb3N0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2tleXdvcmQgd2l0aCBcInBvc3RcIiBmbGFnIGNhbm5vdCBoYXZlIFwidHlwZVwiJyk7XG4gICAgY29uc3QgeyBSVUxFUyB9ID0gdGhpcztcbiAgICBsZXQgcnVsZUdyb3VwID0gcG9zdCA/IFJVTEVTLnBvc3QgOiBSVUxFUy5ydWxlcy5maW5kKCh7IHR5cGU6IHQgfSkgPT4gdCA9PT0gZGF0YVR5cGUpO1xuICAgIGlmICghcnVsZUdyb3VwKSB7XG4gICAgICAgIHJ1bGVHcm91cCA9IHsgdHlwZTogZGF0YVR5cGUsIHJ1bGVzOiBbXSB9O1xuICAgICAgICBSVUxFUy5ydWxlcy5wdXNoKHJ1bGVHcm91cCk7XG4gICAgfVxuICAgIFJVTEVTLmtleXdvcmRzW2tleXdvcmRdID0gdHJ1ZTtcbiAgICBpZiAoIWRlZmluaXRpb24pXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBydWxlID0ge1xuICAgICAgICBrZXl3b3JkLFxuICAgICAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgICAgICAuLi5kZWZpbml0aW9uLFxuICAgICAgICAgICAgdHlwZTogKDAsIGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKShkZWZpbml0aW9uLnR5cGUpLFxuICAgICAgICAgICAgc2NoZW1hVHlwZTogKDAsIGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKShkZWZpbml0aW9uLnNjaGVtYVR5cGUpLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgaWYgKGRlZmluaXRpb24uYmVmb3JlKVxuICAgICAgICBhZGRCZWZvcmVSdWxlLmNhbGwodGhpcywgcnVsZUdyb3VwLCBydWxlLCBkZWZpbml0aW9uLmJlZm9yZSk7XG4gICAgZWxzZVxuICAgICAgICBydWxlR3JvdXAucnVsZXMucHVzaChydWxlKTtcbiAgICBSVUxFUy5hbGxba2V5d29yZF0gPSBydWxlO1xuICAgIChfYSA9IGRlZmluaXRpb24uaW1wbGVtZW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKGt3ZCkgPT4gdGhpcy5hZGRLZXl3b3JkKGt3ZCkpO1xufVxuZnVuY3Rpb24gYWRkQmVmb3JlUnVsZShydWxlR3JvdXAsIHJ1bGUsIGJlZm9yZSkge1xuICAgIGNvbnN0IGkgPSBydWxlR3JvdXAucnVsZXMuZmluZEluZGV4KChfcnVsZSkgPT4gX3J1bGUua2V5d29yZCA9PT0gYmVmb3JlKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgIHJ1bGVHcm91cC5ydWxlcy5zcGxpY2UoaSwgMCwgcnVsZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBydWxlR3JvdXAucnVsZXMucHVzaChydWxlKTtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihgcnVsZSAke2JlZm9yZX0gaXMgbm90IGRlZmluZWRgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBrZXl3b3JkTWV0YXNjaGVtYShkZWYpIHtcbiAgICBsZXQgeyBtZXRhU2NoZW1hIH0gPSBkZWY7XG4gICAgaWYgKG1ldGFTY2hlbWEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChkZWYuJGRhdGEgJiYgdGhpcy5vcHRzLiRkYXRhKVxuICAgICAgICBtZXRhU2NoZW1hID0gc2NoZW1hT3JEYXRhKG1ldGFTY2hlbWEpO1xuICAgIGRlZi52YWxpZGF0ZVNjaGVtYSA9IHRoaXMuY29tcGlsZShtZXRhU2NoZW1hLCB0cnVlKTtcbn1cbmNvbnN0ICRkYXRhUmVmID0ge1xuICAgICRyZWY6IFwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Fqdi12YWxpZGF0b3IvYWp2L21hc3Rlci9saWIvcmVmcy9kYXRhLmpzb24jXCIsXG59O1xuZnVuY3Rpb24gc2NoZW1hT3JEYXRhKHNjaGVtYSkge1xuICAgIHJldHVybiB7IGFueU9mOiBbc2NoZW1hLCAkZGF0YVJlZl0gfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpZFwiLFxuICAgIGNvZGUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTk9UIFNVUFBPUlRFRDoga2V5d29yZCBcImlkXCIsIHVzZSBcIiRpZFwiIGZvciBzY2hlbWEgSUQnKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jYWxsUmVmID0gZXhwb3J0cy5nZXRWYWxpZGF0ZSA9IHZvaWQgMDtcbmNvbnN0IHJlZl9lcnJvcl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvcmVmX2Vycm9yXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL25hbWVzXCIpO1xuY29uc3QgY29tcGlsZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiJHJlZlwiLFxuICAgIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYTogJHJlZiwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBiYXNlSWQsIHNjaGVtYUVudjogZW52LCB2YWxpZGF0ZU5hbWUsIG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgICAgICBjb25zdCB7IHJvb3QgfSA9IGVudjtcbiAgICAgICAgaWYgKCgkcmVmID09PSBcIiNcIiB8fCAkcmVmID09PSBcIiMvXCIpICYmIGJhc2VJZCA9PT0gcm9vdC5iYXNlSWQpXG4gICAgICAgICAgICByZXR1cm4gY2FsbFJvb3RSZWYoKTtcbiAgICAgICAgY29uc3Qgc2NoT3JFbnYgPSBjb21waWxlXzEucmVzb2x2ZVJlZi5jYWxsKHNlbGYsIHJvb3QsIGJhc2VJZCwgJHJlZik7XG4gICAgICAgIGlmIChzY2hPckVudiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IHJlZl9lcnJvcl8xLmRlZmF1bHQoaXQub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCAkcmVmKTtcbiAgICAgICAgaWYgKHNjaE9yRW52IGluc3RhbmNlb2YgY29tcGlsZV8xLlNjaGVtYUVudilcbiAgICAgICAgICAgIHJldHVybiBjYWxsVmFsaWRhdGUoc2NoT3JFbnYpO1xuICAgICAgICByZXR1cm4gaW5saW5lUmVmU2NoZW1hKHNjaE9yRW52KTtcbiAgICAgICAgZnVuY3Rpb24gY2FsbFJvb3RSZWYoKSB7XG4gICAgICAgICAgICBpZiAoZW52ID09PSByb290KVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsUmVmKGN4dCwgdmFsaWRhdGVOYW1lLCBlbnYsIGVudi4kYXN5bmMpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdE5hbWUgPSBnZW4uc2NvcGVWYWx1ZShcInJvb3RcIiwgeyByZWY6IHJvb3QgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2FsbFJlZihjeHQsICgwLCBjb2RlZ2VuXzEuXykgYCR7cm9vdE5hbWV9LnZhbGlkYXRlYCwgcm9vdCwgcm9vdC4kYXN5bmMpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNhbGxWYWxpZGF0ZShzY2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBnZXRWYWxpZGF0ZShjeHQsIHNjaCk7XG4gICAgICAgICAgICBjYWxsUmVmKGN4dCwgdiwgc2NoLCBzY2guJGFzeW5jKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbmxpbmVSZWZTY2hlbWEoc2NoKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hOYW1lID0gZ2VuLnNjb3BlVmFsdWUoXCJzY2hlbWFcIiwgb3B0cy5jb2RlLnNvdXJjZSA9PT0gdHJ1ZSA/IHsgcmVmOiBzY2gsIGNvZGU6ICgwLCBjb2RlZ2VuXzEuc3RyaW5naWZ5KShzY2gpIH0gOiB7IHJlZjogc2NoIH0pO1xuICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiBzY2gsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzOiBbXSxcbiAgICAgICAgICAgICAgICBzY2hlbWFQYXRoOiBjb2RlZ2VuXzEubmlsLFxuICAgICAgICAgICAgICAgIHRvcFNjaGVtYVJlZjogc2NoTmFtZSxcbiAgICAgICAgICAgICAgICBlcnJTY2hlbWFQYXRoOiAkcmVmLFxuICAgICAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCk7XG4gICAgICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5mdW5jdGlvbiBnZXRWYWxpZGF0ZShjeHQsIHNjaCkge1xuICAgIGNvbnN0IHsgZ2VuIH0gPSBjeHQ7XG4gICAgcmV0dXJuIHNjaC52YWxpZGF0ZVxuICAgICAgICA/IGdlbi5zY29wZVZhbHVlKFwidmFsaWRhdGVcIiwgeyByZWY6IHNjaC52YWxpZGF0ZSB9KVxuICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuXykgYCR7Z2VuLnNjb3BlVmFsdWUoXCJ3cmFwcGVyXCIsIHsgcmVmOiBzY2ggfSl9LnZhbGlkYXRlYDtcbn1cbmV4cG9ydHMuZ2V0VmFsaWRhdGUgPSBnZXRWYWxpZGF0ZTtcbmZ1bmN0aW9uIGNhbGxSZWYoY3h0LCB2LCBzY2gsICRhc3luYykge1xuICAgIGNvbnN0IHsgZ2VuLCBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHsgYWxsRXJyb3JzLCBzY2hlbWFFbnY6IGVudiwgb3B0cyB9ID0gaXQ7XG4gICAgY29uc3QgcGFzc0N4dCA9IG9wdHMucGFzc0NvbnRleHQgPyBuYW1lc18xLmRlZmF1bHQudGhpcyA6IGNvZGVnZW5fMS5uaWw7XG4gICAgaWYgKCRhc3luYylcbiAgICAgICAgY2FsbEFzeW5jUmVmKCk7XG4gICAgZWxzZVxuICAgICAgICBjYWxsU3luY1JlZigpO1xuICAgIGZ1bmN0aW9uIGNhbGxBc3luY1JlZigpIHtcbiAgICAgICAgaWYgKCFlbnYuJGFzeW5jKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMgc2NoZW1hIHJlZmVyZW5jZWQgYnkgc3luYyBzY2hlbWFcIik7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgICAgICBnZW4udHJ5KCgpID0+IHtcbiAgICAgICAgICAgIGdlbi5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYGF3YWl0ICR7KDAsIGNvZGVfMS5jYWxsVmFsaWRhdGVDb2RlKShjeHQsIHYsIHBhc3NDeHQpfWApO1xuICAgICAgICAgICAgYWRkRXZhbHVhdGVkRnJvbSh2KTsgLy8gVE9ETyB3aWxsIG5vdCB3b3JrIHdpdGggYXN5bmMsIGl0IGhhcyB0byBiZSByZXR1cm5lZCB3aXRoIHRoZSByZXN1bHRcbiAgICAgICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpO1xuICAgICAgICB9LCAoZSkgPT4ge1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCEoJHtlfSBpbnN0YW5jZW9mICR7aXQuVmFsaWRhdGlvbkVycm9yfSlgLCAoKSA9PiBnZW4udGhyb3coZSkpO1xuICAgICAgICAgICAgYWRkRXJyb3JzRnJvbShlKTtcbiAgICAgICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbGxTeW5jUmVmKCkge1xuICAgICAgICBjeHQucmVzdWx0KCgwLCBjb2RlXzEuY2FsbFZhbGlkYXRlQ29kZSkoY3h0LCB2LCBwYXNzQ3h0KSwgKCkgPT4gYWRkRXZhbHVhdGVkRnJvbSh2KSwgKCkgPT4gYWRkRXJyb3JzRnJvbSh2KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZEVycm9yc0Zyb20oc291cmNlKSB7XG4gICAgICAgIGNvbnN0IGVycnMgPSAoMCwgY29kZWdlbl8xLl8pIGAke3NvdXJjZX0uZXJyb3JzYDtcbiAgICAgICAgZ2VuLmFzc2lnbihuYW1lc18xLmRlZmF1bHQudkVycm9ycywgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30gPT09IG51bGwgPyAke2VycnN9IDogJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30uY29uY2F0KCR7ZXJyc30pYCk7IC8vIFRPRE8gdGFnZ2VkXG4gICAgICAgIGdlbi5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LmVycm9ycywgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30ubGVuZ3RoYCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZEV2YWx1YXRlZEZyb20oc291cmNlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCFpdC5vcHRzLnVuZXZhbHVhdGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBzY2hFdmFsdWF0ZWQgPSAoX2EgPSBzY2ggPT09IG51bGwgfHwgc2NoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2gudmFsaWRhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ldmFsdWF0ZWQ7XG4gICAgICAgIC8vIFRPRE8gcmVmYWN0b3JcbiAgICAgICAgaWYgKGl0LnByb3BzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoc2NoRXZhbHVhdGVkICYmICFzY2hFdmFsdWF0ZWQuZHluYW1pY1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaEV2YWx1YXRlZC5wcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgc2NoRXZhbHVhdGVkLnByb3BzLCBpdC5wcm9wcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBnZW4udmFyKFwicHJvcHNcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtzb3VyY2V9LmV2YWx1YXRlZC5wcm9wc2ApO1xuICAgICAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgcHJvcHMsIGl0LnByb3BzLCBjb2RlZ2VuXzEuTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0Lml0ZW1zICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoc2NoRXZhbHVhdGVkICYmICFzY2hFdmFsdWF0ZWQuZHluYW1pY0l0ZW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaEV2YWx1YXRlZC5pdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0Lml0ZW1zID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgc2NoRXZhbHVhdGVkLml0ZW1zLCBpdC5pdGVtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBnZW4udmFyKFwiaXRlbXNcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtzb3VyY2V9LmV2YWx1YXRlZC5pdGVtc2ApO1xuICAgICAgICAgICAgICAgIGl0Lml0ZW1zID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgaXRlbXMsIGl0Lml0ZW1zLCBjb2RlZ2VuXzEuTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmNhbGxSZWYgPSBjYWxsUmVmO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgaWRfMSA9IHJlcXVpcmUoXCIuL2lkXCIpO1xuY29uc3QgcmVmXzEgPSByZXF1aXJlKFwiLi9yZWZcIik7XG5jb25zdCBjb3JlID0gW1xuICAgIFwiJHNjaGVtYVwiLFxuICAgIFwiJGlkXCIsXG4gICAgXCIkZGVmc1wiLFxuICAgIFwiJHZvY2FidWxhcnlcIixcbiAgICB7IGtleXdvcmQ6IFwiJGNvbW1lbnRcIiB9LFxuICAgIFwiZGVmaW5pdGlvbnNcIixcbiAgICBpZF8xLmRlZmF1bHQsXG4gICAgcmVmXzEuZGVmYXVsdCxcbl07XG5leHBvcnRzLmRlZmF1bHQgPSBjb3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3Qgb3BzID0gY29kZWdlbl8xLm9wZXJhdG9ycztcbmNvbnN0IEtXRHMgPSB7XG4gICAgbWF4aW11bTogeyBva1N0cjogXCI8PVwiLCBvazogb3BzLkxURSwgZmFpbDogb3BzLkdUIH0sXG4gICAgbWluaW11bTogeyBva1N0cjogXCI+PVwiLCBvazogb3BzLkdURSwgZmFpbDogb3BzLkxUIH0sXG4gICAgZXhjbHVzaXZlTWF4aW11bTogeyBva1N0cjogXCI8XCIsIG9rOiBvcHMuTFQsIGZhaWw6IG9wcy5HVEUgfSxcbiAgICBleGNsdXNpdmVNaW5pbXVtOiB7IG9rU3RyOiBcIj5cIiwgb2s6IG9wcy5HVCwgZmFpbDogb3BzLkxURSB9LFxufTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IGJlICR7S1dEc1trZXl3b3JkXS5va1N0cn0gJHtzY2hlbWFDb2RlfWAsXG4gICAgcGFyYW1zOiAoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtjb21wYXJpc29uOiAke0tXRHNba2V5d29yZF0ub2tTdHJ9LCBsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBPYmplY3Qua2V5cyhLV0RzKSxcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBrZXl3b3JkLCBkYXRhLCBzY2hlbWFDb2RlIH0gPSBjeHQ7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSAke0tXRHNba2V5d29yZF0uZmFpbH0gJHtzY2hlbWFDb2RlfSB8fCBpc05hTigke2RhdGF9KWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGltaXROdW1iZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgYmUgbXVsdGlwbGUgb2YgJHtzY2hlbWFDb2RlfWAsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHttdWx0aXBsZU9mOiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwibXVsdGlwbGVPZlwiLFxuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgLy8gY29uc3QgYmR0ID0gYmFkJERhdGFUeXBlKHNjaGVtYUNvZGUsIDxzdHJpbmc+ZGVmLnNjaGVtYVR5cGUsICRkYXRhKVxuICAgICAgICBjb25zdCBwcmVjID0gaXQub3B0cy5tdWx0aXBsZU9mUHJlY2lzaW9uO1xuICAgICAgICBjb25zdCByZXMgPSBnZW4ubGV0KFwicmVzXCIpO1xuICAgICAgICBjb25zdCBpbnZhbGlkID0gcHJlY1xuICAgICAgICAgICAgPyAoMCwgY29kZWdlbl8xLl8pIGBNYXRoLmFicyhNYXRoLnJvdW5kKCR7cmVzfSkgLSAke3Jlc30pID4gMWUtJHtwcmVjfWBcbiAgICAgICAgICAgIDogKDAsIGNvZGVnZW5fMS5fKSBgJHtyZXN9ICE9PSBwYXJzZUludCgke3Jlc30pYDtcbiAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLl8pIGAoJHtzY2hlbWFDb2RlfSA9PT0gMCB8fCAoJHtyZXN9ID0gJHtkYXRhfS8ke3NjaGVtYUNvZGV9LCAke2ludmFsaWR9KSlgKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bHRpcGxlT2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZ1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL3B1bnljb2RlLmpzIC0gcHVueWNvZGUudWNzMi5kZWNvZGVcbmZ1bmN0aW9uIHVjczJsZW5ndGgoc3RyKSB7XG4gICAgY29uc3QgbGVuID0gc3RyLmxlbmd0aDtcbiAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBsZXQgdmFsdWU7XG4gICAgd2hpbGUgKHBvcyA8IGxlbikge1xuICAgICAgICBsZW5ndGgrKztcbiAgICAgICAgdmFsdWUgPSBzdHIuY2hhckNvZGVBdChwb3MrKyk7XG4gICAgICAgIGlmICh2YWx1ZSA+PSAweGQ4MDAgJiYgdmFsdWUgPD0gMHhkYmZmICYmIHBvcyA8IGxlbikge1xuICAgICAgICAgICAgLy8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG4gICAgICAgICAgICB2YWx1ZSA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAoKHZhbHVlICYgMHhmYzAwKSA9PT0gMHhkYzAwKVxuICAgICAgICAgICAgICAgIHBvcysrOyAvLyBsb3cgc3Vycm9nYXRlXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxlbmd0aDtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHVjczJsZW5ndGg7XG51Y3MybGVuZ3RoLmNvZGUgPSAncmVxdWlyZShcImFqdi9kaXN0L3J1bnRpbWUvdWNzMmxlbmd0aFwiKS5kZWZhdWx0Jztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVjczJsZW5ndGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IHVjczJsZW5ndGhfMSA9IHJlcXVpcmUoXCIuLi8uLi9ydW50aW1lL3VjczJsZW5ndGhcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSB7XG4gICAgICAgIGNvbnN0IGNvbXAgPSBrZXl3b3JkID09PSBcIm1heExlbmd0aFwiID8gXCJtb3JlXCIgOiBcImZld2VyXCI7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gY2hhcmFjdGVyc2A7XG4gICAgfSxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2xpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFtcIm1heExlbmd0aFwiLCBcIm1pbkxlbmd0aFwiXSxcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBrZXl3b3JkLCBkYXRhLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCBvcCA9IGtleXdvcmQgPT09IFwibWF4TGVuZ3RoXCIgPyBjb2RlZ2VuXzEub3BlcmF0b3JzLkdUIDogY29kZWdlbl8xLm9wZXJhdG9ycy5MVDtcbiAgICAgICAgY29uc3QgbGVuID0gaXQub3B0cy51bmljb2RlID09PSBmYWxzZSA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoYCA6ICgwLCBjb2RlZ2VuXzEuXykgYCR7KDAsIHV0aWxfMS51c2VGdW5jKShjeHQuZ2VuLCB1Y3MybGVuZ3RoXzEuZGVmYXVsdCl9KCR7ZGF0YX0pYDtcbiAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLl8pIGAke2xlbn0gJHtvcH0gJHtzY2hlbWFDb2RlfWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGltaXRMZW5ndGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBtYXRjaCBwYXR0ZXJuIFwiJHtzY2hlbWFDb2RlfVwiYCxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge3BhdHRlcm46ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJwYXR0ZXJuXCIsXG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBzY2hlbWFUeXBlOiBcInN0cmluZ1wiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgLy8gVE9ETyByZWdleHAgc2hvdWxkIGJlIHdyYXBwZWQgaW4gdHJ5L2NhdGNoc1xuICAgICAgICBjb25zdCB1ID0gaXQub3B0cy51bmljb2RlUmVnRXhwID8gXCJ1XCIgOiBcIlwiO1xuICAgICAgICBjb25zdCByZWdFeHAgPSAkZGF0YSA/ICgwLCBjb2RlZ2VuXzEuXykgYChuZXcgUmVnRXhwKCR7c2NoZW1hQ29kZX0sICR7dX0pKWAgOiAoMCwgY29kZV8xLnVzZVBhdHRlcm4pKGN4dCwgc2NoZW1hKTtcbiAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLl8pIGAhJHtyZWdFeHB9LnRlc3QoJHtkYXRhfSlgKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdHRlcm4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZSh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkge1xuICAgICAgICBjb25zdCBjb21wID0ga2V5d29yZCA9PT0gXCJtYXhQcm9wZXJ0aWVzXCIgPyBcIm1vcmVcIiA6IFwiZmV3ZXJcIjtcbiAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBOT1QgaGF2ZSAke2NvbXB9IHRoYW4gJHtzY2hlbWFDb2RlfSBwcm9wZXJ0aWVzYDtcbiAgICB9LFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7bGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogW1wibWF4UHJvcGVydGllc1wiLCBcIm1pblByb3BlcnRpZXNcIl0sXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZSB9ID0gY3h0O1xuICAgICAgICBjb25zdCBvcCA9IGtleXdvcmQgPT09IFwibWF4UHJvcGVydGllc1wiID8gY29kZWdlbl8xLm9wZXJhdG9ycy5HVCA6IGNvZGVnZW5fMS5vcGVyYXRvcnMuTFQ7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoKDAsIGNvZGVnZW5fMS5fKSBgT2JqZWN0LmtleXMoJHtkYXRhfSkubGVuZ3RoICR7b3B9ICR7c2NoZW1hQ29kZX1gKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0UHJvcGVydGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5IH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IGhhdmUgcmVxdWlyZWQgcHJvcGVydHkgJyR7bWlzc2luZ1Byb3BlcnR5fSdgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eSB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHttaXNzaW5nUHJvcGVydHk6ICR7bWlzc2luZ1Byb3BlcnR5fX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInJlcXVpcmVkXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgc2NoZW1hQ29kZSwgZGF0YSwgJGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgb3B0cyB9ID0gaXQ7XG4gICAgICAgIGlmICghJGRhdGEgJiYgc2NoZW1hLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdXNlTG9vcCA9IHNjaGVtYS5sZW5ndGggPj0gb3B0cy5sb29wUmVxdWlyZWQ7XG4gICAgICAgIGlmIChpdC5hbGxFcnJvcnMpXG4gICAgICAgICAgICBhbGxFcnJvcnNNb2RlKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGV4aXRPbkVycm9yTW9kZSgpO1xuICAgICAgICBpZiAob3B0cy5zdHJpY3RSZXF1aXJlZCkge1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBjeHQucGFyZW50U2NoZW1hLnByb3BlcnRpZXM7XG4gICAgICAgICAgICBjb25zdCB7IGRlZmluZWRQcm9wZXJ0aWVzIH0gPSBjeHQuaXQ7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlcXVpcmVkS2V5IG9mIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGlmICgocHJvcHMgPT09IG51bGwgfHwgcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3BzW3JlcXVpcmVkS2V5XSkgPT09IHVuZGVmaW5lZCAmJiAhZGVmaW5lZFByb3BlcnRpZXMuaGFzKHJlcXVpcmVkS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWFQYXRoID0gaXQuc2NoZW1hRW52LmJhc2VJZCArIGl0LmVyclNjaGVtYVBhdGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IGByZXF1aXJlZCBwcm9wZXJ0eSBcIiR7cmVxdWlyZWRLZXl9XCIgaXMgbm90IGRlZmluZWQgYXQgXCIke3NjaGVtYVBhdGh9XCIgKHN0cmljdFJlcXVpcmVkKWA7XG4gICAgICAgICAgICAgICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgbXNnLCBpdC5vcHRzLnN0cmljdFJlcXVpcmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWxsRXJyb3JzTW9kZSgpIHtcbiAgICAgICAgICAgIGlmICh1c2VMb29wIHx8ICRkYXRhKSB7XG4gICAgICAgICAgICAgICAgY3h0LmJsb2NrJGRhdGEoY29kZWdlbl8xLm5pbCwgbG9vcEFsbFJlcXVpcmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGNvZGVfMS5jaGVja1JlcG9ydE1pc3NpbmdQcm9wKShjeHQsIHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBleGl0T25FcnJvck1vZGUoKSB7XG4gICAgICAgICAgICBjb25zdCBtaXNzaW5nID0gZ2VuLmxldChcIm1pc3NpbmdcIik7XG4gICAgICAgICAgICBpZiAodXNlTG9vcCB8fCAkZGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIHRydWUpO1xuICAgICAgICAgICAgICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCAoKSA9PiBsb29wVW50aWxNaXNzaW5nKG1pc3NpbmcsIHZhbGlkKSk7XG4gICAgICAgICAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZV8xLmNoZWNrTWlzc2luZ1Byb3ApKGN4dCwgc2NoZW1hLCBtaXNzaW5nKSk7XG4gICAgICAgICAgICAgICAgKDAsIGNvZGVfMS5yZXBvcnRNaXNzaW5nUHJvcCkoY3h0LCBtaXNzaW5nKTtcbiAgICAgICAgICAgICAgICBnZW4uZWxzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxvb3BBbGxSZXF1aXJlZCgpIHtcbiAgICAgICAgICAgIGdlbi5mb3JPZihcInByb3BcIiwgc2NoZW1hQ29kZSwgKHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgbWlzc2luZ1Byb3BlcnR5OiBwcm9wIH0pO1xuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZV8xLm5vUHJvcGVydHlJbkRhdGEpKGdlbiwgZGF0YSwgcHJvcCwgb3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4gY3h0LmVycm9yKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbG9vcFVudGlsTWlzc2luZyhtaXNzaW5nLCB2YWxpZCkge1xuICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IG1pc3NpbmdQcm9wZXJ0eTogbWlzc2luZyB9KTtcbiAgICAgICAgICAgIGdlbi5mb3JPZihtaXNzaW5nLCBzY2hlbWFDb2RlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgKDAsIGNvZGVfMS5wcm9wZXJ0eUluRGF0YSkoZ2VuLCBkYXRhLCBtaXNzaW5nLCBvcHRzLm93blByb3BlcnRpZXMpKTtcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjeHQuZXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmJyZWFrKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBjb2RlZ2VuXzEubmlsKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWlyZWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZSh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkge1xuICAgICAgICBjb25zdCBjb21wID0ga2V5d29yZCA9PT0gXCJtYXhJdGVtc1wiID8gXCJtb3JlXCIgOiBcImZld2VyXCI7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gaXRlbXNgO1xuICAgIH0sXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBbXCJtYXhJdGVtc1wiLCBcIm1pbkl0ZW1zXCJdLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZSB9ID0gY3h0O1xuICAgICAgICBjb25zdCBvcCA9IGtleXdvcmQgPT09IFwibWF4SXRlbXNcIiA/IGNvZGVnZW5fMS5vcGVyYXRvcnMuR1QgOiBjb2RlZ2VuXzEub3BlcmF0b3JzLkxUO1xuICAgICAgICBjeHQuZmFpbCRkYXRhKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoICR7b3B9ICR7c2NoZW1hQ29kZX1gKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0SXRlbXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vYWp2LXZhbGlkYXRvci9hanYvaXNzdWVzLzg4OVxuY29uc3QgZXF1YWwgPSByZXF1aXJlKFwiZmFzdC1kZWVwLWVxdWFsXCIpO1xuZXF1YWwuY29kZSA9ICdyZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS9lcXVhbFwiKS5kZWZhdWx0JztcbmV4cG9ydHMuZGVmYXVsdCA9IGVxdWFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXF1YWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBkYXRhVHlwZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVxdWFsXzEgPSByZXF1aXJlKFwiLi4vLi4vcnVudGltZS9lcXVhbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBpLCBqIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IE5PVCBoYXZlIGR1cGxpY2F0ZSBpdGVtcyAoaXRlbXMgIyMgJHtqfSBhbmQgJHtpfSBhcmUgaWRlbnRpY2FsKWAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgaSwgaiB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtpOiAke2l9LCBqOiAke2p9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwidW5pcXVlSXRlbXNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogXCJib29sZWFuXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsICRkYXRhLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKCEkZGF0YSAmJiAhc2NoZW1hKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiKTtcbiAgICAgICAgY29uc3QgaXRlbVR5cGVzID0gcGFyZW50U2NoZW1hLml0ZW1zID8gKDAsIGRhdGFUeXBlXzEuZ2V0U2NoZW1hVHlwZXMpKHBhcmVudFNjaGVtYS5pdGVtcykgOiBbXTtcbiAgICAgICAgY3h0LmJsb2NrJGRhdGEodmFsaWQsIHZhbGlkYXRlVW5pcXVlSXRlbXMsICgwLCBjb2RlZ2VuXzEuXykgYCR7c2NoZW1hQ29kZX0gPT09IGZhbHNlYCk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlVW5pcXVlSXRlbXMoKSB7XG4gICAgICAgICAgICBjb25zdCBpID0gZ2VuLmxldChcImlcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfS5sZW5ndGhgKTtcbiAgICAgICAgICAgIGNvbnN0IGogPSBnZW4ubGV0KFwialwiKTtcbiAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBpLCBqIH0pO1xuICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtpfSA+IDFgLCAoKSA9PiAoY2FuT3B0aW1pemUoKSA/IGxvb3BOIDogbG9vcE4yKShpLCBqKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2FuT3B0aW1pemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbVR5cGVzLmxlbmd0aCA+IDAgJiYgIWl0ZW1UeXBlcy5zb21lKCh0KSA9PiB0ID09PSBcIm9iamVjdFwiIHx8IHQgPT09IFwiYXJyYXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbG9vcE4oaSwgaikge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGdlbi5uYW1lKFwiaXRlbVwiKTtcbiAgICAgICAgICAgIGNvbnN0IHdyb25nVHlwZSA9ICgwLCBkYXRhVHlwZV8xLmNoZWNrRGF0YVR5cGVzKShpdGVtVHlwZXMsIGl0ZW0sIGl0Lm9wdHMuc3RyaWN0TnVtYmVycywgZGF0YVR5cGVfMS5EYXRhVHlwZS5Xcm9uZyk7XG4gICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gZ2VuLmNvbnN0KFwiaW5kaWNlc1wiLCAoMCwgY29kZWdlbl8xLl8pIGB7fWApO1xuICAgICAgICAgICAgZ2VuLmZvcigoMCwgY29kZWdlbl8xLl8pIGA7JHtpfS0tO2AsICgpID0+IHtcbiAgICAgICAgICAgICAgICBnZW4ubGV0KGl0ZW0sICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX1bJHtpfV1gKTtcbiAgICAgICAgICAgICAgICBnZW4uaWYod3JvbmdUeXBlLCAoMCwgY29kZWdlbl8xLl8pIGBjb250aW51ZWApO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtVHlwZXMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2l0ZW19ID09IFwic3RyaW5nXCJgLCAoMCwgY29kZWdlbl8xLl8pIGAke2l0ZW19ICs9IFwiX1wiYCk7XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5pZigoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtpbmRpY2VzfVske2l0ZW19XSA9PSBcIm51bWJlclwiYCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKGosICgwLCBjb2RlZ2VuXzEuXykgYCR7aW5kaWNlc31bJHtpdGVtfV1gKTtcbiAgICAgICAgICAgICAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5icmVhaygpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYCR7aW5kaWNlc31bJHtpdGVtfV0gPSAke2l9YCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsb29wTjIoaSwgaikge1xuICAgICAgICAgICAgY29uc3QgZXFsID0gKDAsIHV0aWxfMS51c2VGdW5jKShnZW4sIGVxdWFsXzEuZGVmYXVsdCk7XG4gICAgICAgICAgICBjb25zdCBvdXRlciA9IGdlbi5uYW1lKFwib3V0ZXJcIik7XG4gICAgICAgICAgICBnZW4ubGFiZWwob3V0ZXIpLmZvcigoMCwgY29kZWdlbl8xLl8pIGA7JHtpfS0tO2AsICgpID0+IGdlbi5mb3IoKDAsIGNvZGVnZW5fMS5fKSBgJHtqfSA9ICR7aX07ICR7an0tLTtgLCAoKSA9PiBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtlcWx9KCR7ZGF0YX1bJHtpfV0sICR7ZGF0YX1bJHtqfV0pYCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGN4dC5lcnJvcigpO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5icmVhayhvdXRlcik7XG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bmlxdWVJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXF1YWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9ydW50aW1lL2VxdWFsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJtdXN0IGJlIGVxdWFsIHRvIGNvbnN0YW50XCIsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHthbGxvd2VkVmFsdWU6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJjb25zdFwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hQ29kZSwgc2NoZW1hIH0gPSBjeHQ7XG4gICAgICAgIGlmICgkZGF0YSB8fCAoc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIikpIHtcbiAgICAgICAgICAgIGN4dC5mYWlsJGRhdGEoKDAsIGNvZGVnZW5fMS5fKSBgISR7KDAsIHV0aWxfMS51c2VGdW5jKShnZW4sIGVxdWFsXzEuZGVmYXVsdCl9KCR7ZGF0YX0sICR7c2NoZW1hQ29kZX0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjeHQuZmFpbCgoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYX0gIT09ICR7ZGF0YX1gKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVxdWFsXzEgPSByZXF1aXJlKFwiLi4vLi4vcnVudGltZS9lcXVhbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwibXVzdCBiZSBlcXVhbCB0byBvbmUgb2YgdGhlIGFsbG93ZWQgdmFsdWVzXCIsXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHthbGxvd2VkVmFsdWVzOiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiZW51bVwiLFxuICAgIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKCEkZGF0YSAmJiBzY2hlbWEubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW51bSBtdXN0IGhhdmUgbm9uLWVtcHR5IGFycmF5XCIpO1xuICAgICAgICBjb25zdCB1c2VMb29wID0gc2NoZW1hLmxlbmd0aCA+PSBpdC5vcHRzLmxvb3BFbnVtO1xuICAgICAgICBsZXQgZXFsO1xuICAgICAgICBjb25zdCBnZXRFcWwgPSAoKSA9PiAoZXFsICE9PSBudWxsICYmIGVxbCAhPT0gdm9pZCAwID8gZXFsIDogKGVxbCA9ICgwLCB1dGlsXzEudXNlRnVuYykoZ2VuLCBlcXVhbF8xLmRlZmF1bHQpKSk7XG4gICAgICAgIGxldCB2YWxpZDtcbiAgICAgICAgaWYgKHVzZUxvb3AgfHwgJGRhdGEpIHtcbiAgICAgICAgICAgIHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgICAgICAgICAgY3h0LmJsb2NrJGRhdGEodmFsaWQsIGxvb3BFbnVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICAgICAgY29uc3QgdlNjaGVtYSA9IGdlbi5jb25zdChcInZTY2hlbWFcIiwgc2NoZW1hQ29kZSk7XG4gICAgICAgICAgICB2YWxpZCA9ICgwLCBjb2RlZ2VuXzEub3IpKC4uLnNjaGVtYS5tYXAoKF94LCBpKSA9PiBlcXVhbENvZGUodlNjaGVtYSwgaSkpKTtcbiAgICAgICAgfVxuICAgICAgICBjeHQucGFzcyh2YWxpZCk7XG4gICAgICAgIGZ1bmN0aW9uIGxvb3BFbnVtKCkge1xuICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpO1xuICAgICAgICAgICAgZ2VuLmZvck9mKFwidlwiLCBzY2hlbWFDb2RlLCAodikgPT4gZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7Z2V0RXFsKCl9KCR7ZGF0YX0sICR7dn0pYCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkuYnJlYWsoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVxdWFsQ29kZSh2U2NoZW1hLCBpKSB7XG4gICAgICAgICAgICBjb25zdCBzY2ggPSBzY2hlbWFbaV07XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHNjaCA9PT0gXCJvYmplY3RcIiAmJiBzY2ggIT09IG51bGxcbiAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7Z2V0RXFsKCl9KCR7ZGF0YX0sICR7dlNjaGVtYX1bJHtpfV0pYFxuICAgICAgICAgICAgICAgIDogKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSA9PT0gJHtzY2h9YDtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW51bS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGxpbWl0TnVtYmVyXzEgPSByZXF1aXJlKFwiLi9saW1pdE51bWJlclwiKTtcbmNvbnN0IG11bHRpcGxlT2ZfMSA9IHJlcXVpcmUoXCIuL211bHRpcGxlT2ZcIik7XG5jb25zdCBsaW1pdExlbmd0aF8xID0gcmVxdWlyZShcIi4vbGltaXRMZW5ndGhcIik7XG5jb25zdCBwYXR0ZXJuXzEgPSByZXF1aXJlKFwiLi9wYXR0ZXJuXCIpO1xuY29uc3QgbGltaXRQcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9saW1pdFByb3BlcnRpZXNcIik7XG5jb25zdCByZXF1aXJlZF8xID0gcmVxdWlyZShcIi4vcmVxdWlyZWRcIik7XG5jb25zdCBsaW1pdEl0ZW1zXzEgPSByZXF1aXJlKFwiLi9saW1pdEl0ZW1zXCIpO1xuY29uc3QgdW5pcXVlSXRlbXNfMSA9IHJlcXVpcmUoXCIuL3VuaXF1ZUl0ZW1zXCIpO1xuY29uc3QgY29uc3RfMSA9IHJlcXVpcmUoXCIuL2NvbnN0XCIpO1xuY29uc3QgZW51bV8xID0gcmVxdWlyZShcIi4vZW51bVwiKTtcbmNvbnN0IHZhbGlkYXRpb24gPSBbXG4gICAgLy8gbnVtYmVyXG4gICAgbGltaXROdW1iZXJfMS5kZWZhdWx0LFxuICAgIG11bHRpcGxlT2ZfMS5kZWZhdWx0LFxuICAgIC8vIHN0cmluZ1xuICAgIGxpbWl0TGVuZ3RoXzEuZGVmYXVsdCxcbiAgICBwYXR0ZXJuXzEuZGVmYXVsdCxcbiAgICAvLyBvYmplY3RcbiAgICBsaW1pdFByb3BlcnRpZXNfMS5kZWZhdWx0LFxuICAgIHJlcXVpcmVkXzEuZGVmYXVsdCxcbiAgICAvLyBhcnJheVxuICAgIGxpbWl0SXRlbXNfMS5kZWZhdWx0LFxuICAgIHVuaXF1ZUl0ZW1zXzEuZGVmYXVsdCxcbiAgICAvLyBhbnlcbiAgICB7IGtleXdvcmQ6IFwidHlwZVwiLCBzY2hlbWFUeXBlOiBbXCJzdHJpbmdcIiwgXCJhcnJheVwiXSB9LFxuICAgIHsga2V5d29yZDogXCJudWxsYWJsZVwiLCBzY2hlbWFUeXBlOiBcImJvb2xlYW5cIiB9LFxuICAgIGNvbnN0XzEuZGVmYXVsdCxcbiAgICBlbnVtXzEuZGVmYXVsdCxcbl07XG5leHBvcnRzLmRlZmF1bHQgPSB2YWxpZGF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbGVuIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IE5PVCBoYXZlIG1vcmUgdGhhbiAke2xlbn0gaXRlbXNgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IGxlbiB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtsaW1pdDogJHtsZW59fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiYWRkaXRpb25hbEl0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcImJvb2xlYW5cIiwgXCJvYmplY3RcIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgaXRlbXMgfSA9IHBhcmVudFNjaGVtYTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCAnXCJhZGRpdGlvbmFsSXRlbXNcIiBpcyBpZ25vcmVkIHdoZW4gXCJpdGVtc1wiIGlzIG5vdCBhbiBhcnJheSBvZiBzY2hlbWFzJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMoY3h0LCBpdGVtcyk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyhjeHQsIGl0ZW1zKSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICBpdC5pdGVtcyA9IHRydWU7XG4gICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoYCk7XG4gICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY3h0LnNldFBhcmFtcyh7IGxlbjogaXRlbXMubGVuZ3RoIH0pO1xuICAgICAgICBjeHQucGFzcygoMCwgY29kZWdlbl8xLl8pIGAke2xlbn0gPD0gJHtpdGVtcy5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiAhKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4udmFyKFwidmFsaWRcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtsZW59IDw9ICR7aXRlbXMubGVuZ3RofWApOyAvLyBUT0RPIHZhclxuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4gdmFsaWRhdGVJdGVtcyh2YWxpZCkpO1xuICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUl0ZW1zKHZhbGlkKSB7XG4gICAgICAgIGdlbi5mb3JSYW5nZShcImlcIiwgaXRlbXMubGVuZ3RoLCBsZW4sIChpKSA9PiB7XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHsga2V5d29yZCwgZGF0YVByb3A6IGksIGRhdGFQcm9wVHlwZTogdXRpbF8xLlR5cGUuTnVtIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGlmICghaXQuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpLCAoKSA9PiBnZW4uYnJlYWsoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMgPSB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcztcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZGl0aW9uYWxJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVUdXBsZSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpdGVtc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJhcnJheVwiLCBcImJvb2xlYW5cIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVUdXBsZShjeHQsIFwiYWRkaXRpb25hbEl0ZW1zXCIsIHNjaGVtYSk7XG4gICAgICAgIGl0Lml0ZW1zID0gdHJ1ZTtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjeHQub2soKDAsIGNvZGVfMS52YWxpZGF0ZUFycmF5KShjeHQpKTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHZhbGlkYXRlVHVwbGUoY3h0LCBleHRyYUl0ZW1zLCBzY2hBcnIgPSBjeHQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBnZW4sIHBhcmVudFNjaGVtYSwgZGF0YSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICBjaGVja1N0cmljdFR1cGxlKHBhcmVudFNjaGVtYSk7XG4gICAgaWYgKGl0Lm9wdHMudW5ldmFsdWF0ZWQgJiYgc2NoQXJyLmxlbmd0aCAmJiBpdC5pdGVtcyAhPT0gdHJ1ZSkge1xuICAgICAgICBpdC5pdGVtcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5pdGVtcyhnZW4sIHNjaEFyci5sZW5ndGgsIGl0Lml0ZW1zKTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9Lmxlbmd0aGApO1xuICAgIHNjaEFyci5mb3JFYWNoKChzY2gsIGkpID0+IHtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2gpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtsZW59ID4gJHtpfWAsICgpID0+IGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAga2V5d29yZCxcbiAgICAgICAgICAgIHNjaGVtYVByb3A6IGksXG4gICAgICAgICAgICBkYXRhUHJvcDogaSxcbiAgICAgICAgfSwgdmFsaWQpKTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBjaGVja1N0cmljdFR1cGxlKHNjaCkge1xuICAgICAgICBjb25zdCB7IG9wdHMsIGVyclNjaGVtYVBhdGggfSA9IGl0O1xuICAgICAgICBjb25zdCBsID0gc2NoQXJyLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZnVsbFR1cGxlID0gbCA9PT0gc2NoLm1pbkl0ZW1zICYmIChsID09PSBzY2gubWF4SXRlbXMgfHwgc2NoW2V4dHJhSXRlbXNdID09PSBmYWxzZSk7XG4gICAgICAgIGlmIChvcHRzLnN0cmljdFR1cGxlcyAmJiAhZnVsbFR1cGxlKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBgXCIke2tleXdvcmR9XCIgaXMgJHtsfS10dXBsZSwgYnV0IG1pbkl0ZW1zIG9yIG1heEl0ZW1zLyR7ZXh0cmFJdGVtc30gYXJlIG5vdCBzcGVjaWZpZWQgb3IgZGlmZmVyZW50IGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCJgO1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBtc2csIG9wdHMuc3RyaWN0VHVwbGVzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVUdXBsZSA9IHZhbGlkYXRlVHVwbGU7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGl0ZW1zXzEgPSByZXF1aXJlKFwiLi9pdGVtc1wiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInByZWZpeEl0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcImFycmF5XCJdLFxuICAgIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIGNvZGU6IChjeHQpID0+ICgwLCBpdGVtc18xLnZhbGlkYXRlVHVwbGUpKGN4dCwgXCJpdGVtc1wiKSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVmaXhJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBhZGRpdGlvbmFsSXRlbXNfMSA9IHJlcXVpcmUoXCIuL2FkZGl0aW9uYWxJdGVtc1wiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBsZW4gfSB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgTk9UIGhhdmUgbW9yZSB0aGFuICR7bGVufSBpdGVtc2AsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgbGVuIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2xpbWl0OiAke2xlbn19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpdGVtc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4SXRlbXMgfSA9IHBhcmVudFNjaGVtYTtcbiAgICAgICAgaXQuaXRlbXMgPSB0cnVlO1xuICAgICAgICBpZiAoKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChwcmVmaXhJdGVtcylcbiAgICAgICAgICAgICgwLCBhZGRpdGlvbmFsSXRlbXNfMS52YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcykoY3h0LCBwcmVmaXhJdGVtcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGN4dC5vaygoMCwgY29kZV8xLnZhbGlkYXRlQXJyYXkpKGN4dCkpO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXRlbXMyMDIwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbWluLCBtYXggfSB9KSA9PiBtYXggPT09IHVuZGVmaW5lZFxuICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBjb250YWluIGF0IGxlYXN0ICR7bWlufSB2YWxpZCBpdGVtKHMpYFxuICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBjb250YWluIGF0IGxlYXN0ICR7bWlufSBhbmQgbm8gbW9yZSB0aGFuICR7bWF4fSB2YWxpZCBpdGVtKHMpYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBtaW4sIG1heCB9IH0pID0+IG1heCA9PT0gdW5kZWZpbmVkID8gKDAsIGNvZGVnZW5fMS5fKSBge21pbkNvbnRhaW5zOiAke21pbn19YCA6ICgwLCBjb2RlZ2VuXzEuXykgYHttaW5Db250YWluczogJHttaW59LCBtYXhDb250YWluczogJHttYXh9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiY29udGFpbnNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGxldCBtaW47XG4gICAgICAgIGxldCBtYXg7XG4gICAgICAgIGNvbnN0IHsgbWluQ29udGFpbnMsIG1heENvbnRhaW5zIH0gPSBwYXJlbnRTY2hlbWE7XG4gICAgICAgIGlmIChpdC5vcHRzLm5leHQpIHtcbiAgICAgICAgICAgIG1pbiA9IG1pbkNvbnRhaW5zID09PSB1bmRlZmluZWQgPyAxIDogbWluQ29udGFpbnM7XG4gICAgICAgICAgICBtYXggPSBtYXhDb250YWlucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1pbiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoYCk7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoeyBtaW4sIG1heCB9KTtcbiAgICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkICYmIG1pbiA9PT0gMCkge1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBgXCJtaW5Db250YWluc1wiID09IDAgd2l0aG91dCBcIm1heENvbnRhaW5zXCI6IFwiY29udGFpbnNcIiBrZXl3b3JkIGlnbm9yZWRgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4ICE9PSB1bmRlZmluZWQgJiYgbWluID4gbWF4KSB7XG4gICAgICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIGBcIm1pbkNvbnRhaW5zXCIgPiBcIm1heENvbnRhaW5zXCIgaXMgYWx3YXlzIGludmFsaWRgKTtcbiAgICAgICAgICAgIGN4dC5mYWlsKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKSB7XG4gICAgICAgICAgICBsZXQgY29uZCA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7bGVufSA+PSAke21pbn1gO1xuICAgICAgICAgICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbmQgPSAoMCwgY29kZWdlbl8xLl8pIGAke2NvbmR9ICYmICR7bGVufSA8PSAke21heH1gO1xuICAgICAgICAgICAgY3h0LnBhc3MoY29uZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaXQuaXRlbXMgPSB0cnVlO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCAmJiBtaW4gPT09IDEpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlSXRlbXModmFsaWQsICgpID0+IGdlbi5pZih2YWxpZCwgKCkgPT4gZ2VuLmJyZWFrKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtaW4gPT09IDApIHtcbiAgICAgICAgICAgIGdlbi5sZXQodmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9Lmxlbmd0aCA+IDBgLCB2YWxpZGF0ZUl0ZW1zV2l0aENvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdlbi5sZXQodmFsaWQsIGZhbHNlKTtcbiAgICAgICAgICAgIHZhbGlkYXRlSXRlbXNXaXRoQ291bnQoKTtcbiAgICAgICAgfVxuICAgICAgICBjeHQucmVzdWx0KHZhbGlkLCAoKSA9PiBjeHQucmVzZXQoKSk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXNXaXRoQ291bnQoKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpO1xuICAgICAgICAgICAgY29uc3QgY291bnQgPSBnZW4ubGV0KFwiY291bnRcIiwgMCk7XG4gICAgICAgICAgICB2YWxpZGF0ZUl0ZW1zKHNjaFZhbGlkLCAoKSA9PiBnZW4uaWYoc2NoVmFsaWQsICgpID0+IGNoZWNrTGltaXRzKGNvdW50KSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXMoX3ZhbGlkLCBibG9jaykge1xuICAgICAgICAgICAgZ2VuLmZvclJhbmdlKFwiaVwiLCAwLCBsZW4sIChpKSA9PiB7XG4gICAgICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwiY29udGFpbnNcIixcbiAgICAgICAgICAgICAgICAgICAgZGF0YVByb3A6IGksXG4gICAgICAgICAgICAgICAgICAgIGRhdGFQcm9wVHlwZTogdXRpbF8xLlR5cGUuTnVtLFxuICAgICAgICAgICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sIF92YWxpZCk7XG4gICAgICAgICAgICAgICAgYmxvY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrTGltaXRzKGNvdW50KSB7XG4gICAgICAgICAgICBnZW4uY29kZSgoMCwgY29kZWdlbl8xLl8pIGAke2NvdW50fSsrYCk7XG4gICAgICAgICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtjb3VudH0gPj0gJHttaW59YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkuYnJlYWsoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtjb3VudH0gPiAke21heH1gLCAoKSA9PiBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSkuYnJlYWsoKSk7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtjb3VudH0gPj0gJHttaW59YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250YWlucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVTY2hlbWFEZXBzID0gZXhwb3J0cy52YWxpZGF0ZVByb3BlcnR5RGVwcyA9IGV4cG9ydHMuZXJyb3IgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuZXhwb3J0cy5lcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgcHJvcGVydHksIGRlcHNDb3VudCwgZGVwcyB9IH0pID0+IHtcbiAgICAgICAgY29uc3QgcHJvcGVydHlfaWVzID0gZGVwc0NvdW50ID09PSAxID8gXCJwcm9wZXJ0eVwiIDogXCJwcm9wZXJ0aWVzXCI7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgaGF2ZSAke3Byb3BlcnR5X2llc30gJHtkZXBzfSB3aGVuIHByb3BlcnR5ICR7cHJvcGVydHl9IGlzIHByZXNlbnRgO1xuICAgIH0sXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgcHJvcGVydHksIGRlcHNDb3VudCwgZGVwcywgbWlzc2luZ1Byb3BlcnR5IH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge3Byb3BlcnR5OiAke3Byb3BlcnR5fSxcbiAgICBtaXNzaW5nUHJvcGVydHk6ICR7bWlzc2luZ1Byb3BlcnR5fSxcbiAgICBkZXBzQ291bnQ6ICR7ZGVwc0NvdW50fSxcbiAgICBkZXBzOiAke2RlcHN9fWAsIC8vIFRPRE8gY2hhbmdlIHRvIHJlZmVyZW5jZVxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImRlcGVuZGVuY2llc1wiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgICBlcnJvcjogZXhwb3J0cy5lcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCBbcHJvcERlcHMsIHNjaERlcHNdID0gc3BsaXREZXBlbmRlbmNpZXMoY3h0KTtcbiAgICAgICAgdmFsaWRhdGVQcm9wZXJ0eURlcHMoY3h0LCBwcm9wRGVwcyk7XG4gICAgICAgIHZhbGlkYXRlU2NoZW1hRGVwcyhjeHQsIHNjaERlcHMpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gc3BsaXREZXBlbmRlbmNpZXMoeyBzY2hlbWEgfSkge1xuICAgIGNvbnN0IHByb3BlcnR5RGVwcyA9IHt9O1xuICAgIGNvbnN0IHNjaGVtYURlcHMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJfX3Byb3RvX19cIilcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBkZXBzID0gQXJyYXkuaXNBcnJheShzY2hlbWFba2V5XSkgPyBwcm9wZXJ0eURlcHMgOiBzY2hlbWFEZXBzO1xuICAgICAgICBkZXBzW2tleV0gPSBzY2hlbWFba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIFtwcm9wZXJ0eURlcHMsIHNjaGVtYURlcHNdO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eURlcHMoY3h0LCBwcm9wZXJ0eURlcHMgPSBjeHQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgaWYgKE9iamVjdC5rZXlzKHByb3BlcnR5RGVwcykubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgbWlzc2luZyA9IGdlbi5sZXQoXCJtaXNzaW5nXCIpO1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wZXJ0eURlcHMpIHtcbiAgICAgICAgY29uc3QgZGVwcyA9IHByb3BlcnR5RGVwc1twcm9wXTtcbiAgICAgICAgaWYgKGRlcHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGhhc1Byb3BlcnR5ID0gKDAsIGNvZGVfMS5wcm9wZXJ0eUluRGF0YSkoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpO1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHtcbiAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgICAgZGVwc0NvdW50OiBkZXBzLmxlbmd0aCxcbiAgICAgICAgICAgIGRlcHM6IGRlcHMuam9pbihcIiwgXCIpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGl0LmFsbEVycm9ycykge1xuICAgICAgICAgICAgZ2VuLmlmKGhhc1Byb3BlcnR5LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkZXBQcm9wIG9mIGRlcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGNvZGVfMS5jaGVja1JlcG9ydE1pc3NpbmdQcm9wKShjeHQsIGRlcFByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7aGFzUHJvcGVydHl9ICYmICgkeygwLCBjb2RlXzEuY2hlY2tNaXNzaW5nUHJvcCkoY3h0LCBkZXBzLCBtaXNzaW5nKX0pYCk7XG4gICAgICAgICAgICAoMCwgY29kZV8xLnJlcG9ydE1pc3NpbmdQcm9wKShjeHQsIG1pc3NpbmcpO1xuICAgICAgICAgICAgZ2VuLmVsc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVQcm9wZXJ0eURlcHMgPSB2YWxpZGF0ZVByb3BlcnR5RGVwcztcbmZ1bmN0aW9uIHZhbGlkYXRlU2NoZW1hRGVwcyhjeHQsIHNjaGVtYURlcHMgPSBjeHQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGtleXdvcmQsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBzY2hlbWFEZXBzKSB7XG4gICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hRGVwc1twcm9wXSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlXzEucHJvcGVydHlJbkRhdGEpKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQsIHNjaGVtYVByb3A6IHByb3AgfSwgdmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoQ3h0LCB2YWxpZCk7XG4gICAgICAgIH0sICgpID0+IGdlbi52YXIodmFsaWQsIHRydWUpIC8vIFRPRE8gdmFyXG4gICAgICAgICk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVNjaGVtYURlcHMgPSB2YWxpZGF0ZVNjaGVtYURlcHM7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXBlbmRlbmNpZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwicHJvcGVydHkgbmFtZSBtdXN0IGJlIHZhbGlkXCIsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXMgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge3Byb3BlcnR5TmFtZTogJHtwYXJhbXMucHJvcGVydHlOYW1lfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInByb3BlcnR5TmFtZXNcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIGdlbi5mb3JJbihcImtleVwiLCBkYXRhLCAoa2V5KSA9PiB7XG4gICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgcHJvcGVydHlOYW1lOiBrZXkgfSk7XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcInByb3BlcnR5TmFtZXNcIixcbiAgICAgICAgICAgICAgICBkYXRhOiBrZXksXG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzOiBbXCJzdHJpbmdcIl0sXG4gICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lOiBrZXksXG4gICAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3h0LmVycm9yKHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghaXQuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgICAgICBnZW4uYnJlYWsoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3BlcnR5TmFtZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvbmFtZXNcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJtdXN0IE5PVCBoYXZlIGFkZGl0aW9uYWwgcHJvcGVydGllc1wiLFxuICAgIHBhcmFtczogKHsgcGFyYW1zIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHthZGRpdGlvbmFsUHJvcGVydHk6ICR7cGFyYW1zLmFkZGl0aW9uYWxQcm9wZXJ0eX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiLFxuICAgIHR5cGU6IFtcIm9iamVjdFwiXSxcbiAgICBzY2hlbWFUeXBlOiBbXCJib29sZWFuXCIsIFwib2JqZWN0XCJdLFxuICAgIGFsbG93VW5kZWZpbmVkOiB0cnVlLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgZGF0YSwgZXJyc0NvdW50LCBpdCB9ID0gY3h0O1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFlcnJzQ291bnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgIGNvbnN0IHsgYWxsRXJyb3JzLCBvcHRzIH0gPSBpdDtcbiAgICAgICAgaXQucHJvcHMgPSB0cnVlO1xuICAgICAgICBpZiAob3B0cy5yZW1vdmVBZGRpdGlvbmFsICE9PSBcImFsbFwiICYmICgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBwcm9wcyA9ICgwLCBjb2RlXzEuYWxsU2NoZW1hUHJvcGVydGllcykocGFyZW50U2NoZW1hLnByb3BlcnRpZXMpO1xuICAgICAgICBjb25zdCBwYXRQcm9wcyA9ICgwLCBjb2RlXzEuYWxsU2NoZW1hUHJvcGVydGllcykocGFyZW50U2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKTtcbiAgICAgICAgY2hlY2tBZGRpdGlvbmFsUHJvcGVydGllcygpO1xuICAgICAgICBjeHQub2soKDAsIGNvZGVnZW5fMS5fKSBgJHtlcnJzQ291bnR9ID09PSAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9YCk7XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrQWRkaXRpb25hbFByb3BlcnRpZXMoKSB7XG4gICAgICAgICAgICBnZW4uZm9ySW4oXCJrZXlcIiwgZGF0YSwgKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcHJvcHMubGVuZ3RoICYmICFwYXRQcm9wcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0eUNvZGUoa2V5KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZihpc0FkZGl0aW9uYWwoa2V5KSwgKCkgPT4gYWRkaXRpb25hbFByb3BlcnR5Q29kZShrZXkpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzQWRkaXRpb25hbChrZXkpIHtcbiAgICAgICAgICAgIGxldCBkZWZpbmVkUHJvcDtcbiAgICAgICAgICAgIGlmIChwcm9wcy5sZW5ndGggPiA4KSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBtYXliZSBhbiBvcHRpb24gaW5zdGVhZCBvZiBoYXJkLWNvZGVkIDg/XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHNTY2hlbWEgPSAoMCwgdXRpbF8xLnNjaGVtYVJlZk9yVmFsKShpdCwgcGFyZW50U2NoZW1hLnByb3BlcnRpZXMsIFwicHJvcGVydGllc1wiKTtcbiAgICAgICAgICAgICAgICBkZWZpbmVkUHJvcCA9ICgwLCBjb2RlXzEuaXNPd25Qcm9wZXJ0eSkoZ2VuLCBwcm9wc1NjaGVtYSwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRlZmluZWRQcm9wID0gKDAsIGNvZGVnZW5fMS5vcikoLi4ucHJvcHMubWFwKChwKSA9PiAoMCwgY29kZWdlbl8xLl8pIGAke2tleX0gPT09ICR7cH1gKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVkUHJvcCA9IGNvZGVnZW5fMS5uaWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0UHJvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lZFByb3AgPSAoMCwgY29kZWdlbl8xLm9yKShkZWZpbmVkUHJvcCwgLi4ucGF0UHJvcHMubWFwKChwKSA9PiAoMCwgY29kZWdlbl8xLl8pIGAkeygwLCBjb2RlXzEudXNlUGF0dGVybikoY3h0LCBwKX0udGVzdCgke2tleX0pYCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEubm90KShkZWZpbmVkUHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGVsZXRlQWRkaXRpb25hbChrZXkpIHtcbiAgICAgICAgICAgIGdlbi5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYGRlbGV0ZSAke2RhdGF9WyR7a2V5fV1gKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhZGRpdGlvbmFsUHJvcGVydHlDb2RlKGtleSkge1xuICAgICAgICAgICAgaWYgKG9wdHMucmVtb3ZlQWRkaXRpb25hbCA9PT0gXCJhbGxcIiB8fCAob3B0cy5yZW1vdmVBZGRpdGlvbmFsICYmIHNjaGVtYSA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlQWRkaXRpb25hbChrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IGFkZGl0aW9uYWxQcm9wZXJ0eToga2V5IH0pO1xuICAgICAgICAgICAgICAgIGN4dC5lcnJvcigpO1xuICAgICAgICAgICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgICAgICBnZW4uYnJlYWsoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiICYmICEoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5yZW1vdmVBZGRpdGlvbmFsID09PSBcImZhaWxpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBhcHBseUFkZGl0aW9uYWxTY2hlbWEoa2V5LCB2YWxpZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3h0LnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVBZGRpdGlvbmFsKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlBZGRpdGlvbmFsU2NoZW1hKGtleSwgdmFsaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbEVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpLCAoKSA9PiBnZW4uYnJlYWsoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5QWRkaXRpb25hbFNjaGVtYShrZXksIHZhbGlkLCBlcnJvcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjaGVtYSA9IHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICAgICAgZGF0YVByb3A6IGtleSxcbiAgICAgICAgICAgICAgICBkYXRhUHJvcFR5cGU6IHV0aWxfMS5UeXBlLlN0cixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZXJyb3JzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc3Vic2NoZW1hLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVycm9yczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGFsbEVycm9yczogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHN1YnNjaGVtYSwgdmFsaWQpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRpdGlvbmFsUHJvcGVydGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHZhbGlkYXRlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9hZGRpdGlvbmFsUHJvcGVydGllc1wiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInByb3BlcnRpZXNcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFwib2JqZWN0XCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAoaXQub3B0cy5yZW1vdmVBZGRpdGlvbmFsID09PSBcImFsbFwiICYmIHBhcmVudFNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllc18xLmRlZmF1bHQuY29kZShuZXcgdmFsaWRhdGVfMS5LZXl3b3JkQ3h0KGl0LCBhZGRpdGlvbmFsUHJvcGVydGllc18xLmRlZmF1bHQsIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFsbFByb3BzID0gKDAsIGNvZGVfMS5hbGxTY2hlbWFQcm9wZXJ0aWVzKShzY2hlbWEpO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgYWxsUHJvcHMpIHtcbiAgICAgICAgICAgIGl0LmRlZmluZWRQcm9wZXJ0aWVzLmFkZChwcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiBhbGxQcm9wcy5sZW5ndGggJiYgaXQucHJvcHMgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgKDAsIHV0aWxfMS50b0hhc2gpKGFsbFByb3BzKSwgaXQucHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBhbGxQcm9wcy5maWx0ZXIoKHApID0+ICEoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hW3BdKSk7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKGhhc0RlZmF1bHQocHJvcCkpIHtcbiAgICAgICAgICAgICAgICBhcHBseVByb3BlcnR5U2NoZW1hKHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlXzEucHJvcGVydHlJbkRhdGEpKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSk7XG4gICAgICAgICAgICAgICAgYXBwbHlQcm9wZXJ0eVNjaGVtYShwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAoIWl0LmFsbEVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmVsc2UoKS52YXIodmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGdlbi5lbmRJZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3h0Lml0LmRlZmluZWRQcm9wZXJ0aWVzLmFkZChwcm9wKTtcbiAgICAgICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaGFzRGVmYXVsdChwcm9wKSB7XG4gICAgICAgICAgICByZXR1cm4gaXQub3B0cy51c2VEZWZhdWx0cyAmJiAhaXQuY29tcG9zaXRlUnVsZSAmJiBzY2hlbWFbcHJvcF0uZGVmYXVsdCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5UHJvcGVydHlTY2hlbWEocHJvcCkge1xuICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJwcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICAgICAgc2NoZW1hUHJvcDogcHJvcCxcbiAgICAgICAgICAgICAgICBkYXRhUHJvcDogcHJvcCxcbiAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvcGVydGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCB1dGlsXzIgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwicGF0dGVyblByb3BlcnRpZXNcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFwib2JqZWN0XCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9wdHMgfSA9IGl0O1xuICAgICAgICBjb25zdCBwYXR0ZXJucyA9ICgwLCBjb2RlXzEuYWxsU2NoZW1hUHJvcGVydGllcykoc2NoZW1hKTtcbiAgICAgICAgY29uc3QgYWx3YXlzVmFsaWRQYXR0ZXJucyA9IHBhdHRlcm5zLmZpbHRlcigocCkgPT4gKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYVtwXSkpO1xuICAgICAgICBpZiAocGF0dGVybnMubGVuZ3RoID09PSAwIHx8XG4gICAgICAgICAgICAoYWx3YXlzVmFsaWRQYXR0ZXJucy5sZW5ndGggPT09IHBhdHRlcm5zLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICghaXQub3B0cy51bmV2YWx1YXRlZCB8fCBpdC5wcm9wcyA9PT0gdHJ1ZSkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hlY2tQcm9wZXJ0aWVzID0gb3B0cy5zdHJpY3RTY2hlbWEgJiYgIW9wdHMuYWxsb3dNYXRjaGluZ1Byb3BlcnRpZXMgJiYgcGFyZW50U2NoZW1hLnByb3BlcnRpZXM7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgaWYgKGl0LnByb3BzICE9PSB0cnVlICYmICEoaXQucHJvcHMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSkpIHtcbiAgICAgICAgICAgIGl0LnByb3BzID0gKDAsIHV0aWxfMi5ldmFsdWF0ZWRQcm9wc1RvTmFtZSkoZ2VuLCBpdC5wcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gaXQ7XG4gICAgICAgIHZhbGlkYXRlUGF0dGVyblByb3BlcnRpZXMoKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVQYXR0ZXJuUHJvcGVydGllcygpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGF0IG9mIHBhdHRlcm5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrUHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tNYXRjaGluZ1Byb3BlcnRpZXMocGF0KTtcbiAgICAgICAgICAgICAgICBpZiAoaXQuYWxsRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLnZhcih2YWxpZCwgdHJ1ZSk7IC8vIFRPRE8gdmFyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uaWYodmFsaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjaGVja01hdGNoaW5nUHJvcGVydGllcyhwYXQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBjaGVja1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3IFJlZ0V4cChwYXQpLnRlc3QocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBgcHJvcGVydHkgJHtwcm9wfSBtYXRjaGVzIHBhdHRlcm4gJHtwYXR9ICh1c2UgYWxsb3dNYXRjaGluZ1Byb3BlcnRpZXMpYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpIHtcbiAgICAgICAgICAgIGdlbi5mb3JJbihcImtleVwiLCBkYXRhLCAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7KDAsIGNvZGVfMS51c2VQYXR0ZXJuKShjeHQsIHBhdCl9LnRlc3QoJHtrZXl9KWAsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWx3YXlzVmFsaWQgPSBhbHdheXNWYWxpZFBhdHRlcm5zLmluY2x1ZGVzKHBhdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWx3YXlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwicGF0dGVyblByb3BlcnRpZXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWFQcm9wOiBwYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVByb3A6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhUHJvcFR5cGU6IHV0aWxfMi5UeXBlLlN0cixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiBwcm9wcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke3Byb3BzfVske2tleX1dYCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWFsd2F5c1ZhbGlkICYmICFpdC5hbGxFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbiBzaG9ydC1jaXJjdWl0IGlmIGB1bmV2YWx1YXRlZFByb3BlcnRpZXNgIGlzIG5vdCBzdXBwb3J0ZWQgKG9wdHMubmV4dCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvciBpZiBhbGwgcHJvcGVydGllcyB3ZXJlIGV2YWx1YXRlZCAocHJvcHMgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4gZ2VuLmJyZWFrKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0dGVyblByb3BlcnRpZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwibm90XCIsXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAoKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGN4dC5mYWlsKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgIGtleXdvcmQ6IFwibm90XCIsXG4gICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgIGFsbEVycm9yczogZmFsc2UsXG4gICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgY3h0LmZhaWxSZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpLCAoKSA9PiBjeHQuZXJyb3IoKSk7XG4gICAgfSxcbiAgICBlcnJvcjogeyBtZXNzYWdlOiBcIm11c3QgTk9UIGJlIHZhbGlkXCIgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImFueU9mXCIsXG4gICAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGNvZGU6IGNvZGVfMS52YWxpZGF0ZVVuaW9uLFxuICAgIGVycm9yOiB7IG1lc3NhZ2U6IFwibXVzdCBtYXRjaCBhIHNjaGVtYSBpbiBhbnlPZlwiIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW55T2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwibXVzdCBtYXRjaCBleGFjdGx5IG9uZSBzY2hlbWEgaW4gb25lT2ZcIixcbiAgICBwYXJhbXM6ICh7IHBhcmFtcyB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7cGFzc2luZ1NjaGVtYXM6ICR7cGFyYW1zLnBhc3Npbmd9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwib25lT2ZcIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgIGlmIChpdC5vcHRzLmRpc2NyaW1pbmF0b3IgJiYgcGFyZW50U2NoZW1hLmRpc2NyaW1pbmF0b3IpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHNjaEFyciA9IHNjaGVtYTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgZmFsc2UpO1xuICAgICAgICBjb25zdCBwYXNzaW5nID0gZ2VuLmxldChcInBhc3NpbmdcIiwgbnVsbCk7XG4gICAgICAgIGNvbnN0IHNjaFZhbGlkID0gZ2VuLm5hbWUoXCJfdmFsaWRcIik7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoeyBwYXNzaW5nIH0pO1xuICAgICAgICAvLyBUT0RPIHBvc3NpYmx5IGZhaWwgc3RyYWlnaHQgYXdheSAod2l0aCB3YXJuaW5nIG9yIGV4Y2VwdGlvbikgaWYgdGhlcmUgYXJlIHR3byBlbXB0eSBhbHdheXMgdmFsaWQgc2NoZW1hc1xuICAgICAgICBnZW4uYmxvY2sodmFsaWRhdGVPbmVPZik7XG4gICAgICAgIGN4dC5yZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZU9uZU9mKCkge1xuICAgICAgICAgICAgc2NoQXJyLmZvckVhY2goKHNjaCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBzY2hDeHQ7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi52YXIoc2NoVmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXl3b3JkOiBcIm9uZU9mXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWFQcm9wOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSwgc2NoVmFsaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAuaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtzY2hWYWxpZH0gJiYgJHt2YWxpZH1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFzc2lnbih2YWxpZCwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXNzaWduKHBhc3NpbmcsICgwLCBjb2RlZ2VuXzEuXykgYFske3Bhc3Npbmd9LCAke2l9XWApXG4gICAgICAgICAgICAgICAgICAgICAgICAuZWxzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZW4uaWYoc2NoVmFsaWQsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24ocGFzc2luZywgaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hDeHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0LCBjb2RlZ2VuXzEuTmFtZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b25lT2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiYWxsT2ZcIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIHNjaGVtYS5mb3JFYWNoKChzY2gsIGkpID0+IHtcbiAgICAgICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHsga2V5d29yZDogXCJhbGxPZlwiLCBzY2hlbWFQcm9wOiBpIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbGxPZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zIH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBtYXRjaCBcIiR7cGFyYW1zLmlmQ2xhdXNlfVwiIHNjaGVtYWAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXMgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2ZhaWxpbmdLZXl3b3JkOiAke3BhcmFtcy5pZkNsYXVzZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpZlwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKHBhcmVudFNjaGVtYS50aGVuID09PSB1bmRlZmluZWQgJiYgcGFyZW50U2NoZW1hLmVsc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCAnXCJpZlwiIHdpdGhvdXQgXCJ0aGVuXCIgYW5kIFwiZWxzZVwiIGlzIGlnbm9yZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNUaGVuID0gaGFzU2NoZW1hKGl0LCBcInRoZW5cIik7XG4gICAgICAgIGNvbnN0IGhhc0Vsc2UgPSBoYXNTY2hlbWEoaXQsIFwiZWxzZVwiKTtcbiAgICAgICAgaWYgKCFoYXNUaGVuICYmICFoYXNFbHNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCB0cnVlKTtcbiAgICAgICAgY29uc3Qgc2NoVmFsaWQgPSBnZW4ubmFtZShcIl92YWxpZFwiKTtcbiAgICAgICAgdmFsaWRhdGVJZigpO1xuICAgICAgICBjeHQucmVzZXQoKTtcbiAgICAgICAgaWYgKGhhc1RoZW4gJiYgaGFzRWxzZSkge1xuICAgICAgICAgICAgY29uc3QgaWZDbGF1c2UgPSBnZW4ubGV0KFwiaWZDbGF1c2VcIik7XG4gICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgaWZDbGF1c2UgfSk7XG4gICAgICAgICAgICBnZW4uaWYoc2NoVmFsaWQsIHZhbGlkYXRlQ2xhdXNlKFwidGhlblwiLCBpZkNsYXVzZSksIHZhbGlkYXRlQ2xhdXNlKFwiZWxzZVwiLCBpZkNsYXVzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhc1RoZW4pIHtcbiAgICAgICAgICAgIGdlbi5pZihzY2hWYWxpZCwgdmFsaWRhdGVDbGF1c2UoXCJ0aGVuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkoc2NoVmFsaWQpLCB2YWxpZGF0ZUNsYXVzZShcImVsc2VcIikpO1xuICAgICAgICB9XG4gICAgICAgIGN4dC5wYXNzKHZhbGlkLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUlmKCkge1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJpZlwiLFxuICAgICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhbGxFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgICAgfSwgc2NoVmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVDbGF1c2Uoa2V5d29yZCwgaWZDbGF1c2UpIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQgfSwgc2NoVmFsaWQpO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHNjaFZhbGlkKTtcbiAgICAgICAgICAgICAgICBjeHQubWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hDeHQsIHZhbGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoaWZDbGF1c2UpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oaWZDbGF1c2UsICgwLCBjb2RlZ2VuXzEuXykgYCR7a2V5d29yZH1gKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBpZkNsYXVzZToga2V5d29yZCB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmZ1bmN0aW9uIGhhc1NjaGVtYShpdCwga2V5d29yZCkge1xuICAgIGNvbnN0IHNjaGVtYSA9IGl0LnNjaGVtYVtrZXl3b3JkXTtcbiAgICByZXR1cm4gc2NoZW1hICE9PSB1bmRlZmluZWQgJiYgISgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFtcInRoZW5cIiwgXCJlbHNlXCJdLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgY29kZSh7IGtleXdvcmQsIHBhcmVudFNjaGVtYSwgaXQgfSkge1xuICAgICAgICBpZiAocGFyZW50U2NoZW1hLmlmID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIGBcIiR7a2V5d29yZH1cIiB3aXRob3V0IFwiaWZcIiBpcyBpZ25vcmVkYCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aGVuRWxzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGFkZGl0aW9uYWxJdGVtc18xID0gcmVxdWlyZShcIi4vYWRkaXRpb25hbEl0ZW1zXCIpO1xuY29uc3QgcHJlZml4SXRlbXNfMSA9IHJlcXVpcmUoXCIuL3ByZWZpeEl0ZW1zXCIpO1xuY29uc3QgaXRlbXNfMSA9IHJlcXVpcmUoXCIuL2l0ZW1zXCIpO1xuY29uc3QgaXRlbXMyMDIwXzEgPSByZXF1aXJlKFwiLi9pdGVtczIwMjBcIik7XG5jb25zdCBjb250YWluc18xID0gcmVxdWlyZShcIi4vY29udGFpbnNcIik7XG5jb25zdCBkZXBlbmRlbmNpZXNfMSA9IHJlcXVpcmUoXCIuL2RlcGVuZGVuY2llc1wiKTtcbmNvbnN0IHByb3BlcnR5TmFtZXNfMSA9IHJlcXVpcmUoXCIuL3Byb3BlcnR5TmFtZXNcIik7XG5jb25zdCBhZGRpdGlvbmFsUHJvcGVydGllc18xID0gcmVxdWlyZShcIi4vYWRkaXRpb25hbFByb3BlcnRpZXNcIik7XG5jb25zdCBwcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9wcm9wZXJ0aWVzXCIpO1xuY29uc3QgcGF0dGVyblByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCIuL3BhdHRlcm5Qcm9wZXJ0aWVzXCIpO1xuY29uc3Qgbm90XzEgPSByZXF1aXJlKFwiLi9ub3RcIik7XG5jb25zdCBhbnlPZl8xID0gcmVxdWlyZShcIi4vYW55T2ZcIik7XG5jb25zdCBvbmVPZl8xID0gcmVxdWlyZShcIi4vb25lT2ZcIik7XG5jb25zdCBhbGxPZl8xID0gcmVxdWlyZShcIi4vYWxsT2ZcIik7XG5jb25zdCBpZl8xID0gcmVxdWlyZShcIi4vaWZcIik7XG5jb25zdCB0aGVuRWxzZV8xID0gcmVxdWlyZShcIi4vdGhlbkVsc2VcIik7XG5mdW5jdGlvbiBnZXRBcHBsaWNhdG9yKGRyYWZ0MjAyMCA9IGZhbHNlKSB7XG4gICAgY29uc3QgYXBwbGljYXRvciA9IFtcbiAgICAgICAgLy8gYW55XG4gICAgICAgIG5vdF8xLmRlZmF1bHQsXG4gICAgICAgIGFueU9mXzEuZGVmYXVsdCxcbiAgICAgICAgb25lT2ZfMS5kZWZhdWx0LFxuICAgICAgICBhbGxPZl8xLmRlZmF1bHQsXG4gICAgICAgIGlmXzEuZGVmYXVsdCxcbiAgICAgICAgdGhlbkVsc2VfMS5kZWZhdWx0LFxuICAgICAgICAvLyBvYmplY3RcbiAgICAgICAgcHJvcGVydHlOYW1lc18xLmRlZmF1bHQsXG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEuZGVmYXVsdCxcbiAgICAgICAgZGVwZW5kZW5jaWVzXzEuZGVmYXVsdCxcbiAgICAgICAgcHJvcGVydGllc18xLmRlZmF1bHQsXG4gICAgICAgIHBhdHRlcm5Qcm9wZXJ0aWVzXzEuZGVmYXVsdCxcbiAgICBdO1xuICAgIC8vIGFycmF5XG4gICAgaWYgKGRyYWZ0MjAyMClcbiAgICAgICAgYXBwbGljYXRvci5wdXNoKHByZWZpeEl0ZW1zXzEuZGVmYXVsdCwgaXRlbXMyMDIwXzEuZGVmYXVsdCk7XG4gICAgZWxzZVxuICAgICAgICBhcHBsaWNhdG9yLnB1c2goYWRkaXRpb25hbEl0ZW1zXzEuZGVmYXVsdCwgaXRlbXNfMS5kZWZhdWx0KTtcbiAgICBhcHBsaWNhdG9yLnB1c2goY29udGFpbnNfMS5kZWZhdWx0KTtcbiAgICByZXR1cm4gYXBwbGljYXRvcjtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGdldEFwcGxpY2F0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBtYXRjaCBmb3JtYXQgXCIke3NjaGVtYUNvZGV9XCJgLFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7Zm9ybWF0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiZm9ybWF0XCIsXG4gICAgdHlwZTogW1wibnVtYmVyXCIsIFwic3RyaW5nXCJdLFxuICAgIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQsIHJ1bGVUeXBlKSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9wdHMsIGVyclNjaGVtYVBhdGgsIHNjaGVtYUVudiwgc2VsZiB9ID0gaXQ7XG4gICAgICAgIGlmICghb3B0cy52YWxpZGF0ZUZvcm1hdHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICgkZGF0YSlcbiAgICAgICAgICAgIHZhbGlkYXRlJERhdGFGb3JtYXQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmFsaWRhdGVGb3JtYXQoKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGUkRGF0YUZvcm1hdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZtdHMgPSBnZW4uc2NvcGVWYWx1ZShcImZvcm1hdHNcIiwge1xuICAgICAgICAgICAgICAgIHJlZjogc2VsZi5mb3JtYXRzLFxuICAgICAgICAgICAgICAgIGNvZGU6IG9wdHMuY29kZS5mb3JtYXRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBmRGVmID0gZ2VuLmNvbnN0KFwiZkRlZlwiLCAoMCwgY29kZWdlbl8xLl8pIGAke2ZtdHN9WyR7c2NoZW1hQ29kZX1dYCk7XG4gICAgICAgICAgICBjb25zdCBmVHlwZSA9IGdlbi5sZXQoXCJmVHlwZVwiKTtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdCA9IGdlbi5sZXQoXCJmb3JtYXRcIik7XG4gICAgICAgICAgICAvLyBUT0RPIHNpbXBsaWZ5XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7ZkRlZn0gPT0gXCJvYmplY3RcIiAmJiAhKCR7ZkRlZn0gaW5zdGFuY2VvZiBSZWdFeHApYCwgKCkgPT4gZ2VuLmFzc2lnbihmVHlwZSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtmRGVmfS50eXBlIHx8IFwic3RyaW5nXCJgKS5hc3NpZ24oZm9ybWF0LCAoMCwgY29kZWdlbl8xLl8pIGAke2ZEZWZ9LnZhbGlkYXRlYCksICgpID0+IGdlbi5hc3NpZ24oZlR5cGUsICgwLCBjb2RlZ2VuXzEuXykgYFwic3RyaW5nXCJgKS5hc3NpZ24oZm9ybWF0LCBmRGVmKSk7XG4gICAgICAgICAgICBjeHQuZmFpbCRkYXRhKCgwLCBjb2RlZ2VuXzEub3IpKHVua25vd25GbXQoKSwgaW52YWxpZEZtdCgpKSk7XG4gICAgICAgICAgICBmdW5jdGlvbiB1bmtub3duRm10KCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLnN0cmljdFNjaGVtYSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEubmlsO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYUNvZGV9ICYmICEke2Zvcm1hdH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gaW52YWxpZEZtdCgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsRm9ybWF0ID0gc2NoZW1hRW52LiRhc3luY1xuICAgICAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuXykgYCgke2ZEZWZ9LmFzeW5jID8gYXdhaXQgJHtmb3JtYXR9KCR7ZGF0YX0pIDogJHtmb3JtYXR9KCR7ZGF0YX0pKWBcbiAgICAgICAgICAgICAgICAgICAgOiAoMCwgY29kZWdlbl8xLl8pIGAke2Zvcm1hdH0oJHtkYXRhfSlgO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkRGF0YSA9ICgwLCBjb2RlZ2VuXzEuXykgYCh0eXBlb2YgJHtmb3JtYXR9ID09IFwiZnVuY3Rpb25cIiA/ICR7Y2FsbEZvcm1hdH0gOiAke2Zvcm1hdH0udGVzdCgke2RhdGF9KSlgO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAke2Zvcm1hdH0gJiYgJHtmb3JtYXR9ICE9PSB0cnVlICYmICR7ZlR5cGV9ID09PSAke3J1bGVUeXBlfSAmJiAhJHt2YWxpZERhdGF9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdERlZiA9IHNlbGYuZm9ybWF0c1tzY2hlbWFdO1xuICAgICAgICAgICAgaWYgKCFmb3JtYXREZWYpIHtcbiAgICAgICAgICAgICAgICB1bmtub3duRm9ybWF0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdERlZiA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBbZm10VHlwZSwgZm9ybWF0LCBmbXRSZWZdID0gZ2V0Rm9ybWF0KGZvcm1hdERlZik7XG4gICAgICAgICAgICBpZiAoZm10VHlwZSA9PT0gcnVsZVR5cGUpXG4gICAgICAgICAgICAgICAgY3h0LnBhc3ModmFsaWRDb25kaXRpb24oKSk7XG4gICAgICAgICAgICBmdW5jdGlvbiB1bmtub3duRm9ybWF0KCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLnN0cmljdFNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2dnZXIud2Fybih1bmtub3duTXNnKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih1bmtub3duTXNnKCkpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVua25vd25Nc2coKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgdW5rbm93biBmb3JtYXQgXCIke3NjaGVtYX1cIiBpZ25vcmVkIGluIHNjaGVtYSBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRGb3JtYXQoZm10RGVmKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IGZtdERlZiBpbnN0YW5jZW9mIFJlZ0V4cFxuICAgICAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEucmVnZXhwQ29kZSkoZm10RGVmKVxuICAgICAgICAgICAgICAgICAgICA6IG9wdHMuY29kZS5mb3JtYXRzXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7b3B0cy5jb2RlLmZvcm1hdHN9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShzY2hlbWEpfWBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZtdCA9IGdlbi5zY29wZVZhbHVlKFwiZm9ybWF0c1wiLCB7IGtleTogc2NoZW1hLCByZWY6IGZtdERlZiwgY29kZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZtdERlZiA9PSBcIm9iamVjdFwiICYmICEoZm10RGVmIGluc3RhbmNlb2YgUmVnRXhwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2ZtdERlZi50eXBlIHx8IFwic3RyaW5nXCIsIGZtdERlZi52YWxpZGF0ZSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtmbXR9LnZhbGlkYXRlYF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJzdHJpbmdcIiwgZm10RGVmLCBmbXRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gdmFsaWRDb25kaXRpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXREZWYgPT0gXCJvYmplY3RcIiAmJiAhKGZvcm1hdERlZiBpbnN0YW5jZW9mIFJlZ0V4cCkgJiYgZm9ybWF0RGVmLmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2NoZW1hRW52LiRhc3luYylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFzeW5jIGZvcm1hdCBpbiBzeW5jIHNjaGVtYVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYGF3YWl0ICR7Zm10UmVmfSgke2RhdGF9KWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZm9ybWF0ID09IFwiZnVuY3Rpb25cIiA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7Zm10UmVmfSgke2RhdGF9KWAgOiAoMCwgY29kZWdlbl8xLl8pIGAke2ZtdFJlZn0udGVzdCgke2RhdGF9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGZvcm1hdF8xID0gcmVxdWlyZShcIi4vZm9ybWF0XCIpO1xuY29uc3QgZm9ybWF0ID0gW2Zvcm1hdF8xLmRlZmF1bHRdO1xuZXhwb3J0cy5kZWZhdWx0ID0gZm9ybWF0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbnRlbnRWb2NhYnVsYXJ5ID0gZXhwb3J0cy5tZXRhZGF0YVZvY2FidWxhcnkgPSB2b2lkIDA7XG5leHBvcnRzLm1ldGFkYXRhVm9jYWJ1bGFyeSA9IFtcbiAgICBcInRpdGxlXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiLFxuICAgIFwiZGVmYXVsdFwiLFxuICAgIFwiZGVwcmVjYXRlZFwiLFxuICAgIFwicmVhZE9ubHlcIixcbiAgICBcIndyaXRlT25seVwiLFxuICAgIFwiZXhhbXBsZXNcIixcbl07XG5leHBvcnRzLmNvbnRlbnRWb2NhYnVsYXJ5ID0gW1xuICAgIFwiY29udGVudE1lZGlhVHlwZVwiLFxuICAgIFwiY29udGVudEVuY29kaW5nXCIsXG4gICAgXCJjb250ZW50U2NoZW1hXCIsXG5dO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0YWRhdGEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuY29uc3QgdmFsaWRhdGlvbl8xID0gcmVxdWlyZShcIi4vdmFsaWRhdGlvblwiKTtcbmNvbnN0IGFwcGxpY2F0b3JfMSA9IHJlcXVpcmUoXCIuL2FwcGxpY2F0b3JcIik7XG5jb25zdCBmb3JtYXRfMSA9IHJlcXVpcmUoXCIuL2Zvcm1hdFwiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGRyYWZ0N1ZvY2FidWxhcmllcyA9IFtcbiAgICBjb3JlXzEuZGVmYXVsdCxcbiAgICB2YWxpZGF0aW9uXzEuZGVmYXVsdCxcbiAgICAoMCwgYXBwbGljYXRvcl8xLmRlZmF1bHQpKCksXG4gICAgZm9ybWF0XzEuZGVmYXVsdCxcbiAgICBtZXRhZGF0YV8xLm1ldGFkYXRhVm9jYWJ1bGFyeSxcbiAgICBtZXRhZGF0YV8xLmNvbnRlbnRWb2NhYnVsYXJ5LFxuXTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRyYWZ0N1ZvY2FidWxhcmllcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyYWZ0Ny5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGlzY3JFcnJvciA9IHZvaWQgMDtcbnZhciBEaXNjckVycm9yO1xuKGZ1bmN0aW9uIChEaXNjckVycm9yKSB7XG4gICAgRGlzY3JFcnJvcltcIlRhZ1wiXSA9IFwidGFnXCI7XG4gICAgRGlzY3JFcnJvcltcIk1hcHBpbmdcIl0gPSBcIm1hcHBpbmdcIjtcbn0pKERpc2NyRXJyb3IgfHwgKGV4cG9ydHMuRGlzY3JFcnJvciA9IERpc2NyRXJyb3IgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi9kaXNjcmltaW5hdG9yL3R5cGVzXCIpO1xuY29uc3QgY29tcGlsZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGVcIik7XG5jb25zdCByZWZfZXJyb3JfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3JlZl9lcnJvclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgZGlzY3JFcnJvciwgdGFnTmFtZSB9IH0pID0+IGRpc2NyRXJyb3IgPT09IHR5cGVzXzEuRGlzY3JFcnJvci5UYWdcbiAgICAgICAgPyBgdGFnIFwiJHt0YWdOYW1lfVwiIG11c3QgYmUgc3RyaW5nYFxuICAgICAgICA6IGB2YWx1ZSBvZiB0YWcgXCIke3RhZ05hbWV9XCIgbXVzdCBiZSBpbiBvbmVPZmAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgZGlzY3JFcnJvciwgdGFnLCB0YWdOYW1lIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2Vycm9yOiAke2Rpc2NyRXJyb3J9LCB0YWc6ICR7dGFnTmFtZX0sIHRhZ1ZhbHVlOiAke3RhZ319YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJkaXNjcmltaW5hdG9yXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm9iamVjdFwiLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBvbmVPZiB9ID0gcGFyZW50U2NoZW1hO1xuICAgICAgICBpZiAoIWl0Lm9wdHMuZGlzY3JpbWluYXRvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogcmVxdWlyZXMgZGlzY3JpbWluYXRvciBvcHRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFnTmFtZSA9IHNjaGVtYS5wcm9wZXJ0eU5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgdGFnTmFtZSAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogcmVxdWlyZXMgcHJvcGVydHlOYW1lXCIpO1xuICAgICAgICBpZiAoc2NoZW1hLm1hcHBpbmcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiBtYXBwaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIGlmICghb25lT2YpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiByZXF1aXJlcyBvbmVPZiBrZXl3b3JkXCIpO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IHRhZyA9IGdlbi5jb25zdChcInRhZ1wiLCAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KSh0YWdOYW1lKX1gKTtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke3RhZ30gPT0gXCJzdHJpbmdcImAsICgpID0+IHZhbGlkYXRlTWFwcGluZygpLCAoKSA9PiBjeHQuZXJyb3IoZmFsc2UsIHsgZGlzY3JFcnJvcjogdHlwZXNfMS5EaXNjckVycm9yLlRhZywgdGFnLCB0YWdOYW1lIH0pKTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVNYXBwaW5nKCkge1xuICAgICAgICAgICAgY29uc3QgbWFwcGluZyA9IGdldE1hcHBpbmcoKTtcbiAgICAgICAgICAgIGdlbi5pZihmYWxzZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRhZ1ZhbHVlIGluIG1hcHBpbmcpIHtcbiAgICAgICAgICAgICAgICBnZW4uZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7dGFnfSA9PT0gJHt0YWdWYWx1ZX1gKTtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBhcHBseVRhZ1NjaGVtYShtYXBwaW5nW3RhZ1ZhbHVlXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuLmVsc2UoKTtcbiAgICAgICAgICAgIGN4dC5lcnJvcihmYWxzZSwgeyBkaXNjckVycm9yOiB0eXBlc18xLkRpc2NyRXJyb3IuTWFwcGluZywgdGFnLCB0YWdOYW1lIH0pO1xuICAgICAgICAgICAgZ2VuLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYXBwbHlUYWdTY2hlbWEoc2NoZW1hUHJvcCkge1xuICAgICAgICAgICAgY29uc3QgX3ZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoeyBrZXl3b3JkOiBcIm9uZU9mXCIsIHNjaGVtYVByb3AgfSwgX3ZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQsIGNvZGVnZW5fMS5OYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBfdmFsaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0TWFwcGluZygpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IG9uZU9mTWFwcGluZyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgdG9wUmVxdWlyZWQgPSBoYXNSZXF1aXJlZChwYXJlbnRTY2hlbWEpO1xuICAgICAgICAgICAgbGV0IHRhZ1JlcXVpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb25lT2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgc2NoID0gb25lT2ZbaV07XG4gICAgICAgICAgICAgICAgaWYgKChzY2ggPT09IG51bGwgfHwgc2NoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2guJHJlZikgJiYgISgwLCB1dGlsXzEuc2NoZW1hSGFzUnVsZXNCdXRSZWYpKHNjaCwgaXQuc2VsZi5SVUxFUykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmID0gc2NoLiRyZWY7XG4gICAgICAgICAgICAgICAgICAgIHNjaCA9IGNvbXBpbGVfMS5yZXNvbHZlUmVmLmNhbGwoaXQuc2VsZiwgaXQuc2NoZW1hRW52LnJvb3QsIGl0LmJhc2VJZCwgcmVmKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaCBpbnN0YW5jZW9mIGNvbXBpbGVfMS5TY2hlbWFFbnYpXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2ggPSBzY2guc2NoZW1hO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcmVmX2Vycm9yXzEuZGVmYXVsdChpdC5vcHRzLnVyaVJlc29sdmVyLCBpdC5iYXNlSWQsIHJlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BTY2ggPSAoX2EgPSBzY2ggPT09IG51bGwgfHwgc2NoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2gucHJvcGVydGllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW3RhZ05hbWVdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcFNjaCAhPSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlzY3JpbWluYXRvcjogb25lT2Ygc3Vic2NoZW1hcyAob3IgcmVmZXJlbmNlZCBzY2hlbWFzKSBtdXN0IGhhdmUgXCJwcm9wZXJ0aWVzLyR7dGFnTmFtZX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YWdSZXF1aXJlZCA9IHRhZ1JlcXVpcmVkICYmICh0b3BSZXF1aXJlZCB8fCBoYXNSZXF1aXJlZChzY2gpKTtcbiAgICAgICAgICAgICAgICBhZGRNYXBwaW5ncyhwcm9wU2NoLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGFnUmVxdWlyZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaXNjcmltaW5hdG9yOiBcIiR7dGFnTmFtZX1cIiBtdXN0IGJlIHJlcXVpcmVkYCk7XG4gICAgICAgICAgICByZXR1cm4gb25lT2ZNYXBwaW5nO1xuICAgICAgICAgICAgZnVuY3Rpb24gaGFzUmVxdWlyZWQoeyByZXF1aXJlZCB9KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocmVxdWlyZWQpICYmIHJlcXVpcmVkLmluY2x1ZGVzKHRhZ05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkTWFwcGluZ3Moc2NoLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaC5jb25zdCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRNYXBwaW5nKHNjaC5jb25zdCwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjaC5lbnVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdGFnVmFsdWUgb2Ygc2NoLmVudW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE1hcHBpbmcodGFnVmFsdWUsIGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpc2NyaW1pbmF0b3I6IFwicHJvcGVydGllcy8ke3RhZ05hbWV9XCIgbXVzdCBoYXZlIFwiY29uc3RcIiBvciBcImVudW1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmcodGFnVmFsdWUsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhZ1ZhbHVlICE9IFwic3RyaW5nXCIgfHwgdGFnVmFsdWUgaW4gb25lT2ZNYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlzY3JpbWluYXRvcjogXCIke3RhZ05hbWV9XCIgdmFsdWVzIG11c3QgYmUgdW5pcXVlIHN0cmluZ3NgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb25lT2ZNYXBwaW5nW3RhZ1ZhbHVlXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NaXNzaW5nUmVmRXJyb3IgPSBleHBvcnRzLlZhbGlkYXRpb25FcnJvciA9IGV4cG9ydHMuQ29kZUdlbiA9IGV4cG9ydHMuTmFtZSA9IGV4cG9ydHMubmlsID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMuXyA9IGV4cG9ydHMuS2V5d29yZEN4dCA9IGV4cG9ydHMuQWp2ID0gdm9pZCAwO1xuY29uc3QgY29yZV8xID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbmNvbnN0IGRyYWZ0N18xID0gcmVxdWlyZShcIi4vdm9jYWJ1bGFyaWVzL2RyYWZ0N1wiKTtcbmNvbnN0IGRpc2NyaW1pbmF0b3JfMSA9IHJlcXVpcmUoXCIuL3ZvY2FidWxhcmllcy9kaXNjcmltaW5hdG9yXCIpO1xuY29uc3QgZHJhZnQ3TWV0YVNjaGVtYSA9IHJlcXVpcmUoXCIuL3JlZnMvanNvbi1zY2hlbWEtZHJhZnQtMDcuanNvblwiKTtcbmNvbnN0IE1FVEFfU1VQUE9SVF9EQVRBID0gW1wiL3Byb3BlcnRpZXNcIl07XG5jb25zdCBNRVRBX1NDSEVNQV9JRCA9IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWFcIjtcbmNsYXNzIEFqdiBleHRlbmRzIGNvcmVfMS5kZWZhdWx0IHtcbiAgICBfYWRkVm9jYWJ1bGFyaWVzKCkge1xuICAgICAgICBzdXBlci5fYWRkVm9jYWJ1bGFyaWVzKCk7XG4gICAgICAgIGRyYWZ0N18xLmRlZmF1bHQuZm9yRWFjaCgodikgPT4gdGhpcy5hZGRWb2NhYnVsYXJ5KHYpKTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5kaXNjcmltaW5hdG9yKVxuICAgICAgICAgICAgdGhpcy5hZGRLZXl3b3JkKGRpc2NyaW1pbmF0b3JfMS5kZWZhdWx0KTtcbiAgICB9XG4gICAgX2FkZERlZmF1bHRNZXRhU2NoZW1hKCkge1xuICAgICAgICBzdXBlci5fYWRkRGVmYXVsdE1ldGFTY2hlbWEoKTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdHMubWV0YSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbWV0YVNjaGVtYSA9IHRoaXMub3B0cy4kZGF0YVxuICAgICAgICAgICAgPyB0aGlzLiRkYXRhTWV0YVNjaGVtYShkcmFmdDdNZXRhU2NoZW1hLCBNRVRBX1NVUFBPUlRfREFUQSlcbiAgICAgICAgICAgIDogZHJhZnQ3TWV0YVNjaGVtYTtcbiAgICAgICAgdGhpcy5hZGRNZXRhU2NoZW1hKG1ldGFTY2hlbWEsIE1FVEFfU0NIRU1BX0lELCBmYWxzZSk7XG4gICAgICAgIHRoaXMucmVmc1tcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvc2NoZW1hXCJdID0gTUVUQV9TQ0hFTUFfSUQ7XG4gICAgfVxuICAgIGRlZmF1bHRNZXRhKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMub3B0cy5kZWZhdWx0TWV0YSA9XG4gICAgICAgICAgICBzdXBlci5kZWZhdWx0TWV0YSgpIHx8ICh0aGlzLmdldFNjaGVtYShNRVRBX1NDSEVNQV9JRCkgPyBNRVRBX1NDSEVNQV9JRCA6IHVuZGVmaW5lZCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQWp2ID0gQWp2O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQWp2O1xubW9kdWxlLmV4cG9ydHMuQWp2ID0gQWp2O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQWp2O1xudmFyIHZhbGlkYXRlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3ZhbGlkYXRlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiS2V5d29yZEN4dFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsaWRhdGVfMS5LZXl3b3JkQ3h0OyB9IH0pO1xudmFyIGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvY29kZWdlblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5fOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuc3RyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaW5naWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuc3RyaW5naWZ5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmlsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEubmlsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLk5hbWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb2RlR2VuXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuQ29kZUdlbjsgfSB9KTtcbnZhciB2YWxpZGF0aW9uX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWYWxpZGF0aW9uRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRpb25fZXJyb3JfMS5kZWZhdWx0OyB9IH0pO1xudmFyIHJlZl9lcnJvcl8xID0gcmVxdWlyZShcIi4vY29tcGlsZS9yZWZfZXJyb3JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNaXNzaW5nUmVmRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZl9lcnJvcl8xLmRlZmF1bHQ7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hanYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZvcm1hdE5hbWVzID0gZXhwb3J0cy5mYXN0Rm9ybWF0cyA9IGV4cG9ydHMuZnVsbEZvcm1hdHMgPSB2b2lkIDA7XG5mdW5jdGlvbiBmbXREZWYodmFsaWRhdGUsIGNvbXBhcmUpIHtcbiAgICByZXR1cm4geyB2YWxpZGF0ZSwgY29tcGFyZSB9O1xufVxuZXhwb3J0cy5mdWxsRm9ybWF0cyA9IHtcbiAgICAvLyBkYXRlOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gICAgZGF0ZTogZm10RGVmKGRhdGUsIGNvbXBhcmVEYXRlKSxcbiAgICAvLyBkYXRlLXRpbWU6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgICB0aW1lOiBmbXREZWYoZ2V0VGltZSh0cnVlKSwgY29tcGFyZVRpbWUpLFxuICAgIFwiZGF0ZS10aW1lXCI6IGZtdERlZihnZXREYXRlVGltZSh0cnVlKSwgY29tcGFyZURhdGVUaW1lKSxcbiAgICBcImlzby10aW1lXCI6IGZtdERlZihnZXRUaW1lKCksIGNvbXBhcmVJc29UaW1lKSxcbiAgICBcImlzby1kYXRlLXRpbWVcIjogZm10RGVmKGdldERhdGVUaW1lKCksIGNvbXBhcmVJc29EYXRlVGltZSksXG4gICAgLy8gZHVyYXRpb246IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I2FwcGVuZGl4LUFcbiAgICBkdXJhdGlvbjogL15QKD8hJCkoKFxcZCtZKT8oXFxkK00pPyhcXGQrRCk/KFQoPz1cXGQpKFxcZCtIKT8oXFxkK00pPyhcXGQrUyk/KT98KFxcZCtXKT8pJC8sXG4gICAgdXJpLFxuICAgIFwidXJpLXJlZmVyZW5jZVwiOiAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KT8oPzpcXC8/XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol18JVswLTlhLWZdezJ9KSpAKT8oPzpcXFsoPzooPzooPzooPzpbMC05YS1mXXsxLDR9Oil7Nn18OjooPzpbMC05YS1mXXsxLDR9Oil7NX18KD86WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7NH18KD86KD86WzAtOWEtZl17MSw0fTopezAsMX1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXszfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwyfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezJ9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDN9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9OnwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw0fVswLTlhLWZdezEsNH0pPzo6KSg/OlswLTlhLWZdezEsNH06WzAtOWEtZl17MSw0fXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykpfCg/Oig/OlswLTlhLWZdezEsNH06KXswLDV9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDZ9WzAtOWEtZl17MSw0fSk/OjopfFtWdl1bMC05YS1mXStcXC5bYS16MC05XFwtLl9+ISQmJygpKissOz06XSspXFxdfCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KXwoPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PV18JVswLTlhLWZdezJ9KSopKD86OlxcZCopPyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSp8XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT98KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT8oPzpcXD8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8oPzojKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/JC9pLFxuICAgIC8vIHVyaS10ZW1wbGF0ZTogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY1NzBcbiAgICBcInVyaS10ZW1wbGF0ZVwiOiAvXig/Oig/OlteXFx4MDAtXFx4MjBcIic8PiVcXFxcXmB7fH1dfCVbMC05YS1mXXsyfSl8XFx7WysjLi87PyY9LCFAfF0/KD86W2EtejAtOV9dfCVbMC05YS1mXXsyfSkrKD86OlsxLTldWzAtOV17MCwzfXxcXCopPyg/OiwoPzpbYS16MC05X118JVswLTlhLWZdezJ9KSsoPzo6WzEtOV1bMC05XXswLDN9fFxcKik/KSpcXH0pKiQvaSxcbiAgICAvLyBGb3IgdGhlIHNvdXJjZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZHBlcmluaS83MjkyOTRcbiAgICAvLyBGb3IgdGVzdCBjYXNlczogaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL2RlbW8vdXJsLXJlZ2V4XG4gICAgdXJsOiAvXig/Omh0dHBzP3xmdHApOlxcL1xcLyg/OlxcUysoPzo6XFxTKik/QCk/KD86KD8hKD86MTB8MTI3KSg/OlxcLlxcZHsxLDN9KXszfSkoPyEoPzoxNjlcXC4yNTR8MTkyXFwuMTY4KSg/OlxcLlxcZHsxLDN9KXsyfSkoPyExNzJcXC4oPzoxWzYtOV18MlxcZHwzWzAtMV0pKD86XFwuXFxkezEsM30pezJ9KSg/OlsxLTldXFxkP3wxXFxkXFxkfDJbMDFdXFxkfDIyWzAtM10pKD86XFwuKD86MT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkpezJ9KD86XFwuKD86WzEtOV1cXGQ/fDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNF0pKXwoPzooPzpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rLSkqW2EtejAtOVxcdXswMGExfS1cXHV7ZmZmZn1dKykoPzpcXC4oPzpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rLSkqW2EtejAtOVxcdXswMGExfS1cXHV7ZmZmZn1dKykqKD86XFwuKD86W2EtelxcdXswMGExfS1cXHV7ZmZmZn1dezIsfSkpKSg/OjpcXGR7Miw1fSk/KD86XFwvW15cXHNdKik/JC9pdSxcbiAgICBlbWFpbDogL15bYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKD86XFwuW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKykqQCg/OlthLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT9cXC4pK1thLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT8kL2ksXG4gICAgaG9zdG5hbWU6IC9eKD89LnsxLDI1M31cXC4/JClbYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8oPzpcXC5bYS16MC05XSg/OlstMC05YS16XXswLDYxfVswLTlhLXpdKT8pKlxcLj8kL2ksXG4gICAgLy8gb3B0aW1pemVkIGh0dHBzOi8vd3d3LnNhZmFyaWJvb2tzb25saW5lLmNvbS9saWJyYXJ5L3ZpZXcvcmVndWxhci1leHByZXNzaW9ucy1jb29rYm9vay85NzgwNTk2ODAyODM3L2NoMDdzMTYuaHRtbFxuICAgIGlwdjQ6IC9eKD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSQvLFxuICAgIGlwdjY6IC9eKCgoWzAtOWEtZl17MSw0fTopezd9KFswLTlhLWZdezEsNH18OikpfCgoWzAtOWEtZl17MSw0fTopezZ9KDpbMC05YS1mXXsxLDR9fCgoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KChbMC05YS1mXXsxLDR9Oil7NX0oKCg6WzAtOWEtZl17MSw0fSl7MSwyfSl8OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KChbMC05YS1mXXsxLDR9Oil7NH0oKCg6WzAtOWEtZl17MSw0fSl7MSwzfSl8KCg6WzAtOWEtZl17MSw0fSk/OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOWEtZl17MSw0fTopezN9KCgoOlswLTlhLWZdezEsNH0pezEsNH0pfCgoOlswLTlhLWZdezEsNH0pezAsMn06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05YS1mXXsxLDR9Oil7Mn0oKCg6WzAtOWEtZl17MSw0fSl7MSw1fSl8KCg6WzAtOWEtZl17MSw0fSl7MCwzfTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlhLWZdezEsNH06KXsxfSgoKDpbMC05YS1mXXsxLDR9KXsxLDZ9KXwoKDpbMC05YS1mXXsxLDR9KXswLDR9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCg6KCgoOlswLTlhLWZdezEsNH0pezEsN30pfCgoOlswLTlhLWZdezEsNH0pezAsNX06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSkpJC9pLFxuICAgIHJlZ2V4LFxuICAgIC8vIHV1aWQ6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQxMjJcbiAgICB1dWlkOiAvXig/OnVybjp1dWlkOik/WzAtOWEtZl17OH0tKD86WzAtOWEtZl17NH0tKXszfVswLTlhLWZdezEyfSQvaSxcbiAgICAvLyBKU09OLXBvaW50ZXI6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2OTAxXG4gICAgLy8gdXJpIGZyYWdtZW50OiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNhcHBlbmRpeC1BXG4gICAgXCJqc29uLXBvaW50ZXJcIjogL14oPzpcXC8oPzpbXn4vXXx+MHx+MSkqKSokLyxcbiAgICBcImpzb24tcG9pbnRlci11cmktZnJhZ21lbnRcIjogL14jKD86XFwvKD86W2EtejAtOV9cXC0uISQmJygpKissOzo9QF18JVswLTlhLWZdezJ9fH4wfH4xKSopKiQvaSxcbiAgICAvLyByZWxhdGl2ZSBKU09OLXBvaW50ZXI6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWx1ZmYtcmVsYXRpdmUtanNvbi1wb2ludGVyLTAwXG4gICAgXCJyZWxhdGl2ZS1qc29uLXBvaW50ZXJcIjogL14oPzowfFsxLTldWzAtOV0qKSg/OiN8KD86XFwvKD86W15+L118fjB8fjEpKikqKSQvLFxuICAgIC8vIHRoZSBmb2xsb3dpbmcgZm9ybWF0cyBhcmUgdXNlZCBieSB0aGUgb3BlbmFwaSBzcGVjaWZpY2F0aW9uOiBodHRwczovL3NwZWMub3BlbmFwaXMub3JnL29hcy92My4wLjAjZGF0YS10eXBlc1xuICAgIC8vIGJ5dGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9taWd1ZWxtb3RhL2lzLWJhc2U2NFxuICAgIGJ5dGUsXG4gICAgLy8gc2lnbmVkIDMyIGJpdCBpbnRlZ2VyXG4gICAgaW50MzI6IHsgdHlwZTogXCJudW1iZXJcIiwgdmFsaWRhdGU6IHZhbGlkYXRlSW50MzIgfSxcbiAgICAvLyBzaWduZWQgNjQgYml0IGludGVnZXJcbiAgICBpbnQ2NDogeyB0eXBlOiBcIm51bWJlclwiLCB2YWxpZGF0ZTogdmFsaWRhdGVJbnQ2NCB9LFxuICAgIC8vIEMtdHlwZSBmbG9hdFxuICAgIGZsb2F0OiB7IHR5cGU6IFwibnVtYmVyXCIsIHZhbGlkYXRlOiB2YWxpZGF0ZU51bWJlciB9LFxuICAgIC8vIEMtdHlwZSBkb3VibGVcbiAgICBkb3VibGU6IHsgdHlwZTogXCJudW1iZXJcIiwgdmFsaWRhdGU6IHZhbGlkYXRlTnVtYmVyIH0sXG4gICAgLy8gaGludCB0byB0aGUgVUkgdG8gaGlkZSBpbnB1dCBzdHJpbmdzXG4gICAgcGFzc3dvcmQ6IHRydWUsXG4gICAgLy8gdW5jaGVja2VkIHN0cmluZyBwYXlsb2FkXG4gICAgYmluYXJ5OiB0cnVlLFxufTtcbmV4cG9ydHMuZmFzdEZvcm1hdHMgPSB7XG4gICAgLi4uZXhwb3J0cy5mdWxsRm9ybWF0cyxcbiAgICBkYXRlOiBmbXREZWYoL15cXGRcXGRcXGRcXGQtWzAtMV1cXGQtWzAtM11cXGQkLywgY29tcGFyZURhdGUpLFxuICAgIHRpbWU6IGZtdERlZigvXig/OlswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkfDIzOjU5OjYwKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pJC9pLCBjb21wYXJlVGltZSksXG4gICAgXCJkYXRlLXRpbWVcIjogZm10RGVmKC9eXFxkXFxkXFxkXFxkLVswLTFdXFxkLVswLTNdXFxkdCg/OlswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkfDIzOjU5OjYwKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pJC9pLCBjb21wYXJlRGF0ZVRpbWUpLFxuICAgIFwiaXNvLXRpbWVcIjogZm10RGVmKC9eKD86WzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGR8MjM6NTk6NjApKD86XFwuXFxkKyk/KD86enxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPyk/JC9pLCBjb21wYXJlSXNvVGltZSksXG4gICAgXCJpc28tZGF0ZS10aW1lXCI6IGZtdERlZigvXlxcZFxcZFxcZFxcZC1bMC0xXVxcZC1bMC0zXVxcZFt0XFxzXSg/OlswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkfDIzOjU5OjYwKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pPyQvaSwgY29tcGFyZUlzb0RhdGVUaW1lKSxcbiAgICAvLyB1cmk6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvaXMtbXktanNvbi12YWxpZC9ibG9iL21hc3Rlci9mb3JtYXRzLmpzXG4gICAgdXJpOiAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KSg/OlxcLz9cXC8pP1teXFxzXSokL2ksXG4gICAgXCJ1cmktcmVmZXJlbmNlXCI6IC9eKD86KD86W2Etel1bYS16MC05K1xcLS5dKjopP1xcLz9cXC8pPyg/OlteXFxcXFxccyNdW15cXHMjXSopPyg/OiNbXlxcXFxcXHNdKik/JC9pLFxuICAgIC8vIGVtYWlsIChzb3VyY2VzIGZyb20ganNlbiB2YWxpZGF0b3IpOlxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjAxMzIzL3VzaW5nLWEtcmVndWxhci1leHByZXNzaW9uLXRvLXZhbGlkYXRlLWFuLWVtYWlsLWFkZHJlc3MjYW5zd2VyLTg4MjkzNjNcbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9mb3Jtcy5odG1sI3ZhbGlkLWUtbWFpbC1hZGRyZXNzIChzZWFyY2ggZm9yICd3aWxmdWwgdmlvbGF0aW9uJylcbiAgICBlbWFpbDogL15bYS16MC05LiEjJCUmJyorLz0/Xl9ge3x9fi1dK0BbYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8oPzpcXC5bYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8pKiQvaSxcbn07XG5leHBvcnRzLmZvcm1hdE5hbWVzID0gT2JqZWN0LmtleXMoZXhwb3J0cy5mdWxsRm9ybWF0cyk7XG5mdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNhcHBlbmRpeC1DXG4gICAgcmV0dXJuIHllYXIgJSA0ID09PSAwICYmICh5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDApO1xufVxuY29uc3QgREFURSA9IC9eKFxcZFxcZFxcZFxcZCktKFxcZFxcZCktKFxcZFxcZCkkLztcbmNvbnN0IERBWVMgPSBbMCwgMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV07XG5mdW5jdGlvbiBkYXRlKHN0cikge1xuICAgIC8vIGZ1bGwtZGF0ZSBmcm9tIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgICBjb25zdCBtYXRjaGVzID0gREFURS5leGVjKHN0cik7XG4gICAgaWYgKCFtYXRjaGVzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgeWVhciA9ICttYXRjaGVzWzFdO1xuICAgIGNvbnN0IG1vbnRoID0gK21hdGNoZXNbMl07XG4gICAgY29uc3QgZGF5ID0gK21hdGNoZXNbM107XG4gICAgcmV0dXJuIChtb250aCA+PSAxICYmXG4gICAgICAgIG1vbnRoIDw9IDEyICYmXG4gICAgICAgIGRheSA+PSAxICYmXG4gICAgICAgIGRheSA8PSAobW9udGggPT09IDIgJiYgaXNMZWFwWWVhcih5ZWFyKSA/IDI5IDogREFZU1ttb250aF0pKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVEYXRlKGQxLCBkMikge1xuICAgIGlmICghKGQxICYmIGQyKSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBpZiAoZDEgPiBkMilcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKGQxIDwgZDIpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICByZXR1cm4gMDtcbn1cbmNvbnN0IFRJTUUgPSAvXihcXGRcXGQpOihcXGRcXGQpOihcXGRcXGQoPzpcXC5cXGQrKT8pKHp8KFsrLV0pKFxcZFxcZCkoPzo6PyhcXGRcXGQpKT8pPyQvaTtcbmZ1bmN0aW9uIGdldFRpbWUoc3RyaWN0VGltZVpvbmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gdGltZShzdHIpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IFRJTUUuZXhlYyhzdHIpO1xuICAgICAgICBpZiAoIW1hdGNoZXMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGhyID0gK21hdGNoZXNbMV07XG4gICAgICAgIGNvbnN0IG1pbiA9ICttYXRjaGVzWzJdO1xuICAgICAgICBjb25zdCBzZWMgPSArbWF0Y2hlc1szXTtcbiAgICAgICAgY29uc3QgdHogPSBtYXRjaGVzWzRdO1xuICAgICAgICBjb25zdCB0elNpZ24gPSBtYXRjaGVzWzVdID09PSBcIi1cIiA/IC0xIDogMTtcbiAgICAgICAgY29uc3QgdHpIID0gKyhtYXRjaGVzWzZdIHx8IDApO1xuICAgICAgICBjb25zdCB0ek0gPSArKG1hdGNoZXNbN10gfHwgMCk7XG4gICAgICAgIGlmICh0ekggPiAyMyB8fCB0ek0gPiA1OSB8fCAoc3RyaWN0VGltZVpvbmUgJiYgIXR6KSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGhyIDw9IDIzICYmIG1pbiA8PSA1OSAmJiBzZWMgPCA2MClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBsZWFwIHNlY29uZFxuICAgICAgICBjb25zdCB1dGNNaW4gPSBtaW4gLSB0ek0gKiB0elNpZ247XG4gICAgICAgIGNvbnN0IHV0Y0hyID0gaHIgLSB0ekggKiB0elNpZ24gLSAodXRjTWluIDwgMCA/IDEgOiAwKTtcbiAgICAgICAgcmV0dXJuICh1dGNIciA9PT0gMjMgfHwgdXRjSHIgPT09IC0xKSAmJiAodXRjTWluID09PSA1OSB8fCB1dGNNaW4gPT09IC0xKSAmJiBzZWMgPCA2MTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcGFyZVRpbWUoczEsIHMyKSB7XG4gICAgaWYgKCEoczEgJiYgczIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHQxID0gbmV3IERhdGUoXCIyMDIwLTAxLTAxVFwiICsgczEpLnZhbHVlT2YoKTtcbiAgICBjb25zdCB0MiA9IG5ldyBEYXRlKFwiMjAyMC0wMS0wMVRcIiArIHMyKS52YWx1ZU9mKCk7XG4gICAgaWYgKCEodDEgJiYgdDIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiB0MSAtIHQyO1xufVxuZnVuY3Rpb24gY29tcGFyZUlzb1RpbWUodDEsIHQyKSB7XG4gICAgaWYgKCEodDEgJiYgdDIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGExID0gVElNRS5leGVjKHQxKTtcbiAgICBjb25zdCBhMiA9IFRJTUUuZXhlYyh0Mik7XG4gICAgaWYgKCEoYTEgJiYgYTIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHQxID0gYTFbMV0gKyBhMVsyXSArIGExWzNdO1xuICAgIHQyID0gYTJbMV0gKyBhMlsyXSArIGEyWzNdO1xuICAgIGlmICh0MSA+IHQyKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAodDEgPCB0MilcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIHJldHVybiAwO1xufVxuY29uc3QgREFURV9USU1FX1NFUEFSQVRPUiA9IC90fFxccy9pO1xuZnVuY3Rpb24gZ2V0RGF0ZVRpbWUoc3RyaWN0VGltZVpvbmUpIHtcbiAgICBjb25zdCB0aW1lID0gZ2V0VGltZShzdHJpY3RUaW1lWm9uZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRhdGVfdGltZShzdHIpIHtcbiAgICAgICAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuICAgICAgICBjb25zdCBkYXRlVGltZSA9IHN0ci5zcGxpdChEQVRFX1RJTUVfU0VQQVJBVE9SKTtcbiAgICAgICAgcmV0dXJuIGRhdGVUaW1lLmxlbmd0aCA9PT0gMiAmJiBkYXRlKGRhdGVUaW1lWzBdKSAmJiB0aW1lKGRhdGVUaW1lWzFdKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcGFyZURhdGVUaW1lKGR0MSwgZHQyKSB7XG4gICAgaWYgKCEoZHQxICYmIGR0MikpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgZDEgPSBuZXcgRGF0ZShkdDEpLnZhbHVlT2YoKTtcbiAgICBjb25zdCBkMiA9IG5ldyBEYXRlKGR0MikudmFsdWVPZigpO1xuICAgIGlmICghKGQxICYmIGQyKSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gZDEgLSBkMjtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVJc29EYXRlVGltZShkdDEsIGR0Mikge1xuICAgIGlmICghKGR0MSAmJiBkdDIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IFtkMSwgdDFdID0gZHQxLnNwbGl0KERBVEVfVElNRV9TRVBBUkFUT1IpO1xuICAgIGNvbnN0IFtkMiwgdDJdID0gZHQyLnNwbGl0KERBVEVfVElNRV9TRVBBUkFUT1IpO1xuICAgIGNvbnN0IHJlcyA9IGNvbXBhcmVEYXRlKGQxLCBkMik7XG4gICAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXMgfHwgY29tcGFyZVRpbWUodDEsIHQyKTtcbn1cbmNvbnN0IE5PVF9VUklfRlJBR01FTlQgPSAvXFwvfDovO1xuY29uc3QgVVJJID0gL14oPzpbYS16XVthLXowLTkrXFwtLl0qOikoPzpcXC8/XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol18JVswLTlhLWZdezJ9KSpAKT8oPzpcXFsoPzooPzooPzooPzpbMC05YS1mXXsxLDR9Oil7Nn18OjooPzpbMC05YS1mXXsxLDR9Oil7NX18KD86WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7NH18KD86KD86WzAtOWEtZl17MSw0fTopezAsMX1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXszfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwyfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezJ9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDN9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9OnwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw0fVswLTlhLWZdezEsNH0pPzo6KSg/OlswLTlhLWZdezEsNH06WzAtOWEtZl17MSw0fXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykpfCg/Oig/OlswLTlhLWZdezEsNH06KXswLDV9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDZ9WzAtOWEtZl17MSw0fSk/OjopfFtWdl1bMC05YS1mXStcXC5bYS16MC05XFwtLl9+ISQmJygpKissOz06XSspXFxdfCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KXwoPzpbYS16MC05XFwtLl9+ISQmJygpKissOz1dfCVbMC05YS1mXXsyfSkqKSg/OjpcXGQqKT8oPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKnxcXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKik/fCg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKSg/OlxcPyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8oPzojKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyQvaTtcbmZ1bmN0aW9uIHVyaShzdHIpIHtcbiAgICAvLyBodHRwOi8vam1yd2FyZS5jb20vYXJ0aWNsZXMvMjAwOS91cmlfcmVnZXhwL1VSSV9yZWdleC5odG1sICsgb3B0aW9uYWwgcHJvdG9jb2wgKyByZXF1aXJlZCBcIi5cIlxuICAgIHJldHVybiBOT1RfVVJJX0ZSQUdNRU5ULnRlc3Qoc3RyKSAmJiBVUkkudGVzdChzdHIpO1xufVxuY29uc3QgQllURSA9IC9eKD86W0EtWmEtejAtOSsvXXs0fSkqKD86W0EtWmEtejAtOSsvXXsyfT09fFtBLVphLXowLTkrL117M309KT8kL2dtO1xuZnVuY3Rpb24gYnl0ZShzdHIpIHtcbiAgICBCWVRFLmxhc3RJbmRleCA9IDA7XG4gICAgcmV0dXJuIEJZVEUudGVzdChzdHIpO1xufVxuY29uc3QgTUlOX0lOVDMyID0gLSgyICoqIDMxKTtcbmNvbnN0IE1BWF9JTlQzMiA9IDIgKiogMzEgLSAxO1xuZnVuY3Rpb24gdmFsaWRhdGVJbnQzMih2YWx1ZSkge1xuICAgIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSAmJiB2YWx1ZSA8PSBNQVhfSU5UMzIgJiYgdmFsdWUgPj0gTUlOX0lOVDMyO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVJbnQ2NCh2YWx1ZSkge1xuICAgIC8vIEpTT04gYW5kIGphdmFzY3JpcHQgbWF4IEludCBpcyAyKio1Mywgc28gYW55IGludCB0aGF0IHBhc3NlcyBpc0ludGVnZXIgaXMgdmFsaWQgZm9yIEludDY0XG4gICAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIodmFsdWUpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBaX0FOQ0hPUiA9IC9bXlxcXFxdXFxcXFovO1xuZnVuY3Rpb24gcmVnZXgoc3RyKSB7XG4gICAgaWYgKFpfQU5DSE9SLnRlc3Qoc3RyKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIG5ldyBSZWdFeHAoc3RyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mb3JtYXRMaW1pdERlZmluaXRpb24gPSB2b2lkIDA7XG5jb25zdCBhanZfMSA9IHJlcXVpcmUoXCJhanZcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3Qgb3BzID0gY29kZWdlbl8xLm9wZXJhdG9ycztcbmNvbnN0IEtXRHMgPSB7XG4gICAgZm9ybWF0TWF4aW11bTogeyBva1N0cjogXCI8PVwiLCBvazogb3BzLkxURSwgZmFpbDogb3BzLkdUIH0sXG4gICAgZm9ybWF0TWluaW11bTogeyBva1N0cjogXCI+PVwiLCBvazogb3BzLkdURSwgZmFpbDogb3BzLkxUIH0sXG4gICAgZm9ybWF0RXhjbHVzaXZlTWF4aW11bTogeyBva1N0cjogXCI8XCIsIG9rOiBvcHMuTFQsIGZhaWw6IG9wcy5HVEUgfSxcbiAgICBmb3JtYXRFeGNsdXNpdmVNaW5pbXVtOiB7IG9rU3RyOiBcIj5cIiwgb2s6IG9wcy5HVCwgZmFpbDogb3BzLkxURSB9LFxufTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBzaG91bGQgYmUgJHtLV0RzW2tleXdvcmRdLm9rU3RyfSAke3NjaGVtYUNvZGV9YCxcbiAgICBwYXJhbXM6ICh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2NvbXBhcmlzb246ICR7S1dEc1trZXl3b3JkXS5va1N0cn0sIGxpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuZXhwb3J0cy5mb3JtYXRMaW1pdERlZmluaXRpb24gPSB7XG4gICAga2V5d29yZDogT2JqZWN0LmtleXMoS1dEcyksXG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBzY2hlbWFUeXBlOiBcInN0cmluZ1wiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBzY2hlbWFDb2RlLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgICAgICBpZiAoIW9wdHMudmFsaWRhdGVGb3JtYXRzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBmQ3h0ID0gbmV3IGFqdl8xLktleXdvcmRDeHQoaXQsIHNlbGYuUlVMRVMuYWxsLmZvcm1hdC5kZWZpbml0aW9uLCBcImZvcm1hdFwiKTtcbiAgICAgICAgaWYgKGZDeHQuJGRhdGEpXG4gICAgICAgICAgICB2YWxpZGF0ZSREYXRhRm9ybWF0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHZhbGlkYXRlRm9ybWF0KCk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlJERhdGFGb3JtYXQoKSB7XG4gICAgICAgICAgICBjb25zdCBmbXRzID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHtcbiAgICAgICAgICAgICAgICByZWY6IHNlbGYuZm9ybWF0cyxcbiAgICAgICAgICAgICAgICBjb2RlOiBvcHRzLmNvZGUuZm9ybWF0cyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZm10ID0gZ2VuLmNvbnN0KFwiZm10XCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7Zm10c31bJHtmQ3h0LnNjaGVtYUNvZGV9XWApO1xuICAgICAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLm9yKSgoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtmbXR9ICE9IFwib2JqZWN0XCJgLCAoMCwgY29kZWdlbl8xLl8pIGAke2ZtdH0gaW5zdGFuY2VvZiBSZWdFeHBgLCAoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtmbXR9LmNvbXBhcmUgIT0gXCJmdW5jdGlvblwiYCwgY29tcGFyZUNvZGUoZm10KSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KCkge1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0ID0gZkN4dC5zY2hlbWE7XG4gICAgICAgICAgICBjb25zdCBmbXREZWYgPSBzZWxmLmZvcm1hdHNbZm9ybWF0XTtcbiAgICAgICAgICAgIGlmICghZm10RGVmIHx8IGZtdERlZiA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZtdERlZiAhPSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICAgICAgZm10RGVmIGluc3RhbmNlb2YgUmVnRXhwIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIGZtdERlZi5jb21wYXJlICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke2tleXdvcmR9XCI6IGZvcm1hdCBcIiR7Zm9ybWF0fVwiIGRvZXMgbm90IGRlZmluZSBcImNvbXBhcmVcIiBmdW5jdGlvbmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZm10ID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHtcbiAgICAgICAgICAgICAgICBrZXk6IGZvcm1hdCxcbiAgICAgICAgICAgICAgICByZWY6IGZtdERlZixcbiAgICAgICAgICAgICAgICBjb2RlOiBvcHRzLmNvZGUuZm9ybWF0cyA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7b3B0cy5jb2RlLmZvcm1hdHN9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShmb3JtYXQpfWAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN4dC5mYWlsJGRhdGEoY29tcGFyZUNvZGUoZm10KSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29tcGFyZUNvZGUoZm10KSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgJHtmbXR9LmNvbXBhcmUoJHtkYXRhfSwgJHtzY2hlbWFDb2RlfSkgJHtLV0RzW2tleXdvcmRdLmZhaWx9IDBgO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFtcImZvcm1hdFwiXSxcbn07XG5jb25zdCBmb3JtYXRMaW1pdFBsdWdpbiA9IChhanYpID0+IHtcbiAgICBhanYuYWRkS2V5d29yZChleHBvcnRzLmZvcm1hdExpbWl0RGVmaW5pdGlvbik7XG4gICAgcmV0dXJuIGFqdjtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBmb3JtYXRMaW1pdFBsdWdpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZm9ybWF0c18xID0gcmVxdWlyZShcIi4vZm9ybWF0c1wiKTtcbmNvbnN0IGxpbWl0XzEgPSByZXF1aXJlKFwiLi9saW1pdFwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCJhanYvZGlzdC9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBmdWxsTmFtZSA9IG5ldyBjb2RlZ2VuXzEuTmFtZShcImZ1bGxGb3JtYXRzXCIpO1xuY29uc3QgZmFzdE5hbWUgPSBuZXcgY29kZWdlbl8xLk5hbWUoXCJmYXN0Rm9ybWF0c1wiKTtcbmNvbnN0IGZvcm1hdHNQbHVnaW4gPSAoYWp2LCBvcHRzID0geyBrZXl3b3JkczogdHJ1ZSB9KSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0cykpIHtcbiAgICAgICAgYWRkRm9ybWF0cyhhanYsIG9wdHMsIGZvcm1hdHNfMS5mdWxsRm9ybWF0cywgZnVsbE5hbWUpO1xuICAgICAgICByZXR1cm4gYWp2O1xuICAgIH1cbiAgICBjb25zdCBbZm9ybWF0cywgZXhwb3J0TmFtZV0gPSBvcHRzLm1vZGUgPT09IFwiZmFzdFwiID8gW2Zvcm1hdHNfMS5mYXN0Rm9ybWF0cywgZmFzdE5hbWVdIDogW2Zvcm1hdHNfMS5mdWxsRm9ybWF0cywgZnVsbE5hbWVdO1xuICAgIGNvbnN0IGxpc3QgPSBvcHRzLmZvcm1hdHMgfHwgZm9ybWF0c18xLmZvcm1hdE5hbWVzO1xuICAgIGFkZEZvcm1hdHMoYWp2LCBsaXN0LCBmb3JtYXRzLCBleHBvcnROYW1lKTtcbiAgICBpZiAob3B0cy5rZXl3b3JkcylcbiAgICAgICAgKDAsIGxpbWl0XzEuZGVmYXVsdCkoYWp2KTtcbiAgICByZXR1cm4gYWp2O1xufTtcbmZvcm1hdHNQbHVnaW4uZ2V0ID0gKG5hbWUsIG1vZGUgPSBcImZ1bGxcIikgPT4ge1xuICAgIGNvbnN0IGZvcm1hdHMgPSBtb2RlID09PSBcImZhc3RcIiA/IGZvcm1hdHNfMS5mYXN0Rm9ybWF0cyA6IGZvcm1hdHNfMS5mdWxsRm9ybWF0cztcbiAgICBjb25zdCBmID0gZm9ybWF0c1tuYW1lXTtcbiAgICBpZiAoIWYpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBmb3JtYXQgXCIke25hbWV9XCJgKTtcbiAgICByZXR1cm4gZjtcbn07XG5mdW5jdGlvbiBhZGRGb3JtYXRzKGFqdiwgbGlzdCwgZnMsIGV4cG9ydE5hbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIF9iO1xuICAgIChfYSA9IChfYiA9IGFqdi5vcHRzLmNvZGUpLmZvcm1hdHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYi5mb3JtYXRzID0gKDAsIGNvZGVnZW5fMS5fKSBgcmVxdWlyZShcImFqdi1mb3JtYXRzL2Rpc3QvZm9ybWF0c1wiKS4ke2V4cG9ydE5hbWV9YCk7XG4gICAgZm9yIChjb25zdCBmIG9mIGxpc3QpXG4gICAgICAgIGFqdi5hZGRGb3JtYXQoZiwgZnNbZl0pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZm9ybWF0c1BsdWdpbjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZvcm1hdHNQbHVnaW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGFqdl8xID0gcmVxdWlyZShcImFqdlwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCJhanYvZGlzdC9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuL2NvZGVcIik7XG5jb25zdCB2YWxpZGF0ZV8xID0gcmVxdWlyZShcImFqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGVcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCJhanYvZGlzdC9jb21waWxlL2Vycm9yc1wiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiYWp2L2Rpc3QvY29tcGlsZS9uYW1lc1wiKTtcbmNvbnN0IGtleXdvcmQgPSBcImVycm9yTWVzc2FnZVwiO1xuY29uc3QgdXNlZCA9IG5ldyBhanZfMS5OYW1lKFwiZW1Vc2VkXCIpO1xuY29uc3QgS0VZV09SRF9QUk9QRVJUWV9QQVJBTVMgPSB7XG4gICAgcmVxdWlyZWQ6IFwibWlzc2luZ1Byb3BlcnR5XCIsXG4gICAgZGVwZW5kZW5jaWVzOiBcInByb3BlcnR5XCIsXG4gICAgZGVwZW5kZW50UmVxdWlyZWQ6IFwicHJvcGVydHlcIixcbn07XG5jb25zdCBJTlRFUlBPTEFUSU9OID0gL1xcJFxce1tefV0rXFx9LztcbmNvbnN0IElOVEVSUE9MQVRJT05fUkVQTEFDRSA9IC9cXCRcXHsoW159XSspXFx9L2c7XG5jb25zdCBFTVBUWV9TVFIgPSAvXlwiXCJcXHMqXFwrXFxzKnxcXHMqXFwrXFxzKlwiXCIkL2c7XG5mdW5jdGlvbiBlcnJvck1lc3NhZ2Uob3B0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGtleXdvcmQsXG4gICAgICAgIHNjaGVtYVR5cGU6IFtcInN0cmluZ1wiLCBcIm9iamVjdFwiXSxcbiAgICAgICAgcG9zdDogdHJ1ZSxcbiAgICAgICAgY29kZShjeHQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBzY2hlbWEsIHNjaGVtYVZhbHVlLCBpdCB9ID0gY3h0O1xuICAgICAgICAgICAgaWYgKGl0LmNyZWF0ZUVycm9ycyA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3Qgc2NoID0gc2NoZW1hO1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2VQYXRoID0gY29kZWdlbl8xLnN0ckNvbmNhdChuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBpdC5lcnJvclBhdGgpO1xuICAgICAgICAgICAgZ2VuLmlmKGFqdl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc30gPiAwYCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2t3ZFByb3BFcnJvcnMsIGt3ZEVycm9yc10gPSBrZXl3b3JkRXJyb3JzQ29uZmlnKHNjaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrd2RFcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzS2V5d29yZEVycm9ycyhrd2RFcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa3dkUHJvcEVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NLZXl3b3JkUHJvcEVycm9ycyhrd2RQcm9wRXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0NoaWxkRXJyb3JzKGNoaWxkRXJyb3JzQ29uZmlnKHNjaCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzY2hNZXNzYWdlID0gdHlwZW9mIHNjaCA9PSBcInN0cmluZ1wiID8gc2NoIDogc2NoLl87XG4gICAgICAgICAgICAgICAgaWYgKHNjaE1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NBbGxFcnJvcnMoc2NoTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmtlZXBFcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZVVzZWRFcnJvcnMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZnVuY3Rpb24gY2hpbGRFcnJvcnNDb25maWcoeyBwcm9wZXJ0aWVzLCBpdGVtcyB9KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JzID0ge307XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnByb3BzID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBpbiBwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnByb3BzW3BdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpdGVtcykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMuaXRlbXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5pdGVtc1tpXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24ga2V5d29yZEVycm9yc0NvbmZpZyhlbVNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGxldCBwcm9wRXJyb3JzO1xuICAgICAgICAgICAgICAgIGxldCBlcnJvcnM7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrIGluIGVtU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrID09PSBcInByb3BlcnRpZXNcIiB8fCBrID09PSBcIml0ZW1zXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga3dkU2NoID0gZW1TY2hlbWFba107XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga3dkU2NoID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BFcnJvcnMgfHwgKHByb3BFcnJvcnMgPSB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJNYXAgPSAocHJvcEVycm9yc1trXSA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBpbiBrd2RTY2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyTWFwW3BdID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMgfHwgKGVycm9ycyA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yc1trXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbcHJvcEVycm9ycywgZXJyb3JzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NLZXl3b3JkRXJyb3JzKGt3ZEVycm9ycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGt3ZEVycnMgPSBnZW4uY29uc3QoXCJlbUVycm9yc1wiLCBhanZfMS5zdHJpbmdpZnkoa3dkRXJyb3JzKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcGxhdGVzID0gZ2VuLmNvbnN0KFwidGVtcGxhdGVzXCIsIGdldFRlbXBsYXRlc0NvZGUoa3dkRXJyb3JzLCBzY2hlbWEpKTtcbiAgICAgICAgICAgICAgICBnZW4uZm9yT2YoXCJlcnJcIiwgbmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsIChlcnIpID0+IGdlbi5pZihtYXRjaEtleXdvcmRFcnJvcihlcnIsIGt3ZEVycnMpLCAoKSA9PiBnZW4uY29kZShhanZfMS5fIGAke2t3ZEVycnN9WyR7ZXJyfS5rZXl3b3JkXS5wdXNoKCR7ZXJyfSlgKS5hc3NpZ24oYWp2XzEuXyBgJHtlcnJ9LiR7dXNlZH1gLCB0cnVlKSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2luZ2xlRXJyb3IgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnZW4ubGV0KFwibWVzc2FnZVwiLCBhanZfMS5fIGBcIlwiYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtc0Vycm9ycyA9IGdlbi5sZXQoXCJwYXJhbXNFcnJvcnNcIiwgYWp2XzEuXyBgW11gKTtcbiAgICAgICAgICAgICAgICAgICAgbG9vcEVycm9ycygoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW4uaWYobWVzc2FnZSwgKCkgPT4gZ2VuLmNvZGUoYWp2XzEuXyBgJHttZXNzYWdlfSArPSAke3R5cGVvZiBzaW5nbGVFcnJvciA9PSBcInN0cmluZ1wiID8gc2luZ2xlRXJyb3IgOiBcIjtcIn1gKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW4uY29kZShhanZfMS5fIGAke21lc3NhZ2V9ICs9ICR7ZXJyTWVzc2FnZShrZXkpfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihwYXJhbXNFcnJvcnMsIGFqdl8xLl8gYCR7cGFyYW1zRXJyb3JzfS5jb25jYXQoJHtrd2RFcnJzfVske2tleX1dKWApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzXzEucmVwb3J0RXJyb3IoY3h0LCB7IG1lc3NhZ2UsIHBhcmFtczogYWp2XzEuXyBge2Vycm9yczogJHtwYXJhbXNFcnJvcnN9fWAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb29wRXJyb3JzKChrZXkpID0+IGVycm9yc18xLnJlcG9ydEVycm9yKGN4dCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyTWVzc2FnZShrZXkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBhanZfMS5fIGB7ZXJyb3JzOiAke2t3ZEVycnN9WyR7a2V5fV19YCxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBsb29wRXJyb3JzKGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmZvckluKFwia2V5XCIsIGt3ZEVycnMsIChrZXkpID0+IGdlbi5pZihhanZfMS5fIGAke2t3ZEVycnN9WyR7a2V5fV0ubGVuZ3RoYCwgKCkgPT4gYm9keShrZXkpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGVyck1lc3NhZ2Uoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhanZfMS5fIGAke2tleX0gaW4gJHt0ZW1wbGF0ZXN9ID8gJHt0ZW1wbGF0ZXN9WyR7a2V5fV0oKSA6ICR7c2NoZW1hVmFsdWV9WyR7a2V5fV1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NLZXl3b3JkUHJvcEVycm9ycyhrd2RQcm9wRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga3dkRXJycyA9IGdlbi5jb25zdChcImVtRXJyb3JzXCIsIGFqdl8xLnN0cmluZ2lmeShrd2RQcm9wRXJyb3JzKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcGxhdGVzQ29kZSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiBrd2RQcm9wRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlc0NvZGUucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICBrLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VGVtcGxhdGVzQ29kZShrd2RQcm9wRXJyb3JzW2tdLCBzY2hlbWFba10pLFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcGxhdGVzID0gZ2VuLmNvbnN0KFwidGVtcGxhdGVzXCIsIGdlbi5vYmplY3QoLi4udGVtcGxhdGVzQ29kZSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGt3ZFByb3BQYXJhbXMgPSBnZW4uc2NvcGVWYWx1ZShcIm9ialwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlZjogS0VZV09SRF9QUk9QRVJUWV9QQVJBTVMsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGFqdl8xLnN0cmluZ2lmeShLRVlXT1JEX1BST1BFUlRZX1BBUkFNUyksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcFBhcmFtID0gZ2VuLmxldChcImVtUHJvcFBhcmFtc1wiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXNFcnJvcnMgPSBnZW4ubGV0KFwiZW1QYXJhbXNFcnJvcnNcIik7XG4gICAgICAgICAgICAgICAgZ2VuLmZvck9mKFwiZXJyXCIsIG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCAoZXJyKSA9PiBnZW4uaWYobWF0Y2hLZXl3b3JkRXJyb3IoZXJyLCBrd2RFcnJzKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHByb3BQYXJhbSwgYWp2XzEuXyBgJHtrd2RQcm9wUGFyYW1zfVske2Vycn0ua2V5d29yZF1gKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihwYXJhbXNFcnJvcnMsIGFqdl8xLl8gYCR7a3dkRXJyc31bJHtlcnJ9LmtleXdvcmRdWyR7ZXJyfS5wYXJhbXNbJHtwcm9wUGFyYW19XV1gKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKHBhcmFtc0Vycm9ycywgKCkgPT4gZ2VuLmNvZGUoYWp2XzEuXyBgJHtwYXJhbXNFcnJvcnN9LnB1c2goJHtlcnJ9KWApLmFzc2lnbihhanZfMS5fIGAke2Vycn0uJHt1c2VkfWAsIHRydWUpKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgZ2VuLmZvckluKFwia2V5XCIsIGt3ZEVycnMsIChrZXkpID0+IGdlbi5mb3JJbihcImtleVByb3BcIiwgYWp2XzEuXyBgJHtrd2RFcnJzfVske2tleX1dYCwgKGtleVByb3ApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihwYXJhbXNFcnJvcnMsIGFqdl8xLl8gYCR7a3dkRXJyc31bJHtrZXl9XVske2tleVByb3B9XWApO1xuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoYWp2XzEuXyBgJHtwYXJhbXNFcnJvcnN9Lmxlbmd0aGAsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRtcGwgPSBnZW4uY29uc3QoXCJ0bXBsXCIsIGFqdl8xLl8gYCR7dGVtcGxhdGVzfVske2tleX1dICYmICR7dGVtcGxhdGVzfVske2tleX1dWyR7a2V5UHJvcH1dYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnNfMS5yZXBvcnRFcnJvcihjeHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBhanZfMS5fIGAke3RtcGx9ID8gJHt0bXBsfSgpIDogJHtzY2hlbWFWYWx1ZX1bJHtrZXl9XVske2tleVByb3B9XWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBhanZfMS5fIGB7ZXJyb3JzOiAke3BhcmFtc0Vycm9yc319YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwcm9jZXNzQ2hpbGRFcnJvcnMoY2hpbGRFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHByb3BzLCBpdGVtcyB9ID0gY2hpbGRFcnJvcnM7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm9wcyAmJiAhaXRlbXMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjb25zdCBpc09iaiA9IGFqdl8xLl8gYHR5cGVvZiAke2RhdGF9ID09IFwib2JqZWN0XCJgO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQXJyID0gYWp2XzEuXyBgQXJyYXkuaXNBcnJheSgke2RhdGF9KWA7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRFcnJzID0gZ2VuLmxldChcImVtRXJyb3JzXCIpO1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZEt3ZDtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRQcm9wO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlcyA9IGdlbi5sZXQoXCJ0ZW1wbGF0ZXNcIik7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzICYmIGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkS3dkID0gZ2VuLmxldChcImVtQ2hpbGRLd2RcIik7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZihpc09iaik7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZihpc0FyciwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdChpdGVtcywgc2NoZW1hLml0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oY2hpbGRLd2QsIGFqdl8xLnN0ciBgaXRlbXNgKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdChwcm9wcywgc2NoZW1hLnByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihjaGlsZEt3ZCwgYWp2XzEuc3RyIGBwcm9wZXJ0aWVzYCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFByb3AgPSBhanZfMS5fIGBbJHtjaGlsZEt3ZH1dYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKGlzQXJyKTtcbiAgICAgICAgICAgICAgICAgICAgaW5pdChpdGVtcywgc2NoZW1hLml0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRQcm9wID0gYWp2XzEuXyBgLml0ZW1zYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5hbmQoaXNPYmosIGNvZGVnZW5fMS5ub3QoaXNBcnIpKSk7XG4gICAgICAgICAgICAgICAgICAgIGluaXQocHJvcHMsIHNjaGVtYS5wcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRQcm9wID0gYWp2XzEuXyBgLnByb3BlcnRpZXNgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZW4uZm9yT2YoXCJlcnJcIiwgbmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsIChlcnIpID0+IGlmTWF0Y2hlc0NoaWxkRXJyb3IoZXJyLCBjaGlsZEVycnMsIChjaGlsZCkgPT4gZ2VuLmNvZGUoYWp2XzEuXyBgJHtjaGlsZEVycnN9WyR7Y2hpbGR9XS5wdXNoKCR7ZXJyfSlgKS5hc3NpZ24oYWp2XzEuXyBgJHtlcnJ9LiR7dXNlZH1gLCB0cnVlKSkpO1xuICAgICAgICAgICAgICAgIGdlbi5mb3JJbihcImtleVwiLCBjaGlsZEVycnMsIChrZXkpID0+IGdlbi5pZihhanZfMS5fIGAke2NoaWxkRXJyc31bJHtrZXl9XS5sZW5ndGhgLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yc18xLnJlcG9ydEVycm9yKGN4dCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYWp2XzEuXyBgJHtrZXl9IGluICR7dGVtcGxhdGVzfSA/ICR7dGVtcGxhdGVzfVske2tleX1dKCkgOiAke3NjaGVtYVZhbHVlfSR7Y2hpbGRQcm9wfVske2tleX1dYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogYWp2XzEuXyBge2Vycm9yczogJHtjaGlsZEVycnN9WyR7a2V5fV19YCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oYWp2XzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc31bJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfS0xXS5pbnN0YW5jZVBhdGhgLCBhanZfMS5fIGAke2luc3RhbmNlUGF0aH0gKyBcIi9cIiArICR7a2V5fS5yZXBsYWNlKC9+L2csIFwifjBcIikucmVwbGFjZSgvXFxcXC8vZywgXCJ+MVwiKWApO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBnZW4uZW5kSWYoKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpbml0KGNoaWxkcmVuLCBtc2dzKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oY2hpbGRFcnJzLCBhanZfMS5zdHJpbmdpZnkoY2hpbGRyZW4pKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih0ZW1wbGF0ZXMsIGdldFRlbXBsYXRlc0NvZGUoY2hpbGRyZW4sIG1zZ3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwcm9jZXNzQWxsRXJyb3JzKHNjaE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJzID0gZ2VuLmNvbnN0KFwiZW1FcnJzXCIsIGFqdl8xLl8gYFtdYCk7XG4gICAgICAgICAgICAgICAgZ2VuLmZvck9mKFwiZXJyXCIsIG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCAoZXJyKSA9PiBnZW4uaWYobWF0Y2hBbnlFcnJvcihlcnIpLCAoKSA9PiBnZW4uY29kZShhanZfMS5fIGAke2VycnN9LnB1c2goJHtlcnJ9KWApLmFzc2lnbihhanZfMS5fIGAke2Vycn0uJHt1c2VkfWAsIHRydWUpKSk7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKGFqdl8xLl8gYCR7ZXJyc30ubGVuZ3RoYCwgKCkgPT4gZXJyb3JzXzEucmVwb3J0RXJyb3IoY3h0LCB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHRlbXBsYXRlRXhwcihzY2hNZXNzYWdlKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBhanZfMS5fIGB7ZXJyb3JzOiAke2VycnN9fWAsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlVXNlZEVycm9ycygpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJzID0gZ2VuLmNvbnN0KFwiZW1FcnJzXCIsIGFqdl8xLl8gYFtdYCk7XG4gICAgICAgICAgICAgICAgZ2VuLmZvck9mKFwiZXJyXCIsIG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCAoZXJyKSA9PiBnZW4uaWYoYWp2XzEuXyBgISR7ZXJyfS4ke3VzZWR9YCwgKCkgPT4gZ2VuLmNvZGUoYWp2XzEuXyBgJHtlcnJzfS5wdXNoKCR7ZXJyfSlgKSkpO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsIGVycnMpLmFzc2lnbihuYW1lc18xLmRlZmF1bHQuZXJyb3JzLCBhanZfMS5fIGAke2VycnN9Lmxlbmd0aGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gbWF0Y2hLZXl3b3JkRXJyb3IoZXJyLCBrd2RFcnJzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5hbmQoYWp2XzEuXyBgJHtlcnJ9LmtleXdvcmQgIT09ICR7a2V5d29yZH1gLCBhanZfMS5fIGAhJHtlcnJ9LiR7dXNlZH1gLCBhanZfMS5fIGAke2Vycn0uaW5zdGFuY2VQYXRoID09PSAke2luc3RhbmNlUGF0aH1gLCBhanZfMS5fIGAke2Vycn0ua2V5d29yZCBpbiAke2t3ZEVycnN9YCwgXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBtYXRjaCB0aGUgZW5kIG9mIHRoZSBzdHJpbmc/XG4gICAgICAgICAgICAgICAgYWp2XzEuXyBgJHtlcnJ9LnNjaGVtYVBhdGguaW5kZXhPZigke2l0LmVyclNjaGVtYVBhdGh9KSA9PT0gMGAsIGFqdl8xLl8gYC9eXFxcXC9bXlxcXFwvXSokLy50ZXN0KCR7ZXJyfS5zY2hlbWFQYXRoLnNsaWNlKCR7aXQuZXJyU2NoZW1hUGF0aC5sZW5ndGh9KSlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlmTWF0Y2hlc0NoaWxkRXJyb3IoZXJyLCBjaGlsZEVycnMsIHRoZW5Cb2R5KSB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5hbmQoYWp2XzEuXyBgJHtlcnJ9LmtleXdvcmQgIT09ICR7a2V5d29yZH1gLCBhanZfMS5fIGAhJHtlcnJ9LiR7dXNlZH1gLCBhanZfMS5fIGAke2Vycn0uaW5zdGFuY2VQYXRoLmluZGV4T2YoJHtpbnN0YW5jZVBhdGh9KSA9PT0gMGApLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkUmVnZXggPSBnZW4uc2NvcGVWYWx1ZShcInBhdHRlcm5cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiAvXlxcLyhbXi9dKikoPzpcXC98JCkvLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogYWp2XzEuXyBgbmV3IFJlZ0V4cChcIl5cXFxcXFwvKFteL10qKSg/OlxcXFxcXC98JClcIilgLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGdlbi5jb25zdChcImVtTWF0Y2hlc1wiLCBhanZfMS5fIGAke2NoaWxkUmVnZXh9LmV4ZWMoJHtlcnJ9Lmluc3RhbmNlUGF0aC5zbGljZSgke2luc3RhbmNlUGF0aH0ubGVuZ3RoKSlgKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBnZW4uY29uc3QoXCJlbUNoaWxkXCIsIGFqdl8xLl8gYCR7bWF0Y2hlc30gJiYgJHttYXRjaGVzfVsxXS5yZXBsYWNlKC9+MS9nLCBcIi9cIikucmVwbGFjZSgvfjAvZywgXCJ+XCIpYCk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZihhanZfMS5fIGAke2NoaWxkfSAhPT0gdW5kZWZpbmVkICYmICR7Y2hpbGR9IGluICR7Y2hpbGRFcnJzfWAsICgpID0+IHRoZW5Cb2R5KGNoaWxkKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBtYXRjaEFueUVycm9yKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEuYW5kKGFqdl8xLl8gYCR7ZXJyfS5rZXl3b3JkICE9PSAke2tleXdvcmR9YCwgYWp2XzEuXyBgISR7ZXJyfS4ke3VzZWR9YCwgY29kZWdlbl8xLm9yKGFqdl8xLl8gYCR7ZXJyfS5pbnN0YW5jZVBhdGggPT09ICR7aW5zdGFuY2VQYXRofWAsIGNvZGVnZW5fMS5hbmQoYWp2XzEuXyBgJHtlcnJ9Lmluc3RhbmNlUGF0aC5pbmRleE9mKCR7aW5zdGFuY2VQYXRofSkgPT09IDBgLCBhanZfMS5fIGAke2Vycn0uaW5zdGFuY2VQYXRoWyR7aW5zdGFuY2VQYXRofS5sZW5ndGhdID09PSBcIi9cImApKSwgYWp2XzEuXyBgJHtlcnJ9LnNjaGVtYVBhdGguaW5kZXhPZigke2l0LmVyclNjaGVtYVBhdGh9KSA9PT0gMGAsIGFqdl8xLl8gYCR7ZXJyfS5zY2hlbWFQYXRoWyR7aXQuZXJyU2NoZW1hUGF0aH0ubGVuZ3RoXSA9PT0gXCIvXCJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFRlbXBsYXRlc0NvZGUoa2V5cywgbXNncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlc0NvZGUgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGsgaW4ga2V5cykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSBtc2dzW2tdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoSU5URVJQT0xBVElPTi50ZXN0KG1zZykpXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZXNDb2RlLnB1c2goW2ssIHRlbXBsYXRlRnVuYyhtc2cpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBnZW4ub2JqZWN0KC4uLnRlbXBsYXRlc0NvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gdGVtcGxhdGVFeHByKG1zZykge1xuICAgICAgICAgICAgICAgIGlmICghSU5URVJQT0xBVElPTi50ZXN0KG1zZykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhanZfMS5zdHJpbmdpZnkobXNnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGNvZGVfMS5fQ29kZShjb2RlXzEuc2FmZVN0cmluZ2lmeShtc2cpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKElOVEVSUE9MQVRJT05fUkVQTEFDRSwgKF9zLCBwdHIpID0+IGBcIiArIEpTT04uc3RyaW5naWZ5KCR7dmFsaWRhdGVfMS5nZXREYXRhKHB0ciwgaXQpfSkgKyBcImApXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKEVNUFRZX1NUUiwgXCJcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gdGVtcGxhdGVGdW5jKG1zZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhanZfMS5fIGBmdW5jdGlvbigpe3JldHVybiAke3RlbXBsYXRlRXhwcihtc2cpfX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtZXRhU2NoZW1hOiB7XG4gICAgICAgICAgICBhbnlPZjogW1xuICAgICAgICAgICAgICAgIHsgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogeyAkcmVmOiBcIiMvJGRlZnMvc3RyaW5nTWFwXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiB7ICRyZWY6IFwiIy8kZGVmcy9zdHJpbmdMaXN0XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiB7ICRyZWY6IFwiIy8kZGVmcy9zdHJpbmdPck1hcFwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXM6IHsgJHJlZjogXCIjLyRkZWZzL3N0cmluZ09yTWFwXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHsgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJGRlZnM6IHtcbiAgICAgICAgICAgICAgICBzdHJpbmdNYXA6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHsgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RyaW5nT3JNYXA6IHtcbiAgICAgICAgICAgICAgICAgICAgYW55T2Y6IFt7IHR5cGU6IFwic3RyaW5nXCIgfSwgeyAkcmVmOiBcIiMvJGRlZnMvc3RyaW5nTWFwXCIgfV0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHJpbmdMaXN0OiB7IHR5cGU6IFwiYXJyYXlcIiwgaXRlbXM6IHsgdHlwZTogXCJzdHJpbmdcIiB9IH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH07XG59XG5jb25zdCBhanZFcnJvcnMgPSAoYWp2LCBvcHRpb25zID0ge30pID0+IHtcbiAgICBpZiAoIWFqdi5vcHRzLmFsbEVycm9ycylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2LWVycm9yczogQWp2IG9wdGlvbiBhbGxFcnJvcnMgbXVzdCBiZSB0cnVlXCIpO1xuICAgIGlmIChhanYub3B0cy5qc1Byb3BlcnR5U3ludGF4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdi1lcnJvcnM6IGFqdiBvcHRpb24ganNQcm9wZXJ0eVN5bnRheCBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYWp2LmFkZEtleXdvcmQoZXJyb3JNZXNzYWdlKG9wdGlvbnMpKTtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBhanZFcnJvcnM7XG5tb2R1bGUuZXhwb3J0cyA9IGFqdkVycm9ycztcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBhanZFcnJvcnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgQWp2LCB7IE9wdGlvbnMsIEVycm9yT2JqZWN0LCBFcnJvcnNUZXh0T3B0aW9ucyB9IGZyb20gXCJhanZcIjtcbmltcG9ydCBhZGRGb3JtYXRzIGZyb20gXCJhanYtZm9ybWF0c1wiO1xuaW1wb3J0IGFkZEVycm9ycyBmcm9tIFwiYWp2LWVycm9yc1wiO1xuaW1wb3J0IFR5cGVkSW5wdXRTY2hlbWEgZnJvbSBcIi4vc2NoZW1hcy90eXBlZC1pbnB1dFwiO1xuaW1wb3J0IE1lc3NhZ2VTY2hlbWEgZnJvbSBcIi4vc2NoZW1hcy9tZXNzYWdlXCI7XG5cbmNsYXNzIFZhbGlkYXRvclNlcnZpY2Uge1xuICBhanY6IEFqdjtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zPzogT3B0aW9ucykge1xuICAgIC8vIGNvbnNvbGUubG9nKFwiSU5TSURFIENPTlNUUlVDVE9SIE9GIFZBTElEQVRPUiBTRVJWSUNFXCIpO1xuICAgIHRoaXMuYWp2ID0gbmV3IEFqdih7XG4gICAgICBhbGxFcnJvcnM6IHRydWUsXG4gICAgICB1c2VEZWZhdWx0czogXCJlbXB0eVwiLFxuICAgICAgdmVyYm9zZTogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlRm9ybWF0czogdHJ1ZSxcbiAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgIGNvZXJjZVR5cGVzOiB0cnVlLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcblxuICAgIGNvbnNvbGUubG9nKHRoaXMuYWp2LnNjaGVtYXMpO1xuXG4gICAgLy8gTk9URTogdGhpcyBwbHVnaW4gZW5hYmxlcyB1c2VycyB0byB1c2UgZm9ybWF0cyBrZXl3b3JkXG4gICAgYWRkRm9ybWF0cyh0aGlzLmFqdik7XG5cbiAgICAvLyBOT1RFOyB0aGlzIHBsdWdpbiBlbmFibGVzIHVzZXJzIHRvIGRlY2xhcmUgY3VzdG9tIGVycm9yIG1lc3NhZ2VzXG4gICAgYWRkRXJyb3JzKHRoaXMuYWp2KTtcblxuICAgIHRoaXMuYWp2LmFkZEtleXdvcmQoXCJub2RlVHlwZVwiKTtcbiAgfVxuXG4gIGNyZWF0ZVZhbGlkYXRvcihzY2hlbWE6IEFueVNjaGVtYSkge1xuICAgIC8vIGNvbnNvbGUubG9nKFwiSU5TSURFIENSRUFURVZBTElEQVRPUlwiKTtcbiAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmFqdi5zY2hlbWFzKTtcbiAgICByZXR1cm4gdGhpcy5hanYuY29tcGlsZShzY2hlbWEpO1xuICB9XG5cbiAgcmVzZXRDYWNoZSgpIHtcbiAgICB0aGlzLmFqdi5jYWNoZS5jbGVhcigpO1xuICB9XG5cbiAgZXJyb3JzKFxuICAgIGVycm9ycz86IEVycm9yT2JqZWN0W10gfCBudWxsIHwgdW5kZWZpbmVkLFxuICAgIG9wdGlvbnM/OiBFcnJvcnNUZXh0T3B0aW9uc1xuICApIHtcbiAgICByZXR1cm4gdGhpcy5hanYuZXJyb3JzVGV4dChlcnJvcnMsIG9wdGlvbnMpO1xuICB9XG59XG5cbmV4cG9ydCB7IFZhbGlkYXRvclNlcnZpY2UgfTtcbiIsImltcG9ydCB7IFZhbGlkYXRvclNlcnZpY2UgfSBmcm9tIFwiLi4vdmFsaWRhdG9yLXNlcnZpY2VcIjtcbi8vIE5PVEU6IHNpbmdsZXRvbiB0byB1c2UgYWp2IGNhY2hpbmcgZmVhdHVyZXNcbmNvbnN0IHZhbGlkYXRvclNlcnZpY2UgPSBuZXcgVmFsaWRhdG9yU2VydmljZSgpO1xuXG5leHBvcnQgeyB2YWxpZGF0b3JTZXJ2aWNlIH07XG4iLCJ2YXIgaGFzRXhjYXBlID0gL34vXG52YXIgZXNjYXBlTWF0Y2hlciA9IC9+WzAxXS9nXG5mdW5jdGlvbiBlc2NhcGVSZXBsYWNlciAobSkge1xuICBzd2l0Y2ggKG0pIHtcbiAgICBjYXNlICd+MSc6IHJldHVybiAnLydcbiAgICBjYXNlICd+MCc6IHJldHVybiAnfidcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGlsZGUgZXNjYXBlOiAnICsgbSlcbn1cblxuZnVuY3Rpb24gdW50aWxkZSAoc3RyKSB7XG4gIGlmICghaGFzRXhjYXBlLnRlc3Qoc3RyKSkgcmV0dXJuIHN0clxuICByZXR1cm4gc3RyLnJlcGxhY2UoZXNjYXBlTWF0Y2hlciwgZXNjYXBlUmVwbGFjZXIpXG59XG5cbmZ1bmN0aW9uIHNldHRlciAob2JqLCBwb2ludGVyLCB2YWx1ZSkge1xuICB2YXIgcGFydFxuICB2YXIgaGFzTmV4dFBhcnRcblxuICBmb3IgKHZhciBwID0gMSwgbGVuID0gcG9pbnRlci5sZW5ndGg7IHAgPCBsZW47KSB7XG4gICAgaWYgKHBvaW50ZXJbcF0gPT09ICdjb25zdHJ1Y3RvcicgfHwgcG9pbnRlcltwXSA9PT0gJ3Byb3RvdHlwZScgfHwgcG9pbnRlcltwXSA9PT0gJ19fcHJvdG9fXycpIHJldHVybiBvYmpcblxuICAgIHBhcnQgPSB1bnRpbGRlKHBvaW50ZXJbcCsrXSlcbiAgICBoYXNOZXh0UGFydCA9IGxlbiA+IHBcblxuICAgIGlmICh0eXBlb2Ygb2JqW3BhcnRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gc3VwcG9ydCBzZXR0aW5nIG9mIC8tXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopICYmIHBhcnQgPT09ICctJykge1xuICAgICAgICBwYXJ0ID0gb2JqLmxlbmd0aFxuICAgICAgfVxuXG4gICAgICAvLyBzdXBwb3J0IG5lc3RlZCBvYmplY3RzL2FycmF5IHdoZW4gc2V0dGluZyB2YWx1ZXNcbiAgICAgIGlmIChoYXNOZXh0UGFydCkge1xuICAgICAgICBpZiAoKHBvaW50ZXJbcF0gIT09ICcnICYmIHBvaW50ZXJbcF0gPCBJbmZpbml0eSkgfHwgcG9pbnRlcltwXSA9PT0gJy0nKSBvYmpbcGFydF0gPSBbXVxuICAgICAgICBlbHNlIG9ialtwYXJ0XSA9IHt9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFoYXNOZXh0UGFydCkgYnJlYWtcbiAgICBvYmogPSBvYmpbcGFydF1cbiAgfVxuXG4gIHZhciBvbGRWYWx1ZSA9IG9ialtwYXJ0XVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgZGVsZXRlIG9ialtwYXJ0XVxuICBlbHNlIG9ialtwYXJ0XSA9IHZhbHVlXG4gIHJldHVybiBvbGRWYWx1ZVxufVxuXG5mdW5jdGlvbiBjb21waWxlUG9pbnRlciAocG9pbnRlcikge1xuICBpZiAodHlwZW9mIHBvaW50ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgcG9pbnRlciA9IHBvaW50ZXIuc3BsaXQoJy8nKVxuICAgIGlmIChwb2ludGVyWzBdID09PSAnJykgcmV0dXJuIHBvaW50ZXJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSlNPTiBwb2ludGVyLicpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwb2ludGVyKSkge1xuICAgIGZvciAoY29uc3QgcGFydCBvZiBwb2ludGVyKSB7XG4gICAgICBpZiAodHlwZW9mIHBhcnQgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBwYXJ0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSlNPTiBwb2ludGVyLiBNdXN0IGJlIG9mIHR5cGUgc3RyaW5nIG9yIG51bWJlci4nKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcG9pbnRlclxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEpTT04gcG9pbnRlci4nKVxufVxuXG5mdW5jdGlvbiBnZXQgKG9iaiwgcG9pbnRlcikge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCBvYmplY3QuJylcbiAgcG9pbnRlciA9IGNvbXBpbGVQb2ludGVyKHBvaW50ZXIpXG4gIHZhciBsZW4gPSBwb2ludGVyLmxlbmd0aFxuICBpZiAobGVuID09PSAxKSByZXR1cm4gb2JqXG5cbiAgZm9yICh2YXIgcCA9IDE7IHAgPCBsZW47KSB7XG4gICAgb2JqID0gb2JqW3VudGlsZGUocG9pbnRlcltwKytdKV1cbiAgICBpZiAobGVuID09PSBwKSByZXR1cm4gb2JqXG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG59XG5cbmZ1bmN0aW9uIHNldCAob2JqLCBwb2ludGVyLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCBvYmplY3QuJylcbiAgcG9pbnRlciA9IGNvbXBpbGVQb2ludGVyKHBvaW50ZXIpXG4gIGlmIChwb2ludGVyLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEpTT04gcG9pbnRlciBmb3Igc2V0LicpXG4gIHJldHVybiBzZXR0ZXIob2JqLCBwb2ludGVyLCB2YWx1ZSlcbn1cblxuZnVuY3Rpb24gY29tcGlsZSAocG9pbnRlcikge1xuICB2YXIgY29tcGlsZWQgPSBjb21waWxlUG9pbnRlcihwb2ludGVyKVxuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGdldChvYmplY3QsIGNvbXBpbGVkKVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAob2JqZWN0LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHNldChvYmplY3QsIGNvbXBpbGVkLCB2YWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5nZXQgPSBnZXRcbmV4cG9ydHMuc2V0ID0gc2V0XG5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlXG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgc3R5bGU9XCJ3aWR0aDogMTAwJVwiPlxuICAgIDxOb2RlUmVkTm9kZUZvcm0gOm5vZGU9XCJsb2NhbE5vZGVcIiA6ZXJyb3JzPVwiZXJyb3JzXCIgc3R5bGU9XCJ3aWR0aDogMTAwJVwiIC8+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7IHZhbGlkYXRvclNlcnZpY2UgfSBmcm9tIFwiLi92YWxpZGF0b3JcIjtcbmltcG9ydCBqc29ucG9pbnRlciBmcm9tIFwianNvbnBvaW50ZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiBcIk5vZGVSZWRWdWVBcHBcIixcbiAgcHJvcHM6IHtcbiAgICBub2RlOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB9LFxuICAgIHZhbGlkYXRvcjoge1xuICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB9LFxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsb2NhbE5vZGU6IHRoaXMubm9kZSxcbiAgICAgIGVycm9yczoge30sXG4gICAgfTtcbiAgfSxcbiAgYmVmb3JlTW91bnQoKSB7XG4gICAgdGhpcy52YWxpZGF0b3IodGhpcy5sb2NhbE5vZGUpO1xuXG4gICAgT2JqZWN0LmtleXModGhpcy5sb2NhbE5vZGUuX2RlZi5kZWZhdWx0cykuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgdGhpcy4kd2F0Y2goXG4gICAgICAgICgpID0+IHRoaXMubG9jYWxOb2RlW3Byb3BdLFxuICAgICAgICAobmV3VmFsKSA9PiB7XG4gICAgICAgICAgdGhpcy52YWxpZGF0ZSgpO1xuICAgICAgICB9LFxuICAgICAgICB7IGRlZXA6IHRydWUgfVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIE9iamVjdC5rZXlzKHRoaXMubG9jYWxOb2RlLl9kZWYuY3JlZGVudGlhbHMpLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5sb2NhbE5vZGUuX2RlZi5jcmVkZW50aWFsc1twcm9wXS50eXBlID09PSBcInBhc3N3b3JkXCIgJiZcbiAgICAgICAgdGhpcy5sb2NhbE5vZGUuY3JlZGVudGlhbHNbYGhhc18ke3Byb3B9YF1cbiAgICAgICkge1xuICAgICAgICB0aGlzLmxvY2FsTm9kZS5jcmVkZW50aWFsc1twcm9wXSA9IFwiX19QV0RfX1wiO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiR3YXRjaChcbiAgICAgICAgKCkgPT4gdGhpcy5sb2NhbE5vZGUuY3JlZGVudGlhbHNbcHJvcF0sXG4gICAgICAgIChuZXdWYWwsIG9sZFZhbCkgPT4ge1xuICAgICAgICAgIHRoaXMudmFsaWRhdGUoKTtcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMubG9jYWxOb2RlLl9kZWYuY3JlZGVudGlhbHNbcHJvcF0udHlwZSA9PT0gXCJwYXNzd29yZFwiICYmXG4gICAgICAgICAgICBuZXdWYWwgIT09IG9sZFZhbFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5sb2NhbE5vZGUuY3JlZGVudGlhbHNbYGhhc18ke3Byb3B9YF0gPSAhIW5ld1ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHsgZGVlcDogdHJ1ZSB9XG4gICAgICApO1xuICAgIH0pO1xuICB9LFxuICBiZWZvcmVVbm1vdW50KCkge1xuICAgICQoXCIjbm9kZS1kaWFsb2ctb2tcIik/LnByb3AoXCJkaXNhYmxlZFwiLCBmYWxzZSkucmVtb3ZlQ2xhc3MoXCJkaXNhYmxlZFwiKTtcbiAgICAkKFwiI25vZGUtY29uZmlnLWRpYWxvZy1va1wiKVxuICAgICAgPy5wcm9wKFwiZGlzYWJsZWRcIiwgZmFsc2UpXG4gICAgICAucmVtb3ZlQ2xhc3MoXCJkaXNhYmxlZFwiKTtcbiAgICAkKFwiI3JlZC11aS13b3Jrc3BhY2VcIikuZ2V0KDApLnN0eWxlLnNldFByb3BlcnR5KFwicG9pbnRlci1ldmVudHNcIiwgXCJcIik7XG4gICAgLy8gJChcIiNyZWQtdWktd29ya3NwYWNlLWNoYXJ0IHN2Z1wiKVxuICAgIC8vICAgLmdldCgwKVxuICAgIC8vICAgLnN0eWxlLnNldFByb3BlcnR5KFwicG9pbnRlci1ldmVudHNcIiwgXCJhbGxcIik7XG5cbiAgICAvLyBOT1RFOiBtdXN0IHNldCBjcmVkZW50aWFscyBwcm9wIHRvIHVuZGVmaW5lZCB0byBhdm9pZCB1cGRhdGluZyBpdCB0byBfX1BXRF9fIGluIHRoZSBzZXJ2ZXJcbiAgICBPYmplY3Qua2V5cyh0aGlzLmxvY2FsTm9kZS5fZGVmLmNyZWRlbnRpYWxzKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMubG9jYWxOb2RlLl9kZWYuY3JlZGVudGlhbHNbcHJvcF0udHlwZSA9PT0gXCJwYXNzd29yZFwiICYmXG4gICAgICAgIHRoaXMubG9jYWxOb2RlLmNyZWRlbnRpYWxzW2BoYXNfJHtwcm9wfWBdICYmXG4gICAgICAgIHRoaXMubG9jYWxOb2RlLmNyZWRlbnRpYWxzW3Byb3BdID09PSBcIl9fUFdEX19cIlxuICAgICAgKSB7XG4gICAgICAgIHRoaXMubG9jYWxOb2RlLmNyZWRlbnRpYWxzW3Byb3BdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgdmFsaWRhdGUoKSB7XG4gICAgICBjb25zdCB2YWxpZCA9IHRoaXMudmFsaWRhdG9yKHRoaXMubG9jYWxOb2RlKTtcbiAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgY29uc3QgZXJyb3JzID0gdGhpcy52YWxpZGF0b3IuZXJyb3JzO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycy5yZWR1Y2UoKGFjYywgZXJyb3IpID0+IHtcbiAgICAgICAgICBjb25zdCBlcnJvclZhbHVlID0ganNvbnBvaW50ZXIuZ2V0KFxuICAgICAgICAgICAgdGhpcy5sb2NhbE5vZGUsXG4gICAgICAgICAgICBlcnJvci5pbnN0YW5jZVBhdGhcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGVycm9yLnBhcmVudFNjaGVtYS5mb3JtYXQgPT09IFwicGFzc3dvcmRcIiAmJlxuICAgICAgICAgICAgZXJyb3JWYWx1ZSA9PT0gXCJfX1BXRF9fXCJcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICBcInBhc3N3b3JkIGZpZWxkcyB3aXRoIHZhbHVlIGVxdWFsIHRvIF9fUFdEX18gc2hvdWxkIG5vdCBiZSBhbiBlcnJvclwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYG5vZGUke2Vycm9yLmluc3RhbmNlUGF0aC5yZXBsYWNlQWxsKFwiL1wiLCBcIi5cIil9YDtcbiAgICAgICAgICAgIGFjY1trZXldID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7fSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVycm9ycyA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuZXJyb3JzKS5sZW5ndGgpIHtcbiAgICAgICAgJChcIiNub2RlLWRpYWxvZy1va1wiKT8ucHJvcChcImRpc2FibGVkXCIsIHRydWUpLmFkZENsYXNzKFwiZGlzYWJsZWRcIik7XG4gICAgICAgICQoXCIjbm9kZS1jb25maWctZGlhbG9nLW9rXCIpXG4gICAgICAgICAgPy5wcm9wKFwiZGlzYWJsZWRcIiwgdHJ1ZSlcbiAgICAgICAgICAuYWRkQ2xhc3MoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgJChcIiNyZWQtdWktd29ya3NwYWNlXCIpXG4gICAgICAgICAgLmdldCgwKVxuICAgICAgICAgIC5zdHlsZS5zZXRQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiLCBcImltcG9ydGFudFwiKTtcbiAgICAgICAgLy8gJChcIiNyZWQtdWktd29ya3NwYWNlLWNoYXJ0IHN2Z1wiKVxuICAgICAgICAvLyAgIC5nZXQoMClcbiAgICAgICAgLy8gICAuc3R5bGUuc2V0UHJvcGVydHkoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIiwgXCJpbXBvcnRhbnRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkKFwiI25vZGUtZGlhbG9nLW9rXCIpLnByb3AoXCJkaXNhYmxlZFwiLCBmYWxzZSkucmVtb3ZlQ2xhc3MoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgJChcIiNub2RlLWNvbmZpZy1kaWFsb2ctb2tcIilcbiAgICAgICAgICAucHJvcChcImRpc2FibGVkXCIsIGZhbHNlKVxuICAgICAgICAgIC5yZW1vdmVDbGFzcyhcImRpc2FibGVkXCIpO1xuICAgICAgICAkKFwiI3JlZC11aS13b3Jrc3BhY2VcIikuZ2V0KDApLnN0eWxlLnNldFByb3BlcnR5KFwicG9pbnRlci1ldmVudHNcIiwgXCJcIik7XG4gICAgICAgIC8vICQoXCIjcmVkLXVpLXdvcmtzcGFjZS1jaGFydCBzdmdcIilcbiAgICAgICAgLy8gICAuZ2V0KDApXG4gICAgICAgIC8vICAgLnN0eWxlLnNldFByb3BlcnR5KFwicG9pbnRlci1ldmVudHNcIiwgXCJhbGxcIik7XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbn07XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuLm5vZGUtcmVkLXZ1ZS1pbnB1dC1lcnJvci1tZXNzYWdlIHtcbiAgY29sb3I6IHZhcigtLXJlZC11aS1mb3JtLWlucHV0LWJvcmRlci1lcnJvci1jb2xvcik7XG59XG48L3N0eWxlPlxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IHN0eWxlPVwiZGlzcGxheTogZmxleDsgZmxleC1kaXJlY3Rpb246IGNvbHVtbjsgd2lkdGg6IDEwMCVcIj5cbiAgICA8aW5wdXRcbiAgICAgIHJlZj1cImlucHV0RmllbGRcIlxuICAgICAgOnR5cGU9XCJ0eXBlXCJcbiAgICAgIDp2YWx1ZT1cImludGVybmFsVmFsdWVcIlxuICAgICAgOnBsYWNlaG9sZGVyPVwicGxhY2Vob2xkZXJcIlxuICAgICAgQGlucHV0PVwib25JbnB1dFwiXG4gICAgICBAZm9jdXM9XCJvbkZvY3VzXCJcbiAgICAgIEBibHVyPVwib25CbHVyXCJcbiAgICAgIHN0eWxlPVwiZmxleDogMTsgd2lkdGg6IDEwMCVcIlxuICAgIC8+XG4gICAgPGRpdiB2LWlmPVwiZXJyb3JcIiBjbGFzcz1cIm5vZGUtcmVkLXZ1ZS1pbnB1dC1lcnJvci1tZXNzYWdlXCI+XG4gICAgICB7eyBlcnJvciB9fVxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIHByb3BzOiB7XG4gICAgdmFsdWU6IFN0cmluZyxcbiAgICB0eXBlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBcInRleHRcIixcbiAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBbXCJ0ZXh0XCIsIFwicGFzc3dvcmRcIl0uaW5jbHVkZXModmFsdWUpO1xuICAgICAgfSxcbiAgICB9LFxuICAgIHBsYWNlaG9sZGVyOiBTdHJpbmcsXG4gICAgZXJyb3I6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IFwiXCIsXG4gICAgfSxcbiAgfSxcbiAgZW1pdHM6IFtcInVwZGF0ZTp2YWx1ZVwiLCBcImlucHV0XCJdLFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpbnRlcm5hbFZhbHVlOiBcIlwiLFxuICAgICAgc2VjcmV0UGF0dGVybjogXCIqKioqKioqKioqKioqXCIsXG4gICAgfTtcbiAgfSxcbiAgYmVmb3JlTW91bnQoKSB7XG4gICAgdGhpcy5pbnRlcm5hbFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICB0aGlzLm9uQmx1cigpO1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25JbnB1dChldmVudCkge1xuICAgICAgdGhpcy5pbnRlcm5hbFZhbHVlID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgICAgdGhpcy4kZW1pdChcInVwZGF0ZTp2YWx1ZVwiLCB0aGlzLmludGVybmFsVmFsdWUpO1xuICAgICAgdGhpcy4kZW1pdChcImlucHV0XCIsIHRoaXMuaW50ZXJuYWxWYWx1ZSk7XG4gICAgfSxcbiAgICBvbkZvY3VzKCkge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLnR5cGUgPT09IFwicGFzc3dvcmRcIiAmJlxuICAgICAgICB0aGlzLmludGVybmFsVmFsdWUgPT09IHRoaXMuc2VjcmV0UGF0dGVyblxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxWYWx1ZSA9IFwiXCI7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkJsdXIoKSB7XG4gICAgICBpZiAodGhpcy50eXBlID09PSBcInBhc3N3b3JkXCIgJiYgdGhpcy52YWx1ZSA9PT0gXCJfX1BXRF9fXCIpIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFZhbHVlID0gdGhpcy5zZWNyZXRQYXR0ZXJuO1xuICAgICAgfVxuICAgIH0sXG4gIH0sXG59O1xuPC9zY3JpcHQ+XG4iLCJjb25zdCBUWVBFRF9JTlBVVF9UWVBFUyA9IFtcbiAgXCJtc2dcIixcbiAgXCJmbG93XCIsXG4gIFwiZ2xvYmFsXCIsXG4gIFwic3RyXCIsXG4gIFwibnVtXCIsXG4gIFwiYm9vbFwiLFxuICBcImpzb25cIixcbiAgXCJiaW5cIixcbiAgXCJyZVwiLFxuICBcImpzb25hdGFcIixcbiAgXCJkYXRlXCIsXG4gIFwiZW52XCIsXG4gIFwibm9kZVwiLFxuICBcImNyZWRcIixcbl07XG5cbmV4cG9ydCB7IFRZUEVEX0lOUFVUX1RZUEVTIH07XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgc3R5bGU9XCJkaXNwbGF5OiBmbGV4OyBmbGV4LWRpcmVjdGlvbjogY29sdW1uOyB3aWR0aDogMTAwJVwiPlxuICAgIDxpbnB1dFxuICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgcmVmPVwidHlwZWRJbnB1dFwiXG4gICAgICBjbGFzcz1cIm5vZGUtcmVkLXR5cGVkLWlucHV0XCJcbiAgICAgIHN0eWxlPVwiZmxleDogMTsgd2lkdGg6IDEwMCVcIlxuICAgIC8+XG4gICAgPGRpdiB2LWlmPVwiZXJyb3JcIiBjbGFzcz1cIm5vZGUtcmVkLXZ1ZS1pbnB1dC1lcnJvci1tZXNzYWdlXCI+XG4gICAgICB7eyBlcnJvciB9fVxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBUWVBFRF9JTlBVVF9UWVBFUyB9IGZyb20gXCIuLi8uLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBwcm9wczoge1xuICAgIHZhbHVlOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAoIXR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJQcm9wICd2YWx1ZScgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1ZhbGlkID1cbiAgICAgICAgICBvYmouaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSAmJlxuICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikgJiZcbiAgICAgICAgICB0eXBlb2Ygb2JqLnZhbHVlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgdHlwZW9mIG9iai50eXBlID09PSBcInN0cmluZ1wiO1xuICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBcIlZhbGlkYXRpb24gZmFpbGVkIGZvciBwcm9wICd2YWx1ZSc6IEl0IG11c3QgYmUgYW4gb2JqZWN0IHdpdGggJ3ZhbHVlJyBhbmQgJ3R5cGUnIHByb3BlcnRpZXMgYmVpbmcgc3RyaW5ncy5cIixcbiAgICAgICAgICAgIG9ialxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgICB9LFxuICAgIH0sXG4gICAgdHlwZXM6IHtcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgZGVmYXVsdDogKCkgPT4gVFlQRURfSU5QVVRfVFlQRVMsXG4gICAgfSxcbiAgICBlcnJvcjoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogXCJcIixcbiAgICB9LFxuICB9LFxuICBlbWl0czogW1widXBkYXRlOnZhbHVlXCJdLFxuICBjb21wdXRlZDoge1xuICAgIGlzUHJvdmlkZWRWYWx1ZVR5cGVWYWxpZCgpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLnZhbHVlLnR5cGU7XG4gICAgICBjb25zdCB0eXBlcyA9IHRoaXMudHlwZXM7XG5cbiAgICAgIHJldHVybiB0eXBlcy5pbmNsdWRlcyh0eXBlKTtcbiAgICB9LFxuICB9LFxuICB3YXRjaDoge1xuICAgIGlzUHJvdmlkZWRWYWx1ZVR5cGVWYWxpZDoge1xuICAgICAgaGFuZGxlcihuZXdWYWx1ZSkge1xuICAgICAgICBpZiAoIW5ld1ZhbHVlKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYFZhbGlkYXRpb24gZmFpbGVkOiB0aGlzLnZhbHVlLnR5cGUgKCR7dGhpcy52YWx1ZS50eXBlfSkgbXVzdCBiZSBvbmUgb2YgdGhlIHByb3ZpZGVkIHR5cGVzICgke3RoaXMudHlwZXN9KS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGltbWVkaWF0ZTogdHJ1ZSxcbiAgICB9LFxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIGNvbnN0IGlucHV0RWxlbWVudCA9IHRoaXMuJHJlZnMudHlwZWRJbnB1dDtcbiAgICB0aGlzLiRpbnB1dCA9ICQoaW5wdXRFbGVtZW50KS50eXBlZElucHV0KHtcbiAgICAgIGRlZmF1bHQ6IHRoaXMudmFsdWUudHlwZSB8fCB0aGlzLnR5cGVzWzBdLFxuICAgICAgdHlwZXM6IHRoaXMudHlwZXMsXG4gICAgfSk7XG5cbiAgICB0aGlzLiRpbnB1dC50eXBlZElucHV0KFwidmFsdWVcIiwgdGhpcy52YWx1ZS52YWx1ZSB8fCBcIlwiKTtcbiAgICB0aGlzLiRpbnB1dC50eXBlZElucHV0KFwidHlwZVwiLCB0aGlzLnZhbHVlLnR5cGUgfHwgdGhpcy50eXBlc1swXSk7XG5cbiAgICAvLyBOT1RFOiB3aGVuIHR5cGVkIGlucHV0IGlzIGp1c3QgYSB0ZXh0IGlucHV0LCBpdCBpc24ndCBlbWl0aW5nIGNoYW5nZSB3aGlsZSB0eXBpbmcgYmVjYXVzZSBpdCBpcyB1cGRhdGluZyB0aGUgdmFsdWUgaW4gYSBoaWRkZW4gaW5wdXRcbiAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChtdXRhdGlvbnMpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgICBpZiAobXV0YXRpb24uYXR0cmlidXRlTmFtZSA9PT0gXCJ2YWx1ZVwiKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShpbnB1dEVsZW1lbnQsIHtcbiAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgYXR0cmlidXRlRmlsdGVyOiBbXCJ2YWx1ZVwiXSxcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIH0pO1xuXG4gICAgLy8gTk9URTogdGhpcyBlbWl0cyBjaGFuZ2VzIHRvIGFsbCB0eXBlcyB0aGF0IGxvc2UgZm9jdXMgd2hlbiBjaG9vc2luZyBhIHZhbHVlLCBidXQgdGV4dCBpbnB1dHNcbiAgICB0aGlzLiRpbnB1dC5vbihcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgfSk7XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgZXJyb3IobmV3VmFsKSB7XG4gICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldERpdiA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgXCIucmVkLXVpLXR5cGVkSW5wdXQtY29udGFpbmVyXCJcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKG5ld1ZhbCkge1xuICAgICAgICAgIHRhcmdldERpdi5jbGFzc0xpc3QuYWRkKFwiaW5wdXQtZXJyb3JcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0RGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJpbnB1dC1lcnJvclwiKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uQ2hhbmdlKCkge1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSB0aGlzLiRpbnB1dC50eXBlZElucHV0KFwidmFsdWVcIik7XG4gICAgICBjb25zdCBuZXdUeXBlID0gdGhpcy4kaW5wdXQudHlwZWRJbnB1dChcInR5cGVcIik7XG4gICAgICBpZiAodGhpcy52YWx1ZS52YWx1ZSAhPT0gbmV3VmFsdWUgfHwgdGhpcy52YWx1ZS50eXBlICE9PSBuZXdUeXBlKSB7XG4gICAgICAgIHRoaXMuJGVtaXQoXCJ1cGRhdGU6dmFsdWVcIiwge1xuICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICB0eXBlOiBuZXdUeXBlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICB9LFxufTtcbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IHN0eWxlPVwiZGlzcGxheTogZmxleDsgZmxleC1kaXJlY3Rpb246IGNvbHVtbjsgd2lkdGg6IDEwMCVcIj5cbiAgICA8aW5wdXQgdHlwZT1cInRleHRcIiA6aWQ9XCJpbnB1dElkXCIgc3R5bGU9XCJ3aWR0aDogMTAwJVwiIC8+XG4gICAgPGRpdiB2LWlmPVwiZXJyb3JcIiBjbGFzcz1cIm5vZGUtcmVkLXZ1ZS1pbnB1dC1lcnJvci1tZXNzYWdlXCI+XG4gICAgICB7eyBlcnJvciB9fVxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIHByb3BzOiB7XG4gICAgdmFsdWU6IFN0cmluZyxcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgZXJyb3I6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IFwiXCIsXG4gICAgfSxcbiAgfSxcbiAgZW1pdHM6IFtcInVwZGF0ZTp2YWx1ZVwiXSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBpbnB1dFByZWZpeCgpIHtcbiAgICAgIHJldHVybiBcIm5vZGUtaW5wdXQtXCIgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgOSk7XG4gICAgfSxcbiAgICBpbnB1dElkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5wdXRQcmVmaXggKyBcIi1cIiArIHRoaXMudmFsdWU7XG4gICAgfSxcbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICBSRUQuZWRpdG9yLnByZXBhcmVDb25maWdOb2RlU2VsZWN0KFxuICAgICAgdGhpcyxcbiAgICAgIHRoaXMudmFsdWUsXG4gICAgICB0aGlzLnR5cGUsXG4gICAgICB0aGlzLmlucHV0UHJlZml4XG4gICAgKTtcblxuICAgIGNvbnN0IGlucHV0ID0gJChcIiNcIiArIHRoaXMuaW5wdXRJZCk7XG4gICAgaW5wdXQub24oXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgdGhpcy4kZW1pdChcInVwZGF0ZTp2YWx1ZVwiLCBpbnB1dC52YWwoKSk7XG4gICAgfSk7XG5cbiAgICBpbnB1dC52YWwodGhpcy52YWx1ZSB8fCBcIl9BRERfXCIpO1xuICB9LFxufTtcbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IHN0eWxlPVwiZGlzcGxheTogZmxleDsgZmxleC1kaXJlY3Rpb246IGNvbHVtbjsgd2lkdGg6IDEwMCVcIj5cbiAgICA8aW5wdXRcbiAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgIHJlZj1cInNlbGVjdElucHV0XCJcbiAgICAgIGNsYXNzPVwibm9kZS1pbnB1dC1zZWxlY3RcIlxuICAgICAgc3R5bGU9XCJ3aWR0aDogMTAwJVwiXG4gICAgLz5cbiAgICA8ZGl2IHYtaWY9XCJlcnJvclwiIGNsYXNzPVwibm9kZS1yZWQtdnVlLWlucHV0LWVycm9yLW1lc3NhZ2VcIj5cbiAgICAgIHt7IGVycm9yIH19XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgcHJvcHM6IHtcbiAgICB2YWx1ZTogU3RyaW5nIHwgQXJyYXksXG4gICAgb3B0aW9uczoge1xuICAgICAgdHlwZTogQXJyYXksXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJQcm9wICdvcHRpb25zJyBtdXN0IGJlIGFuIGFycmF5LlwiKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNWYWxpZCA9IHZhbHVlLmV2ZXJ5KChpdGVtKSA9PiB7XG4gICAgICAgICAgY29uc3QgaXNPYmplY3QgPSB0eXBlb2YgaXRlbSA9PT0gXCJvYmplY3RcIiAmJiBpdGVtICE9PSBudWxsO1xuICAgICAgICAgIGlmICghaXNPYmplY3QpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXRlbS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpICYmXG4gICAgICAgICAgICBpdGVtLmhhc093blByb3BlcnR5KFwibGFiZWxcIikgJiZcbiAgICAgICAgICAgIHR5cGVvZiBpdGVtLnZhbHVlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICB0eXBlb2YgaXRlbS5sYWJlbCA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIFwiVmFsaWRhdGlvbiBmYWlsZWQgZm9yIHByb3AgJ29wdGlvbnMnOiBFYWNoIGl0ZW0gbXVzdCBiZSBhbiBvYmplY3Qgd2l0aCAndmFsdWUnIGFuZCAnbGFiZWwnIHByb3BlcnRpZXMgYmVpbmcgc3RyaW5ncy5cIixcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNWYWxpZDtcbiAgICAgIH0sXG4gICAgfSxcbiAgICBtdWx0aXBsZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIH0sXG4gICAgZXJyb3I6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IFwiXCIsXG4gICAgfSxcbiAgfSxcbiAgZW1pdHM6IFtcInVwZGF0ZTp2YWx1ZVwiXSxcbiAgbW91bnRlZCgpIHtcbiAgICBjb25zdCBpbnB1dEVsZW1lbnQgPSB0aGlzLiRyZWZzLnNlbGVjdElucHV0O1xuICAgIGNvbnN0ICRzZWxlY3RJbnB1dCA9ICQoaW5wdXRFbGVtZW50KTtcbiAgICAkc2VsZWN0SW5wdXQudHlwZWRJbnB1dCh7XG4gICAgICB0eXBlczogW1xuICAgICAgICB7XG4gICAgICAgICAgbXVsdGlwbGU6IHRoaXMubXVsdGlwbGUsXG4gICAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9KTtcblxuICAgICRzZWxlY3RJbnB1dC50eXBlZElucHV0KFxuICAgICAgXCJ2YWx1ZVwiLFxuICAgICAgQXJyYXkuaXNBcnJheSh0aGlzLnZhbHVlKSA/IHRoaXMudmFsdWUuam9pbihcIixcIikgOiB0aGlzLnZhbHVlXG4gICAgKTtcbiAgICAkc2VsZWN0SW5wdXQub24oXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSB0aGlzLm11bHRpcGxlXG4gICAgICAgID8gJHNlbGVjdElucHV0LnR5cGVkSW5wdXQoXCJ2YWx1ZVwiKT8uc3BsaXQoXCIsXCIpXG4gICAgICAgIDogJHNlbGVjdElucHV0LnR5cGVkSW5wdXQoXCJ2YWx1ZVwiKTtcbiAgICAgIHRoaXMuJGVtaXQoXCJ1cGRhdGU6dmFsdWVcIiwgbmV3VmFsdWUpO1xuICAgIH0pO1xuICB9LFxufTtcbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IHJlZj1cImNvbnRhaW5lckRpdlwiIGNsYXNzPVwibm9kZS10ZXh0LWVkaXRvci1jb250YWluZXJcIj5cbiAgICA8ZGl2IHJlZj1cImVkaXRvckRpdlwiIDppZD1cImVkaXRvcklkXCIgY2xhc3M9XCJub2RlLXRleHQtZWRpdG9yXCI+PC9kaXY+XG4gICAgPGRpdiB2LXNob3c9XCJlcnJvclwiIGNsYXNzPVwibm9kZS1yZWQtdnVlLWlucHV0LWVycm9yLW1lc3NhZ2VcIj5cbiAgICAgIHt7IGVycm9yIH19XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgcHJvcHM6IHtcbiAgICB2YWx1ZTogU3RyaW5nLFxuICAgIGxhbmd1YWdlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBcImpzb25cIixcbiAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGFsbG93ZWRMYW5ndWFnZXMgPSBbXG4gICAgICAgICAgXCJ0ZXh0XCIsXG4gICAgICAgICAgXCJqc29uXCIsXG4gICAgICAgICAgXCJqYXZhc2NyaXB0XCIsXG4gICAgICAgICAgXCJodG1sXCIsXG4gICAgICAgICAgXCJjc3NcIixcbiAgICAgICAgICBcIm1hcmtkb3duXCIsXG4gICAgICAgICAgXCJzcWxcIixcbiAgICAgICAgICBcInlhbWxcIixcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgaXNWYWxpZCA9IGFsbG93ZWRMYW5ndWFnZXMuaW5jbHVkZXModmFsdWUpO1xuICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBgW05vZGVSZWRFZGl0b3JDb21wb25lbnRdIEludmFsaWQgQUNFIGVkaXRvciBtb2RlIHByb3A6IFwiJHt2YWx1ZX1cIi4gYCArXG4gICAgICAgICAgICAgIGBFeHBlY3RlZCBvbmUgb2Y6ICR7YWxsb3dlZExhbmd1YWdlcy5qb2luKFwiLCBcIil9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgICB9LFxuICAgIH0sXG4gICAgZXJyb3I6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IFwiXCIsXG4gICAgfSxcbiAgfSxcbiAgZW1pdHM6IFtcInVwZGF0ZTp2YWx1ZVwiXSxcbiAgZWRpdG9yOiBudWxsLFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBlZGl0b3JJZDogXCJub2RlLXJlZC1lZGl0b3ItXCIgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgOSksXG4gICAgfTtcbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLm1vdW50RWRpdG9yKCk7XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBtb3VudEVkaXRvcigpIHtcbiAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyRWwgPSB0aGlzLiRyZWZzLmNvbnRhaW5lckRpdjtcbiAgICAgICAgY29uc3QgZWRpdG9yRWwgPSB0aGlzLiRyZWZzLmVkaXRvckRpdjtcblxuICAgICAgICBpZiAoY29udGFpbmVyRWwgJiYgZWRpdG9yRWwpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaW5saW5lSGVpZ2h0ID0gY29udGFpbmVyRWwuc3R5bGUuaGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgaW5saW5lV2lkdGggPSBjb250YWluZXJFbC5zdHlsZS53aWR0aDtcbiAgICAgICAgICAgIGlmIChpbmxpbmVIZWlnaHQpIHtcbiAgICAgICAgICAgICAgZWRpdG9yRWwuc3R5bGUuaGVpZ2h0ID0gaW5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWRpdG9yRWwuc3R5bGUuaGVpZ2h0ID0gXCIyMDBweFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5saW5lV2lkdGgpIHtcbiAgICAgICAgICAgICAgZWRpdG9yRWwuc3R5bGUud2lkdGggPSBpbmxpbmVXaWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVkaXRvckVsLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRWRpdG9ySW5zdGFuY2UoKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIltOb2RlUmVkRWRpdG9ySW5wdXRdIEVycm9yIHNldHRpbmcgaW5pdGlhbCBlZGl0b3Igc3R5bGU6XCIsXG4gICAgICAgICAgICAgIGVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUVkaXRvckluc3RhbmNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIltOb2RlUmVkRWRpdG9ySW5wdXRdIENvbnRhaW5lciBvciBFZGl0b3IgZGl2IHJlZnMgbm90IGZvdW5kIG9uIG1vdW50LlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBjcmVhdGVFZGl0b3JJbnN0YW5jZSgpIHtcbiAgICAgIHRoaXMuZWRpdG9ySW5zdGFuY2UgPSBSRUQuZWRpdG9yLmNyZWF0ZUVkaXRvcih7XG4gICAgICAgIGlkOiB0aGlzLmVkaXRvcklkLFxuICAgICAgICBtb2RlOiB0aGlzLmxhbmd1YWdlLFxuICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lZGl0b3JJbnN0YW5jZS5nZXRTZXNzaW9uKCkub24oXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLmVkaXRvckluc3RhbmNlLmdldFZhbHVlKCk7XG4gICAgICAgIGlmIChjdXJyZW50VmFsdWUgIT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICB0aGlzLiRlbWl0KFwidXBkYXRlOnZhbHVlXCIsIGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gIH0sXG4gIGJlZm9yZVVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuZWRpdG9ySW5zdGFuY2UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuZWRpdG9ySW5zdGFuY2UuZGVzdHJveSgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGRlc3Ryb3lpbmcgZWRpdG9yIGZvciBJRCAke3RoaXMuZWRpdG9ySWR9OmAsIGVycik7XG4gICAgICB9XG4gICAgICB0aGlzLmVkaXRvckluc3RhbmNlID0gbnVsbDtcbiAgICB9XG4gIH0sXG59O1xuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgJCBmcm9tIFwianF1ZXJ5XCI7XG5pbXBvcnQgeyBjcmVhdGVBcHAsIENvbXBvbmVudCwgQXBwLCBkZWZpbmVDb21wb25lbnQgfSBmcm9tIFwidnVlXCI7XG5pbXBvcnQgeyBjbG9uZURlZXAsIGlzRXF1YWwsIG1lcmdlIH0gZnJvbSBcImVzLXRvb2xraXRcIjtcbmltcG9ydCB7IEFueVNjaGVtYSwgVmFsaWRhdGVGdW5jdGlvbiB9IGZyb20gXCJhanZcIjtcbmltcG9ydCB7XG4gIGdldERlZmF1bHRzRnJvbVNjaGVtYSxcbiAgZ2V0Q3JlZGVudGlhbHNGcm9tU2NoZW1hLFxuICBwYXRjaFBhc3N3b3JkUGF0dGVybnMsXG59IGZyb20gXCIuLi91dGlsc1wiO1xuXG5pbXBvcnQgTm9kZVJlZFZ1ZUFwcCBmcm9tIFwiLi9BcHAudnVlXCI7XG5pbXBvcnQgTm9kZVJlZElucHV0IGZyb20gXCIuL2NvbXBvbmVudHMvTm9kZVJlZElucHV0LnZ1ZVwiO1xuaW1wb3J0IE5vZGVSZWRUeXBlZElucHV0IGZyb20gXCIuL2NvbXBvbmVudHMvTm9kZVJlZFR5cGVkSW5wdXQudnVlXCI7XG5pbXBvcnQgTm9kZVJlZENvbmZpZ0lucHV0IGZyb20gXCIuL2NvbXBvbmVudHMvTm9kZVJlZENvbmZpZ0lucHV0LnZ1ZVwiO1xuaW1wb3J0IE5vZGVSZWRTZWxlY3RJbnB1dCBmcm9tIFwiLi9jb21wb25lbnRzL05vZGVSZWRTZWxlY3RJbnB1dC52dWVcIjtcbmltcG9ydCBOb2RlUmVkRWRpdG9ySW5wdXQgZnJvbSBcIi4vY29tcG9uZW50cy9Ob2RlUmVkRWRpdG9ySW5wdXQudnVlXCI7XG5cbmltcG9ydCB7IHZhbGlkYXRvclNlcnZpY2UgfSBmcm9tIFwiLi92YWxpZGF0b3JcIjtcblxuZnVuY3Rpb24gY3JlYXRlTm9kZVJlZFZ1ZUFwcChcbiAgbm9kZTogYW55LFxuICBmb3JtOiBDb21wb25lbnQsXG4gIHZhbGlkYXRvcjogVmFsaWRhdGVGdW5jdGlvbiB8ICgoKSA9PiBib29sZWFuKVxuKTogQXBwPEVsZW1lbnQ+IHtcbiAgY29uc3QgYXBwID0gY3JlYXRlQXBwKE5vZGVSZWRWdWVBcHAsIHtcbiAgICBub2RlLFxuICAgIHZhbGlkYXRvcixcbiAgfSk7XG5cbiAgYXBwLmNvbXBvbmVudChcIk5vZGVSZWRJbnB1dFwiLCBOb2RlUmVkSW5wdXQpO1xuICBhcHAuY29tcG9uZW50KFwiTm9kZVJlZFR5cGVkSW5wdXRcIiwgTm9kZVJlZFR5cGVkSW5wdXQpO1xuICBhcHAuY29tcG9uZW50KFwiTm9kZVJlZENvbmZpZ0lucHV0XCIsIE5vZGVSZWRDb25maWdJbnB1dCk7XG4gIGFwcC5jb21wb25lbnQoXCJOb2RlUmVkU2VsZWN0SW5wdXRcIiwgTm9kZVJlZFNlbGVjdElucHV0KTtcbiAgYXBwLmNvbXBvbmVudChcIk5vZGVSZWRFZGl0b3JJbnB1dFwiLCBOb2RlUmVkRWRpdG9ySW5wdXQpO1xuICBhcHAuY29tcG9uZW50KFwiTm9kZVJlZE5vZGVGb3JtXCIsIGZvcm0pO1xuICByZXR1cm4gYXBwO1xufVxuXG5mdW5jdGlvbiBtb3VudEFwcChcbiAgbm9kZTogYW55LFxuICBmb3JtOiBDb21wb25lbnQsXG4gIHZhbGlkYXRvcjogVmFsaWRhdGVGdW5jdGlvbiB8ICgoKSA9PiBib29sZWFuKVxuKSB7XG4gICQoXCIjYXBwXCIpLmVtcHR5KCk7XG4gIG5vZGUuX25ld1N0YXRlID0gY2xvbmVEZWVwKG5vZGUpO1xuICBub2RlLl9hcHAgPSBjcmVhdGVOb2RlUmVkVnVlQXBwKG5vZGUuX25ld1N0YXRlLCBmb3JtLCB2YWxpZGF0b3IpO1xuICBub2RlLl9hcHAubW91bnQoXCIjYXBwXCIpO1xufVxuXG5mdW5jdGlvbiB1bm1vdW50QXBwKG5vZGU6IGFueSkge1xuICBpZiAobm9kZS5fYXBwKSB7XG4gICAgbm9kZS5fYXBwLnVubW91bnQoKTtcbiAgICBub2RlLl9hcHAgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldE5vZGVTdGF0ZShub2RlOiBhbnkpIHtcbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgY3JlZGVudGlhbHM6IHt9LFxuICB9O1xuICBPYmplY3Qua2V5cyhub2RlLl9kZWYuZGVmYXVsdHMpLmZvckVhY2goKHByb3ApID0+IHtcbiAgICBzdGF0ZVtwcm9wXSA9IG5vZGVbcHJvcF07XG4gIH0pO1xuICBPYmplY3Qua2V5cyhub2RlLl9kZWYuY3JlZGVudGlhbHMpLmZvckVhY2goKHByb3ApID0+IHtcbiAgICBzdGF0ZS5jcmVkZW50aWFsc1twcm9wXSA9IG5vZGUuY3JlZGVudGlhbHNbcHJvcF07XG5cbiAgICBpZiAobm9kZS5fZGVmLmNyZWRlbnRpYWxzW3Byb3BdLnR5cGUgPT09IFwicGFzc3dvcmRcIikge1xuICAgICAgc3RhdGUuY3JlZGVudGlhbHNbYGhhc18ke3Byb3B9YF0gPVxuICAgICAgICBub2RlLmNyZWRlbnRpYWxzW2BoYXNfJHtwcm9wfWBdIHx8IGZhbHNlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG5mdW5jdGlvbiBnZXRDaGFuZ2VzKG86IFJlY29yZDxhbnksIGFueT4sIG46IFJlY29yZDxhbnksIGFueT4pIHtcbiAgY29uc3QgY2hhbmdlcyA9IHt9O1xuXG4gIE9iamVjdC5rZXlzKG8pLmZvckVhY2goKHByb3ApID0+IHtcbiAgICBjb25zdCBfbyA9IG9bcHJvcF07XG4gICAgY29uc3QgX24gPSBuW3Byb3BdO1xuXG4gICAgaWYgKHR5cGVvZiBfbyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3QgX2NoYW5nZXMgPSBnZXRDaGFuZ2VzKF9vLCBfbik7XG4gICAgICBpZiAoT2JqZWN0LmtleXMoX2NoYW5nZXMpLmxlbmd0aCkge1xuICAgICAgICBjaGFuZ2VzW3Byb3BdID0gX2NoYW5nZXM7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNFcXVhbChfbywgX24pKSB7XG4gICAgICBjaGFuZ2VzW3Byb3BdID0gX287XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY2hhbmdlcztcbn1cblxuLyoqXG4gKiBJbnRlcmZhY2UgcmVwcmVzZW50aW5nIGEgYnV0dG9uIGNvbmZpZ3VyYXRpb24gZm9yIGEgbm9kZS5cbiAqXG4gKiBAaW50ZXJmYWNlIElOb2RlQnV0dG9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdG9nZ2xlIC0gVGV4dCB0byBkaXNwbGF5IHdoZW4gdG9nZ2xpbmcgdGhlIGJ1dHRvbi5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oKTogdm9pZH0gb25jbGljayAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgYnV0dG9uIGlzIGNsaWNrZWQuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKCk6IGJvb2xlYW59IFtlbmFibGVkXSAtIEZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBidXR0b24gc2hvdWxkIGJlXG4gKiAgIGVuYWJsZWQuIFJldHVybnMgdHJ1ZSBpZiB0aGUgYnV0dG9uIHNob3VsZCBiZSBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKCk6IGJvb2xlYW59IFt2aXNpYmxlXSAtIEZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBidXR0b24gc2hvdWxkIGJlXG4gKiAgIHZpc2libGUuIFJldHVybnMgdHJ1ZSBpZiB0aGUgYnV0dG9uIHNob3VsZCBiZSB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmludGVyZmFjZSBJTm9kZUJ1dHRvbiB7XG4gIHRvZ2dsZTogc3RyaW5nO1xuICBvbmNsaWNrOiAoKSA9PiB2b2lkO1xuICBlbmFibGVkPzogKCkgPT4gYm9vbGVhbjtcbiAgdmlzaWJsZT86ICgpID0+IGJvb2xlYW47XG59XG5cbi8qKlxuICogSW50ZXJmYWNlIHJlcHJlc2VudGluZyBhIE5vZGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAaW50ZXJmYWNlIElOb2RlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBub2RlIHR5cGUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY2F0ZWdvcnkgLSBUaGUgY2F0ZWdvcnkgdGhpcyBub2RlIGJlbG9uZ3MgdG8gaW4gdGhlIHBhbGV0dGUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NvbG9yXSAtIFRoZSBjb2xvciBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCBpbiBoZXggZm9ybWF0LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtpY29uXSAtIFRoZSBpY29uIHRvIGRpc3BsYXkgZm9yIHRoaXMgbm9kZS5cbiAqIEBwcm9wZXJ0eSB7KGZ1bmN0aW9uKCk6IHN0cmluZyl8c3RyaW5nfSBbbGFiZWxdIC0gVGhlIGxhYmVsIHRvIGRpc3BsYXkgb24gdGhlIG5vZGUuIENhbiBiZSBhIHN0YXRpYyBzdHJpbmcgb3IgYSBmdW5jdGlvbiByZXR1cm5pbmcgYSBzdHJpbmcuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2lucHV0c10gLSBOdW1iZXIgb2YgaW5wdXQgcG9ydHMgdGhlIG5vZGUgc2hvdWxkIGhhdmUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW291dHB1dHNdIC0gTnVtYmVyIG9mIG91dHB1dCBwb3J0cyB0aGUgbm9kZSBzaG91bGQgaGF2ZS5cbiAqIEBwcm9wZXJ0eSB7KGZ1bmN0aW9uKCk6IHN0cmluZyl8c3RyaW5nfSBbcGFsZXR0ZUxhYmVsXSAtIFRoZSBsYWJlbCB0byBzaG93IGluIHRoZSBwYWxldHRlLiBDYW4gYmUgYSBzdGF0aWMgc3RyaW5nIG9yIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgc3RyaW5nLlxuICogQHByb3BlcnR5IHsoZnVuY3Rpb24oKTogc3RyaW5nKXxzdHJpbmd9IFtsYWJlbFN0eWxlXSAtIENTUyBzdHlsZSB0byBhcHBseSB0byB0aGUgbm9kZSBsYWJlbC4gQ2FuIGJlIGEgc3RhdGljIHN0cmluZyBvciBhIGZ1bmN0aW9uIHJldHVybmluZyBhIHN0cmluZy5cbiAqIEBwcm9wZXJ0eSB7KGZ1bmN0aW9uKCk6IHN0cmluZyl8c3RyaW5nfSBbaW5wdXRMYWJlbHNdIC0gTGFiZWxzIGZvciB0aGUgaW5wdXQgcG9ydHMuIENhbiBiZSBhIHN0YXRpYyBzdHJpbmcgb3IgYSBmdW5jdGlvbiByZXR1cm5pbmcgYSBzdHJpbmcuXG4gKiBAcHJvcGVydHkgeyhmdW5jdGlvbigpOiBzdHJpbmcpfHN0cmluZ30gW291dHB1dExhYmVsc10gLSBMYWJlbHMgZm9yIHRoZSBvdXRwdXQgcG9ydHMuIENhbiBiZSBhIHN0YXRpYyBzdHJpbmcgb3IgYSBmdW5jdGlvbiByZXR1cm5pbmcgYSBzdHJpbmcuXG4gKiBAcHJvcGVydHkge1wibGVmdFwifFwicmlnaHRcIn0gW2FsaWduXSAtIEFsaWdubWVudCBvZiB0aGUgbm9kZSBjb250ZW50LlxuICogQHByb3BlcnR5IHtJTm9kZUJ1dHRvbn0gW2J1dHRvbl0gLSBDb25maWd1cmF0aW9uIGZvciBhIGJ1dHRvbiBvbiB0aGUgbm9kZS5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oKTogdm9pZH0gW29uUGFsZXR0ZUFkZF0gLSBGdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgbm9kZSBpcyBhZGRlZCB0byB0aGUgcGFsZXR0ZS5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oKTogdm9pZH0gW29uUGFsZXR0ZVJlbW92ZV0gLSBGdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgbm9kZSBpcyByZW1vdmVkIGZyb20gdGhlIHBhbGV0dGUuXG4gKiBAcHJvcGVydHkge0NvbXBvbmVudH0gZm9ybSAtIFRoZSBmb3JtIGNvbXBvbmVudCB0byB1c2UgZm9yIGNvbmZpZ3VyaW5nIHRoZSBub2RlLlxuICogQHByb3BlcnR5IHtBbnlTY2hlbWF9IFtzY2hlbWFdIC0gU2NoZW1hIGRlZmluaXRpb24gZm9yIHZhbGlkYXRpb24uXG4gKi9cbmludGVyZmFjZSBJTm9kZSB7XG4gIHR5cGU6IHN0cmluZztcbiAgY2F0ZWdvcnk6IHN0cmluZztcbiAgY29sb3I/OiBzdHJpbmc7XG4gIGljb24/OiBzdHJpbmc7XG4gIGxhYmVsPzogKCgpID0+IHN0cmluZykgfCBzdHJpbmc7XG4gIGlucHV0cz86IG51bWJlcjtcbiAgb3V0cHV0cz86IG51bWJlcjtcbiAgcGFsZXR0ZUxhYmVsPzogKCgpID0+IHN0cmluZykgfCBzdHJpbmc7XG4gIGxhYmVsU3R5bGU/OiAoKCkgPT4gc3RyaW5nKSB8IHN0cmluZztcbiAgaW5wdXRMYWJlbHM/OiAoKCkgPT4gc3RyaW5nKSB8IHN0cmluZztcbiAgb3V0cHV0TGFiZWxzPzogKCgpID0+IHN0cmluZykgfCBzdHJpbmc7XG4gIGFsaWduPzogXCJsZWZ0XCIgfCBcInJpZ2h0XCI7XG4gIGJ1dHRvbj86IElOb2RlQnV0dG9uO1xuICBvblBhbGV0dGVBZGQ/OiAoKSA9PiB2b2lkO1xuICBvblBhbGV0dGVSZW1vdmU/OiAoKSA9PiB2b2lkO1xuICBmb3JtOiBDb21wb25lbnQ7XG4gIHNjaGVtYT86IEFueVNjaGVtYTtcbn1cblxuLyoqXG4gKiBQcmVwYXJlcyBhIG5vZGUgcmVnaXN0cmF0aW9uIGZ1bmN0aW9uIHVzaW5nIHRoZSBwcm92aWRlZCBiYXNlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogVGhpcyBpcyBhIGhpZ2hlci1vcmRlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBjYW4gYmUgdXNlZFxuICogdG8gcmVnaXN0ZXIgdGhlIG5vZGUgd2l0aCBhIHNwZWNpZmljIHR5cGUgYXQgcnVudGltZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZUNvbmZpZyAtIFRoZSBzdGF0aWMgY29uZmlndXJhdGlvbiBzaGFyZWQgYnkgYWxsIG5vZGVzIG9mIHRoaXMga2luZFxuICogQHBhcmFtIHtzdHJpbmd9IFtub2RlQ29uZmlnLmNhdGVnb3J5PVwidW5kZWZpbmVkXCJdIC0gVGhlIGNhdGVnb3J5IHRoaXMgbm9kZSBiZWxvbmdzIHRvIGluIHRoZSBwYWxldHRlXG4gKiBAcGFyYW0ge3N0cmluZ30gW25vZGVDb25maWcuY29sb3I9XCIjRkZGRkZGXCJdIC0gVGhlIGNvbG9yIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG5vZGUsIGluIGhleCBmb3JtYXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbm9kZUNvbmZpZy5pY29uXSAtIFRoZSBpY29uIHRvIGRpc3BsYXkgZm9yIHRoaXMgbm9kZVxuICogQHBhcmFtIHsoZnVuY3Rpb24oKTogc3RyaW5nKXxzdHJpbmd9IFtub2RlQ29uZmlnLmxhYmVsXSAtIFRoZSBsYWJlbCB0byBkaXNwbGF5IG9uIHRoZSBub2RlXG4gKiBAcGFyYW0ge251bWJlcn0gW25vZGVDb25maWcuaW5wdXRzPTBdIC0gTnVtYmVyIG9mIGlucHV0IHBvcnRzIHRoZSBub2RlIHNob3VsZCBoYXZlXG4gKiBAcGFyYW0ge251bWJlcn0gW25vZGVDb25maWcub3V0cHV0cz0wXSAtIE51bWJlciBvZiBvdXRwdXQgcG9ydHMgdGhlIG5vZGUgc2hvdWxkIGhhdmVcbiAqIEBwYXJhbSB7KGZ1bmN0aW9uKCk6IHN0cmluZyl8c3RyaW5nfSBbbm9kZUNvbmZpZy5wYWxldHRlTGFiZWxdIC0gVGhlIGxhYmVsIHRvIHNob3cgaW4gdGhlIHBhbGV0dGVcbiAqIEBwYXJhbSB7KGZ1bmN0aW9uKCk6IHN0cmluZyl8c3RyaW5nfSBbbm9kZUNvbmZpZy5sYWJlbFN0eWxlXSAtIENTUyBzdHlsZSB0byBhcHBseSB0byB0aGUgbm9kZSBsYWJlbFxuICogQHBhcmFtIHsoZnVuY3Rpb24oKTogc3RyaW5nKXxzdHJpbmd9IFtub2RlQ29uZmlnLmlucHV0TGFiZWxzXSAtIExhYmVscyBmb3IgdGhlIGlucHV0IHBvcnRzXG4gKiBAcGFyYW0geyhmdW5jdGlvbigpOiBzdHJpbmcpfHN0cmluZ30gW25vZGVDb25maWcub3V0cHV0TGFiZWxzXSAtIExhYmVscyBmb3IgdGhlIG91dHB1dCBwb3J0c1xuICogQHBhcmFtIHtcImxlZnRcInxcInJpZ2h0XCJ9IFtub2RlQ29uZmlnLmFsaWduPVwibGVmdFwiXSAtIEFsaWdubWVudCBvZiB0aGUgbm9kZSBjb250ZW50XG4gKiBAcGFyYW0ge0lOb2RlQnV0dG9ufSBbbm9kZUNvbmZpZy5idXR0b25dIC0gQ29uZmlndXJhdGlvbiBmb3IgYSBidXR0b24gb24gdGhlIG5vZGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogdm9pZH0gW25vZGVDb25maWcub25QYWxldHRlQWRkXSAtIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZSBub2RlIGlzIGFkZGVkIHRvIHRoZSBwYWxldHRlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFtub2RlQ29uZmlnLm9uUGFsZXR0ZVJlbW92ZV0gLSBGdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgbm9kZSBpcyByZW1vdmVkIGZyb20gdGhlIHBhbGV0dGVcbiAqIEBwYXJhbSB7Q29tcG9uZW50fSBub2RlQ29uZmlnLmZvcm0gLSBUaGUgZm9ybSBjb21wb25lbnQgdG8gdXNlIGZvciBjb25maWd1cmluZyB0aGUgbm9kZVxuICogQHBhcmFtIHtBbnlTY2hlbWF9IFtub2RlQ29uZmlnLnNjaGVtYV0gLSBTY2hlbWEgZGVmaW5pdGlvbiBmb3IgdmFsaWRhdGlvblxuICpcbiAqIEByZXR1cm5zIHtmdW5jdGlvbih0eXBlOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+fSAtIEEgZnVuY3Rpb24gdGhhdCByZWdpc3RlcnMgdGhlIG5vZGUgd2l0aCB0aGUgc3BlY2lmaWVkIHR5cGVcbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJUeXBlKG9wdGlvbnM6IE9taXQ8SU5vZGUsIFwidHlwZVwiPikge1xuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgbm9kZSB0eXBlIHdpdGggdGhlIE5vZGUtUkVEIHJ1bnRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgaWRlbnRpZmllciBmb3IgdGhlIG5vZGVcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiByZWdpc3RyYXRpb24gaXMgY29tcGxldGVcbiAgICogQHRocm93cyB7RXJyb3J9IC0gSWYgdGhlcmUgaXMgYSBuZXR3b3JrIGVycm9yIG9yIHRoZSBzZXJ2ZXIgcmV0dXJucyBhbiBlcnJvciBzdGF0dXNcbiAgICovXG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiAodHlwZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9ucmcvbm9kZXMvJHt0eXBlfWApO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgc2NoZW1hIH0gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGNvbnN0IGRlZmF1bHRzID0gZ2V0RGVmYXVsdHNGcm9tU2NoZW1hKHNjaGVtYSk7XG4gICAgICBpZiAoZGVmYXVsdHMuY3JlZGVudGlhbHMpIGRlbGV0ZSBkZWZhdWx0cy5jcmVkZW50aWFscztcbiAgICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gZ2V0Q3JlZGVudGlhbHNGcm9tU2NoZW1hKFxuICAgICAgICBzY2hlbWEucHJvcGVydGllcy5jcmVkZW50aWFsc1xuICAgICAgKTtcblxuICAgICAgY29uc29sZS5sb2coXCJkZWZhdWx0c1wiLCBkZWZhdWx0cyk7XG4gICAgICBjb25zb2xlLmxvZyhcImNyZWRlbnRpYWxzXCIsIGNyZWRlbnRpYWxzKTtcblxuICAgICAgUkVELm5vZGVzLnJlZ2lzdGVyVHlwZSh0eXBlLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGRlZmF1bHRzLFxuICAgICAgICBjcmVkZW50aWFscyxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgbGFiZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBvbmVkaXRwcmVwYXJlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gdmFsaWRhdG9yU2VydmljZS5jcmVhdGVWYWxpZGF0b3Ioc2NoZW1hKTtcbiAgICAgICAgICBtb3VudEFwcCh0aGlzLCBvcHRpb25zLmZvcm0sIHZhbGlkYXRvcik7XG4gICAgICAgIH0sXG4gICAgICAgIG9uZWRpdHNhdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gdGhpcztcbiAgICAgICAgICB1bm1vdW50QXBwKG5vZGUpO1xuXG4gICAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBnZXROb2RlU3RhdGUobm9kZS5fbmV3U3RhdGUpO1xuICAgICAgICAgIGNvbnN0IG9sZFN0YXRlID0gZ2V0Tm9kZVN0YXRlKG5vZGUpO1xuICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSBnZXRDaGFuZ2VzKG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gICAgICAgICAgY29uc3QgY2hhbmdlZCA9ICEhT2JqZWN0LmtleXMoY2hhbmdlcyk/Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWNoYW5nZWQpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgIE9iamVjdC5rZXlzKG5vZGUuX2RlZi5kZWZhdWx0cykuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUuX2RlZi5kZWZhdWx0cz8uW3Byb3BdPy50eXBlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG9sZENvbmZpZ05vZGVJZCA9IG5vZGVbcHJvcF07XG4gICAgICAgICAgICAgIGNvbnN0IG5ld0NvbmZpZ05vZGVJZCA9IG5vZGUuX25ld1N0YXRlW3Byb3BdO1xuICAgICAgICAgICAgICBpZiAob2xkQ29uZmlnTm9kZUlkICE9PSBuZXdDb25maWdOb2RlSWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRDb25maWdOb2RlID0gUkVELm5vZGVzLm5vZGUob2xkQ29uZmlnTm9kZUlkKTtcbiAgICAgICAgICAgICAgICBpZiAob2xkQ29uZmlnTm9kZSAmJiBvbGRDb25maWdOb2RlLl9kZWYuY2F0ZWdvcnkgPT09IFwiY29uZmlnXCIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGVJbmRleCA9IG9sZENvbmZpZ05vZGUudXNlcnMuZmluZEluZGV4KFxuICAgICAgICAgICAgICAgICAgICAoX25vZGUpID0+IF9ub2RlLmlkID09PSBub2RlLmlkXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudE5vZGVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkQ29uZmlnTm9kZS51c2Vycy5zcGxpY2UocGFyZW50Tm9kZUluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIE9iamVjdC5rZXlzKG5vZGUuX2RlZi5kZWZhdWx0cykuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUuX2RlZi5kZWZhdWx0cz8uW3Byb3BdPy50eXBlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5ld1N0YXRlQ29uZmlnTm9kZUlkID0gbm9kZS5fbmV3U3RhdGVbcHJvcF07XG4gICAgICAgICAgICAgIGNvbnN0IG5ld1N0YXRlQ29uZmlnTm9kZSA9IFJFRC5ub2Rlcy5ub2RlKG5ld1N0YXRlQ29uZmlnTm9kZUlkKTtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG5ld1N0YXRlQ29uZmlnTm9kZSAmJlxuICAgICAgICAgICAgICAgIG5ld1N0YXRlQ29uZmlnTm9kZS5fZGVmLmNhdGVnb3J5ID09PSBcImNvbmZpZ1wiXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGVJbmRleCA9IG5ld1N0YXRlQ29uZmlnTm9kZS51c2Vycy5maW5kSW5kZXgoXG4gICAgICAgICAgICAgICAgICAoX25vZGUpID0+IF9ub2RlLmlkID09PSBub2RlLmlkXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Tm9kZUluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgbmV3U3RhdGVDb25maWdOb2RlLnVzZXJzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBtZXJnZShub2RlLCBuZXdTdGF0ZSk7XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhbmdlZCxcbiAgICAgICAgICAgIGhpc3Rvcnk6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHQ6IFwiZWRpdFwiLFxuICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgICAgICAgICBsaW5rczogW10sXG4gICAgICAgICAgICAgICAgZGlydHk6IFJFRC5ub2Rlcy5kaXJ0eSgpLFxuICAgICAgICAgICAgICAgIGNoYW5nZWQsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIG9uZWRpdGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHVubW91bnRBcHAodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uZWRpdGRlbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHVubW91bnRBcHAodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9ucGFsZXR0ZWFkZDogb3B0aW9ucy5vblBhbGV0dGVBZGQsXG4gICAgICAgIG9ucGFsdHRlcmVtb3ZlOiBvcHRpb25zLm9uUGFsZXR0ZVJlbW92ZSxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBub2RlIHR5cGUgJHt0eXBlfTpgLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCB7IHJlZ2lzdGVyVHlwZSwgSU5vZGUsIElOb2RlQnV0dG9uIH07XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXY+XG4gICAgPGRpdiBjbGFzcz1cImZvcm0tcm93XCI+XG4gICAgICA8bGFiZWw+PGkgY2xhc3M9XCJmYSBmYS10YWdcIj48L2k+IE5hbWU8L2xhYmVsPlxuICAgICAgPE5vZGVSZWRJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5uYW1lXCJcbiAgICAgICAgOmVycm9yPVwiZXJyb3JzWydub2RlLm5hbWUnXVwiXG4gICAgICAgIHBsYWNlaG9sZGVyPVwibmFtZVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLXJvd1wiPlxuICAgICAgPGxhYmVsPjxpIGNsYXNzPVwiZmEgZmEtdGFnXCI+PC9pPiBIb3N0bmFtZTwvbGFiZWw+XG4gICAgICA8Tm9kZVJlZElucHV0XG4gICAgICAgIHYtbW9kZWw6dmFsdWU9XCJub2RlLmhvc3RcIlxuICAgICAgICA6ZXJyb3I9XCJlcnJvcnNbJ25vZGUuaG9zdCddXCJcbiAgICAgICAgcGxhY2Vob2xkZXI9XCJob3N0bmFtZVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6IFwiTm9kZVJlZE5vZGVGb3JtXCIsXG4gIHByb3BzOiB7XG4gICAgbm9kZToge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgfSxcbiAgICBlcnJvcnM6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIGRlZmF1bHQ6ICgpID0+ICh7fSksXG4gICAgfSxcbiAgfSxcbn07XG48L3NjcmlwdD5cblxuPHN0eWxlIHNjb3BlZD5cbmxhYmVsIHtcbiAgd2lkdGg6IDEwMCU7XG59XG48L3N0eWxlPlxuIiwiLy8gTk9URTogdGhpcyBmaWxlIGlzIHByb3ZpZGVkIGJ5IHRoZSB1c2VyXG4vLyBOT1RFOyB0aGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IG5yZ1xuaW1wb3J0IHsgcmVnaXN0ZXJUeXBlIH0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvY2xpZW50XCI7XG5pbXBvcnQgZm9ybSBmcm9tIFwiLi9Gb3JtLnZ1ZVwiO1xuXG5leHBvcnQgZGVmYXVsdCByZWdpc3RlclR5cGUoe1xuICBjYXRlZ29yeTogXCJjb25maWdcIixcbiAgY29sb3I6IFwiI2E2YmJjZlwiLFxuICBmb3JtOiBmb3JtLFxufSk7XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXY+XG4gICAgPGRpdiBjbGFzcz1cImZvcm0tcm93XCI+XG4gICAgICA8bGFiZWw+PGkgY2xhc3M9XCJmYSBmYS10YWdcIj48L2k+IFVzZXJuYW1lPC9sYWJlbD5cbiAgICAgIDxOb2RlUmVkSW5wdXRcbiAgICAgICAgdi1tb2RlbDp2YWx1ZT1cIm5vZGUuY3JlZGVudGlhbHMudXNlcm5hbWVcIlxuICAgICAgICA6ZXJyb3I9XCJlcnJvcnNbJ25vZGUuY3JlZGVudGlhbHMudXNlcm5hbWUnXVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImZvcm0tcm93XCI+XG4gICAgICA8bGFiZWw+PGkgY2xhc3M9XCJmYSBmYS10YWdcIj48L2k+IFBhc3N3b3JkPC9sYWJlbD5cbiAgICAgIDxOb2RlUmVkSW5wdXRcbiAgICAgICAgdi1tb2RlbDp2YWx1ZT1cIm5vZGUuY3JlZGVudGlhbHMucGFzc3dvcmRcIlxuICAgICAgICB0eXBlPVwicGFzc3dvcmRcIlxuICAgICAgICA6ZXJyb3I9XCJlcnJvcnNbJ25vZGUuY3JlZGVudGlhbHMucGFzc3dvcmQnXVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImZvcm0tcm93XCI+XG4gICAgICA8bGFiZWw+PGkgY2xhc3M9XCJmYSBmYS10YWdcIj48L2k+IFBhc3N3b3JkIDI8L2xhYmVsPlxuICAgICAgPE5vZGVSZWRJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5jcmVkZW50aWFscy5wYXNzd29yZDJcIlxuICAgICAgICB0eXBlPVwicGFzc3dvcmRcIlxuICAgICAgICA6ZXJyb3I9XCJlcnJvcnNbJ25vZGUuY3JlZGVudGlhbHMucGFzc3dvcmQyJ11cIlxuICAgICAgLz5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLXJvd1wiPlxuICAgICAgPGxhYmVsPlR5cGVkIElucHV0PC9sYWJlbD5cbiAgICAgIDxOb2RlUmVkVHlwZWRJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5teVByb3BlcnR5XCJcbiAgICAgICAgOnR5cGVzPVwidHlwZXNcIlxuICAgICAgICA6ZXJyb3I9XCJlcnJvcnNbJ25vZGUubXlQcm9wZXJ0eSddXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1yb3dcIj5cbiAgICAgIDxsYWJlbD5UeXBlZCBJbnB1dCAyPC9sYWJlbD5cbiAgICAgIDxOb2RlUmVkVHlwZWRJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5teVByb3BlcnR5MlwiXG4gICAgICAgIDplcnJvcj1cImVycm9yc1snbm9kZS5teVByb3BlcnR5MiddXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1yb3dcIj5cbiAgICAgIDxsYWJlbD5Db25maWcgSW5wdXQ8L2xhYmVsPlxuICAgICAgPE5vZGVSZWRDb25maWdJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5yZW1vdGVTZXJ2ZXJcIlxuICAgICAgICB0eXBlPVwicmVtb3RlLXNlcnZlclwiXG4gICAgICAgIDplcnJvcj1cImVycm9yc1snbm9kZS5yZW1vdGVTZXJ2ZXInXVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImZvcm0tcm93XCI+XG4gICAgICA8bGFiZWw+Q29uZmlnIElucHV0PC9sYWJlbD5cbiAgICAgIDxOb2RlUmVkQ29uZmlnSW5wdXRcbiAgICAgICAgdi1tb2RlbDp2YWx1ZT1cIm5vZGUuYW5vdGhlclJlbW90ZVNlcnZlclwiXG4gICAgICAgIHR5cGU9XCJyZW1vdGUtc2VydmVyXCJcbiAgICAgICAgOmVycm9yPVwiZXJyb3JzWydub2RlLmFub3RoZXJSZW1vdGVTZXJ2ZXInXVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImZvcm0tcm93XCI+XG4gICAgICA8bGFiZWw+U2VsZWN0IElucHV0PC9sYWJlbD5cbiAgICAgIDxOb2RlUmVkU2VsZWN0SW5wdXRcbiAgICAgICAgdi1tb2RlbDp2YWx1ZT1cIm5vZGUuY291bnRyeVwiXG4gICAgICAgIDpvcHRpb25zPVwiY291bnRyaWVzXCJcbiAgICAgICAgOmVycm9yPVwiZXJyb3JzWydub2RlLmNvdW50cnknXVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImZvcm0tcm93XCI+XG4gICAgICA8bGFiZWw+TXVsdGlTZWxlY3QgSW5wdXQ8L2xhYmVsPlxuICAgICAgPE5vZGVSZWRTZWxlY3RJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5mcnVpdFwiXG4gICAgICAgIDpvcHRpb25zPVwiZnJ1aXRzXCJcbiAgICAgICAgbXVsdGlwbGVcbiAgICAgICAgOmVycm9yPVwiZXJyb3JzWydub2RlLmZydWl0J11cIlxuICAgICAgLz5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLXJvd1wiPlxuICAgICAgPGxhYmVsPlNlbGVjdCBJbnB1dDwvbGFiZWw+XG4gICAgICA8Tm9kZVJlZFNlbGVjdElucHV0XG4gICAgICAgIHYtbW9kZWw6dmFsdWU9XCJub2RlLm51bWJlclwiXG4gICAgICAgIDpvcHRpb25zPVwibnVtYmVyc1wiXG4gICAgICAgIDplcnJvcj1cImVycm9yc1snbm9kZS5udW1iZXInXVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImZvcm0tcm93XCI+XG4gICAgICA8bGFiZWw+U2VsZWN0IElucHV0PC9sYWJlbD5cbiAgICAgIDxOb2RlUmVkU2VsZWN0SW5wdXRcbiAgICAgICAgdi1tb2RlbDp2YWx1ZT1cIm5vZGUub2JqZWN0XCJcbiAgICAgICAgOm9wdGlvbnM9XCJvYmplY3RzXCJcbiAgICAgICAgbXVsdGlwbGVcbiAgICAgICAgOmVycm9yPVwiZXJyb3JzWydub2RlLm9iamVjdCddXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1yb3dcIj5cbiAgICAgIDxsYWJlbD5TZWxlY3QgSW5wdXQ8L2xhYmVsPlxuICAgICAgPE5vZGVSZWRTZWxlY3RJbnB1dFxuICAgICAgICB2LW1vZGVsOnZhbHVlPVwibm9kZS5hcnJheVwiXG4gICAgICAgIDpvcHRpb25zPVwiYXJyYXlzXCJcbiAgICAgICAgOmVycm9yPVwiZXJyb3JzWydub2RlLmFycmF5J11cIlxuICAgICAgLz5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLXJvd1wiPlxuICAgICAgPGxhYmVsPkVkaXRvciB3aXRoIGRlZmF1bHQgaGVpZ2h0IDIwMHB4IGFuZCBKU09OPC9sYWJlbD5cbiAgICAgIDxOb2RlUmVkRWRpdG9ySW5wdXRcbiAgICAgICAgdi1tb2RlbDp2YWx1ZT1cIm5vZGUuanNvbnRlc3RcIlxuICAgICAgICA6ZXJyb3I9XCJlcnJvcnNbJ25vZGUuanNvbnRlc3QnXVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImZvcm0tcm93XCI+XG4gICAgICA8bGFiZWw+RWRpdG9yIHdpdGggY3VzdG9tIGhlaWdodCBhbmQgQ1NTPC9sYWJlbD5cbiAgICAgIDxOb2RlUmVkRWRpdG9ySW5wdXRcbiAgICAgICAgdi1tb2RlbDp2YWx1ZT1cIm5vZGUuY3NzdGVzdFwiXG4gICAgICAgIGxhbmd1YWdlPVwiY3NzXCJcbiAgICAgICAgc3R5bGU9XCJoZWlnaHQ6IDEwMHB4XCJcbiAgICAgICAgOmVycm9yPVwiZXJyb3JzWydub2RlLmNzc3Rlc3QnXVwiXG4gICAgICAvPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6IFwiTm9kZVJlZE5vZGVGb3JtXCIsXG4gIHByb3BzOiB7XG4gICAgbm9kZToge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgfSxcbiAgICBlcnJvcnM6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIGRlZmF1bHQ6ICgpID0+ICh7fSksXG4gICAgfSxcbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZXM6IFtcInN0clwiLCBcIm1zZ1wiLCBcIm5vZGVcIl0sXG4gICAgICBjb3VudHJpZXM6IFtcbiAgICAgICAgeyB2YWx1ZTogXCJ1c2FcIiwgbGFiZWw6IFwidXNhXCIgfSxcbiAgICAgICAgeyB2YWx1ZTogXCJhcmdlbnRpbmFcIiwgbGFiZWw6IFwiYXJnZW50aW5hXCIgfSxcbiAgICAgICAgeyB2YWx1ZTogXCJicmFzaWxcIiwgbGFiZWw6IFwiYnJhc2lsXCIgfSxcbiAgICAgIF0sXG4gICAgICBmcnVpdHM6IFtcbiAgICAgICAgeyB2YWx1ZTogXCJhcHBsZVwiLCBsYWJlbDogXCJhcHBsZVwiIH0sXG4gICAgICAgIHsgdmFsdWU6IFwibWVsb25cIiwgbGFiZWw6IFwibWVsb25cIiB9LFxuICAgICAgICB7IHZhbHVlOiBcInJhc3BiZXJyeVwiLCBsYWJlbDogXCJyYXNwYmVycnlcIiB9LFxuICAgICAgXSxcbiAgICAgIG51bWJlcnM6IFtcbiAgICAgICAgeyB2YWx1ZTogXCIxXCIsIGxhYmVsOiBcIjFcIiB9LFxuICAgICAgICB7IHZhbHVlOiBcIjJcIiwgbGFiZWw6IFwiMlwiIH0sXG4gICAgICAgIHsgdmFsdWU6IFwiM1wiLCBsYWJlbDogXCIzXCIgfSxcbiAgICAgIF0sXG4gICAgICBvYmplY3RzOiBbXG4gICAgICAgIHsgdmFsdWU6IEpTT04uc3RyaW5naWZ5KHsgdGVzdDogXCJhXCIgfSksIGxhYmVsOiBcImFcIiB9LFxuICAgICAgICB7IHZhbHVlOiBKU09OLnN0cmluZ2lmeSh7IHRlc3Q6IFwiYlwiIH0pLCBsYWJlbDogXCJiXCIgfSxcbiAgICAgICAgeyB2YWx1ZTogSlNPTi5zdHJpbmdpZnkoeyB0ZXN0OiBcImNcIiB9KSwgbGFiZWw6IFwiY1wiIH0sXG4gICAgICBdLFxuICAgICAgYXJyYXlzOiBbXG4gICAgICAgIHsgdmFsdWU6IEpTT04uc3RyaW5naWZ5KFtcImFcIl0pLCBsYWJlbDogXCJhXCIgfSxcbiAgICAgICAgeyB2YWx1ZTogSlNPTi5zdHJpbmdpZnkoW1wiYlwiXSksIGxhYmVsOiBcImJcIiB9LFxuICAgICAgICB7IHZhbHVlOiBKU09OLnN0cmluZ2lmeShbXCJjXCJdKSwgbGFiZWw6IFwiY1wiIH0sXG4gICAgICBdLFxuICAgIH07XG4gIH0sXG59O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBzY29wZWQ+XG5sYWJlbCB7XG4gIHdpZHRoOiAxMDAlO1xufVxuPC9zdHlsZT5cbiIsIi8vIE5PVEU6IHRoaXMgZmlsZSBpcyBwcm92aWRlZCBieSB0aGUgdXNlclxuLy8gTk9URTsgdGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBucmdcbmltcG9ydCB7IHJlZ2lzdGVyVHlwZSB9IGZyb20gXCIuLi8uLi8uLi9jb3JlL2NsaWVudFwiO1xuaW1wb3J0IGZvcm0gZnJvbSBcIi4vRm9ybS52dWVcIjtcblxuZXhwb3J0IGRlZmF1bHQgcmVnaXN0ZXJUeXBlKHtcbiAgY2F0ZWdvcnk6IFwiZnVuY3Rpb25cIixcbiAgY29sb3I6IFwiI0ZGRkZGRlwiLFxuICBpbnB1dHM6IDEsXG4gIG91dHB1dHM6IDEsXG4gIGljb246IFwidnVlLnBuZ1wiLFxuICBmb3JtLFxuICBvblBhbGV0dGVBZGQ6ICgpID0+IHtcbiAgICBjb25zb2xlLmxvZyhcIk5PREUgVFlQRSBSRUdJU1RFUkVEIE9OIFRIRSBQQUxFVFRFXCIpO1xuICB9LFxufSk7XG4iLCIvLyBOT1RFOiB0aGlzIHdpbGwgYmUgZ2VuZXJhdGVkIGJ5IG5yZyB1c2luZyBhIHRlbXBsYXRlXG5pbXBvcnQgcmVtb3RlU2VydmVyIGZyb20gXCIuL3JlbW90ZS1zZXJ2ZXIvY2xpZW50XCI7XG5pbXBvcnQgeW91ck5vZGUgZnJvbSBcIi4veW91ci1ub2RlL2NsaWVudFwiO1xuXG4vLyBUT0RPOiBpcyB0aGVyZSBhIHVzZSBjYXNlIGZvciBjb250cm9sbGluZyB0aGUgb3JkZXIgbm9kZXMgaW4gdGhlIGVkaXRvciBhcmUgcmVnaXN0ZXJlZD9cbmFzeW5jIGZ1bmN0aW9uIHJlZ2lzdGVyTm9kZXMoKSB7XG4gIHRyeSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW3JlbW90ZVNlcnZlcihcInJlbW90ZS1zZXJ2ZXJcIiksIHlvdXJOb2RlKFwieW91ci1ub2RlXCIpXSk7XG4gICAgY29uc29sZS5sb2coXCJBbGwgbm9kZSB0eXBlcyByZWdpc3RlcmVkIGluIHBhcmFsbGVsXCIpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciByZWdpc3RlcmluZyBub2RlIHR5cGVzOlwiLCBlcnJvcik7XG4gIH1cbn1cblxucmVnaXN0ZXJOb2RlcygpO1xuIl0sIm5hbWVzIjpbIm1hcCIsInJlbW92ZSIsImhhc093blByb3BlcnR5IiwiaXNBcnJheSIsImlzTWFwIiwiaXNTZXQiLCJpc0RhdGUiLCJpc1JlZ0V4cCIsImlzRnVuY3Rpb24iLCJpc1N0cmluZyIsImlzU3ltYm9sIiwiaXNQcm9taXNlIiwiaXNQbGFpbk9iamVjdCIsImNhcGl0YWxpemUiLCJ0b051bWJlciIsInJhbmdlIiwicGFkIiwidHlwZSIsImVxdWFsIiwiaXNSZWYiLCJ3YXJuIiwibGFzdCIsImhlYWQiLCJ0YWlsIiwiY29tcHV0ZWQiLCJzZWxmIiwicmVhZG9ubHkiLCJyZWYiLCJ3YXRjaCIsIm9uY2UiLCJlZmZlY3QiLCJzY29wZSIsInAiLCJpZCIsInZlcnNpb24iLCJlbnRlckNiS2V5IiwiY2FsbEhvb2siLCJwYXRjaFByb3AiLCJoeWRyYXRlIiwiaGFzV2FybmVkIiwiZm9ybWF0IiwidGltZW91dCIsImRlbGF5IiwicmV0cnkiLCJyZXNvbHZlIiwicmVmMiIsInBhdHRlcm4iLCJkZWZhdWx0cyIsInJlbmRlciIsImgiLCJjcmVhdGVBcHAiLCJyZXF1aXJlZCIsInR5cGVzIiwiaXNCb29sZWFuIiwicmVtb3ZlMiIsInRyYWNrIiwidHJpZ2dlciIsImlzTW9kZWxMaXN0ZW5lciIsImVtaXQiLCJyZW5kZXIyIiwibmFtZXMiLCJjb21waWxlIiwiYmVmb3JlIiwiY2FtZWxpemUkMSIsImRlZiIsImNsb25lIiwidHJpbSIsImFyciIsIml0ZW1zIiwiZ2V0VmFsdWUiLCJ1bmlvbiIsImludGVyc2VjdGlvbiIsInJlc3QiLCJwbGFjZWhvbGRlclN5bWJvbCIsInN0YWNrIiwibWVyZ2UiLCJlc2NhcGUiLCJ1bmVzY2FwZSIsInByb3BlcnRpZXMiLCJjb2RlIiwicmVxdWlyZSQkMCIsIlVzZWRWYWx1ZVN0YXRlIiwicHJlZml4ZXMiLCJyZXF1aXJlJCQxIiwibm90IiwicnVsZXMiLCJrZXl3b3JkIiwiVHlwZSIsIm5hbWVzXzEiLCJyZXF1aXJlJCQyIiwicmVxdWlyZSQkMyIsInJlcXVpcmUkJDQiLCJEYXRhVHlwZSIsImRhdGFUeXBlIiwidmFsaWRhdGUiLCJlcnJvcnMiLCJfYSIsInN1YnNjaGVtYSIsInRyYXZlcnNlIiwianNvblNjaGVtYVRyYXZlcnNlTW9kdWxlIiwibGltaXQiLCJyZXF1aXJlJCQ1IiwicmVxdWlyZSQkNiIsInJlcXVpcmUkJDciLCJyZXF1aXJlJCQ4IiwicmVxdWlyZSQkOSIsInJlcXVpcmUkJDEwIiwibWF0Y2hlcyIsImJ1ZmZlciIsInVyaSIsImZhc3RVcmkiLCJmYXN0VXJpTW9kdWxlIiwidXJpXzEiLCJBanYiLCIkc2NoZW1hIiwiZGVmaW5pdGlvbnMiLCJjb3JlXzEiLCJjb3JlIiwidWNzMmxlbmd0aF8xIiwidWNzMmxlbmd0aCIsImVxdWFsXzEiLCJ2YWxpZGF0aW9uXzEiLCJ2YWxpZGF0aW9uIiwicHJlZml4SXRlbXMiLCJyZXF1aXJlJCQxMSIsInJlcXVpcmUkJDEyIiwicmVxdWlyZSQkMTMiLCJyZXF1aXJlJCQxNCIsInJlcXVpcmUkJDE1IiwiYXBwbGljYXRvciIsImZvcm1hdF8yIiwiRGlzY3JFcnJvciIsIm9uZU9mIiwiYWp2IiwiYWRkRm9ybWF0cyIsImZvcm1hdHMiLCJqc29ucG9pbnRlciIsIl9zZmNfbWFpbiIsIl9ob2lzdGVkXzEiLCJfb3BlbkJsb2NrIiwiX2NyZWF0ZUVsZW1lbnRCbG9jayIsIl9jcmVhdGVWTm9kZSIsIl9ob2lzdGVkXzIiLCJfY3JlYXRlRWxlbWVudFZOb2RlIiwiX2hvaXN0ZWRfMyIsIl90b0Rpc3BsYXlTdHJpbmciLCJfY3JlYXRlQ29tbWVudFZOb2RlIiwiaXNPYmplY3QiLCJfd2l0aERpcmVjdGl2ZXMiLCJmb3JtIiwiJCIsIl9jcmVhdGVUZXh0Vk5vZGUiXSwibWFwcGluZ3MiOiI7Ozs7O0VBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0E7QUFBQTtBQUVBLFdBQVMsUUFBUSxLQUFLO0FBQ2QsVUFBQUEsT0FBNkIsdUJBQUEsT0FBTyxJQUFJO0FBQzlDLGVBQVcsT0FBTyxJQUFJLE1BQU0sR0FBRyxFQUFHLENBQUFBLEtBQUksR0FBRyxJQUFJO0FBQ3RDLFdBQUEsQ0FBQyxRQUFRLE9BQU9BO0FBQUEsRUFDekI7QUFFQSxRQUFNLFlBQVksT0FBNEMsT0FBTyxPQUFPLENBQUEsQ0FBRSxJ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QSxJQUNSLFNBQVM7QUFBQSxJQUNULE1BQU07QUFBQSxJQUNOO0FBQUEsSUFDQSxjQUFjLE1BQU07QUFDbEIsY0FBUSxJQUFJLHFDQUFxQztBQUFBLElBQUE7QUFBQSxFQUVyRCxDQUFDO0FDVkQsaUJBQWUsZ0JBQWdCO0FBQ3pCLFFBQUE7QUFDSSxZQUFBLFFBQVEsSUFBSSxDQUFDLGFBQWEsZUFBZSxHQUFHLFNBQVMsV0FBVyxDQUFDLENBQUM7QUFDeEUsY0FBUSxJQUFJLHVDQUF1QztBQUFBLGFBQzVDLE9BQU87QUFDTixjQUFBLE1BQU0saUNBQWlDLEtBQUs7QUFBQSxJQUFBO0FBQUEsRUFFeEQ7QUFFQSxnQkFBYzs7IiwieF9nb29nbGVfaWdub3JlTGlzdCI6WzAsMSwyLDMsNCw1LDYsNyw4LDksMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsMjYsMjcsMjgsMjksMzAsMzEsMzIsMzMsMzQsMzUsMzYsMzcsMzgsMzksNDAsNDEsNDIsNDMsNDQsNDUsNDYsNDcsNDgsNDksNTAsNTEsNTIsNTMsNTQsNTUsNTYsNTcsNTgsNTksNjAsNjEsNjIsNjMsNjQsNjUsNjYsNjcsNjgsNjksNzAsNzEsNzIsNzMsNzQsNzUsNzYsNzcsNzgsNzksODAsODEsODIsODMsODQsODUsODYsODcsODgsODksOTAsOTEsOTIsOTMsOTQsOTUsOTYsOTcsOTgsOTksMTAwLDEwMSwxMDIsMTAzLDEwNCwxMDUsMTA2LDEwNywxMDgsMTA5LDExMCwxMTEsMTEyLDExMywxMTQsMTE1LDExNiwxMTcsMTE4LDExOSwxMjAsMTIxLDEyMiwxMjMsMTI0LDEyNSwxMjYsMTI3LDEyOCwxMjksMTMwLDEzMSwxMzIsMTMzLDEzNCwxMzUsMTM2LDEzNywxMzgsMTM5LDE0MCwxNDEsMTQyLDE0MywxNDQsMTQ1LDE0NiwxNDcsMTQ4LDE0OSwxNTAsMTUxLDE1MiwxNTMsMTU0LDE1NSwxNTYsMTU3LDE1OCwxNTksMTYwLDE2MSwxNjIsMTYzLDE2NCwxNjUsMTY2LDE2NywxNjgsMTY5LDE3MCwxNzEsMTcyLDE3MywxNzQsMTc1LDE3NiwxNzcsMTc4LDE3OSwxODAsMTgxLDE4MiwxODMsMTg0LDE4NSwxODYsMTg3LDE4OCwxOTAsMTkxLDE5MiwxOTMsMTk0LDE5NSwxOTYsMTk3LDE5OCwxOTksMjAwLDIwMSwyMDIsMjAzLDIwNCwyMDUsMjA2LDIwNywyMDgsMjA5LDIxMCwyMTEsMjEyLDIxMywyMTQsMjE1LDIxNiwyMTcsMjE4LDIxOSwyMjAsMjIxLDIyMiwyMjMsMjI0LDIyNSwyMjYsMjI3LDIyOCwyMjksMjMwLDIzMSwyMzIsMjMzLDIzNCwyMzUsMjM2LDIzNywyMzgsMjM5LDI0MCwyNDEsMjQyLDI0MywyNDQsMjQ1LDI0NiwyNDcsMjQ4LDI0OSwyNTAsMjUxLDI1MiwyNTMsMjU0LDI1NSwyNTYsMjU3LDI1OCwyNTksMjYwLDI2M119
  
  //# sourceURL=src/nodes/client.js
  </script>
